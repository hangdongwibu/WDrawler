var ky = Object.defineProperty;
var ng = b => {
    throw TypeError(b)
}
;
var Ey = (b, l, _) => l in b ? ky(b, l, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: _
}) : b[l] = _;
var lr = (b, l, _) => Ey(b, typeof l != "symbol" ? l + "" : l, _)
  , lf = (b, l, _) => l.has(b) || ng("Cannot " + _);
var et = (b, l, _) => (lf(b, l, "read from private field"),
_ ? _.call(b) : l.get(b))
  , br = (b, l, _) => l.has(b) ? ng("Cannot add the same private member more than once") : l instanceof WeakSet ? l.add(b) : l.set(b, _)
  , Jn = (b, l, _, C) => (lf(b, l, "write to private field"),
C ? C.call(b, _) : l.set(b, _),
_)
  , Fr = (b, l, _) => (lf(b, l, "access private method"),
_);
import "../chunks/Bzak7iHL.js";
import {o as Ii, s as Ji} from "../chunks/ByKBPM-D.js";
import {Y as zy, aZ as Ly, bp as Dy, a$ as Ry, bq as By, be as Fy, aR as nt, A as x, aH as oe, aG as zn, p as Sr, aT as lt, w as Zr, f as Ie, d as k, s as V, br as Oy, r as A, t as Ge, b as H, c as Pr, an as Wi, o as fi, bj as an, q as Tr, bo as Su, v as Hf, x as Go, aS as Jt, a as zt, aU as Fn, ay as Ny, ax as ag, az as jy, aB as Mg, bs as ts, ap as fa, bt as Ag, ak as qy} from "../chunks/DUoKDNpf.js";
import {s as fe} from "../chunks/g8c1BvYP.js";
import {p as Et, i as Ue, r as Qt, s as lo, u as kg} from "../chunks/5NasrULQ.js";
import {h as Vy} from "../chunks/2CRhGZHc.js";
import {a as er, r as ea, e as On, s as Or, f as Jl, b as zr, d as uc, g as Tu, c as Vo} from "../chunks/CbcY1qdF.js";
import {d as Uy, a as Zo, f as $o, L as Wf, p as Xf, k as Pu, t as En, C as Zy, T as Eg, G as $y} from "../chunks/D19aEwZq.js";
import {p as La} from "../chunks/DszI4SLk.js";
import {S as $n, a as ni, t as qr, u as Dt, i as ds, j as Gy, k as Hy, l as Wy, m as Xy, n as Ky, o as Yy, p as Jy, q as Qy, r as ex, v as tx, c as Cd, g as oa, C as sg, w as og, x as rx, y as ix, z as nx} from "../chunks/1lh-LSvX.js";
import {c as zg, A as pa, a as yf, g as cf, p as ax, b as sx} from "../chunks/D2m5UD3G.js";
import {g as Lg, b as ox} from "../chunks/DeGEJ59e.js";
import {h as lx} from "../chunks/BMKgGW48.js";
import {b as ps} from "../chunks/CMs8vKjq.js";
import {g as jd, d as qd, h as Vd, A as Dg, f as tc, D as Rg, a as Ud, r as cx, i as ux, I as lg, e as hx, c as dx, j as px, P as Bg, b as fx} from "../chunks/B__ni71n.js";
import {g as Fe, l as mx} from "../chunks/C5GsJ62f.js";
import {e as nn, i as Zd} from "../chunks/U908S-6f.js";
import {P as es, g as Zn, A as _x, t as Fg, b as Kf, c as gx, d as vx} from "../chunks/DfQpDKXu.js";
import "../chunks/D35KiPL1.js";
import {i as Og} from "../chunks/D1ivTjwA.js";
import {L as Ng} from "../chunks/CL2zjQj-.js";
import {c as _n} from "../chunks/BtP6pfnb.js";
import {L as yx, T as jg, a as xx} from "../chunks/BCbikyPd.js";
import {_ as bx} from "../chunks/Dp1pzeXC.js";
import {R as wx, r as Tx} from "../chunks/BIDE-9NB.js";
import {W as Cx} from "../chunks/BKlGAqpR.js";
const Sx = [];
function Px(b, l=!1, _=!1) {
    return Sd(b, new Map, "", Sx, null, _)
}
function Sd(b, l, _, C, L=null, O=!1) {
    if (typeof b == "object" && b !== null) {
        var T = l.get(b);
        if (T !== void 0)
            return T;
        if (b instanceof Map)
            return new Map(b);
        if (b instanceof Set)
            return new Set(b);
        if (zy(b)) {
            var o = Array(b.length);
            l.set(b, o),
            L !== null && l.set(L, o);
            for (var $ = 0; $ < b.length; $ += 1) {
                var W = b[$];
                $ in b && (o[$] = Sd(W, l, _, C, null, O))
            }
            return o
        }
        if (Ly(b) === Dy) {
            o = {},
            l.set(b, o),
            L !== null && l.set(L, o);
            for (var ie in b)
                o[ie] = Sd(b[ie], l, _, C, null, O);
            return o
        }
        if (b instanceof Date)
            return structuredClone(b);
        if (typeof b.toJSON == "function" && !O)
            return Sd(b.toJSON(), l, _, C, b)
    }
    if (b instanceof EventTarget)
        return b;
    try {
        return structuredClone(b)
    } catch {
        return b
    }
}
function Ix() {
    return Symbol(Ry)
}
function $d(b, l) {
    By(window, ["resize"], () => Fy( () => l(window[b])))
}
const Mx = () => "Log in"
  , Ax = () => "Entrar"
  , kx = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Mx() : Ax()
  , Ex = () => "Store"
  , zx = () => "Loja"
  , qg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Ex() : zx()
  , Lx = () => "Alliance"
  , Dx = () => "Aliança"
  , Gd = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Lx() : Dx()
  , Rx = () => "Leaderboard"
  , Bx = () => "Ranking"
  , Yf = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Rx() : Bx()
  , Fx = () => "Unlock"
  , Ox = () => "Destravar"
  , Nx = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Fx() : Ox()
  , jx = () => "Lock"
  , qx = () => "Travar"
  , Vx = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? jx() : qx()
  , Ux = () => "Info"
  , Zx = () => "Informações"
  , $x = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Ux() : Zx()
  , Gx = () => "Zoom in"
  , Hx = () => "Aumentar zoom"
  , Wx = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Gx() : Hx()
  , Xx = () => "Zoom out"
  , Kx = () => "Diminuir zoom"
  , Yx = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Xx() : Kx()
  , Jx = () => "Previous location"
  , Qx = () => "Localização anterior"
  , e1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Jx() : Qx()
  , t1 = () => "Offline"
  , r1 = () => "Offline"
  , i1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? t1() : r1()
  , n1 = () => "Zoom in to see the pixels"
  , a1 = () => "Amplie para ver os pixels"
  , s1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? n1() : a1()
  , o1 = () => "Phone verification required"
  , l1 = () => "Verificação de telefone necessária"
  , cg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? o1() : l1()
  , c1 = () => "My location"
  , u1 = () => "Minha localização"
  , h1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? c1() : u1()
  , d1 = () => "You don't have charges to paint. Wait to recharge."
  , p1 = () => "Você não possui tinta para pintar. Aguarde para carrega-las."
  , f1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? d1() : p1()
  , m1 = () => "Map powered by:"
  , _1 = () => "Mapa fornecido por:"
  , g1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? m1() : _1()
  , v1 = () => "OpenMapTiles Data from"
  , y1 = () => "OpenMapTiles com dados do"
  , x1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? v1() : y1()
  , b1 = () => "Feedback and bugs"
  , w1 = () => "Feedback e bugs"
  , T1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? b1() : w1()
  , C1 = () => "Overview"
  , S1 = () => "Visão Geral"
  , P1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? C1() : S1()
  , I1 = () => "How to paint faster"
  , M1 = () => "Como pintar mais rápido"
  , A1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? I1() : M1()
  , k1 = () => "When painting, click on the button"
  , E1 = () => "Quando pintar clique no botão"
  , z1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? k1() : E1()
  , L1 = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map."
  , D1 = () => "no canto superior direito da tela. Isso bloqueará a tela, mas também permitirá pintar movendo o dedo sobre o mapa."
  , R1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? L1() : D1()
  , B1 = () => "Hold"
  , F1 = () => "Segure"
  , O1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? B1() : F1()
  , N1 = () => "SPACE"
  , j1 = () => "Espaço"
  , q1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? N1() : j1()
  , V1 = () => "and move your cursor over the map."
  , U1 = () => "e mova seu cursor sobre o mapa."
  , Z1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? V1() : U1()
  , $1 = () => "Explore"
  , G1 = () => "Explorar"
  , H1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? $1() : G1()
  , W1 = () => "Recharge paint charges"
  , X1 = () => "Recarga de tinta"
  , K1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? W1() : X1()
  , Y1 = () => "Items"
  , J1 = () => "Itens"
  , Q1 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Y1() : J1()
  , eb = () => "Get more charges"
  , tb = () => "Recarregue tinta para pintar"
  , rb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? eb() : tb()
  , ib = b => `+${b.amount} Max. Charges`
  , nb = b => `+${b.amount} Tinta máxima`
  , ab = (b, l={}) => (l.locale ?? Fe()) === "en" ? ib(b) : nb(b)
  , sb = () => "Increase your maximum paint charges capacity"
  , ob = () => "Aumente sua capacidade máxima de tinta"
  , lb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? sb() : ob()
  , cb = () => "Profile picture"
  , ub = () => "Imagem de perfil"
  , hb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? cb() : ub()
  , db = () => "Add a new 16x16 profile picture"
  , pb = () => "Adicionar uma nova imagem de perfil 16x16"
  , fb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? db() : pb()
  , mb = () => "Not enough droplets"
  , _b = () => "Droplets insuficientes"
  , Hd = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? mb() : _b()
  , gb = () => "Show profile"
  , vb = () => "Exibir perfil"
  , yb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? gb() : vb()
  , xb = () => "Menu"
  , bb = () => "Menu"
  , wb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? xb() : bb()
  , Tb = b => `Could not install the app: ${b.error}`
  , Cb = b => `Não pode instalar o app: ${b.error}`
  , Sb = (b, l={}) => (l.locale ?? Fe()) === "en" ? Tb(b) : Cb(b)
  , Pb = () => "Install App"
  , Ib = () => "Instalar App"
  , Mb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Pb() : Ib()
  , Ab = () => "Livestreams"
  , kb = () => "Livestreams"
  , Eb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Ab() : kb()
  , zb = () => "Log Out"
  , Lb = () => "Log Out"
  , Db = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? zb() : Lb()
  , Rb = () => "Hide UI"
  , Bb = () => "Esconder UI"
  , Fb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Rb() : Bb()
  , Ob = () => "Change picture:"
  , Nb = () => "Change picture:"
  , jb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Ob() : Nb()
  , qb = () => "Show last painted pixel on alliance"
  , Vb = () => "Mostrar último pixel pintado na aliança"
  , Ub = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? qb() : Vb()
  , Zb = () => "Delete Account"
  , $b = () => "Deletar Conta"
  , ug = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Zb() : $b()
  , Gb = () => "Save"
  , Hb = () => "Salvar"
  , Wb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Gb() : Hb()
  , Xb = () => "Are you absolutely sure?"
  , Kb = () => "Você tem certeza absoluta?"
  , Yb = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Xb() : Kb()
  , Jb = () => "This will permanently delete your account and all associated data. This action cannot be undone."
  , Qb = () => "Isso excluirá permanentemente sua conta e todos os dados associados. Esta ação não pode ser desfeita."
  , e2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Jb() : Qb()
  , t2 = () => "Profile"
  , r2 = () => "Perfil"
  , i2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? t2() : r2()
  , n2 = () => "Display your country’s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent."
  , a2 = () => "Exiba a bandeira do seu país ao lado do seu nome de usuário. Além disso, ao pintar em regiões onde você possui a bandeira correspondente, você recupera 10% das tintas gastas."
  , s2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? n2() : a2()
  , o2 = () => "Does not need to be equipped to provide the bonus"
  , l2 = () => "Não precisa estar equipada para obter o bônus"
  , c2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? o2() : l2()
  , u2 = () => "Equipped"
  , h2 = () => "Equipado"
  , d2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? u2() : h2()
  , p2 = () => "Equip"
  , f2 = () => "Equipar"
  , m2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? p2() : f2()
  , _2 = () => "Country"
  , g2 = () => "País"
  , Vg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? _2() : g2()
  , v2 = () => "No country found."
  , y2 = () => "País não encontrado."
  , x2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? v2() : y2()
  , b2 = () => "Welcome to"
  , w2 = () => "Bem vindo ao"
  , T2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? b2() : w2()
  , C2 = () => "Rules"
  , S2 = () => "Regras"
  , P2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? C2() : S2()
  , I2 = () => "Important"
  , M2 = () => "Importante"
  , A2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? I2() : M2()
  , k2 = () => "🚫 No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)"
  , E2 = () => "🚫 Conteúdo inapropriado não permitido (+18, discurso de ódio, links inapropriados, conteúdo altamente sugestivo, ...)"
  , z2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? k2() : E2()
  , L2 = () => "😈 Do not paint over other artworks using random colors or patterns just to mess things up"
  , D2 = () => "😈 Não desenhe por cima de outras artes usando cores ou padrões aleatórios só para bagunçar"
  , R2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? L2() : D2()
  , B2 = () => "🧑‍🤝‍🧑 Do not paint with more than one account"
  , F2 = () => "🧑‍🤝‍🧑 Não desenhe com mais de uma conta"
  , O2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? B2() : F2()
  , N2 = () => "🤖 Use of bots is not allowed"
  , j2 = () => "🤖 Usar bots não é permitido"
  , q2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? N2() : j2()
  , V2 = () => "🙅 Disclosing other's personal information is not allowed"
  , U2 = () => "🙅 Divulgar informações pessoais dos outros não é permitido"
  , Z2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? V2() : U2()
  , $2 = () => "✅ Painting over other artworks to complement them or create a new drawing is allowed"
  , G2 = () => "✅ Desenhar sobre outras artes para complementar ou criar novas artes é permitido"
  , H2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? $2() : G2()
  , W2 = () => "✅ Griefing political party flags or portraits of politicians is allowed"
  , X2 = () => "✅ Desenhar sobre bandeiras de partidos e retratos de políticos é permitido"
  , K2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? W2() : X2()
  , Y2 = () => "Violations of these rules may result in suspension of your account."
  , J2 = () => "Violações destas regras podem resultar na suspensão da sua conta."
  , Q2 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Y2() : J2()
  , ew = () => "Understood"
  , tw = () => "Entendido"
  , rw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? ew() : tw()
  , iw = () => "Toggle art opacity"
  , nw = () => "Alterar opacidade"
  , Ug = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? iw() : nw()
  , aw = () => "Paint"
  , sw = () => "Pintar"
  , Zg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? aw() : sw()
  , ow = () => "Select a color"
  , lw = () => "Selecione uma color"
  , cw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? ow() : lw()
  , uw = () => "Select a pixel to erase"
  , hw = () => "Selecione um pixel para apagar"
  , dw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? uw() : hw()
  , pw = () => "Pick a color from the map"
  , fw = () => "Escolha uma cor do mapa"
  , mw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? pw() : fw()
  , _w = () => "Click"
  , gw = () => "Clique"
  , vw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? _w() : gw()
  , yw = () => "SPACE"
  , xw = () => "ESPAÇO"
  , bw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? yw() : xw()
  , ww = () => "or hold"
  , Tw = () => "ou segure"
  , Cw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? ww() : Tw()
  , Sw = () => "to paint,"
  , Pw = () => "para pintar"
  , Iw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Sw() : Pw()
  , Mw = () => "You can paint more than 1 pixel"
  , Aw = () => "Você pode pintar mais de 1 pixel"
  , kw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Mw() : Aw()
  , Ew = () => "Paint pixel"
  , zw = () => "Pintar pixel"
  , Lw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Ew() : zw()
  , Dw = () => "Color Picker"
  , Rw = () => "Conta Gotas"
  , Bw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Dw() : Rw()
  , Fw = () => "+2 max. charge/level"
  , Ow = () => "+2 tinta máxima/level"
  , Nw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Fw() : Ow()
  , jw = () => "Name"
  , qw = () => "Nome"
  , xf = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? jw() : qw()
  , Vw = () => "Discord Username"
  , Uw = () => "Usuário do Discord"
  , Zw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Vw() : Uw()
  , $w = () => "Max. Charges"
  , Gw = () => "Tinta máxima"
  , hg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? $w() : Gw()
  , Hw = () => "Paint Charges"
  , Ww = () => "Tintas"
  , Xw = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Hw() : Ww()
  , Kw = b => `+${b.amount} Paint Charges`
  , Yw = b => `+${b.amount} Tintas`
  , Jw = (b, l={}) => (l.locale ?? Fe()) === "en" ? Kw(b) : Yw(b)
  , Qw = () => "Leave alliance"
  , e5 = () => "Sair da aliança"
  , t5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Qw() : e5()
  , r5 = () => "Members"
  , i5 = () => "Membros"
  , $g = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? r5() : i5()
  , n5 = () => "Headquarters"
  , a5 = () => "Quartel General"
  , s5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? n5() : a5()
  , o5 = () => "Not set"
  , l5 = () => "Não configurado"
  , c5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? o5() : l5()
  , u5 = () => "You are not in an alliance"
  , h5 = () => "Você não está em uma aliança"
  , d5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? u5() : h5()
  , p5 = () => "Get invited to an alliance"
  , f5 = () => "Seja convidado para uma aliança"
  , m5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? p5() : f5()
  , _5 = () => "OR"
  , g5 = () => "OU"
  , v5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? _5() : g5()
  , y5 = () => "Create an alliance"
  , x5 = () => "Crie uma aliança"
  , b5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? y5() : x5()
  , w5 = () => "Invite link"
  , T5 = () => "Link de convite"
  , C5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? w5() : T5()
  , S5 = () => "Send the link below to everybody you want to invite to the alliance"
  , P5 = () => "Envie o link abaixo para quem você deseja convidar para a aliança"
  , I5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? S5() : P5()
  , M5 = () => "Copied"
  , A5 = () => "Copiado"
  , Gg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? M5() : A5()
  , k5 = () => "Copy"
  , E5 = () => "Copiar"
  , bf = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? k5() : E5()
  , z5 = () => "No description"
  , L5 = () => "Sem descrição"
  , Hg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? z5() : L5()
  , D5 = () => "Invite"
  , R5 = () => "Convite"
  , B5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? D5() : R5()
  , F5 = () => "No pixels painted"
  , O5 = () => "Nenhum pixel pintado"
  , Jf = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? F5() : O5()
  , N5 = () => "Today"
  , j5 = () => "Hoje"
  , Wd = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? N5() : j5()
  , q5 = () => "Week"
  , V5 = () => "Semana"
  , U5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? q5() : V5()
  , Z5 = () => "Month"
  , $5 = () => "Mês"
  , G5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Z5() : $5()
  , H5 = () => "All time"
  , W5 = () => "Geral"
  , X5 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? H5() : W5()
  , K5 = () => "this week"
  , Y5 = () => "nesta semana"
  , Qf = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? K5() : Y5()
  , J5 = () => "this month"
  , Q5 = () => "neste mês"
  , em = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? J5() : Q5()
  , eT = () => "Player"
  , tT = () => "Jogador"
  , tm = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? eT() : tT()
  , rT = () => "Last pixel"
  , iT = () => "Último pixel"
  , nT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? rT() : iT()
  , aT = () => "Create alliance"
  , sT = () => "Criar aliança"
  , oT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? aT() : sT()
  , lT = () => "Alliance Name"
  , cT = () => "Nome da aliança"
  , uT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? lT() : cT()
  , hT = () => "Create"
  , dT = () => "Criar"
  , pT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? hT() : dT()
  , fT = () => "Give admin"
  , mT = () => "Tornar admin"
  , _T = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? fT() : mT()
  , gT = () => "Ban from alliance"
  , vT = () => "Banir da aliança"
  , Wg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? gT() : vT()
  , yT = () => "No action"
  , xT = () => "Sem opção"
  , bT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? yT() : xT()
  , wT = () => "Unban"
  , TT = () => "Desbanir"
  , CT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? wT() : TT()
  , ST = () => "No banned users"
  , PT = () => "Sem usuários banidos"
  , IT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? ST() : PT()
  , MT = () => "Update"
  , AT = () => "Atualizar"
  , kT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? MT() : AT()
  , ET = () => "Error giving admin to user"
  , zT = () => "Erro ao tornar usuário admin"
  , LT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? ET() : zT()
  , DT = () => "Users"
  , RT = () => "Usuários"
  , BT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? DT() : RT()
  , FT = () => "Banned"
  , OT = () => "Banido"
  , NT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? FT() : OT()
  , jT = () => "Regions"
  , qT = () => "Regiões"
  , VT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? jT() : qT()
  , UT = () => "Countries"
  , ZT = () => "Países"
  , $T = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? UT() : ZT()
  , GT = () => "Players"
  , HT = () => "Jogadores"
  , Xg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? GT() : HT()
  , WT = () => "Alliances"
  , XT = () => "Alianças"
  , Kg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? WT() : XT()
  , KT = () => "Region"
  , YT = () => "Região"
  , JT = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? KT() : YT()
  , QT = () => "Pixels"
  , e3 = () => "Pixels"
  , Ql = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? QT() : e3()
  , t3 = () => "Painted"
  , r3 = () => "Pintados"
  , ec = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? t3() : r3()
  , i3 = () => "Pixels painted inside the region"
  , n3 = () => "Pixels pintados dentro da região"
  , a3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? i3() : n3()
  , s3 = () => "Visit"
  , o3 = () => "Visitar"
  , l3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? s3() : o3()
  , c3 = () => "Not painted"
  , u3 = () => "Não pintado"
  , h3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? c3() : u3()
  , d3 = () => "Painted by"
  , p3 = () => "Pintado por"
  , f3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? d3() : p3()
  , m3 = () => "Limit reached"
  , _3 = () => "Limite atingido"
  , g3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? m3() : _3()
  , v3 = () => "Favorite"
  , y3 = () => "Favoritar"
  , x3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? v3() : y3()
  , b3 = () => "Share"
  , w3 = () => "Compartilhar"
  , T3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? b3() : w3()
  , C3 = () => "Share place"
  , S3 = () => "Compartilhar local"
  , P3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? C3() : S3()
  , I3 = () => "Mute"
  , M3 = () => "Mutar"
  , A3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? I3() : M3()
  , k3 = () => "Unmute"
  , E3 = () => "Desmutar"
  , z3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? k3() : E3()
  , L3 = () => "Select the headquarters location"
  , D3 = () => "Selecione a localização do quartel general"
  , R3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? L3() : D3()
  , B3 = () => "Pixels painted inside the country"
  , F3 = () => "Pixels pintados dentro do país"
  , O3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? B3() : F3()
  , N3 = () => "Username copied to clipboard"
  , j3 = () => "Usuário copiado"
  , q3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? N3() : j3()
  , V3 = () => "No more charges"
  , U3 = () => "Acabou a tinta"
  , Z3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? V3() : U3()
  , $3 = () => "You are not allowed to use multiple accounts. Use your main account to paint."
  , G3 = () => "Não é permitido usar várias contas. Use sua conta principal para pintar."
  , H3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? $3() : G3()
  , W3 = () => "SMS sent to"
  , X3 = () => "SMS enviado para"
  , K3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? W3() : X3()
  , Y3 = () => "Phone successfully verified"
  , J3 = () => "Telefone verificado com sucesso"
  , Q3 = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? Y3() : J3()
  , eC = () => "Not a valid phone number"
  , tC = () => "Não é um número válido"
  , rC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? eC() : tC()
  , iC = () => "Location unfavorited"
  , nC = () => "Localização desfavoritada"
  , aC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? iC() : nC()
  , sC = () => "Location favorited"
  , oC = () => "Localização favoritada"
  , lC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? sC() : oC()
  , cC = () => "Giving admin to user"
  , uC = () => "Tornar usuário um admin"
  , hC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? cC() : uC()
  , dC = () => "Profile updated"
  , pC = () => "Perfil atualizado"
  , fC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? dC() : pC()
  , mC = () => "Account successfully deleted"
  , _C = () => "Conta deletada com sucesso"
  , gC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? mC() : _C()
  , vC = () => "Logged out"
  , yC = () => "Logout feito"
  , xC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? vC() : yC()
  , bC = () => "Could not logout. Try refreshing the page."
  , wC = () => "Não foi possível sair da conta. Tente recarregar a página."
  , TC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? bC() : wC()
  , CC = () => "You need to zoom in to select a pixel"
  , SC = () => "Dê zoom para selecionar um pixel"
  , PC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? CC() : SC()
  , IC = () => "Phone verification"
  , MC = () => "Verificação de telefone"
  , AC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? IC() : MC()
  , kC = () => "Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone."
  , EC = () => "Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experiência segura e criativa para todos."
  , zC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? kC() : EC()
  , LC = () => "Send Code"
  , DC = () => "Enviar o código"
  , RC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? LC() : DC()
  , BC = () => "Input the code"
  , FC = () => "Insira o código"
  , OC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? BC() : FC()
  , NC = () => "Sent to"
  , jC = () => "Enviar para"
  , qC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? NC() : jC()
  , VC = () => "Resend Code"
  , UC = () => "Reenviar Código"
  , ZC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? VC() : UC()
  , $C = () => "Try another number"
  , GC = () => "Tentar outro número"
  , HC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? $C() : GC()
  , WC = () => "Edit profile"
  , XC = () => "Editar perfil"
  , KC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? WC() : XC()
  , YC = () => "Image"
  , JC = () => "Imagem"
  , QC = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? YC() : JC()
  , eS = () => "Download"
  , tS = () => "Download"
  , rS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? eS() : tS()
  , iS = () => "Image copied to clipboard"
  , nS = () => "Imagem copiada para a área de transferência"
  , aS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? iS() : nS()
  , sS = () => "My map is lagging"
  , oS = () => "Meu mapa está travando"
  , lS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? sS() : oS()
  , cS = () => "Verify if"
  , uS = () => "Verifique se"
  , hS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? cS() : uS()
  , dS = () => "Use hardware acceleration when available"
  , pS = () => "Usar aceleração gráfica quando disponível"
  , fS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? dS() : pS()
  , mS = () => "is enabled on"
  , _S = () => "está habilitado em"
  , gS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? mS() : _S()
  , vS = () => "Follow the instructions to enable hardware acceleration"
  , yS = () => "Siga a instrução para habilitar a aceleração de hardware"
  , xS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? vS() : yS()
  , bS = () => "Report User"
  , wS = () => "Reportar usuário"
  , Yg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? bS() : wS()
  , TS = () => "Ban User"
  , CS = () => "Banir usuário"
  , Jg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? TS() : CS()
  , SS = () => "Select the reason"
  , PS = () => "Selecione o motivo"
  , IS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? SS() : PS()
  , MS = () => "Other"
  , AS = () => "Outro motivo"
  , kS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? MS() : AS()
  , ES = () => "Other reason not listed"
  , zS = () => "Outro motivo não listado"
  , LS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? ES() : zS()
  , DS = () => "Extra context on what happened"
  , RS = () => "Mais informações sobre o que aconteceu"
  , BS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? DS() : RS()
  , FS = () => "Report"
  , OS = () => "Reportar"
  , NS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? FS() : OS()
  , jS = () => "Report sent successfully"
  , qS = () => "Denúncia enviada com sucesso"
  , VS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? jS() : qS()
  , US = () => "Select the report reason"
  , ZS = () => "Selecione o motivo da denúncia"
  , $S = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? US() : ZS()
  , GS = () => "Report failed. Please try again later"
  , HS = () => "Denúncia falhou. Por favor, tente novamente mais tarde"
  , WS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? GS() : HS()
  , XS = () => "Moderation"
  , KS = () => "Moderação"
  , YS = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? XS() : KS()
  , JS = () => "Terms"
  , QS = () => "Termos"
  , eP = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? JS() : QS()
  , tP = () => "Privacy"
  , rP = () => "Privacidade"
  , iP = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? tP() : rP()
  , nP = () => "Clear area"
  , aP = () => "Limpar área"
  , sP = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? nP() : aP()
  , oP = () => "Select the area's first corner"
  , lP = () => "Selecione o primeiro canto da área"
  , cP = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? oP() : lP()
  , uP = () => "Select the area's opposite corner"
  , hP = () => "Selecione o canto oposto da área"
  , dP = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? uP() : hP()
  , pP = () => "Suspender usuário"
  , fP = () => "timeout_user"
  , Qg = (b={}, l={}) => (l.locale ?? Fe()) === "en" ? fP() : pP()
  , Es = 2 * Math.PI * 6378137 / 2;
class hc {
    constructor(l=256) {
        lr(this, "initialResolution");
        this.tileSize = l,
        this.initialResolution = 2 * Es / this.tileSize
    }
    latLonToMeters(l, _) {
        const C = _ / 180 * Es
          , L = Math.log(Math.tan((90 + l) * Math.PI / 360)) / (Math.PI / 180) * Es / 180;
        return [C, L]
    }
    metersToLatLon(l, _) {
        const C = l / Es * 180;
        let L = _ / Es * 180;
        return L = 180 / Math.PI * (2 * Math.atan(Math.exp(L * Math.PI / 180)) - Math.PI / 2),
        [L, C]
    }
    pixelsToMeters(l, _, C) {
        const L = this.resolution(C)
          , O = l * L - Es
          , T = Es - _ * L;
        return [O, T]
    }
    pixelsToLatLon(l, _, C) {
        const [L,O] = this.pixelsToMeters(l, _, C);
        return this.metersToLatLon(L, O)
    }
    latLonToPixels(l, _, C) {
        const [L,O] = this.latLonToMeters(l, _);
        return this.metersToPixels(L, O, C)
    }
    latLonToPixelsFloor(l, _, C) {
        const [L,O] = this.latLonToPixels(l, _, C);
        return [Math.floor(L), Math.floor(O)]
    }
    metersToPixels(l, _, C) {
        const L = this.resolution(C)
          , O = (l + Es) / L
          , T = (Es - _) / L;
        return [O, T]
    }
    latLonToTile(l, _, C) {
        const [L,O] = this.latLonToMeters(l, _);
        return this.metersToTile(L, O, C)
    }
    metersToTile(l, _, C) {
        const [L,O] = this.metersToPixels(l, _, C);
        return this.pixelsToTile(L, O)
    }
    pixelsToTile(l, _) {
        const C = Math.ceil(l / this.tileSize) - 1
          , L = Math.ceil(_ / this.tileSize) - 1;
        return [C, L]
    }
    pixelsToTileLocal(l, _) {
        return {
            tile: this.pixelsToTile(l, _),
            pixel: [Math.floor(l) % this.tileSize, Math.floor(_) % this.tileSize]
        }
    }
    tileBounds(l, _, C) {
        const [L,O] = this.pixelsToMeters(l * this.tileSize, _ * this.tileSize, C)
          , [T,o] = this.pixelsToMeters((l + 1) * this.tileSize, (_ + 1) * this.tileSize, C);
        return {
            min: [L, O],
            max: [T, o]
        }
    }
    tileBoundsLatLon(l, _, C) {
        const L = this.tileBounds(l, _, C);
        return {
            min: this.metersToLatLon(L.min[0], L.min[1]),
            max: this.metersToLatLon(L.max[0], L.max[1])
        }
    }
    resolution(l) {
        return this.initialResolution / 2 ** l
    }
    latLonToTileAndPixel(l, _, C) {
        const [L,O] = this.latLonToMeters(l, _)
          , [T,o] = this.metersToTile(L, O, C)
          , [$,W] = this.metersToPixels(L, O, C);
        return {
            tile: [T, o],
            pixel: [Math.floor($) % this.tileSize, Math.floor(W) % this.tileSize]
        }
    }
    pixelBounds(l, _, C) {
        return {
            min: this.pixelsToMeters(l, _, C),
            max: this.pixelsToMeters(l + 1, _ + 1, C)
        }
    }
    pixelToBoundsLatLon(l, _, C) {
        const L = this.pixelBounds(l, _, C)
          , O = .001885
          , T = (L.max[0] - L.min[0]) * O
          , o = (L.max[1] - L.min[1]) * O;
        return L.min[0] -= T,
        L.max[0] -= T,
        L.min[1] -= o,
        L.max[1] -= o,
        {
            min: this.metersToLatLon(L.min[0], L.min[1]),
            max: this.metersToLatLon(L.max[0], L.max[1])
        }
    }
    latLonToTileBoundsLatLon(l, _, C) {
        const [L,O] = this.latLonToMeters(l, _)
          , [T,o] = this.metersToTile(L, O, C);
        return this.tileBoundsLatLon(T, o, C)
    }
    latLonToPixelBoundsLatLon(l, _, C) {
        const [L,O] = this.latLonToMeters(l, _)
          , [T,o] = this.metersToPixels(L, O, C);
        return this.pixelToBoundsLatLon(Math.floor(T), Math.floor(o), C)
    }
    latLonToRegionAndPixel(l, _, C, L=$n.regionSize) {
        const [O,T] = this.latLonToPixelsFloor(l, _, C)
          , o = this.tileSize * L;
        return {
            region: [Math.floor(O / o), Math.floor(T / o)],
            pixel: [O % o, T % o]
        }
    }
}
function rm(b, l=!0) {
    const {min: _, max: C} = b;
    return l ? [[_[1], C[0]], [C[1], C[0]], [C[1], _[0]], [_[1], _[0]]] : [[_[0], C[1]], [C[0], C[1]], [C[0], _[1]], [_[0], _[1]]]
}
function im(b) {
    return [(b.min[0] + b.max[0]) / 2, (b.min[1] + b.max[1]) / 2]
}
const mP = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg=="
  , dg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";
function _P(b) {
    return Math.floor(Math.random() * b)
}
const wf = 14.5;
async function gP() {
    const b = xP();
    if (b)
        return b;
    try {
        if ((await navigator.permissions.query({
            name: "geolocation"
        })).state === "granted") {
            const _ = await new Promise( (C, L) => navigator.geolocation.getCurrentPosition(O => C(O), O => L(O)));
            return {
                lat: _.coords.latitude,
                lng: _.coords.longitude,
                zoom: wf
            }
        }
    } catch (l) {
        console.error(l)
    }
    return {
        ...vP().pos,
        zoom: wf
    }
}
function vP() {
    const b = Object.entries(yP)
      , l = _P(b.length)
      , [_,C] = b[l];
    return {
        city: _,
        pos: C
    }
}
const yP = {
    tokyo: {
        lat: 35.677545560719665,
        lng: 139.76394445809638
    },
    paris: {
        lat: 48.8537151734952,
        lng: 2.3484026030630787
    },
    newYork: {
        lat: 40.71283173786517,
        lng: -74.00599771376795
    },
    saoPaulo: {
        lat: -23.550584064565356,
        lng: -46.63339720713918
    },
    sydney: {
        lat: -33.86943325619071,
        lng: 151.2083447239608
    }
}
  , ev = "location";
function Qa(b, l) {
    localStorage.setItem(ev, JSON.stringify({
        ...b,
        zoom: l
    }))
}
function xP() {
    const b = localStorage.getItem(ev);
    if (!b)
        return;
    const l = JSON.parse(b);
    return l.zoom ?? (l.zoom = wf),
    l
}
var ku, Eu;
class bP {
    constructor() {
        br(this, ku, nt(-1));
        br(this, Eu, nt([]))
    }
    get idx() {
        return x(et(this, ku))
    }
    set idx(l) {
        oe(et(this, ku), l, !0)
    }
    get entries() {
        return x(et(this, Eu))
    }
    set entries(l) {
        oe(et(this, Eu), l)
    }
    hasNext() {
        return this.idx < this.entries.length - 1
    }
    goToNext(l) {
        const _ = this.idx + 1
          , C = this.entries[_];
        C && (this.idx = _,
        l.flyTo({
            center: C.pos,
            zoom: C.zoom
        }))
    }
    hasPrev() {
        return this.idx > 0
    }
    goToPrev(l) {
        const _ = this.idx - 1
          , C = this.entries[_];
        C && (this.idx = _,
        l.flyTo({
            center: C.pos,
            zoom: C.zoom
        }))
    }
    isEmpty() {
        return this.entries.length === 0
    }
    push(l) {
        this.idx = this.idx + 1,
        this.entries = [...this.entries.slice(0, this.idx), l]
    }
}
ku = new WeakMap,
Eu = new WeakMap;
const Ho = new bP;
function nm(b) {
    return b && b.__esModule && Object.prototype.hasOwnProperty.call(b, "default") ? b.default : b
}
var Pd = {
    exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.2/LICENSE.txt
 */
var wP = Pd.exports, pg;
function TP() {
    return pg || (pg = 1,
    (function(b, l) {
        (function(_, C) {
            b.exports = C()
        }
        )(wP, (function() {
            var _ = {}
              , C = {};
            function L(T, o, $) {
                if (C[T] = $,
                T === "index") {
                    var W = "var sharedModule = {}; (" + C.shared + ")(sharedModule); (" + C.worker + ")(sharedModule);"
                      , ie = {};
                    return C.shared(ie),
                    C.index(_, ie),
                    typeof window < "u" && _.setWorkerUrl(window.URL.createObjectURL(new Blob([W],{
                        type: "text/javascript"
                    }))),
                    _
                }
            }
            L("shared", ["exports"], (function(T) {
                function o(i, t, r, a) {
                    return new (r || (r = Promise))((function(c, p) {
                        function f(S) {
                            try {
                                v(a.next(S))
                            } catch (I) {
                                p(I)
                            }
                        }
                        function g(S) {
                            try {
                                v(a.throw(S))
                            } catch (I) {
                                p(I)
                            }
                        }
                        function v(S) {
                            var I;
                            S.done ? c(S.value) : (I = S.value,
                            I instanceof r ? I : new r((function(E) {
                                E(I)
                            }
                            ))).then(f, g)
                        }
                        v((a = a.apply(i, t || [])).next())
                    }
                    ))
                }
                function $(i, t) {
                    this.x = i,
                    this.y = t
                }
                function W(i) {
                    return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
                }
                var ie, pe;
                typeof SuppressedError == "function" && SuppressedError,
                $.prototype = {
                    clone() {
                        return new $(this.x,this.y)
                    },
                    add(i) {
                        return this.clone()._add(i)
                    },
                    sub(i) {
                        return this.clone()._sub(i)
                    },
                    multByPoint(i) {
                        return this.clone()._multByPoint(i)
                    },
                    divByPoint(i) {
                        return this.clone()._divByPoint(i)
                    },
                    mult(i) {
                        return this.clone()._mult(i)
                    },
                    div(i) {
                        return this.clone()._div(i)
                    },
                    rotate(i) {
                        return this.clone()._rotate(i)
                    },
                    rotateAround(i, t) {
                        return this.clone()._rotateAround(i, t)
                    },
                    matMult(i) {
                        return this.clone()._matMult(i)
                    },
                    unit() {
                        return this.clone()._unit()
                    },
                    perp() {
                        return this.clone()._perp()
                    },
                    round() {
                        return this.clone()._round()
                    },
                    mag() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    },
                    equals(i) {
                        return this.x === i.x && this.y === i.y
                    },
                    dist(i) {
                        return Math.sqrt(this.distSqr(i))
                    },
                    distSqr(i) {
                        const t = i.x - this.x
                          , r = i.y - this.y;
                        return t * t + r * r
                    },
                    angle() {
                        return Math.atan2(this.y, this.x)
                    },
                    angleTo(i) {
                        return Math.atan2(this.y - i.y, this.x - i.x)
                    },
                    angleWith(i) {
                        return this.angleWithSep(i.x, i.y)
                    },
                    angleWithSep(i, t) {
                        return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t)
                    },
                    _matMult(i) {
                        const t = i[2] * this.x + i[3] * this.y;
                        return this.x = i[0] * this.x + i[1] * this.y,
                        this.y = t,
                        this
                    },
                    _add(i) {
                        return this.x += i.x,
                        this.y += i.y,
                        this
                    },
                    _sub(i) {
                        return this.x -= i.x,
                        this.y -= i.y,
                        this
                    },
                    _mult(i) {
                        return this.x *= i,
                        this.y *= i,
                        this
                    },
                    _div(i) {
                        return this.x /= i,
                        this.y /= i,
                        this
                    },
                    _multByPoint(i) {
                        return this.x *= i.x,
                        this.y *= i.y,
                        this
                    },
                    _divByPoint(i) {
                        return this.x /= i.x,
                        this.y /= i.y,
                        this
                    },
                    _unit() {
                        return this._div(this.mag()),
                        this
                    },
                    _perp() {
                        const i = this.y;
                        return this.y = this.x,
                        this.x = -i,
                        this
                    },
                    _rotate(i) {
                        const t = Math.cos(i)
                          , r = Math.sin(i)
                          , a = r * this.x + t * this.y;
                        return this.x = t * this.x - r * this.y,
                        this.y = a,
                        this
                    },
                    _rotateAround(i, t) {
                        const r = Math.cos(i)
                          , a = Math.sin(i)
                          , c = t.y + a * (this.x - t.x) + r * (this.y - t.y);
                        return this.x = t.x + r * (this.x - t.x) - a * (this.y - t.y),
                        this.y = c,
                        this
                    },
                    _round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this
                    },
                    constructor: $
                },
                $.convert = function(i) {
                    if (i instanceof $)
                        return i;
                    if (Array.isArray(i))
                        return new $(+i[0],+i[1]);
                    if (i.x !== void 0 && i.y !== void 0)
                        return new $(+i.x,+i.y);
                    throw new Error("Expected [x, y] or {x, y} point format")
                }
                ;
                var ye = (function() {
                    if (pe)
                        return ie;
                    function i(t, r, a, c) {
                        this.cx = 3 * t,
                        this.bx = 3 * (a - t) - this.cx,
                        this.ax = 1 - this.cx - this.bx,
                        this.cy = 3 * r,
                        this.by = 3 * (c - r) - this.cy,
                        this.ay = 1 - this.cy - this.by,
                        this.p1x = t,
                        this.p1y = r,
                        this.p2x = a,
                        this.p2y = c
                    }
                    return pe = 1,
                    ie = i,
                    i.prototype = {
                        sampleCurveX: function(t) {
                            return ((this.ax * t + this.bx) * t + this.cx) * t
                        },
                        sampleCurveY: function(t) {
                            return ((this.ay * t + this.by) * t + this.cy) * t
                        },
                        sampleCurveDerivativeX: function(t) {
                            return (3 * this.ax * t + 2 * this.bx) * t + this.cx
                        },
                        solveCurveX: function(t, r) {
                            if (r === void 0 && (r = 1e-6),
                            t < 0)
                                return 0;
                            if (t > 1)
                                return 1;
                            for (var a = t, c = 0; c < 8; c++) {
                                var p = this.sampleCurveX(a) - t;
                                if (Math.abs(p) < r)
                                    return a;
                                var f = this.sampleCurveDerivativeX(a);
                                if (Math.abs(f) < 1e-6)
                                    break;
                                a -= p / f
                            }
                            var g = 0
                              , v = 1;
                            for (a = t,
                            c = 0; c < 20 && (p = this.sampleCurveX(a),
                            !(Math.abs(p - t) < r)); c++)
                                t > p ? g = a : v = a,
                                a = .5 * (v - g) + g;
                            return a
                        },
                        solve: function(t, r) {
                            return this.sampleCurveY(this.solveCurveX(t, r))
                        }
                    },
                    ie
                }
                )()
                  , X = W(ye);
                let Se, we;
                function Re() {
                    return Se == null && (Se = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") && typeof createImageBitmap == "function"),
                    Se
                }
                function ke() {
                    if (we == null && (we = !1,
                    Re())) {
                        const t = new OffscreenCanvas(5,5).getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (t) {
                            for (let a = 0; a < 25; a++) {
                                const c = 4 * a;
                                t.fillStyle = `rgb(${c},${c + 1},${c + 2})`,
                                t.fillRect(a % 5, Math.floor(a / 5), 1, 1)
                            }
                            const r = t.getImageData(0, 0, 5, 5).data;
                            for (let a = 0; a < 100; a++)
                                if (a % 4 != 3 && r[a] !== a) {
                                    we = !0;
                                    break
                                }
                        }
                    }
                    return we || !1
                }
                var Oe = 1e-6
                  , Ee = typeof Float32Array < "u" ? Float32Array : Array;
                function Ne() {
                    var i = new Ee(9);
                    return Ee != Float32Array && (i[1] = 0,
                    i[2] = 0,
                    i[3] = 0,
                    i[5] = 0,
                    i[6] = 0,
                    i[7] = 0),
                    i[0] = 1,
                    i[4] = 1,
                    i[8] = 1,
                    i
                }
                function ft(i) {
                    return i[0] = 1,
                    i[1] = 0,
                    i[2] = 0,
                    i[3] = 0,
                    i[4] = 0,
                    i[5] = 1,
                    i[6] = 0,
                    i[7] = 0,
                    i[8] = 0,
                    i[9] = 0,
                    i[10] = 1,
                    i[11] = 0,
                    i[12] = 0,
                    i[13] = 0,
                    i[14] = 0,
                    i[15] = 1,
                    i
                }
                function ht() {
                    var i = new Ee(3);
                    return Ee != Float32Array && (i[0] = 0,
                    i[1] = 0,
                    i[2] = 0),
                    i
                }
                function Xe(i) {
                    return Math.hypot(i[0], i[1], i[2])
                }
                function ct(i, t, r) {
                    var a = new Ee(3);
                    return a[0] = i,
                    a[1] = t,
                    a[2] = r,
                    a
                }
                function Je(i, t, r) {
                    return i[0] = t[0] + r[0],
                    i[1] = t[1] + r[1],
                    i[2] = t[2] + r[2],
                    i
                }
                function Be(i, t, r) {
                    return i[0] = t[0] * r,
                    i[1] = t[1] * r,
                    i[2] = t[2] * r,
                    i
                }
                function st(i, t, r) {
                    var a = t[0]
                      , c = t[1]
                      , p = t[2]
                      , f = r[0]
                      , g = r[1]
                      , v = r[2];
                    return i[0] = c * v - p * g,
                    i[1] = p * f - a * v,
                    i[2] = a * g - c * f,
                    i
                }
                Math.hypot || (Math.hypot = function() {
                    for (var i = 0, t = arguments.length; t--; )
                        i += arguments[t] * arguments[t];
                    return Math.sqrt(i)
                }
                );
                var it, Qe = Xe;
                function Ae(i, t, r) {
                    var a = t[0]
                      , c = t[1]
                      , p = t[2]
                      , f = t[3];
                    return i[0] = r[0] * a + r[4] * c + r[8] * p + r[12] * f,
                    i[1] = r[1] * a + r[5] * c + r[9] * p + r[13] * f,
                    i[2] = r[2] * a + r[6] * c + r[10] * p + r[14] * f,
                    i[3] = r[3] * a + r[7] * c + r[11] * p + r[15] * f,
                    i
                }
                function vt() {
                    var i = new Ee(4);
                    return Ee != Float32Array && (i[0] = 0,
                    i[1] = 0,
                    i[2] = 0),
                    i[3] = 1,
                    i
                }
                function Q(i, t, r, a) {
                    var c = .5 * Math.PI / 180;
                    t *= c,
                    r *= c,
                    a *= c;
                    var p = Math.sin(t)
                      , f = Math.cos(t)
                      , g = Math.sin(r)
                      , v = Math.cos(r)
                      , S = Math.sin(a)
                      , I = Math.cos(a);
                    return i[0] = p * v * I - f * g * S,
                    i[1] = f * g * I + p * v * S,
                    i[2] = f * v * S - p * g * I,
                    i[3] = f * v * I + p * g * S,
                    i
                }
                function te() {
                    var i = new Ee(2);
                    return Ee != Float32Array && (i[0] = 0,
                    i[1] = 0),
                    i
                }
                function _e(i, t) {
                    var r = new Ee(2);
                    return r[0] = i,
                    r[1] = t,
                    r
                }
                ht(),
                it = new Ee(4),
                Ee != Float32Array && (it[0] = 0,
                it[1] = 0,
                it[2] = 0,
                it[3] = 0),
                ht(),
                ct(1, 0, 0),
                ct(0, 1, 0),
                vt(),
                vt(),
                Ne(),
                te();
                const ne = 8192;
                function Pe(i, t, r) {
                    return t * (ne / (i.tileSize * Math.pow(2, r - i.tileID.overscaledZ)))
                }
                function Me(i, t) {
                    return (i % t + t) % t
                }
                function at(i, t, r) {
                    return i * (1 - r) + t * r
                }
                function We(i) {
                    if (i <= 0)
                        return 0;
                    if (i >= 1)
                        return 1;
                    const t = i * i
                      , r = t * i;
                    return 4 * (i < .5 ? r : 3 * (i - t) + r - .75)
                }
                function Ct(i, t, r, a) {
                    const c = new X(i,t,r,a);
                    return p => c.solve(p)
                }
                const _t = Ct(.25, .1, .25, 1);
                function xt(i, t, r) {
                    return Math.min(r, Math.max(t, i))
                }
                function tt(i, t, r) {
                    const a = r - t
                      , c = ((i - t) % a + a) % a + t;
                    return c === t ? r : c
                }
                function pt(i, ...t) {
                    for (const r of t)
                        for (const a in r)
                            i[a] = r[a];
                    return i
                }
                let It = 1;
                function ut(i, t, r) {
                    const a = {};
                    for (const c in i)
                        a[c] = t.call(this, i[c], c, i);
                    return a
                }
                function bt(i, t, r) {
                    const a = {};
                    for (const c in i)
                        t.call(this, i[c], c, i) && (a[c] = i[c]);
                    return a
                }
                function wt(i) {
                    return Array.isArray(i) ? i.map(wt) : typeof i == "object" && i ? ut(i, wt) : i
                }
                const dt = {};
                function Lt(i) {
                    dt[i] || (typeof console < "u" && console.warn(i),
                    dt[i] = !0)
                }
                function Xt(i, t, r) {
                    return (r.y - i.y) * (t.x - i.x) > (t.y - i.y) * (r.x - i.x)
                }
                function Yt(i) {
                    return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope
                }
                let nr = null;
                function ar(i) {
                    return typeof ImageBitmap < "u" && i instanceof ImageBitmap
                }
                const Ft = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
                function dr(i, t, r, a, c) {
                    return o(this, void 0, void 0, (function*() {
                        if (typeof VideoFrame > "u")
                            throw new Error("VideoFrame not supported");
                        const p = new VideoFrame(i,{
                            timestamp: 0
                        });
                        try {
                            const f = p == null ? void 0 : p.format;
                            if (!f || !f.startsWith("BGR") && !f.startsWith("RGB"))
                                throw new Error(`Unrecognized format ${f}`);
                            const g = f.startsWith("BGR")
                              , v = new Uint8ClampedArray(a * c * 4);
                            if (yield p.copyTo(v, (function(S, I, E, R, N) {
                                const j = 4 * Math.max(-I, 0)
                                  , Z = (Math.max(0, E) - E) * R * 4 + j
                                  , Y = 4 * R
                                  , ae = Math.max(0, I)
                                  , ze = Math.max(0, E);
                                return {
                                    rect: {
                                        x: ae,
                                        y: ze,
                                        width: Math.min(S.width, I + R) - ae,
                                        height: Math.min(S.height, E + N) - ze
                                    },
                                    layout: [{
                                        offset: Z,
                                        stride: Y
                                    }]
                                }
                            }
                            )(i, t, r, a, c)),
                            g)
                                for (let S = 0; S < v.length; S += 4) {
                                    const I = v[S];
                                    v[S] = v[S + 2],
                                    v[S + 2] = I
                                }
                            return v
                        } finally {
                            p.close()
                        }
                    }
                    ))
                }
                let _r, Ir;
                function jr(i, t, r, a) {
                    return i.addEventListener(t, r, a),
                    {
                        unsubscribe: () => {
                            i.removeEventListener(t, r, a)
                        }
                    }
                }
                function ur(i) {
                    return i * Math.PI / 180
                }
                function Mr(i) {
                    return i / Math.PI * 180
                }
                const Ar = {
                    touchstart: !0,
                    touchmove: !0,
                    touchmoveWindow: !0,
                    touchend: !0,
                    touchcancel: !0
                }
                  , kr = {
                    dblclick: !0,
                    click: !0,
                    mouseover: !0,
                    mouseout: !0,
                    mousedown: !0,
                    mousemove: !0,
                    mousemoveWindow: !0,
                    mouseup: !0,
                    mouseupWindow: !0,
                    contextmenu: !0,
                    wheel: !0
                }
                  , Nr = "AbortError";
                function ce() {
                    return new Error(Nr)
                }
                const F = {
                    MAX_PARALLEL_IMAGE_REQUESTS: 16,
                    MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
                    MAX_TILE_CACHE_ZOOM_LEVELS: 5,
                    REGISTERED_PROTOCOLS: {},
                    WORKER_URL: ""
                };
                function q(i) {
                    return F.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))]
                }
                const G = "global-dispatcher";
                class K extends Error {
                    constructor(t, r, a, c) {
                        super(`AJAXError: ${r} (${t}): ${a}`),
                        this.status = t,
                        this.statusText = r,
                        this.url = a,
                        this.body = c
                    }
                }
                const le = () => Yt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href
                  , ve = function(i, t) {
                    if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
                        const a = q(i.url);
                        if (a)
                            return a(i, t);
                        if (Yt(self) && self.worker && self.worker.actor)
                            return self.worker.actor.sendAsync({
                                type: "GR",
                                data: i,
                                targetMapId: G
                            }, t)
                    }
                    if (!(/^file:/.test(r = i.url) || /^file:/.test(le()) && !/^\w+:/.test(r))) {
                        if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
                            return (function(a, c) {
                                return o(this, void 0, void 0, (function*() {
                                    const p = new Request(a.url,{
                                        method: a.method || "GET",
                                        body: a.body,
                                        credentials: a.credentials,
                                        headers: a.headers,
                                        cache: a.cache,
                                        referrer: le(),
                                        signal: c.signal
                                    });
                                    let f, g;
                                    a.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json");
                                    try {
                                        f = yield fetch(p)
                                    } catch (S) {
                                        throw new K(0,S.message,a.url,new Blob)
                                    }
                                    if (!f.ok) {
                                        const S = yield f.blob();
                                        throw new K(f.status,f.statusText,a.url,S)
                                    }
                                    g = a.type === "arrayBuffer" || a.type === "image" ? f.arrayBuffer() : a.type === "json" ? f.json() : f.text();
                                    const v = yield g;
                                    if (c.signal.aborted)
                                        throw ce();
                                    return {
                                        data: v,
                                        cacheControl: f.headers.get("Cache-Control"),
                                        expires: f.headers.get("Expires")
                                    }
                                }
                                ))
                            }
                            )(i, t);
                        if (Yt(self) && self.worker && self.worker.actor)
                            return self.worker.actor.sendAsync({
                                type: "GR",
                                data: i,
                                mustQueue: !0,
                                targetMapId: G
                            }, t)
                    }
                    var r;
                    return (function(a, c) {
                        return new Promise(( (p, f) => {
                            var g;
                            const v = new XMLHttpRequest;
                            v.open(a.method || "GET", a.url, !0),
                            a.type !== "arrayBuffer" && a.type !== "image" || (v.responseType = "arraybuffer");
                            for (const S in a.headers)
                                v.setRequestHeader(S, a.headers[S]);
                            a.type === "json" && (v.responseType = "text",
                            !((g = a.headers) === null || g === void 0) && g.Accept || v.setRequestHeader("Accept", "application/json")),
                            v.withCredentials = a.credentials === "include",
                            v.onerror = () => {
                                f(new Error(v.statusText))
                            }
                            ,
                            v.onload = () => {
                                if (!c.signal.aborted)
                                    if ((v.status >= 200 && v.status < 300 || v.status === 0) && v.response !== null) {
                                        let S = v.response;
                                        if (a.type === "json")
                                            try {
                                                S = JSON.parse(v.response)
                                            } catch (I) {
                                                return void f(I)
                                            }
                                        p({
                                            data: S,
                                            cacheControl: v.getResponseHeader("Cache-Control"),
                                            expires: v.getResponseHeader("Expires")
                                        })
                                    } else {
                                        const S = new Blob([v.response],{
                                            type: v.getResponseHeader("Content-Type")
                                        });
                                        f(new K(v.status,v.statusText,a.url,S))
                                    }
                            }
                            ,
                            c.signal.addEventListener("abort", ( () => {
                                v.abort(),
                                f(ce())
                            }
                            )),
                            v.send(a.body)
                        }
                        ))
                    }
                    )(i, t)
                };
                function Le(i) {
                    if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0)
                        return !0;
                    const t = new URL(i)
                      , r = window.location;
                    return t.protocol === r.protocol && t.host === r.host
                }
                function Ce(i, t, r) {
                    r[i] && r[i].indexOf(t) !== -1 || (r[i] = r[i] || [],
                    r[i].push(t))
                }
                function Ze(i, t, r) {
                    if (r && r[i]) {
                        const a = r[i].indexOf(t);
                        a !== -1 && r[i].splice(a, 1)
                    }
                }
                class ot {
                    constructor(t, r={}) {
                        pt(this, r),
                        this.type = t
                    }
                }
                class Ye extends ot {
                    constructor(t, r={}) {
                        super("error", pt({
                            error: t
                        }, r))
                    }
                }
                class Ot {
                    on(t, r) {
                        return this._listeners = this._listeners || {},
                        Ce(t, r, this._listeners),
                        {
                            unsubscribe: () => {
                                this.off(t, r)
                            }
                        }
                    }
                    off(t, r) {
                        return Ze(t, r, this._listeners),
                        Ze(t, r, this._oneTimeListeners),
                        this
                    }
                    once(t, r) {
                        return r ? (this._oneTimeListeners = this._oneTimeListeners || {},
                        Ce(t, r, this._oneTimeListeners),
                        this) : new Promise((a => this.once(t, a)))
                    }
                    fire(t, r) {
                        typeof t == "string" && (t = new ot(t,r || {}));
                        const a = t.type;
                        if (this.listens(a)) {
                            t.target = this;
                            const c = this._listeners && this._listeners[a] ? this._listeners[a].slice() : [];
                            for (const g of c)
                                g.call(this, t);
                            const p = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : [];
                            for (const g of p)
                                Ze(a, g, this._oneTimeListeners),
                                g.call(this, t);
                            const f = this._eventedParent;
                            f && (pt(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData),
                            f.fire(t))
                        } else
                            t instanceof Ye && console.error(t.error);
                        return this
                    }
                    listens(t) {
                        return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
                    }
                    setEventedParent(t, r) {
                        return this._eventedParent = t,
                        this._eventedParentData = r,
                        this
                    }
                }
                var xe = {
                    $version: 8,
                    $root: {
                        version: {
                            required: !0,
                            type: "enum",
                            values: [8]
                        },
                        name: {
                            type: "string"
                        },
                        metadata: {
                            type: "*"
                        },
                        center: {
                            type: "array",
                            value: "number"
                        },
                        centerAltitude: {
                            type: "number"
                        },
                        zoom: {
                            type: "number"
                        },
                        bearing: {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees"
                        },
                        pitch: {
                            type: "number",
                            default: 0,
                            units: "degrees"
                        },
                        roll: {
                            type: "number",
                            default: 0,
                            units: "degrees"
                        },
                        state: {
                            type: "state",
                            default: {}
                        },
                        light: {
                            type: "light"
                        },
                        sky: {
                            type: "sky"
                        },
                        projection: {
                            type: "projection"
                        },
                        terrain: {
                            type: "terrain"
                        },
                        sources: {
                            required: !0,
                            type: "sources"
                        },
                        sprite: {
                            type: "sprite"
                        },
                        glyphs: {
                            type: "string"
                        },
                        transition: {
                            type: "transition"
                        },
                        layers: {
                            required: !0,
                            type: "array",
                            value: "layer"
                        }
                    },
                    sources: {
                        "*": {
                            type: "source"
                        }
                    },
                    source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
                    source_vector: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                vector: {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        scheme: {
                            type: "enum",
                            values: {
                                xyz: {},
                                tms: {}
                            },
                            default: "xyz"
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        attribution: {
                            type: "string"
                        },
                        promoteId: {
                            type: "promoteId"
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_raster: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                raster: {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        tileSize: {
                            type: "number",
                            default: 512,
                            units: "pixels"
                        },
                        scheme: {
                            type: "enum",
                            values: {
                                xyz: {},
                                tms: {}
                            },
                            default: "xyz"
                        },
                        attribution: {
                            type: "string"
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_raster_dem: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                "raster-dem": {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        tileSize: {
                            type: "number",
                            default: 512,
                            units: "pixels"
                        },
                        attribution: {
                            type: "string"
                        },
                        encoding: {
                            type: "enum",
                            values: {
                                terrarium: {},
                                mapbox: {},
                                custom: {}
                            },
                            default: "mapbox"
                        },
                        redFactor: {
                            type: "number",
                            default: 1
                        },
                        blueFactor: {
                            type: "number",
                            default: 1
                        },
                        greenFactor: {
                            type: "number",
                            default: 1
                        },
                        baseShift: {
                            type: "number",
                            default: 0
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_geojson: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                geojson: {}
                            }
                        },
                        data: {
                            required: !0,
                            type: "*"
                        },
                        maxzoom: {
                            type: "number",
                            default: 18
                        },
                        attribution: {
                            type: "string"
                        },
                        buffer: {
                            type: "number",
                            default: 128,
                            maximum: 512,
                            minimum: 0
                        },
                        filter: {
                            type: "*"
                        },
                        tolerance: {
                            type: "number",
                            default: .375
                        },
                        cluster: {
                            type: "boolean",
                            default: !1
                        },
                        clusterRadius: {
                            type: "number",
                            default: 50,
                            minimum: 0
                        },
                        clusterMaxZoom: {
                            type: "number"
                        },
                        clusterMinPoints: {
                            type: "number"
                        },
                        clusterProperties: {
                            type: "*"
                        },
                        lineMetrics: {
                            type: "boolean",
                            default: !1
                        },
                        generateId: {
                            type: "boolean",
                            default: !1
                        },
                        promoteId: {
                            type: "promoteId"
                        }
                    },
                    source_video: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                video: {}
                            }
                        },
                        urls: {
                            required: !0,
                            type: "array",
                            value: "string"
                        },
                        coordinates: {
                            required: !0,
                            type: "array",
                            length: 4,
                            value: {
                                type: "array",
                                length: 2,
                                value: "number"
                            }
                        }
                    },
                    source_image: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                image: {}
                            }
                        },
                        url: {
                            required: !0,
                            type: "string"
                        },
                        coordinates: {
                            required: !0,
                            type: "array",
                            length: 4,
                            value: {
                                type: "array",
                                length: 2,
                                value: "number"
                            }
                        }
                    },
                    layer: {
                        id: {
                            type: "string",
                            required: !0
                        },
                        type: {
                            type: "enum",
                            values: {
                                fill: {},
                                line: {},
                                symbol: {},
                                circle: {},
                                heatmap: {},
                                "fill-extrusion": {},
                                raster: {},
                                hillshade: {},
                                "color-relief": {},
                                background: {}
                            },
                            required: !0
                        },
                        metadata: {
                            type: "*"
                        },
                        source: {
                            type: "string"
                        },
                        "source-layer": {
                            type: "string"
                        },
                        minzoom: {
                            type: "number",
                            minimum: 0,
                            maximum: 24
                        },
                        maxzoom: {
                            type: "number",
                            minimum: 0,
                            maximum: 24
                        },
                        filter: {
                            type: "filter"
                        },
                        layout: {
                            type: "layout"
                        },
                        paint: {
                            type: "paint"
                        }
                    },
                    layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
                    layout_background: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_fill: {
                        "fill-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_circle: {
                        "circle-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_heatmap: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    "layout_fill-extrusion": {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_line: {
                        "line-cap": {
                            type: "enum",
                            values: {
                                butt: {},
                                round: {},
                                square: {}
                            },
                            default: "butt",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-join": {
                            type: "enum",
                            values: {
                                bevel: {},
                                round: {},
                                miter: {}
                            },
                            default: "miter",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-miter-limit": {
                            type: "number",
                            default: 2,
                            requires: [{
                                "line-join": "miter"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-round-limit": {
                            type: "number",
                            default: 1.05,
                            requires: [{
                                "line-join": "round"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_symbol: {
                        "symbol-placement": {
                            type: "enum",
                            values: {
                                point: {},
                                line: {},
                                "line-center": {}
                            },
                            default: "point",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-spacing": {
                            type: "number",
                            default: 250,
                            minimum: 1,
                            units: "pixels",
                            requires: [{
                                "symbol-placement": "line"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-avoid-edges": {
                            type: "boolean",
                            default: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "symbol-z-order": {
                            type: "enum",
                            values: {
                                auto: {},
                                "viewport-y": {},
                                source: {}
                            },
                            default: "auto",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-allow-overlap": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", {
                                "!": "icon-overlap"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-overlap": {
                            type: "enum",
                            values: {
                                never: {},
                                always: {},
                                cooperative: {}
                            },
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-ignore-placement": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-optional": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", "text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-rotation-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-size": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            units: "factor of the original icon size",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-text-fit": {
                            type: "enum",
                            values: {
                                none: {},
                                width: {},
                                height: {},
                                both: {}
                            },
                            default: "none",
                            requires: ["icon-image", "text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-text-fit-padding": {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [0, 0, 0, 0],
                            units: "pixels",
                            requires: ["icon-image", "text-field", {
                                "icon-text-fit": ["both", "width", "height"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-image": {
                            type: "resolvedImage",
                            tokens: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-padding": {
                            type: "padding",
                            default: [2],
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-keep-upright": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", {
                                "icon-rotation-alignment": "map"
                            }, {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-offset": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-anchor": {
                            type: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            default: "center",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-rotation-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                "viewport-glyph": {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-field": {
                            type: "formatted",
                            default: "",
                            tokens: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-font": {
                            type: "array",
                            value: "string",
                            default: ["Open Sans Regular", "Arial Unicode MS Regular"],
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-size": {
                            type: "number",
                            default: 16,
                            minimum: 0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-max-width": {
                            type: "number",
                            default: 10,
                            minimum: 0,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-line-height": {
                            type: "number",
                            default: 1.2,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-letter-spacing": {
                            type: "number",
                            default: 0,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-justify": {
                            type: "enum",
                            values: {
                                auto: {},
                                left: {},
                                center: {},
                                right: {}
                            },
                            default: "center",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-radial-offset": {
                            type: "number",
                            units: "ems",
                            default: 0,
                            requires: ["text-field"],
                            "property-type": "data-driven",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            }
                        },
                        "text-variable-anchor": {
                            type: "array",
                            value: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-variable-anchor-offset": {
                            type: "variableAnchorOffsetCollection",
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-anchor": {
                            type: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            default: "center",
                            requires: ["text-field", {
                                "!": "text-variable-anchor"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-max-angle": {
                            type: "number",
                            default: 45,
                            units: "degrees",
                            requires: ["text-field", {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-writing-mode": {
                            type: "array",
                            value: "enum",
                            values: {
                                horizontal: {},
                                vertical: {}
                            },
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-padding": {
                            type: "number",
                            default: 2,
                            minimum: 0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-keep-upright": {
                            type: "boolean",
                            default: !0,
                            requires: ["text-field", {
                                "text-rotation-alignment": "map"
                            }, {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-transform": {
                            type: "enum",
                            values: {
                                none: {},
                                uppercase: {},
                                lowercase: {}
                            },
                            default: "none",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-offset": {
                            type: "array",
                            value: "number",
                            units: "ems",
                            length: 2,
                            default: [0, 0],
                            requires: ["text-field", {
                                "!": "text-radial-offset"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-allow-overlap": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field", {
                                "!": "text-overlap"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-overlap": {
                            type: "enum",
                            values: {
                                never: {},
                                always: {},
                                cooperative: {}
                            },
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-ignore-placement": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-optional": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field", "icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_raster: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_hillshade: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    "layout_color-relief": {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    filter: {
                        type: "array",
                        value: "*"
                    },
                    filter_operator: {
                        type: "enum",
                        values: {
                            "==": {},
                            "!=": {},
                            ">": {},
                            ">=": {},
                            "<": {},
                            "<=": {},
                            in: {},
                            "!in": {},
                            all: {},
                            any: {},
                            none: {},
                            has: {},
                            "!has": {}
                        }
                    },
                    geometry_type: {
                        type: "enum",
                        values: {
                            Point: {},
                            LineString: {},
                            Polygon: {}
                        }
                    },
                    function: {
                        expression: {
                            type: "expression"
                        },
                        stops: {
                            type: "array",
                            value: "function_stop"
                        },
                        base: {
                            type: "number",
                            default: 1,
                            minimum: 0
                        },
                        property: {
                            type: "string",
                            default: "$zoom"
                        },
                        type: {
                            type: "enum",
                            values: {
                                identity: {},
                                exponential: {},
                                interval: {},
                                categorical: {}
                            },
                            default: "exponential"
                        },
                        colorSpace: {
                            type: "enum",
                            values: {
                                rgb: {},
                                lab: {},
                                hcl: {}
                            },
                            default: "rgb"
                        },
                        default: {
                            type: "*",
                            required: !1
                        }
                    },
                    function_stop: {
                        type: "array",
                        minimum: 0,
                        maximum: 24,
                        value: ["number", "color"],
                        length: 2
                    },
                    expression: {
                        type: "array",
                        value: "*",
                        minimum: 1
                    },
                    light: {
                        anchor: {
                            type: "enum",
                            default: "viewport",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            "property-type": "data-constant",
                            transition: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            }
                        },
                        position: {
                            type: "array",
                            default: [1.15, 210, 30],
                            length: 3,
                            value: "number",
                            "property-type": "data-constant",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            }
                        },
                        color: {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        intensity: {
                            type: "number",
                            "property-type": "data-constant",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        }
                    },
                    sky: {
                        "sky-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#88C6FC",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "horizon-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "fog-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "fog-ground-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "horizon-fog-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "sky-horizon-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "atmosphere-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        }
                    },
                    terrain: {
                        source: {
                            type: "string",
                            required: !0
                        },
                        exaggeration: {
                            type: "number",
                            minimum: 0,
                            default: 1
                        }
                    },
                    projection: {
                        type: {
                            type: "projectionDefinition",
                            default: "mercator",
                            "property-type": "data-constant",
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            }
                        }
                    },
                    paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
                    paint_fill: {
                        "fill-antialias": {
                            type: "boolean",
                            default: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "fill-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-outline-color": {
                            type: "color",
                            transition: !0,
                            requires: [{
                                "!": "fill-pattern"
                            }, {
                                "fill-antialias": !0
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["fill-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        }
                    },
                    "paint_fill-extrusion": {
                        "fill-extrusion-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "fill-extrusion-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["fill-extrusion-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        },
                        "fill-extrusion-height": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "meters",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-base": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "meters",
                            transition: !0,
                            requires: ["fill-extrusion-height"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-vertical-gradient": {
                            type: "boolean",
                            default: !0,
                            transition: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_line: {
                        "line-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "line-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["line-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-width": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-gap-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-offset": {
                            type: "number",
                            default: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-dasharray": {
                            type: "array",
                            value: "number",
                            minimum: 0,
                            transition: !0,
                            units: "line widths",
                            requires: [{
                                "!": "line-pattern"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "cross-faded"
                        },
                        "line-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        },
                        "line-gradient": {
                            type: "color",
                            transition: !1,
                            requires: [{
                                "!": "line-dasharray"
                            }, {
                                "!": "line-pattern"
                            }, {
                                source: "geojson",
                                has: {
                                    lineMetrics: !0
                                }
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["line-progress"]
                            },
                            "property-type": "color-ramp"
                        }
                    },
                    paint_circle: {
                        "circle-radius": {
                            type: "number",
                            default: 5,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-blur": {
                            type: "number",
                            default: 0,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["circle-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-pitch-scale": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "viewport",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-stroke-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-stroke-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-stroke-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        }
                    },
                    paint_heatmap: {
                        "heatmap-radius": {
                            type: "number",
                            default: 30,
                            minimum: 1,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "heatmap-weight": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "heatmap-intensity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "heatmap-color": {
                            type: "color",
                            default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"],
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["heatmap-density"]
                            },
                            "property-type": "color-ramp"
                        },
                        "heatmap-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_symbol: {
                        "icon-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-color": {
                            type: "color",
                            default: "rgba(0, 0, 0, 0)",
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["icon-image", "icon-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            overridable: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-color": {
                            type: "color",
                            default: "rgba(0, 0, 0, 0)",
                            transition: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["text-field", "text-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_raster: {
                        "raster-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-hue-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            transition: !0,
                            units: "degrees",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-brightness-min": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-brightness-max": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-saturation": {
                            type: "number",
                            default: 0,
                            minimum: -1,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-contrast": {
                            type: "number",
                            default: 0,
                            minimum: -1,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-resampling": {
                            type: "enum",
                            values: {
                                linear: {},
                                nearest: {}
                            },
                            default: "linear",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-fade-duration": {
                            type: "number",
                            default: 300,
                            minimum: 0,
                            transition: !1,
                            units: "milliseconds",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_hillshade: {
                        "hillshade-illumination-direction": {
                            type: "numberArray",
                            default: 335,
                            minimum: 0,
                            maximum: 359,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-illumination-altitude": {
                            type: "numberArray",
                            default: 45,
                            minimum: 0,
                            maximum: 90,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-illumination-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "viewport",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-exaggeration": {
                            type: "number",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-shadow-color": {
                            type: "colorArray",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-highlight-color": {
                            type: "colorArray",
                            default: "#FFFFFF",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-accent-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-method": {
                            type: "enum",
                            values: {
                                standard: {},
                                basic: {},
                                combined: {},
                                igor: {},
                                multidirectional: {}
                            },
                            default: "standard",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    "paint_color-relief": {
                        "color-relief-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "color-relief-color": {
                            type: "color",
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["elevation"]
                            },
                            "property-type": "color-ramp"
                        }
                    },
                    paint_background: {
                        "background-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "background-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "background-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "cross-faded"
                        },
                        "background-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    transition: {
                        duration: {
                            type: "number",
                            default: 300,
                            minimum: 0,
                            units: "milliseconds"
                        },
                        delay: {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "milliseconds"
                        }
                    },
                    "property-type": {
                        "data-driven": {
                            type: "property-type"
                        },
                        "cross-faded": {
                            type: "property-type"
                        },
                        "cross-faded-data-driven": {
                            type: "property-type"
                        },
                        "color-ramp": {
                            type: "property-type"
                        },
                        "data-constant": {
                            type: "property-type"
                        },
                        constant: {
                            type: "property-type"
                        }
                    },
                    promoteId: {
                        "*": {
                            type: "string"
                        }
                    }
                };
                const At = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
                function Pt(i, t) {
                    const r = {};
                    for (const a in i)
                        a !== "ref" && (r[a] = i[a]);
                    return At.forEach((a => {
                        a in t && (r[a] = t[a])
                    }
                    )),
                    r
                }
                function kt(i, t) {
                    if (Array.isArray(i)) {
                        if (!Array.isArray(t) || i.length !== t.length)
                            return !1;
                        for (let r = 0; r < i.length; r++)
                            if (!kt(i[r], t[r]))
                                return !1;
                        return !0
                    }
                    if (typeof i == "object" && i !== null && t !== null) {
                        if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length)
                            return !1;
                        for (const r in i)
                            if (!kt(i[r], t[r]))
                                return !1;
                        return !0
                    }
                    return i === t
                }
                function Wt(i, t) {
                    i.push(t)
                }
                function Lr(i, t, r) {
                    Wt(r, {
                        command: "addSource",
                        args: [i, t[i]]
                    })
                }
                function Kr(i, t, r) {
                    Wt(t, {
                        command: "removeSource",
                        args: [i]
                    }),
                    r[i] = !0
                }
                function Hr(i, t, r, a) {
                    Kr(i, r, a),
                    Lr(i, t, r)
                }
                function $r(i, t, r) {
                    let a;
                    for (a in i[r])
                        if (Object.prototype.hasOwnProperty.call(i[r], a) && a !== "data" && !kt(i[r][a], t[r][a]))
                            return !1;
                    for (a in t[r])
                        if (Object.prototype.hasOwnProperty.call(t[r], a) && a !== "data" && !kt(i[r][a], t[r][a]))
                            return !1;
                    return !0
                }
                function mr(i, t, r, a, c, p) {
                    i = i || {},
                    t = t || {};
                    for (const f in i)
                        Object.prototype.hasOwnProperty.call(i, f) && (kt(i[f], t[f]) || r.push({
                            command: p,
                            args: [a, f, t[f], c]
                        }));
                    for (const f in t)
                        Object.prototype.hasOwnProperty.call(t, f) && !Object.prototype.hasOwnProperty.call(i, f) && (kt(i[f], t[f]) || r.push({
                            command: p,
                            args: [a, f, t[f], c]
                        }))
                }
                function gr(i) {
                    return i.id
                }
                function ai(i, t) {
                    return i[t.id] = t,
                    i
                }
                class Tt {
                    constructor(t, r, a, c) {
                        this.message = (t ? `${t}: ` : "") + a,
                        c && (this.identifier = c),
                        r != null && r.__line__ && (this.line = r.__line__)
                    }
                }
                function Ci(i, ...t) {
                    for (const r of t)
                        for (const a in r)
                            i[a] = r[a];
                    return i
                }
                class di extends Error {
                    constructor(t, r) {
                        super(r),
                        this.message = r,
                        this.key = t
                    }
                }
                class Pn {
                    constructor(t, r=[]) {
                        this.parent = t,
                        this.bindings = {};
                        for (const [a,c] of r)
                            this.bindings[a] = c
                    }
                    concat(t) {
                        return new Pn(this,t)
                    }
                    get(t) {
                        if (this.bindings[t])
                            return this.bindings[t];
                        if (this.parent)
                            return this.parent.get(t);
                        throw new Error(`${t} not found in scope.`)
                    }
                    has(t) {
                        return !!this.bindings[t] || !!this.parent && this.parent.has(t)
                    }
                }
                const Mt = {
                    kind: "null"
                }
                  , Ke = {
                    kind: "number"
                }
                  , jt = {
                    kind: "string"
                }
                  , Gt = {
                    kind: "boolean"
                }
                  , Dr = {
                    kind: "color"
                }
                  , Gr = {
                    kind: "projectionDefinition"
                }
                  , li = {
                    kind: "object"
                }
                  , fr = {
                    kind: "value"
                }
                  , bi = {
                    kind: "collator"
                }
                  , Si = {
                    kind: "formatted"
                }
                  , zi = {
                    kind: "padding"
                }
                  , mi = {
                    kind: "colorArray"
                }
                  , Li = {
                    kind: "numberArray"
                }
                  , rr = {
                    kind: "resolvedImage"
                }
                  , yi = {
                    kind: "variableAnchorOffsetCollection"
                };
                function Qr(i, t) {
                    return {
                        kind: "array",
                        itemType: i,
                        N: t
                    }
                }
                function Yr(i) {
                    if (i.kind === "array") {
                        const t = Yr(i.itemType);
                        return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`
                    }
                    return i.kind
                }
                const la = [Mt, Ke, jt, Gt, Dr, Gr, Si, li, Qr(fr), zi, Li, mi, rr, yi];
                function sn(i, t) {
                    if (t.kind === "error")
                        return null;
                    if (i.kind === "array") {
                        if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !sn(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N))
                            return null
                    } else {
                        if (i.kind === t.kind)
                            return null;
                        if (i.kind === "value") {
                            for (const r of la)
                                if (!sn(r, t))
                                    return null
                        }
                    }
                    return `Expected ${Yr(i)} but found ${Yr(t)} instead.`
                }
                function ta(i, t) {
                    return t.some((r => r.kind === i.kind))
                }
                function Fi(i, t) {
                    return t.some((r => r === "null" ? i === null : r === "array" ? Array.isArray(i) : r === "object" ? i && !Array.isArray(i) && typeof i == "object" : r === typeof i))
                }
                function Xi(i, t) {
                    return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind
                }
                const Gn = .96422
                  , Hn = .82521
                  , Ln = 4 / 29
                  , gt = 6 / 29
                  , qt = 3 * gt * gt
                  , vr = gt * gt * gt
                  , _i = Math.PI / 180
                  , Di = 180 / Math.PI;
                function $i(i) {
                    return (i %= 360) < 0 && (i += 360),
                    i
                }
                function Mi([i,t,r,a]) {
                    let c, p;
                    const f = gn((.2225045 * (i = Cr(i)) + .7168786 * (t = Cr(t)) + .0606169 * (r = Cr(r))) / 1);
                    i === t && t === r ? c = p = f : (c = gn((.4360747 * i + .3850649 * t + .1430804 * r) / Gn),
                    p = gn((.0139322 * i + .0971045 * t + .7141733 * r) / Hn));
                    const g = 116 * f - 16;
                    return [g < 0 ? 0 : g, 500 * (c - f), 200 * (f - p), a]
                }
                function Cr(i) {
                    return i <= .04045 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)
                }
                function gn(i) {
                    return i > vr ? Math.pow(i, 1 / 3) : i / qt + Ln
                }
                function tr([i,t,r,a]) {
                    let c = (i + 16) / 116
                      , p = isNaN(t) ? c : c + t / 500
                      , f = isNaN(r) ? c : c - r / 200;
                    return c = 1 * ei(c),
                    p = Gn * ei(p),
                    f = Hn * ei(f),
                    [Ht(3.1338561 * p - 1.6168667 * c - .4906146 * f), Ht(-.9787684 * p + 1.9161415 * c + .033454 * f), Ht(.0719453 * p - .2289914 * c + 1.4052427 * f), a]
                }
                function Ht(i) {
                    return (i = i <= .00304 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - .055) < 0 ? 0 : i > 1 ? 1 : i
                }
                function ei(i) {
                    return i > gt ? i * i * i : qt * (i - Ln)
                }
                const ri = Object.hasOwn || function(i, t) {
                    return Object.prototype.hasOwnProperty.call(i, t)
                }
                ;
                function gi(i, t) {
                    return ri(i, t) ? i[t] : void 0
                }
                function ci(i) {
                    return parseInt(i.padEnd(2, i), 16) / 255
                }
                function pi(i, t) {
                    return Er(t ? i / 100 : i, 0, 1)
                }
                function Er(i, t, r) {
                    return Math.min(Math.max(t, i), r)
                }
                function Ri(i) {
                    return !i.some(Number.isNaN)
                }
                const ui = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    grey: [128, 128, 128],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    rebeccapurple: [102, 51, 153],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 50]
                };
                function Jr(i, t, r) {
                    return i + r * (t - i)
                }
                function ti(i, t, r) {
                    return i.map(( (a, c) => Jr(a, t[c], r)))
                }
                class yr {
                    constructor(t, r, a, c=1, p=!0) {
                        this.r = t,
                        this.g = r,
                        this.b = a,
                        this.a = c,
                        p || (this.r *= c,
                        this.g *= c,
                        this.b *= c,
                        c || this.overwriteGetter("rgb", [t, r, a, c]))
                    }
                    static parse(t) {
                        if (t instanceof yr)
                            return t;
                        if (typeof t != "string")
                            return;
                        const r = (function(a) {
                            if ((a = a.toLowerCase().trim()) === "transparent")
                                return [0, 0, 0, 0];
                            const c = gi(ui, a);
                            if (c) {
                                const [f,g,v] = c;
                                return [f / 255, g / 255, v / 255, 1]
                            }
                            if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) {
                                const f = a.length < 6 ? 1 : 2;
                                let g = 1;
                                return [ci(a.slice(g, g += f)), ci(a.slice(g, g += f)), ci(a.slice(g, g += f)), ci(a.slice(g, g + f) || "ff")]
                            }
                            if (a.startsWith("rgb")) {
                                const f = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                                if (f) {
                                    const [g,v,S,I,E,R,N,j,Z,Y,ae,ze] = f
                                      , me = [I || " ", N || " ", Y].join("");
                                    if (me === "  " || me === "  /" || me === ",," || me === ",,,") {
                                        const be = [S, R, Z].join("")
                                          , Ve = be === "%%%" ? 100 : be === "" ? 255 : 0;
                                        if (Ve) {
                                            const rt = [Er(+v / Ve, 0, 1), Er(+E / Ve, 0, 1), Er(+j / Ve, 0, 1), ae ? pi(+ae, ze) : 1];
                                            if (Ri(rt))
                                                return rt
                                        }
                                    }
                                    return
                                }
                            }
                            const p = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                            if (p) {
                                const [f,g,v,S,I,E,R,N,j] = p
                                  , Z = [v || " ", I || " ", R].join("");
                                if (Z === "  " || Z === "  /" || Z === ",," || Z === ",,,") {
                                    const Y = [+g, Er(+S, 0, 100), Er(+E, 0, 100), N ? pi(+N, j) : 1];
                                    if (Ri(Y))
                                        return (function([ae,ze,me,be]) {
                                            function Ve(rt) {
                                                const St = (rt + ae / 30) % 12
                                                  , $t = ze * Math.min(me, 1 - me);
                                                return me - $t * Math.max(-1, Math.min(St - 3, 9 - St, 1))
                                            }
                                            return ae = $i(ae),
                                            ze /= 100,
                                            me /= 100,
                                            [Ve(0), Ve(8), Ve(4), be]
                                        }
                                        )(Y)
                                }
                            }
                        }
                        )(t);
                        return r ? new yr(...r,!1) : void 0
                    }
                    get rgb() {
                        const {r: t, g: r, b: a, a: c} = this
                          , p = c || 1 / 0;
                        return this.overwriteGetter("rgb", [t / p, r / p, a / p, c])
                    }
                    get hcl() {
                        return this.overwriteGetter("hcl", (function(t) {
                            const [r,a,c,p] = Mi(t)
                              , f = Math.sqrt(a * a + c * c);
                            return [Math.round(1e4 * f) ? $i(Math.atan2(c, a) * Di) : NaN, f, r, p]
                        }
                        )(this.rgb))
                    }
                    get lab() {
                        return this.overwriteGetter("lab", Mi(this.rgb))
                    }
                    overwriteGetter(t, r) {
                        return Object.defineProperty(this, t, {
                            value: r
                        }),
                        r
                    }
                    toString() {
                        const [t,r,a,c] = this.rgb;
                        return `rgba(${[t, r, a].map((p => Math.round(255 * p))).join(",")},${c})`
                    }
                    static interpolate(t, r, a, c="rgb") {
                        switch (c) {
                        case "rgb":
                            {
                                const [p,f,g,v] = ti(t.rgb, r.rgb, a);
                                return new yr(p,f,g,v,!1)
                            }
                        case "hcl":
                            {
                                const [p,f,g,v] = t.hcl
                                  , [S,I,E,R] = r.hcl;
                                let N, j;
                                if (isNaN(p) || isNaN(S))
                                    isNaN(p) ? isNaN(S) ? N = NaN : (N = S,
                                    g !== 1 && g !== 0 || (j = I)) : (N = p,
                                    E !== 1 && E !== 0 || (j = f));
                                else {
                                    let me = S - p;
                                    S > p && me > 180 ? me -= 360 : S < p && p - S > 180 && (me += 360),
                                    N = p + a * me
                                }
                                const [Z,Y,ae,ze] = (function([me,be,Ve,rt]) {
                                    return me = isNaN(me) ? 0 : me * _i,
                                    tr([Ve, Math.cos(me) * be, Math.sin(me) * be, rt])
                                }
                                )([N, j ?? Jr(f, I, a), Jr(g, E, a), Jr(v, R, a)]);
                                return new yr(Z,Y,ae,ze,!1)
                            }
                        case "lab":
                            {
                                const [p,f,g,v] = tr(ti(t.lab, r.lab, a));
                                return new yr(p,f,g,v,!1)
                            }
                        }
                    }
                }
                yr.black = new yr(0,0,0,1),
                yr.white = new yr(1,1,1,1),
                yr.transparent = new yr(0,0,0,0),
                yr.red = new yr(1,0,0,1);
                class on {
                    constructor(t, r, a) {
                        this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base",
                        this.locale = a,
                        this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                            sensitivity: this.sensitivity,
                            usage: "search"
                        })
                    }
                    compare(t, r) {
                        return this.collator.compare(t, r)
                    }
                    resolvedLocale() {
                        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                    }
                }
                const vn = ["bottom", "center", "top"];
                class _a {
                    constructor(t, r, a, c, p, f) {
                        this.text = t,
                        this.image = r,
                        this.scale = a,
                        this.fontStack = c,
                        this.textColor = p,
                        this.verticalAlign = f
                    }
                }
                class ln {
                    constructor(t) {
                        this.sections = t
                    }
                    static fromString(t) {
                        return new ln([new _a(t,null,null,null,null,null)])
                    }
                    isEmpty() {
                        return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
                    }
                    static factory(t) {
                        return t instanceof ln ? t : ln.fromString(t)
                    }
                    toString() {
                        return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
                    }
                }
                class Ki {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof Ki)
                            return t;
                        if (typeof t == "number")
                            return new Ki([t, t, t, t]);
                        if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
                            for (const r of t)
                                if (typeof r != "number")
                                    return;
                            switch (t.length) {
                            case 1:
                                t = [t[0], t[0], t[0], t[0]];
                                break;
                            case 2:
                                t = [t[0], t[1], t[0], t[1]];
                                break;
                            case 3:
                                t = [t[0], t[1], t[2], t[1]]
                            }
                            return new Ki(t)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, r, a) {
                        return new Ki(ti(t.values, r.values, a))
                    }
                }
                class cn {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof cn)
                            return t;
                        if (typeof t == "number")
                            return new cn([t]);
                        if (Array.isArray(t)) {
                            for (const r of t)
                                if (typeof r != "number")
                                    return;
                            return new cn(t)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, r, a) {
                        return new cn(ti(t.values, r.values, a))
                    }
                }
                class Ni {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof Ni)
                            return t;
                        if (typeof t == "string") {
                            const a = yr.parse(t);
                            return a ? new Ni([a]) : void 0
                        }
                        if (!Array.isArray(t))
                            return;
                        const r = [];
                        for (const a of t) {
                            if (typeof a != "string")
                                return;
                            const c = yr.parse(a);
                            if (!c)
                                return;
                            r.push(c)
                        }
                        return new Ni(r)
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, r, a, c="rgb") {
                        const p = [];
                        if (t.values.length != r.values.length)
                            throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
                        for (let f = 0; f < t.values.length; f++)
                            p.push(yr.interpolate(t.values[f], r.values[f], a, c));
                        return new Ni(p)
                    }
                }
                class wi extends Error {
                    constructor(t) {
                        super(t),
                        this.name = "RuntimeError"
                    }
                    toJSON() {
                        return this.message
                    }
                }
                const Ko = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
                class un {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof un)
                            return t;
                        if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
                            for (let r = 0; r < t.length; r += 2) {
                                const a = t[r]
                                  , c = t[r + 1];
                                if (typeof a != "string" || !Ko.has(a) || !Array.isArray(c) || c.length !== 2 || typeof c[0] != "number" || typeof c[1] != "number")
                                    return
                            }
                            return new un(t)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, r, a) {
                        const c = t.values
                          , p = r.values;
                        if (c.length !== p.length)
                            throw new wi(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
                        const f = [];
                        for (let g = 0; g < c.length; g += 2) {
                            if (c[g] !== p[g])
                                throw new wi(`Cannot interpolate values containing mismatched anchors. from[${g}]: ${c[g]}, to[${g}]: ${p[g]}`);
                            f.push(c[g]);
                            const [v,S] = c[g + 1]
                              , [I,E] = p[g + 1];
                            f.push([Jr(v, I, a), Jr(S, E, a)])
                        }
                        return new un(f)
                    }
                }
                class Nn {
                    constructor(t) {
                        this.name = t.name,
                        this.available = t.available
                    }
                    toString() {
                        return this.name
                    }
                    static fromString(t) {
                        return t ? new Nn({
                            name: t,
                            available: !1
                        }) : null
                    }
                }
                class hn {
                    constructor(t, r, a) {
                        this.from = t,
                        this.to = r,
                        this.transition = a
                    }
                    static interpolate(t, r, a) {
                        return new hn(t,r,a)
                    }
                    static parse(t) {
                        return t instanceof hn ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new hn(t[0],t[1],t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new hn(t.from,t.to,t.transition) : typeof t == "string" ? new hn(t,t,1) : void 0
                    }
                }
                function Ti(i, t, r, a) {
                    return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[i, t, r, a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a == "number" ? [i, t, r, a] : [i, t, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
                }
                function Za(i) {
                    if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof hn || i instanceof yr || i instanceof on || i instanceof ln || i instanceof Ki || i instanceof cn || i instanceof Ni || i instanceof un || i instanceof Nn)
                        return !0;
                    if (Array.isArray(i)) {
                        for (const t of i)
                            if (!Za(t))
                                return !1;
                        return !0
                    }
                    if (typeof i == "object") {
                        for (const t in i)
                            if (!Za(i[t]))
                                return !1;
                        return !0
                    }
                    return !1
                }
                function wr(i) {
                    if (i === null)
                        return Mt;
                    if (typeof i == "string")
                        return jt;
                    if (typeof i == "boolean")
                        return Gt;
                    if (typeof i == "number")
                        return Ke;
                    if (i instanceof yr)
                        return Dr;
                    if (i instanceof hn)
                        return Gr;
                    if (i instanceof on)
                        return bi;
                    if (i instanceof ln)
                        return Si;
                    if (i instanceof Ki)
                        return zi;
                    if (i instanceof cn)
                        return Li;
                    if (i instanceof Ni)
                        return mi;
                    if (i instanceof un)
                        return yi;
                    if (i instanceof Nn)
                        return rr;
                    if (Array.isArray(i)) {
                        const t = i.length;
                        let r;
                        for (const a of i) {
                            const c = wr(a);
                            if (r) {
                                if (r === c)
                                    continue;
                                r = fr;
                                break
                            }
                            r = c
                        }
                        return Qr(r || fr, t)
                    }
                    return li
                }
                function Vr(i) {
                    const t = typeof i;
                    return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof yr || i instanceof hn || i instanceof ln || i instanceof Ki || i instanceof cn || i instanceof Ni || i instanceof un || i instanceof Nn ? i.toString() : JSON.stringify(i)
                }
                class ga {
                    constructor(t, r) {
                        this.type = t,
                        this.value = r
                    }
                    static parse(t, r) {
                        if (t.length !== 2)
                            return r.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (!Za(t[1]))
                            return r.error("invalid value");
                        const a = t[1];
                        let c = wr(a);
                        const p = r.expectedType;
                        return c.kind !== "array" || c.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (c = p),
                        new ga(c,a)
                    }
                    evaluate() {
                        return this.value
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                const hi = {
                    string: jt,
                    number: Ke,
                    boolean: Gt,
                    object: li
                };
                class ra {
                    constructor(t, r) {
                        this.type = t,
                        this.args = r
                    }
                    static parse(t, r) {
                        if (t.length < 2)
                            return r.error("Expected at least one argument.");
                        let a, c = 1;
                        const p = t[0];
                        if (p === "array") {
                            let g, v;
                            if (t.length > 2) {
                                const S = t[1];
                                if (typeof S != "string" || !(S in hi) || S === "object")
                                    return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                                g = hi[S],
                                c++
                            } else
                                g = fr;
                            if (t.length > 3) {
                                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2])))
                                    return r.error('The length argument to "array" must be a positive integer literal', 2);
                                v = t[2],
                                c++
                            }
                            a = Qr(g, v)
                        } else {
                            if (!hi[p])
                                throw new Error(`Types doesn't contain name = ${p}`);
                            a = hi[p]
                        }
                        const f = [];
                        for (; c < t.length; c++) {
                            const g = r.parse(t[c], c, fr);
                            if (!g)
                                return null;
                            f.push(g)
                        }
                        return new ra(a,f)
                    }
                    evaluate(t) {
                        for (let r = 0; r < this.args.length; r++) {
                            const a = this.args[r].evaluate(t);
                            if (!sn(this.type, wr(a)))
                                return a;
                            if (r === this.args.length - 1)
                                throw new wi(`Expected value to be of type ${Yr(this.type)}, but found ${Yr(wr(a))} instead.`)
                        }
                        throw new Error
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every((t => t.outputDefined()))
                    }
                }
                const Ra = {
                    "to-boolean": Gt,
                    "to-color": Dr,
                    "to-number": Ke,
                    "to-string": jt
                };
                class Ba {
                    constructor(t, r) {
                        this.type = t,
                        this.args = r
                    }
                    static parse(t, r) {
                        if (t.length < 2)
                            return r.error("Expected at least one argument.");
                        const a = t[0];
                        if (!Ra[a])
                            throw new Error(`Can't parse ${a} as it is not part of the known types`);
                        if ((a === "to-boolean" || a === "to-string") && t.length !== 2)
                            return r.error("Expected one argument.");
                        const c = Ra[a]
                          , p = [];
                        for (let f = 1; f < t.length; f++) {
                            const g = r.parse(t[f], f, fr);
                            if (!g)
                                return null;
                            p.push(g)
                        }
                        return new Ba(c,p)
                    }
                    evaluate(t) {
                        switch (this.type.kind) {
                        case "boolean":
                            return !!this.args[0].evaluate(t);
                        case "color":
                            {
                                let r, a;
                                for (const c of this.args) {
                                    if (r = c.evaluate(t),
                                    a = null,
                                    r instanceof yr)
                                        return r;
                                    if (typeof r == "string") {
                                        const p = t.parseColor(r);
                                        if (p)
                                            return p
                                    } else if (Array.isArray(r) && (a = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : Ti(r[0], r[1], r[2], r[3]),
                                    !a))
                                        return new yr(r[0] / 255,r[1] / 255,r[2] / 255,r[3])
                                }
                                throw new wi(a || `Could not parse color from value '${typeof r == "string" ? r : JSON.stringify(r)}'`)
                            }
                        case "padding":
                            {
                                let r;
                                for (const a of this.args) {
                                    r = a.evaluate(t);
                                    const c = Ki.parse(r);
                                    if (c)
                                        return c
                                }
                                throw new wi(`Could not parse padding from value '${typeof r == "string" ? r : JSON.stringify(r)}'`)
                            }
                        case "numberArray":
                            {
                                let r;
                                for (const a of this.args) {
                                    r = a.evaluate(t);
                                    const c = cn.parse(r);
                                    if (c)
                                        return c
                                }
                                throw new wi(`Could not parse numberArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`)
                            }
                        case "colorArray":
                            {
                                let r;
                                for (const a of this.args) {
                                    r = a.evaluate(t);
                                    const c = Ni.parse(r);
                                    if (c)
                                        return c
                                }
                                throw new wi(`Could not parse colorArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`)
                            }
                        case "variableAnchorOffsetCollection":
                            {
                                let r;
                                for (const a of this.args) {
                                    r = a.evaluate(t);
                                    const c = un.parse(r);
                                    if (c)
                                        return c
                                }
                                throw new wi(`Could not parse variableAnchorOffsetCollection from value '${typeof r == "string" ? r : JSON.stringify(r)}'`)
                            }
                        case "number":
                            {
                                let r = null;
                                for (const a of this.args) {
                                    if (r = a.evaluate(t),
                                    r === null)
                                        return 0;
                                    const c = Number(r);
                                    if (!isNaN(c))
                                        return c
                                }
                                throw new wi(`Could not convert ${JSON.stringify(r)} to number.`)
                            }
                        case "formatted":
                            return ln.fromString(Vr(this.args[0].evaluate(t)));
                        case "resolvedImage":
                            return Nn.fromString(Vr(this.args[0].evaluate(t)));
                        case "projectionDefinition":
                            return this.args[0].evaluate(t);
                        default:
                            return Vr(this.args[0].evaluate(t))
                        }
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every((t => t.outputDefined()))
                    }
                }
                const Yo = ["Unknown", "Point", "LineString", "Polygon"];
                class mc {
                    constructor() {
                        this.globals = null,
                        this.feature = null,
                        this.featureState = null,
                        this.formattedSection = null,
                        this._parseColorCache = new Map,
                        this.availableImages = null,
                        this.canonical = null
                    }
                    id() {
                        return this.feature && "id"in this.feature ? this.feature.id : null
                    }
                    geometryType() {
                        return this.feature ? typeof this.feature.type == "number" ? Yo[this.feature.type] : this.feature.type : null
                    }
                    geometry() {
                        return this.feature && "geometry"in this.feature ? this.feature.geometry : null
                    }
                    canonicalID() {
                        return this.canonical
                    }
                    properties() {
                        return this.feature && this.feature.properties || {}
                    }
                    parseColor(t) {
                        let r = this._parseColorCache.get(t);
                        return r || (r = yr.parse(t),
                        this._parseColorCache.set(t, r)),
                        r
                    }
                }
                class Rs {
                    constructor(t, r, a=[], c, p=new Pn, f=[]) {
                        this.registry = t,
                        this.path = a,
                        this.key = a.map((g => `[${g}]`)).join(""),
                        this.scope = p,
                        this.errors = f,
                        this.expectedType = c,
                        this._isConstant = r
                    }
                    parse(t, r, a, c, p={}) {
                        return r ? this.concat(r, a, c)._parse(t, p) : this._parse(t, p)
                    }
                    _parse(t, r) {
                        function a(c, p, f) {
                            return f === "assert" ? new ra(p,[c]) : f === "coerce" ? new Ba(p,[c]) : c
                        }
                        if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]),
                        Array.isArray(t)) {
                            if (t.length === 0)
                                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                            const c = t[0];
                            if (typeof c != "string")
                                return this.error(`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`, 0),
                                null;
                            const p = this.registry[c];
                            if (p) {
                                let f = p.parse(t, this);
                                if (!f)
                                    return null;
                                if (this.expectedType) {
                                    const g = this.expectedType
                                      , v = f.type;
                                    if (g.kind !== "string" && g.kind !== "number" && g.kind !== "boolean" && g.kind !== "object" && g.kind !== "array" || v.kind !== "value") {
                                        if (g.kind === "projectionDefinition" && ["string", "array"].includes(v.kind) || ["color", "formatted", "resolvedImage"].includes(g.kind) && ["value", "string"].includes(v.kind) || ["padding", "numberArray"].includes(g.kind) && ["value", "number", "array"].includes(v.kind) || g.kind === "colorArray" && ["value", "string", "array"].includes(v.kind) || g.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(v.kind))
                                            f = a(f, g, r.typeAnnotation || "coerce");
                                        else if (this.checkSubtype(g, v))
                                            return null
                                    } else
                                        f = a(f, g, r.typeAnnotation || "assert")
                                }
                                if (!(f instanceof ga) && f.type.kind !== "resolvedImage" && this._isConstant(f)) {
                                    const g = new mc;
                                    try {
                                        f = new ga(f.type,f.evaluate(g))
                                    } catch (v) {
                                        return this.error(v.message),
                                        null
                                    }
                                }
                                return f
                            }
                            return this.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0)
                        }
                        return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
                    }
                    concat(t, r, a) {
                        const c = typeof t == "number" ? this.path.concat(t) : this.path
                          , p = a ? this.scope.concat(a) : this.scope;
                        return new Rs(this.registry,this._isConstant,c,r || null,p,this.errors)
                    }
                    error(t, ...r) {
                        const a = `${this.key}${r.map((c => `[${c}]`)).join("")}`;
                        this.errors.push(new di(a,t))
                    }
                    checkSubtype(t, r) {
                        const a = sn(t, r);
                        return a && this.error(a),
                        a
                    }
                }
                class co {
                    constructor(t, r) {
                        this.type = r.type,
                        this.bindings = [].concat(t),
                        this.result = r
                    }
                    evaluate(t) {
                        return this.result.evaluate(t)
                    }
                    eachChild(t) {
                        for (const r of this.bindings)
                            t(r[1]);
                        t(this.result)
                    }
                    static parse(t, r) {
                        if (t.length < 4)
                            return r.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
                        const a = [];
                        for (let p = 1; p < t.length - 1; p += 2) {
                            const f = t[p];
                            if (typeof f != "string")
                                return r.error(`Expected string, but found ${typeof f} instead.`, p);
                            if (/[^a-zA-Z0-9_]/.test(f))
                                return r.error("Variable names must contain only alphanumeric characters or '_'.", p);
                            const g = r.parse(t[p + 1], p + 1);
                            if (!g)
                                return null;
                            a.push([f, g])
                        }
                        const c = r.parse(t[t.length - 1], t.length - 1, r.expectedType, a);
                        return c ? new co(a,c) : null
                    }
                    outputDefined() {
                        return this.result.outputDefined()
                    }
                }
                class Jo {
                    constructor(t, r) {
                        this.type = r.type,
                        this.name = t,
                        this.boundExpression = r
                    }
                    static parse(t, r) {
                        if (t.length !== 2 || typeof t[1] != "string")
                            return r.error("'var' expression requires exactly one string literal argument.");
                        const a = t[1];
                        return r.scope.has(a) ? new Jo(a,r.scope.get(a)) : r.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1)
                    }
                    evaluate(t) {
                        return this.boundExpression.evaluate(t)
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                }
                class Qo {
                    constructor(t, r, a) {
                        this.type = t,
                        this.index = r,
                        this.input = a
                    }
                    static parse(t, r) {
                        if (t.length !== 3)
                            return r.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const a = r.parse(t[1], 1, Ke)
                          , c = r.parse(t[2], 2, Qr(r.expectedType || fr));
                        return a && c ? new Qo(c.type.itemType,a,c) : null
                    }
                    evaluate(t) {
                        const r = this.index.evaluate(t)
                          , a = this.input.evaluate(t);
                        if (r < 0)
                            throw new wi(`Array index out of bounds: ${r} < 0.`);
                        if (r >= a.length)
                            throw new wi(`Array index out of bounds: ${r} > ${a.length - 1}.`);
                        if (r !== Math.floor(r))
                            throw new wi(`Array index must be an integer, but found ${r} instead.`);
                        return a[r]
                    }
                    eachChild(t) {
                        t(this.index),
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class el {
                    constructor(t, r) {
                        this.type = Gt,
                        this.needle = t,
                        this.haystack = r
                    }
                    static parse(t, r) {
                        if (t.length !== 3)
                            return r.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const a = r.parse(t[1], 1, fr)
                          , c = r.parse(t[2], 2, fr);
                        return a && c ? ta(a.type, [Gt, jt, Ke, Mt, fr]) ? new el(a,c) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Yr(a.type)} instead`) : null
                    }
                    evaluate(t) {
                        const r = this.needle.evaluate(t)
                          , a = this.haystack.evaluate(t);
                        if (!a)
                            return !1;
                        if (!Fi(r, ["boolean", "string", "number", "null"]))
                            throw new wi(`Expected first argument to be of type boolean, string, number or null, but found ${Yr(wr(r))} instead.`);
                        if (!Fi(a, ["string", "array"]))
                            throw new wi(`Expected second argument to be of type array or string, but found ${Yr(wr(a))} instead.`);
                        return a.indexOf(r) >= 0
                    }
                    eachChild(t) {
                        t(this.needle),
                        t(this.haystack)
                    }
                    outputDefined() {
                        return !0
                    }
                }
                class va {
                    constructor(t, r, a) {
                        this.type = Ke,
                        this.needle = t,
                        this.haystack = r,
                        this.fromIndex = a
                    }
                    static parse(t, r) {
                        if (t.length <= 2 || t.length >= 5)
                            return r.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const a = r.parse(t[1], 1, fr)
                          , c = r.parse(t[2], 2, fr);
                        if (!a || !c)
                            return null;
                        if (!ta(a.type, [Gt, jt, Ke, Mt, fr]))
                            return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Yr(a.type)} instead`);
                        if (t.length === 4) {
                            const p = r.parse(t[3], 3, Ke);
                            return p ? new va(a,c,p) : null
                        }
                        return new va(a,c)
                    }
                    evaluate(t) {
                        const r = this.needle.evaluate(t)
                          , a = this.haystack.evaluate(t);
                        if (!Fi(r, ["boolean", "string", "number", "null"]))
                            throw new wi(`Expected first argument to be of type boolean, string, number or null, but found ${Yr(wr(r))} instead.`);
                        let c;
                        if (this.fromIndex && (c = this.fromIndex.evaluate(t)),
                        Fi(a, ["string"])) {
                            const p = a.indexOf(r, c);
                            return p === -1 ? -1 : [...a.slice(0, p)].length
                        }
                        if (Fi(a, ["array"]))
                            return a.indexOf(r, c);
                        throw new wi(`Expected second argument to be of type array or string, but found ${Yr(wr(a))} instead.`)
                    }
                    eachChild(t) {
                        t(this.needle),
                        t(this.haystack),
                        this.fromIndex && t(this.fromIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class yn {
                    constructor(t, r, a, c, p, f) {
                        this.inputType = t,
                        this.type = r,
                        this.input = a,
                        this.cases = c,
                        this.outputs = p,
                        this.otherwise = f
                    }
                    static parse(t, r) {
                        if (t.length < 5)
                            return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 1)
                            return r.error("Expected an even number of arguments.");
                        let a, c;
                        r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
                        const p = {}
                          , f = [];
                        for (let S = 2; S < t.length - 1; S += 2) {
                            let I = t[S];
                            const E = t[S + 1];
                            Array.isArray(I) || (I = [I]);
                            const R = r.concat(S);
                            if (I.length === 0)
                                return R.error("Expected at least one branch label.");
                            for (const j of I) {
                                if (typeof j != "number" && typeof j != "string")
                                    return R.error("Branch labels must be numbers or strings.");
                                if (typeof j == "number" && Math.abs(j) > Number.MAX_SAFE_INTEGER)
                                    return R.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                                if (typeof j == "number" && Math.floor(j) !== j)
                                    return R.error("Numeric branch labels must be integer values.");
                                if (a) {
                                    if (R.checkSubtype(a, wr(j)))
                                        return null
                                } else
                                    a = wr(j);
                                if (p[String(j)] !== void 0)
                                    return R.error("Branch labels must be unique.");
                                p[String(j)] = f.length
                            }
                            const N = r.parse(E, S, c);
                            if (!N)
                                return null;
                            c = c || N.type,
                            f.push(N)
                        }
                        const g = r.parse(t[1], 1, fr);
                        if (!g)
                            return null;
                        const v = r.parse(t[t.length - 1], t.length - 1, c);
                        return v ? g.type.kind !== "value" && r.concat(1).checkSubtype(a, g.type) ? null : new yn(a,c,g,p,f,v) : null
                    }
                    evaluate(t) {
                        const r = this.input.evaluate(t);
                        return (wr(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t)
                    }
                    eachChild(t) {
                        t(this.input),
                        this.outputs.forEach(t),
                        t(this.otherwise)
                    }
                    outputDefined() {
                        return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
                    }
                }
                class Bs {
                    constructor(t, r, a) {
                        this.type = t,
                        this.branches = r,
                        this.otherwise = a
                    }
                    static parse(t, r) {
                        if (t.length < 4)
                            return r.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 0)
                            return r.error("Expected an odd number of arguments.");
                        let a;
                        r.expectedType && r.expectedType.kind !== "value" && (a = r.expectedType);
                        const c = [];
                        for (let f = 1; f < t.length - 1; f += 2) {
                            const g = r.parse(t[f], f, Gt);
                            if (!g)
                                return null;
                            const v = r.parse(t[f + 1], f + 1, a);
                            if (!v)
                                return null;
                            c.push([g, v]),
                            a = a || v.type
                        }
                        const p = r.parse(t[t.length - 1], t.length - 1, a);
                        if (!p)
                            return null;
                        if (!a)
                            throw new Error("Can't infer output type");
                        return new Bs(a,c,p)
                    }
                    evaluate(t) {
                        for (const [r,a] of this.branches)
                            if (r.evaluate(t))
                                return a.evaluate(t);
                        return this.otherwise.evaluate(t)
                    }
                    eachChild(t) {
                        for (const [r,a] of this.branches)
                            t(r),
                            t(a);
                        t(this.otherwise)
                    }
                    outputDefined() {
                        return this.branches.every(( ([t,r]) => r.outputDefined())) && this.otherwise.outputDefined()
                    }
                }
                class uo {
                    constructor(t, r, a, c) {
                        this.type = t,
                        this.input = r,
                        this.beginIndex = a,
                        this.endIndex = c
                    }
                    static parse(t, r) {
                        if (t.length <= 2 || t.length >= 5)
                            return r.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const a = r.parse(t[1], 1, fr)
                          , c = r.parse(t[2], 2, Ke);
                        if (!a || !c)
                            return null;
                        if (!ta(a.type, [Qr(fr), jt, fr]))
                            return r.error(`Expected first argument to be of type array or string, but found ${Yr(a.type)} instead`);
                        if (t.length === 4) {
                            const p = r.parse(t[3], 3, Ke);
                            return p ? new uo(a.type,a,c,p) : null
                        }
                        return new uo(a.type,a,c)
                    }
                    evaluate(t) {
                        const r = this.input.evaluate(t)
                          , a = this.beginIndex.evaluate(t);
                        let c;
                        if (this.endIndex && (c = this.endIndex.evaluate(t)),
                        Fi(r, ["string"]))
                            return [...r].slice(a, c).join("");
                        if (Fi(r, ["array"]))
                            return r.slice(a, c);
                        throw new wi(`Expected first argument to be of type array or string, but found ${Yr(wr(r))} instead.`)
                    }
                    eachChild(t) {
                        t(this.input),
                        t(this.beginIndex),
                        this.endIndex && t(this.endIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                function fs(i, t) {
                    const r = i.length - 1;
                    let a, c, p = 0, f = r, g = 0;
                    for (; p <= f; )
                        if (g = Math.floor((p + f) / 2),
                        a = i[g],
                        c = i[g + 1],
                        a <= t) {
                            if (g === r || t < c)
                                return g;
                            p = g + 1
                        } else {
                            if (!(a > t))
                                throw new wi("Input is not a number.");
                            f = g - 1
                        }
                    return 0
                }
                class Gi {
                    constructor(t, r, a) {
                        this.type = t,
                        this.input = r,
                        this.labels = [],
                        this.outputs = [];
                        for (const [c,p] of a)
                            this.labels.push(c),
                            this.outputs.push(p)
                    }
                    static parse(t, r) {
                        if (t.length - 1 < 4)
                            return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0)
                            return r.error("Expected an even number of arguments.");
                        const a = r.parse(t[1], 1, Ke);
                        if (!a)
                            return null;
                        const c = [];
                        let p = null;
                        r.expectedType && r.expectedType.kind !== "value" && (p = r.expectedType);
                        for (let f = 1; f < t.length; f += 2) {
                            const g = f === 1 ? -1 / 0 : t[f]
                              , v = t[f + 1]
                              , S = f
                              , I = f + 1;
                            if (typeof g != "number")
                                return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', S);
                            if (c.length && c[c.length - 1][0] >= g)
                                return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', S);
                            const E = r.parse(v, I, p);
                            if (!E)
                                return null;
                            p = p || E.type,
                            c.push([g, E])
                        }
                        return new Gi(p,a,c)
                    }
                    evaluate(t) {
                        const r = this.labels
                          , a = this.outputs;
                        if (r.length === 1)
                            return a[0].evaluate(t);
                        const c = this.input.evaluate(t);
                        if (c <= r[0])
                            return a[0].evaluate(t);
                        const p = r.length;
                        return c >= r[p - 1] ? a[p - 1].evaluate(t) : a[fs(r, c)].evaluate(t)
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const r of this.outputs)
                            t(r)
                    }
                    outputDefined() {
                        return this.outputs.every((t => t.outputDefined()))
                    }
                }
                function _h(i) {
                    return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
                }
                var ho, _c, Yd = (function() {
                    if (_c)
                        return ho;
                    function i(t, r, a, c) {
                        this.cx = 3 * t,
                        this.bx = 3 * (a - t) - this.cx,
                        this.ax = 1 - this.cx - this.bx,
                        this.cy = 3 * r,
                        this.by = 3 * (c - r) - this.cy,
                        this.ay = 1 - this.cy - this.by,
                        this.p1x = t,
                        this.p1y = r,
                        this.p2x = a,
                        this.p2y = c
                    }
                    return _c = 1,
                    ho = i,
                    i.prototype = {
                        sampleCurveX: function(t) {
                            return ((this.ax * t + this.bx) * t + this.cx) * t
                        },
                        sampleCurveY: function(t) {
                            return ((this.ay * t + this.by) * t + this.cy) * t
                        },
                        sampleCurveDerivativeX: function(t) {
                            return (3 * this.ax * t + 2 * this.bx) * t + this.cx
                        },
                        solveCurveX: function(t, r) {
                            if (r === void 0 && (r = 1e-6),
                            t < 0)
                                return 0;
                            if (t > 1)
                                return 1;
                            for (var a = t, c = 0; c < 8; c++) {
                                var p = this.sampleCurveX(a) - t;
                                if (Math.abs(p) < r)
                                    return a;
                                var f = this.sampleCurveDerivativeX(a);
                                if (Math.abs(f) < 1e-6)
                                    break;
                                a -= p / f
                            }
                            var g = 0
                              , v = 1;
                            for (a = t,
                            c = 0; c < 20 && (p = this.sampleCurveX(a),
                            !(Math.abs(p - t) < r)); c++)
                                t > p ? g = a : v = a,
                                a = .5 * (v - g) + g;
                            return a
                        },
                        solve: function(t, r) {
                            return this.sampleCurveY(this.solveCurveX(t, r))
                        }
                    },
                    ho
                }
                )(), Fs = _h(Yd);
                class In {
                    constructor(t, r, a, c, p) {
                        this.type = t,
                        this.operator = r,
                        this.interpolation = a,
                        this.input = c,
                        this.labels = [],
                        this.outputs = [];
                        for (const [f,g] of p)
                            this.labels.push(f),
                            this.outputs.push(g)
                    }
                    static interpolationFactor(t, r, a, c) {
                        let p = 0;
                        if (t.name === "exponential")
                            p = po(r, t.base, a, c);
                        else if (t.name === "linear")
                            p = po(r, 1, a, c);
                        else if (t.name === "cubic-bezier") {
                            const f = t.controlPoints;
                            p = new Fs(f[0],f[1],f[2],f[3]).solve(po(r, 1, a, c))
                        }
                        return p
                    }
                    static parse(t, r) {
                        let[a,c,p,...f] = t;
                        if (!Array.isArray(c) || c.length === 0)
                            return r.error("Expected an interpolation type expression.", 1);
                        if (c[0] === "linear")
                            c = {
                                name: "linear"
                            };
                        else if (c[0] === "exponential") {
                            const S = c[1];
                            if (typeof S != "number")
                                return r.error("Exponential interpolation requires a numeric base.", 1, 1);
                            c = {
                                name: "exponential",
                                base: S
                            }
                        } else {
                            if (c[0] !== "cubic-bezier")
                                return r.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
                            {
                                const S = c.slice(1);
                                if (S.length !== 4 || S.some((I => typeof I != "number" || I < 0 || I > 1)))
                                    return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                                c = {
                                    name: "cubic-bezier",
                                    controlPoints: S
                                }
                            }
                        }
                        if (t.length - 1 < 4)
                            return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0)
                            return r.error("Expected an even number of arguments.");
                        if (p = r.parse(p, 2, Ke),
                        !p)
                            return null;
                        const g = [];
                        let v = null;
                        a !== "interpolate-hcl" && a !== "interpolate-lab" || r.expectedType == mi ? r.expectedType && r.expectedType.kind !== "value" && (v = r.expectedType) : v = Dr;
                        for (let S = 0; S < f.length; S += 2) {
                            const I = f[S]
                              , E = f[S + 1]
                              , R = S + 3
                              , N = S + 4;
                            if (typeof I != "number")
                                return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', R);
                            if (g.length && g[g.length - 1][0] >= I)
                                return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', R);
                            const j = r.parse(E, N, v);
                            if (!j)
                                return null;
                            v = v || j.type,
                            g.push([I, j])
                        }
                        return Xi(v, Ke) || Xi(v, Gr) || Xi(v, Dr) || Xi(v, zi) || Xi(v, Li) || Xi(v, mi) || Xi(v, yi) || Xi(v, Qr(Ke)) ? new In(v,a,c,p,g) : r.error(`Type ${Yr(v)} is not interpolatable.`)
                    }
                    evaluate(t) {
                        const r = this.labels
                          , a = this.outputs;
                        if (r.length === 1)
                            return a[0].evaluate(t);
                        const c = this.input.evaluate(t);
                        if (c <= r[0])
                            return a[0].evaluate(t);
                        const p = r.length;
                        if (c >= r[p - 1])
                            return a[p - 1].evaluate(t);
                        const f = fs(r, c)
                          , g = In.interpolationFactor(this.interpolation, c, r[f], r[f + 1])
                          , v = a[f].evaluate(t)
                          , S = a[f + 1].evaluate(t);
                        switch (this.operator) {
                        case "interpolate":
                            switch (this.type.kind) {
                            case "number":
                                return Jr(v, S, g);
                            case "color":
                                return yr.interpolate(v, S, g);
                            case "padding":
                                return Ki.interpolate(v, S, g);
                            case "colorArray":
                                return Ni.interpolate(v, S, g);
                            case "numberArray":
                                return cn.interpolate(v, S, g);
                            case "variableAnchorOffsetCollection":
                                return un.interpolate(v, S, g);
                            case "array":
                                return ti(v, S, g);
                            case "projectionDefinition":
                                return hn.interpolate(v, S, g)
                            }
                        case "interpolate-hcl":
                            switch (this.type.kind) {
                            case "color":
                                return yr.interpolate(v, S, g, "hcl");
                            case "colorArray":
                                return Ni.interpolate(v, S, g, "hcl")
                            }
                        case "interpolate-lab":
                            switch (this.type.kind) {
                            case "color":
                                return yr.interpolate(v, S, g, "lab");
                            case "colorArray":
                                return Ni.interpolate(v, S, g, "lab")
                            }
                        }
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const r of this.outputs)
                            t(r)
                    }
                    outputDefined() {
                        return this.outputs.every((t => t.outputDefined()))
                    }
                }
                function po(i, t, r, a) {
                    const c = a - r
                      , p = i - r;
                    return c === 0 ? 0 : t === 1 ? p / c : (Math.pow(t, p) - 1) / (Math.pow(t, c) - 1)
                }
                const Fa = {
                    color: yr.interpolate,
                    number: Jr,
                    padding: Ki.interpolate,
                    numberArray: cn.interpolate,
                    colorArray: Ni.interpolate,
                    variableAnchorOffsetCollection: un.interpolate,
                    array: ti
                };
                class fo {
                    constructor(t, r) {
                        this.type = t,
                        this.args = r
                    }
                    static parse(t, r) {
                        if (t.length < 2)
                            return r.error("Expected at least one argument.");
                        let a = null;
                        const c = r.expectedType;
                        c && c.kind !== "value" && (a = c);
                        const p = [];
                        for (const g of t.slice(1)) {
                            const v = r.parse(g, 1 + p.length, a, void 0, {
                                typeAnnotation: "omit"
                            });
                            if (!v)
                                return null;
                            a = a || v.type,
                            p.push(v)
                        }
                        if (!a)
                            throw new Error("No output type");
                        const f = c && p.some((g => sn(c, g.type)));
                        return new fo(f ? fr : a,p)
                    }
                    evaluate(t) {
                        let r, a = null, c = 0;
                        for (const p of this.args)
                            if (c++,
                            a = p.evaluate(t),
                            a && a instanceof Nn && !a.available && (r || (r = a.name),
                            a = null,
                            c === this.args.length && (a = r)),
                            a !== null)
                                break;
                        return a
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every((t => t.outputDefined()))
                    }
                }
                function mo(i, t) {
                    return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
                }
                function _o(i, t, r, a) {
                    return a.compare(t, r) === 0
                }
                function Dn(i, t, r) {
                    const a = i !== "==" && i !== "!=";
                    return class tv {
                        constructor(p, f, g) {
                            this.type = Gt,
                            this.lhs = p,
                            this.rhs = f,
                            this.collator = g,
                            this.hasUntypedArgument = p.type.kind === "value" || f.type.kind === "value"
                        }
                        static parse(p, f) {
                            if (p.length !== 3 && p.length !== 4)
                                return f.error("Expected two or three arguments.");
                            const g = p[0];
                            let v = f.parse(p[1], 1, fr);
                            if (!v)
                                return null;
                            if (!mo(g, v.type))
                                return f.concat(1).error(`"${g}" comparisons are not supported for type '${Yr(v.type)}'.`);
                            let S = f.parse(p[2], 2, fr);
                            if (!S)
                                return null;
                            if (!mo(g, S.type))
                                return f.concat(2).error(`"${g}" comparisons are not supported for type '${Yr(S.type)}'.`);
                            if (v.type.kind !== S.type.kind && v.type.kind !== "value" && S.type.kind !== "value")
                                return f.error(`Cannot compare types '${Yr(v.type)}' and '${Yr(S.type)}'.`);
                            a && (v.type.kind === "value" && S.type.kind !== "value" ? v = new ra(S.type,[v]) : v.type.kind !== "value" && S.type.kind === "value" && (S = new ra(v.type,[S])));
                            let I = null;
                            if (p.length === 4) {
                                if (v.type.kind !== "string" && S.type.kind !== "string" && v.type.kind !== "value" && S.type.kind !== "value")
                                    return f.error("Cannot use collator to compare non-string types.");
                                if (I = f.parse(p[3], 3, bi),
                                !I)
                                    return null
                            }
                            return new tv(v,S,I)
                        }
                        evaluate(p) {
                            const f = this.lhs.evaluate(p)
                              , g = this.rhs.evaluate(p);
                            if (a && this.hasUntypedArgument) {
                                const v = wr(f)
                                  , S = wr(g);
                                if (v.kind !== S.kind || v.kind !== "string" && v.kind !== "number")
                                    throw new wi(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${v.kind}, ${S.kind}) instead.`)
                            }
                            if (this.collator && !a && this.hasUntypedArgument) {
                                const v = wr(f)
                                  , S = wr(g);
                                if (v.kind !== "string" || S.kind !== "string")
                                    return t(p, f, g)
                            }
                            return this.collator ? r(p, f, g, this.collator.evaluate(p)) : t(p, f, g)
                        }
                        eachChild(p) {
                            p(this.lhs),
                            p(this.rhs),
                            this.collator && p(this.collator)
                        }
                        outputDefined() {
                            return !0
                        }
                    }
                }
                const gh = Dn("==", (function(i, t, r) {
                    return t === r
                }
                ), _o)
                  , tl = Dn("!=", (function(i, t, r) {
                    return t !== r
                }
                ), (function(i, t, r, a) {
                    return !_o(0, t, r, a)
                }
                ))
                  , Jd = Dn("<", (function(i, t, r) {
                    return t < r
                }
                ), (function(i, t, r, a) {
                    return a.compare(t, r) < 0
                }
                ))
                  , gc = Dn(">", (function(i, t, r) {
                    return t > r
                }
                ), (function(i, t, r, a) {
                    return a.compare(t, r) > 0
                }
                ))
                  , Qd = Dn("<=", (function(i, t, r) {
                    return t <= r
                }
                ), (function(i, t, r, a) {
                    return a.compare(t, r) <= 0
                }
                ))
                  , ep = Dn(">=", (function(i, t, r) {
                    return t >= r
                }
                ), (function(i, t, r, a) {
                    return a.compare(t, r) >= 0
                }
                ));
                class rl {
                    constructor(t, r, a) {
                        this.type = bi,
                        this.locale = a,
                        this.caseSensitive = t,
                        this.diacriticSensitive = r
                    }
                    static parse(t, r) {
                        if (t.length !== 2)
                            return r.error("Expected one argument.");
                        const a = t[1];
                        if (typeof a != "object" || Array.isArray(a))
                            return r.error("Collator options argument must be an object.");
                        const c = r.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, Gt);
                        if (!c)
                            return null;
                        const p = r.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, Gt);
                        if (!p)
                            return null;
                        let f = null;
                        return a.locale && (f = r.parse(a.locale, 1, jt),
                        !f) ? null : new rl(c,p,f)
                    }
                    evaluate(t) {
                        return new on(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale ? this.locale.evaluate(t) : null)
                    }
                    eachChild(t) {
                        t(this.caseSensitive),
                        t(this.diacriticSensitive),
                        this.locale && t(this.locale)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class vc {
                    constructor(t, r, a, c, p) {
                        this.type = jt,
                        this.number = t,
                        this.locale = r,
                        this.currency = a,
                        this.minFractionDigits = c,
                        this.maxFractionDigits = p
                    }
                    static parse(t, r) {
                        if (t.length !== 3)
                            return r.error("Expected two arguments.");
                        const a = r.parse(t[1], 1, Ke);
                        if (!a)
                            return null;
                        const c = t[2];
                        if (typeof c != "object" || Array.isArray(c))
                            return r.error("NumberFormat options argument must be an object.");
                        let p = null;
                        if (c.locale && (p = r.parse(c.locale, 1, jt),
                        !p))
                            return null;
                        let f = null;
                        if (c.currency && (f = r.parse(c.currency, 1, jt),
                        !f))
                            return null;
                        let g = null;
                        if (c["min-fraction-digits"] && (g = r.parse(c["min-fraction-digits"], 1, Ke),
                        !g))
                            return null;
                        let v = null;
                        return c["max-fraction-digits"] && (v = r.parse(c["max-fraction-digits"], 1, Ke),
                        !v) ? null : new vc(a,p,f,g,v)
                    }
                    evaluate(t) {
                        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [],{
                            style: this.currency ? "currency" : "decimal",
                            currency: this.currency ? this.currency.evaluate(t) : void 0,
                            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
                            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
                        }).format(this.number.evaluate(t))
                    }
                    eachChild(t) {
                        t(this.number),
                        this.locale && t(this.locale),
                        this.currency && t(this.currency),
                        this.minFractionDigits && t(this.minFractionDigits),
                        this.maxFractionDigits && t(this.maxFractionDigits)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class ms {
                    constructor(t) {
                        this.type = Si,
                        this.sections = t
                    }
                    static parse(t, r) {
                        if (t.length < 2)
                            return r.error("Expected at least one argument.");
                        const a = t[1];
                        if (!Array.isArray(a) && typeof a == "object")
                            return r.error("First argument must be an image or text section.");
                        const c = [];
                        let p = !1;
                        for (let f = 1; f <= t.length - 1; ++f) {
                            const g = t[f];
                            if (p && typeof g == "object" && !Array.isArray(g)) {
                                p = !1;
                                let v = null;
                                if (g["font-scale"] && (v = r.parse(g["font-scale"], 1, Ke),
                                !v))
                                    return null;
                                let S = null;
                                if (g["text-font"] && (S = r.parse(g["text-font"], 1, Qr(jt)),
                                !S))
                                    return null;
                                let I = null;
                                if (g["text-color"] && (I = r.parse(g["text-color"], 1, Dr),
                                !I))
                                    return null;
                                let E = null;
                                if (g["vertical-align"]) {
                                    if (typeof g["vertical-align"] == "string" && !vn.includes(g["vertical-align"]))
                                        return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${g["vertical-align"]}' instead.`);
                                    if (E = r.parse(g["vertical-align"], 1, jt),
                                    !E)
                                        return null
                                }
                                const R = c[c.length - 1];
                                R.scale = v,
                                R.font = S,
                                R.textColor = I,
                                R.verticalAlign = E
                            } else {
                                const v = r.parse(t[f], 1, fr);
                                if (!v)
                                    return null;
                                const S = v.type.kind;
                                if (S !== "string" && S !== "value" && S !== "null" && S !== "resolvedImage")
                                    return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                                p = !0,
                                c.push({
                                    content: v,
                                    scale: null,
                                    font: null,
                                    textColor: null,
                                    verticalAlign: null
                                })
                            }
                        }
                        return new ms(c)
                    }
                    evaluate(t) {
                        return new ln(this.sections.map((r => {
                            const a = r.content.evaluate(t);
                            return wr(a) === rr ? new _a("",a,null,null,null,r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new _a(Vr(a),null,r.scale ? r.scale.evaluate(t) : null,r.font ? r.font.evaluate(t).join(",") : null,r.textColor ? r.textColor.evaluate(t) : null,r.verticalAlign ? r.verticalAlign.evaluate(t) : null)
                        }
                        )))
                    }
                    eachChild(t) {
                        for (const r of this.sections)
                            t(r.content),
                            r.scale && t(r.scale),
                            r.font && t(r.font),
                            r.textColor && t(r.textColor),
                            r.verticalAlign && t(r.verticalAlign)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class yc {
                    constructor(t) {
                        this.type = rr,
                        this.input = t
                    }
                    static parse(t, r) {
                        if (t.length !== 2)
                            return r.error("Expected two arguments.");
                        const a = r.parse(t[1], 1, jt);
                        return a ? new yc(a) : r.error("No image name provided.")
                    }
                    evaluate(t) {
                        const r = this.input.evaluate(t)
                          , a = Nn.fromString(r);
                        return a && t.availableImages && (a.available = t.availableImages.indexOf(r) > -1),
                        a
                    }
                    eachChild(t) {
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class il {
                    constructor(t) {
                        this.type = Ke,
                        this.input = t
                    }
                    static parse(t, r) {
                        if (t.length !== 2)
                            return r.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                        const a = r.parse(t[1], 1);
                        return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${Yr(a.type)} instead.`) : new il(a) : null
                    }
                    evaluate(t) {
                        const r = this.input.evaluate(t);
                        if (typeof r == "string")
                            return [...r].length;
                        if (Array.isArray(r))
                            return r.length;
                        throw new wi(`Expected value to be of type string or array, but found ${Yr(wr(r))} instead.`)
                    }
                    eachChild(t) {
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                const ya = 8192;
                function tp(i, t) {
                    const r = (180 + i[0]) / 360
                      , a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360
                      , c = Math.pow(2, t.z);
                    return [Math.round(r * c * ya), Math.round(a * c * ya)]
                }
                function nl(i, t) {
                    const r = Math.pow(2, t.z);
                    return [(c = (i[0] / ya + t.x) / r,
                    360 * c - 180), (a = (i[1] / ya + t.y) / r,
                    360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)];
                    var a, c
                }
                function go(i, t) {
                    i[0] = Math.min(i[0], t[0]),
                    i[1] = Math.min(i[1], t[1]),
                    i[2] = Math.max(i[2], t[0]),
                    i[3] = Math.max(i[3], t[1])
                }
                function vo(i, t) {
                    return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3])
                }
                function rp(i, t, r) {
                    const a = i[0] - t[0]
                      , c = i[1] - t[1]
                      , p = i[0] - r[0]
                      , f = i[1] - r[1];
                    return a * f - p * c == 0 && a * p <= 0 && c * f <= 0
                }
                function al(i, t, r, a) {
                    return (c = [a[0] - r[0], a[1] - r[1]])[0] * (p = [t[0] - i[0], t[1] - i[1]])[1] - c[1] * p[0] != 0 && !(!yh(i, t, r, a) || !yh(r, a, i, t));
                    var c, p
                }
                function ip(i, t, r) {
                    for (const a of r)
                        for (let c = 0; c < a.length - 1; ++c)
                            if (al(i, t, a[c], a[c + 1]))
                                return !0;
                    return !1
                }
                function _s(i, t, r=!1) {
                    let a = !1;
                    for (const g of t)
                        for (let v = 0; v < g.length - 1; v++) {
                            if (rp(i, g[v], g[v + 1]))
                                return r;
                            (p = g[v])[1] > (c = i)[1] != (f = g[v + 1])[1] > c[1] && c[0] < (f[0] - p[0]) * (c[1] - p[1]) / (f[1] - p[1]) + p[0] && (a = !a)
                        }
                    var c, p, f;
                    return a
                }
                function vh(i, t) {
                    for (const r of t)
                        if (_s(i, r))
                            return !0;
                    return !1
                }
                function xc(i, t) {
                    for (const r of i)
                        if (!_s(r, t))
                            return !1;
                    for (let r = 0; r < i.length - 1; ++r)
                        if (ip(i[r], i[r + 1], t))
                            return !1;
                    return !0
                }
                function np(i, t) {
                    for (const r of t)
                        if (xc(i, r))
                            return !0;
                    return !1
                }
                function yh(i, t, r, a) {
                    const c = a[0] - r[0]
                      , p = a[1] - r[1]
                      , f = (i[0] - r[0]) * p - c * (i[1] - r[1])
                      , g = (t[0] - r[0]) * p - c * (t[1] - r[1]);
                    return f > 0 && g < 0 || f < 0 && g > 0
                }
                function bc(i, t, r) {
                    const a = [];
                    for (let c = 0; c < i.length; c++) {
                        const p = [];
                        for (let f = 0; f < i[c].length; f++) {
                            const g = tp(i[c][f], r);
                            go(t, g),
                            p.push(g)
                        }
                        a.push(p)
                    }
                    return a
                }
                function xh(i, t, r) {
                    const a = [];
                    for (let c = 0; c < i.length; c++) {
                        const p = bc(i[c], t, r);
                        a.push(p)
                    }
                    return a
                }
                function sl(i, t, r, a) {
                    if (i[0] < r[0] || i[0] > r[2]) {
                        const c = .5 * a;
                        let p = i[0] - r[0] > c ? -a : r[0] - i[0] > c ? a : 0;
                        p === 0 && (p = i[0] - r[2] > c ? -a : r[2] - i[0] > c ? a : 0),
                        i[0] += p
                    }
                    go(t, i)
                }
                function bh(i, t, r, a) {
                    const c = Math.pow(2, a.z) * ya
                      , p = [a.x * ya, a.y * ya]
                      , f = [];
                    for (const g of i)
                        for (const v of g) {
                            const S = [v.x + p[0], v.y + p[1]];
                            sl(S, t, r, c),
                            f.push(S)
                        }
                    return f
                }
                function wh(i, t, r, a) {
                    const c = Math.pow(2, a.z) * ya
                      , p = [a.x * ya, a.y * ya]
                      , f = [];
                    for (const v of i) {
                        const S = [];
                        for (const I of v) {
                            const E = [I.x + p[0], I.y + p[1]];
                            go(t, E),
                            S.push(E)
                        }
                        f.push(S)
                    }
                    if (t[2] - t[0] <= c / 2) {
                        (g = t)[0] = g[1] = 1 / 0,
                        g[2] = g[3] = -1 / 0;
                        for (const v of f)
                            for (const S of v)
                                sl(S, t, r, c)
                    }
                    var g;
                    return f
                }
                class gs {
                    constructor(t, r) {
                        this.type = Gt,
                        this.geojson = t,
                        this.geometries = r
                    }
                    static parse(t, r) {
                        if (t.length !== 2)
                            return r.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (Za(t[1])) {
                            const a = t[1];
                            if (a.type === "FeatureCollection") {
                                const c = [];
                                for (const p of a.features) {
                                    const {type: f, coordinates: g} = p.geometry;
                                    f === "Polygon" && c.push(g),
                                    f === "MultiPolygon" && c.push(...g)
                                }
                                if (c.length)
                                    return new gs(a,{
                                        type: "MultiPolygon",
                                        coordinates: c
                                    })
                            } else if (a.type === "Feature") {
                                const c = a.geometry.type;
                                if (c === "Polygon" || c === "MultiPolygon")
                                    return new gs(a,a.geometry)
                            } else if (a.type === "Polygon" || a.type === "MultiPolygon")
                                return new gs(a,a)
                        }
                        return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(t) {
                        if (t.geometry() != null && t.canonicalID() != null) {
                            if (t.geometryType() === "Point")
                                return (function(r, a) {
                                    const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , p = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , f = r.canonicalID();
                                    if (a.type === "Polygon") {
                                        const g = bc(a.coordinates, p, f)
                                          , v = bh(r.geometry(), c, p, f);
                                        if (!vo(c, p))
                                            return !1;
                                        for (const S of v)
                                            if (!_s(S, g))
                                                return !1
                                    }
                                    if (a.type === "MultiPolygon") {
                                        const g = xh(a.coordinates, p, f)
                                          , v = bh(r.geometry(), c, p, f);
                                        if (!vo(c, p))
                                            return !1;
                                        for (const S of v)
                                            if (!vh(S, g))
                                                return !1
                                    }
                                    return !0
                                }
                                )(t, this.geometries);
                            if (t.geometryType() === "LineString")
                                return (function(r, a) {
                                    const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , p = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , f = r.canonicalID();
                                    if (a.type === "Polygon") {
                                        const g = bc(a.coordinates, p, f)
                                          , v = wh(r.geometry(), c, p, f);
                                        if (!vo(c, p))
                                            return !1;
                                        for (const S of v)
                                            if (!xc(S, g))
                                                return !1
                                    }
                                    if (a.type === "MultiPolygon") {
                                        const g = xh(a.coordinates, p, f)
                                          , v = wh(r.geometry(), c, p, f);
                                        if (!vo(c, p))
                                            return !1;
                                        for (const S of v)
                                            if (!np(S, g))
                                                return !1
                                    }
                                    return !0
                                }
                                )(t, this.geometries)
                        }
                        return !1
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                let wc = class {
                    constructor(i=[], t= (r, a) => r < a ? -1 : r > a ? 1 : 0) {
                        if (this.data = i,
                        this.length = this.data.length,
                        this.compare = t,
                        this.length > 0)
                            for (let r = (this.length >> 1) - 1; r >= 0; r--)
                                this._down(r)
                    }
                    push(i) {
                        this.data.push(i),
                        this._up(this.length++)
                    }
                    pop() {
                        if (this.length === 0)
                            return;
                        const i = this.data[0]
                          , t = this.data.pop();
                        return --this.length > 0 && (this.data[0] = t,
                        this._down(0)),
                        i
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(i) {
                        const {data: t, compare: r} = this
                          , a = t[i];
                        for (; i > 0; ) {
                            const c = i - 1 >> 1
                              , p = t[c];
                            if (r(a, p) >= 0)
                                break;
                            t[i] = p,
                            i = c
                        }
                        t[i] = a
                    }
                    _down(i) {
                        const {data: t, compare: r} = this
                          , a = this.length >> 1
                          , c = t[i];
                        for (; i < a; ) {
                            let p = 1 + (i << 1);
                            const f = p + 1;
                            if (f < this.length && r(t[f], t[p]) < 0 && (p = f),
                            r(t[p], c) >= 0)
                                break;
                            t[i] = t[p],
                            i = p
                        }
                        t[i] = c
                    }
                }
                ;
                function Tc(i, t, r=0, a=i.length - 1, c=ap) {
                    for (; a > r; ) {
                        if (a - r > 600) {
                            const v = a - r + 1
                              , S = t - r + 1
                              , I = Math.log(v)
                              , E = .5 * Math.exp(2 * I / 3)
                              , R = .5 * Math.sqrt(I * E * (v - E) / v) * (S - v / 2 < 0 ? -1 : 1);
                            Tc(i, t, Math.max(r, Math.floor(t - S * E / v + R)), Math.min(a, Math.floor(t + (v - S) * E / v + R)), c)
                        }
                        const p = i[t];
                        let f = r
                          , g = a;
                        for (yo(i, r, t),
                        c(i[a], p) > 0 && yo(i, r, a); f < g; ) {
                            for (yo(i, f, g),
                            f++,
                            g--; c(i[f], p) < 0; )
                                f++;
                            for (; c(i[g], p) > 0; )
                                g--
                        }
                        c(i[r], p) === 0 ? yo(i, r, g) : (g++,
                        yo(i, g, a)),
                        g <= t && (r = g + 1),
                        t <= g && (a = g - 1)
                    }
                }
                function yo(i, t, r) {
                    const a = i[t];
                    i[t] = i[r],
                    i[r] = a
                }
                function ap(i, t) {
                    return i < t ? -1 : i > t ? 1 : 0
                }
                function xo(i, t) {
                    if (i.length <= 1)
                        return [i];
                    const r = [];
                    let a, c;
                    for (const p of i) {
                        const f = sp(p);
                        f !== 0 && (p.area = Math.abs(f),
                        c === void 0 && (c = f < 0),
                        c === f < 0 ? (a && r.push(a),
                        a = [p]) : a.push(p))
                    }
                    if (a && r.push(a),
                    t > 1)
                        for (let p = 0; p < r.length; p++)
                            r[p].length <= t || (Tc(r[p], t, 1, r[p].length - 1, Th),
                            r[p] = r[p].slice(0, t));
                    return r
                }
                function Th(i, t) {
                    return t.area - i.area
                }
                function sp(i) {
                    let t = 0;
                    for (let r, a, c = 0, p = i.length, f = p - 1; c < p; f = c++)
                        r = i[c],
                        a = i[f],
                        t += (a.x - r.x) * (r.y + a.y);
                    return t
                }
                const Ch = 1 / 298.257223563
                  , Sh = Ch * (2 - Ch)
                  , Cc = Math.PI / 180;
                class Sc {
                    constructor(t) {
                        const r = 6378.137 * Cc * 1e3
                          , a = Math.cos(t * Cc)
                          , c = 1 / (1 - Sh * (1 - a * a))
                          , p = Math.sqrt(c);
                        this.kx = r * p * a,
                        this.ky = r * p * c * (1 - Sh)
                    }
                    distance(t, r) {
                        const a = this.wrap(t[0] - r[0]) * this.kx
                          , c = (t[1] - r[1]) * this.ky;
                        return Math.sqrt(a * a + c * c)
                    }
                    pointOnLine(t, r) {
                        let a, c, p, f, g = 1 / 0;
                        for (let v = 0; v < t.length - 1; v++) {
                            let S = t[v][0]
                              , I = t[v][1]
                              , E = this.wrap(t[v + 1][0] - S) * this.kx
                              , R = (t[v + 1][1] - I) * this.ky
                              , N = 0;
                            E === 0 && R === 0 || (N = (this.wrap(r[0] - S) * this.kx * E + (r[1] - I) * this.ky * R) / (E * E + R * R),
                            N > 1 ? (S = t[v + 1][0],
                            I = t[v + 1][1]) : N > 0 && (S += E / this.kx * N,
                            I += R / this.ky * N)),
                            E = this.wrap(r[0] - S) * this.kx,
                            R = (r[1] - I) * this.ky;
                            const j = E * E + R * R;
                            j < g && (g = j,
                            a = S,
                            c = I,
                            p = v,
                            f = N)
                        }
                        return {
                            point: [a, c],
                            index: p,
                            t: Math.max(0, Math.min(1, f))
                        }
                    }
                    wrap(t) {
                        for (; t < -180; )
                            t += 360;
                        for (; t > 180; )
                            t -= 360;
                        return t
                    }
                }
                function Ph(i, t) {
                    return t[0] - i[0]
                }
                function ol(i) {
                    return i[1] - i[0] + 1
                }
                function $a(i, t) {
                    return i[1] >= i[0] && i[1] < t
                }
                function vi(i, t) {
                    if (i[0] > i[1])
                        return [null, null];
                    const r = ol(i);
                    if (t) {
                        if (r === 2)
                            return [i, null];
                        const c = Math.floor(r / 2);
                        return [[i[0], i[0] + c], [i[0] + c, i[1]]]
                    }
                    if (r === 1)
                        return [i, null];
                    const a = Math.floor(r / 2) - 1;
                    return [[i[0], i[0] + a], [i[0] + a + 1, i[1]]]
                }
                function Pc(i, t) {
                    if (!$a(t, i.length))
                        return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (let a = t[0]; a <= t[1]; ++a)
                        go(r, i[a]);
                    return r
                }
                function Ic(i) {
                    const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (const r of i)
                        for (const a of r)
                            go(t, a);
                    return t
                }
                function Ih(i) {
                    return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0
                }
                function Mc(i, t, r) {
                    if (!Ih(i) || !Ih(t))
                        return NaN;
                    let a = 0
                      , c = 0;
                    return i[2] < t[0] && (a = t[0] - i[2]),
                    i[0] > t[2] && (a = i[0] - t[2]),
                    i[1] > t[3] && (c = i[1] - t[3]),
                    i[3] < t[1] && (c = t[1] - i[3]),
                    r.distance([0, 0], [a, c])
                }
                function vs(i, t, r) {
                    const a = r.pointOnLine(t, i);
                    return r.distance(i, a.point)
                }
                function Ac(i, t, r, a, c) {
                    const p = Math.min(vs(i, [r, a], c), vs(t, [r, a], c))
                      , f = Math.min(vs(r, [i, t], c), vs(a, [i, t], c));
                    return Math.min(p, f)
                }
                function op(i, t, r, a, c) {
                    if (!$a(t, i.length) || !$a(a, r.length))
                        return 1 / 0;
                    let p = 1 / 0;
                    for (let f = t[0]; f < t[1]; ++f) {
                        const g = i[f]
                          , v = i[f + 1];
                        for (let S = a[0]; S < a[1]; ++S) {
                            const I = r[S]
                              , E = r[S + 1];
                            if (al(g, v, I, E))
                                return 0;
                            p = Math.min(p, Ac(g, v, I, E, c))
                        }
                    }
                    return p
                }
                function lp(i, t, r, a, c) {
                    if (!$a(t, i.length) || !$a(a, r.length))
                        return NaN;
                    let p = 1 / 0;
                    for (let f = t[0]; f <= t[1]; ++f)
                        for (let g = a[0]; g <= a[1]; ++g)
                            if (p = Math.min(p, c.distance(i[f], r[g])),
                            p === 0)
                                return p;
                    return p
                }
                function cp(i, t, r) {
                    if (_s(i, t, !0))
                        return 0;
                    let a = 1 / 0;
                    for (const c of t) {
                        const p = c[0]
                          , f = c[c.length - 1];
                        if (p !== f && (a = Math.min(a, vs(i, [f, p], r)),
                        a === 0))
                            return a;
                        const g = r.pointOnLine(c, i);
                        if (a = Math.min(a, r.distance(i, g.point)),
                        a === 0)
                            return a
                    }
                    return a
                }
                function up(i, t, r, a) {
                    if (!$a(t, i.length))
                        return NaN;
                    for (let p = t[0]; p <= t[1]; ++p)
                        if (_s(i[p], r, !0))
                            return 0;
                    let c = 1 / 0;
                    for (let p = t[0]; p < t[1]; ++p) {
                        const f = i[p]
                          , g = i[p + 1];
                        for (const v of r)
                            for (let S = 0, I = v.length, E = I - 1; S < I; E = S++) {
                                const R = v[E]
                                  , N = v[S];
                                if (al(f, g, R, N))
                                    return 0;
                                c = Math.min(c, Ac(f, g, R, N, a))
                            }
                    }
                    return c
                }
                function Mh(i, t) {
                    for (const r of i)
                        for (const a of r)
                            if (_s(a, t, !0))
                                return !0;
                    return !1
                }
                function hp(i, t, r, a=1 / 0) {
                    const c = Ic(i)
                      , p = Ic(t);
                    if (a !== 1 / 0 && Mc(c, p, r) >= a)
                        return a;
                    if (vo(c, p)) {
                        if (Mh(i, t))
                            return 0
                    } else if (Mh(t, i))
                        return 0;
                    let f = 1 / 0;
                    for (const g of i)
                        for (let v = 0, S = g.length, I = S - 1; v < S; I = v++) {
                            const E = g[I]
                              , R = g[v];
                            for (const N of t)
                                for (let j = 0, Z = N.length, Y = Z - 1; j < Z; Y = j++) {
                                    const ae = N[Y]
                                      , ze = N[j];
                                    if (al(E, R, ae, ze))
                                        return 0;
                                    f = Math.min(f, Ac(E, R, ae, ze, r))
                                }
                        }
                    return f
                }
                function Ah(i, t, r, a, c, p) {
                    if (!p)
                        return;
                    const f = Mc(Pc(a, p), c, r);
                    f < t && i.push([f, p, [0, 0]])
                }
                function ll(i, t, r, a, c, p, f) {
                    if (!p || !f)
                        return;
                    const g = Mc(Pc(a, p), Pc(c, f), r);
                    g < t && i.push([g, p, f])
                }
                function cl(i, t, r, a, c=1 / 0) {
                    let p = Math.min(a.distance(i[0], r[0][0]), c);
                    if (p === 0)
                        return p;
                    const f = new wc([[0, [0, i.length - 1], [0, 0]]],Ph)
                      , g = Ic(r);
                    for (; f.length > 0; ) {
                        const v = f.pop();
                        if (v[0] >= p)
                            continue;
                        const S = v[1]
                          , I = t ? 50 : 100;
                        if (ol(S) <= I) {
                            if (!$a(S, i.length))
                                return NaN;
                            if (t) {
                                const E = up(i, S, r, a);
                                if (isNaN(E) || E === 0)
                                    return E;
                                p = Math.min(p, E)
                            } else
                                for (let E = S[0]; E <= S[1]; ++E) {
                                    const R = cp(i[E], r, a);
                                    if (p = Math.min(p, R),
                                    p === 0)
                                        return 0
                                }
                        } else {
                            const E = vi(S, t);
                            Ah(f, p, a, i, g, E[0]),
                            Ah(f, p, a, i, g, E[1])
                        }
                    }
                    return p
                }
                function ul(i, t, r, a, c, p=1 / 0) {
                    let f = Math.min(p, c.distance(i[0], r[0]));
                    if (f === 0)
                        return f;
                    const g = new wc([[0, [0, i.length - 1], [0, r.length - 1]]],Ph);
                    for (; g.length > 0; ) {
                        const v = g.pop();
                        if (v[0] >= f)
                            continue;
                        const S = v[1]
                          , I = v[2]
                          , E = t ? 50 : 100
                          , R = a ? 50 : 100;
                        if (ol(S) <= E && ol(I) <= R) {
                            if (!$a(S, i.length) && $a(I, r.length))
                                return NaN;
                            let N;
                            if (t && a)
                                N = op(i, S, r, I, c),
                                f = Math.min(f, N);
                            else if (t && !a) {
                                const j = i.slice(S[0], S[1] + 1);
                                for (let Z = I[0]; Z <= I[1]; ++Z)
                                    if (N = vs(r[Z], j, c),
                                    f = Math.min(f, N),
                                    f === 0)
                                        return f
                            } else if (!t && a) {
                                const j = r.slice(I[0], I[1] + 1);
                                for (let Z = S[0]; Z <= S[1]; ++Z)
                                    if (N = vs(i[Z], j, c),
                                    f = Math.min(f, N),
                                    f === 0)
                                        return f
                            } else
                                N = lp(i, S, r, I, c),
                                f = Math.min(f, N)
                        } else {
                            const N = vi(S, t)
                              , j = vi(I, a);
                            ll(g, f, c, i, r, N[0], j[0]),
                            ll(g, f, c, i, r, N[0], j[1]),
                            ll(g, f, c, i, r, N[1], j[0]),
                            ll(g, f, c, i, r, N[1], j[1])
                        }
                    }
                    return f
                }
                function kc(i) {
                    return i.type === "MultiPolygon" ? i.coordinates.map((t => ({
                        type: "Polygon",
                        coordinates: t
                    }))) : i.type === "MultiLineString" ? i.coordinates.map((t => ({
                        type: "LineString",
                        coordinates: t
                    }))) : i.type === "MultiPoint" ? i.coordinates.map((t => ({
                        type: "Point",
                        coordinates: t
                    }))) : [i]
                }
                class ys {
                    constructor(t, r) {
                        this.type = Ke,
                        this.geojson = t,
                        this.geometries = r
                    }
                    static parse(t, r) {
                        if (t.length !== 2)
                            return r.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (Za(t[1])) {
                            const a = t[1];
                            if (a.type === "FeatureCollection")
                                return new ys(a,a.features.map((c => kc(c.geometry))).flat());
                            if (a.type === "Feature")
                                return new ys(a,kc(a.geometry));
                            if ("type"in a && "coordinates"in a)
                                return new ys(a,kc(a))
                        }
                        return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(t) {
                        if (t.geometry() != null && t.canonicalID() != null) {
                            if (t.geometryType() === "Point")
                                return (function(r, a) {
                                    const c = r.geometry()
                                      , p = c.flat().map((v => nl([v.x, v.y], r.canonical)));
                                    if (c.length === 0)
                                        return NaN;
                                    const f = new Sc(p[0][1]);
                                    let g = 1 / 0;
                                    for (const v of a) {
                                        switch (v.type) {
                                        case "Point":
                                            g = Math.min(g, ul(p, !1, [v.coordinates], !1, f, g));
                                            break;
                                        case "LineString":
                                            g = Math.min(g, ul(p, !1, v.coordinates, !0, f, g));
                                            break;
                                        case "Polygon":
                                            g = Math.min(g, cl(p, !1, v.coordinates, f, g))
                                        }
                                        if (g === 0)
                                            return g
                                    }
                                    return g
                                }
                                )(t, this.geometries);
                            if (t.geometryType() === "LineString")
                                return (function(r, a) {
                                    const c = r.geometry()
                                      , p = c.flat().map((v => nl([v.x, v.y], r.canonical)));
                                    if (c.length === 0)
                                        return NaN;
                                    const f = new Sc(p[0][1]);
                                    let g = 1 / 0;
                                    for (const v of a) {
                                        switch (v.type) {
                                        case "Point":
                                            g = Math.min(g, ul(p, !0, [v.coordinates], !1, f, g));
                                            break;
                                        case "LineString":
                                            g = Math.min(g, ul(p, !0, v.coordinates, !0, f, g));
                                            break;
                                        case "Polygon":
                                            g = Math.min(g, cl(p, !0, v.coordinates, f, g))
                                        }
                                        if (g === 0)
                                            return g
                                    }
                                    return g
                                }
                                )(t, this.geometries);
                            if (t.geometryType() === "Polygon")
                                return (function(r, a) {
                                    const c = r.geometry();
                                    if (c.length === 0 || c[0].length === 0)
                                        return NaN;
                                    const p = xo(c, 0).map((v => v.map((S => S.map((I => nl([I.x, I.y], r.canonical)))))))
                                      , f = new Sc(p[0][0][0][1]);
                                    let g = 1 / 0;
                                    for (const v of a)
                                        for (const S of p) {
                                            switch (v.type) {
                                            case "Point":
                                                g = Math.min(g, cl([v.coordinates], !1, S, f, g));
                                                break;
                                            case "LineString":
                                                g = Math.min(g, cl(v.coordinates, !0, S, f, g));
                                                break;
                                            case "Polygon":
                                                g = Math.min(g, hp(S, v.coordinates, f, g))
                                            }
                                            if (g === 0)
                                                return g
                                        }
                                    return g
                                }
                                )(t, this.geometries)
                        }
                        return NaN
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                class bo {
                    constructor(t) {
                        this.type = fr,
                        this.key = t
                    }
                    static parse(t, r) {
                        if (t.length !== 2)
                            return r.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                        const a = t[1];
                        return a == null ? r.error("Global state property must be defined.") : typeof a != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new bo(a)
                    }
                    evaluate(t) {
                        var r;
                        const a = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
                        return a && Object.keys(a).length !== 0 ? gi(a, this.key) : null
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                }
                const Os = {
                    "==": gh,
                    "!=": tl,
                    ">": gc,
                    "<": Jd,
                    ">=": ep,
                    "<=": Qd,
                    array: ra,
                    at: Qo,
                    boolean: ra,
                    case: Bs,
                    coalesce: fo,
                    collator: rl,
                    format: ms,
                    image: yc,
                    in: el,
                    "index-of": va,
                    interpolate: In,
                    "interpolate-hcl": In,
                    "interpolate-lab": In,
                    length: il,
                    let: co,
                    literal: ga,
                    match: yn,
                    number: ra,
                    "number-format": vc,
                    object: ra,
                    slice: uo,
                    step: Gi,
                    string: ra,
                    "to-boolean": Ba,
                    "to-color": Ba,
                    "to-number": Ba,
                    "to-string": Ba,
                    var: Jo,
                    within: gs,
                    distance: ys,
                    "global-state": bo
                };
                class ca {
                    constructor(t, r, a, c) {
                        this.name = t,
                        this.type = r,
                        this._evaluate = a,
                        this.args = c
                    }
                    evaluate(t) {
                        return this._evaluate(t, this.args)
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return !1
                    }
                    static parse(t, r) {
                        const a = t[0]
                          , c = ca.definitions[a];
                        if (!c)
                            return r.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
                        const p = Array.isArray(c) ? c[0] : c.type
                          , f = Array.isArray(c) ? [[c[1], c[2]]] : c.overloads
                          , g = f.filter(( ([S]) => !Array.isArray(S) || S.length === t.length - 1));
                        let v = null;
                        for (const [S,I] of g) {
                            v = new Rs(r.registry,hl,r.path,null,r.scope);
                            const E = [];
                            let R = !1;
                            for (let N = 1; N < t.length; N++) {
                                const j = t[N]
                                  , Z = Array.isArray(S) ? S[N - 1] : S.type
                                  , Y = v.parse(j, 1 + E.length, Z);
                                if (!Y) {
                                    R = !0;
                                    break
                                }
                                E.push(Y)
                            }
                            if (!R)
                                if (Array.isArray(S) && S.length !== E.length)
                                    v.error(`Expected ${S.length} arguments, but found ${E.length} instead.`);
                                else {
                                    for (let N = 0; N < E.length; N++) {
                                        const j = Array.isArray(S) ? S[N] : S.type
                                          , Z = E[N];
                                        v.concat(N + 1).checkSubtype(j, Z.type)
                                    }
                                    if (v.errors.length === 0)
                                        return new ca(a,p,I,E)
                                }
                        }
                        if (g.length === 1)
                            r.errors.push(...v.errors);
                        else {
                            const S = (g.length ? g : f).map(( ([E]) => {
                                return R = E,
                                Array.isArray(R) ? `(${R.map(Yr).join(", ")})` : `(${Yr(R.type)}...)`;
                                var R
                            }
                            )).join(" | ")
                              , I = [];
                            for (let E = 1; E < t.length; E++) {
                                const R = r.parse(t[E], 1 + I.length);
                                if (!R)
                                    return null;
                                I.push(Yr(R.type))
                            }
                            r.error(`Expected arguments of type ${S}, but found (${I.join(", ")}) instead.`)
                        }
                        return null
                    }
                    static register(t, r) {
                        ca.definitions = r;
                        for (const a in r)
                            t[a] = ca
                    }
                }
                function kh(i, [t,r,a,c]) {
                    t = t.evaluate(i),
                    r = r.evaluate(i),
                    a = a.evaluate(i);
                    const p = c ? c.evaluate(i) : 1
                      , f = Ti(t, r, a, p);
                    if (f)
                        throw new wi(f);
                    return new yr(t / 255,r / 255,a / 255,p,!1)
                }
                function Eh(i, t) {
                    return i in t
                }
                function Ec(i, t) {
                    const r = t[i];
                    return r === void 0 ? null : r
                }
                function xs(i) {
                    return {
                        type: i
                    }
                }
                function hl(i) {
                    if (i instanceof Jo)
                        return hl(i.boundExpression);
                    if (i instanceof ca && i.name === "error" || i instanceof rl || i instanceof gs || i instanceof ys || i instanceof bo)
                        return !1;
                    const t = i instanceof Ba || i instanceof ra;
                    let r = !0;
                    return i.eachChild((a => {
                        r = t ? r && hl(a) : r && a instanceof ga
                    }
                    )),
                    !!r && dl(i) && pl(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
                }
                function dl(i) {
                    if (i instanceof ca && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof gs || i instanceof ys)
                        return !1;
                    let t = !0;
                    return i.eachChild((r => {
                        t && !dl(r) && (t = !1)
                    }
                    )),
                    t
                }
                function wo(i) {
                    if (i instanceof ca && i.name === "feature-state")
                        return !1;
                    let t = !0;
                    return i.eachChild((r => {
                        t && !wo(r) && (t = !1)
                    }
                    )),
                    t
                }
                function pl(i, t) {
                    if (i instanceof ca && t.indexOf(i.name) >= 0)
                        return !1;
                    let r = !0;
                    return i.eachChild((a => {
                        r && !pl(a, t) && (r = !1)
                    }
                    )),
                    r
                }
                function zh(i) {
                    return {
                        result: "success",
                        value: i
                    }
                }
                function Ns(i) {
                    return {
                        result: "error",
                        value: i
                    }
                }
                function rs(i) {
                    return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven"
                }
                function Lh(i) {
                    return !!i.expression && i.expression.parameters.indexOf("zoom") > -1
                }
                function zc(i) {
                    return !!i.expression && i.expression.interpolated
                }
                function ii(i) {
                    return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i
                }
                function To(i) {
                    return typeof i == "object" && i !== null && !Array.isArray(i) && wr(i) === li
                }
                function dp(i) {
                    return i
                }
                function Dh(i, t) {
                    const r = i.stops && typeof i.stops[0][0] == "object"
                      , a = r || !(r || i.property !== void 0)
                      , c = i.type || (zc(t) ? "exponential" : "interval")
                      , p = (function(I) {
                        switch (I.type) {
                        case "color":
                            return yr.parse;
                        case "padding":
                            return Ki.parse;
                        case "numberArray":
                            return cn.parse;
                        case "colorArray":
                            return Ni.parse;
                        default:
                            return null
                        }
                    }
                    )(t);
                    if (p && ((i = Ci({}, i)).stops && (i.stops = i.stops.map((I => [I[0], p(I[1])]))),
                    i.default = p(i.default ? i.default : t.default)),
                    i.colorSpace && (f = i.colorSpace) !== "rgb" && f !== "hcl" && f !== "lab")
                        throw new Error(`Unknown color space: "${i.colorSpace}"`);
                    var f;
                    const g = (function(I) {
                        switch (I) {
                        case "exponential":
                            return Bh;
                        case "interval":
                            return pp;
                        case "categorical":
                            return Rh;
                        case "identity":
                            return fp;
                        default:
                            throw new Error(`Unknown function type "${I}"`)
                        }
                    }
                    )(c);
                    let v, S;
                    if (c === "categorical") {
                        v = Object.create(null);
                        for (const I of i.stops)
                            v[I[0]] = I[1];
                        S = typeof i.stops[0][0]
                    }
                    if (r) {
                        const I = {}
                          , E = [];
                        for (let j = 0; j < i.stops.length; j++) {
                            const Z = i.stops[j]
                              , Y = Z[0].zoom;
                            I[Y] === void 0 && (I[Y] = {
                                zoom: Y,
                                type: i.type,
                                property: i.property,
                                default: i.default,
                                stops: []
                            },
                            E.push(Y)),
                            I[Y].stops.push([Z[0].value, Z[1]])
                        }
                        const R = [];
                        for (const j of E)
                            R.push([I[j].zoom, Dh(I[j], t)]);
                        const N = {
                            name: "linear"
                        };
                        return {
                            kind: "composite",
                            interpolationType: N,
                            interpolationFactor: In.interpolationFactor.bind(void 0, N),
                            zoomStops: R.map((j => j[0])),
                            evaluate: ({zoom: j}, Z) => Bh({
                                stops: R,
                                base: i.base
                            }, t, j).evaluate(j, Z)
                        }
                    }
                    if (a) {
                        const I = c === "exponential" ? {
                            name: "exponential",
                            base: i.base !== void 0 ? i.base : 1
                        } : null;
                        return {
                            kind: "camera",
                            interpolationType: I,
                            interpolationFactor: In.interpolationFactor.bind(void 0, I),
                            zoomStops: i.stops.map((E => E[0])),
                            evaluate: ({zoom: E}) => g(i, t, E, v, S)
                        }
                    }
                    return {
                        kind: "source",
                        evaluate(I, E) {
                            const R = E && E.properties ? E.properties[i.property] : void 0;
                            return R === void 0 ? is(i.default, t.default) : g(i, t, R, v, S)
                        }
                    }
                }
                function is(i, t, r) {
                    return i !== void 0 ? i : t !== void 0 ? t : r !== void 0 ? r : void 0
                }
                function Rh(i, t, r, a, c) {
                    return is(typeof r === c ? a[r] : void 0, i.default, t.default)
                }
                function pp(i, t, r) {
                    if (ii(r) !== "number")
                        return is(i.default, t.default);
                    const a = i.stops.length;
                    if (a === 1 || r <= i.stops[0][0])
                        return i.stops[0][1];
                    if (r >= i.stops[a - 1][0])
                        return i.stops[a - 1][1];
                    const c = fs(i.stops.map((p => p[0])), r);
                    return i.stops[c][1]
                }
                function Bh(i, t, r) {
                    const a = i.base !== void 0 ? i.base : 1;
                    if (ii(r) !== "number")
                        return is(i.default, t.default);
                    const c = i.stops.length;
                    if (c === 1 || r <= i.stops[0][0])
                        return i.stops[0][1];
                    if (r >= i.stops[c - 1][0])
                        return i.stops[c - 1][1];
                    const p = fs(i.stops.map((I => I[0])), r)
                      , f = (function(I, E, R, N) {
                        const j = N - R
                          , Z = I - R;
                        return j === 0 ? 0 : E === 1 ? Z / j : (Math.pow(E, Z) - 1) / (Math.pow(E, j) - 1)
                    }
                    )(r, a, i.stops[p][0], i.stops[p + 1][0])
                      , g = i.stops[p][1]
                      , v = i.stops[p + 1][1]
                      , S = Fa[t.type] || dp;
                    return typeof g.evaluate == "function" ? {
                        evaluate(...I) {
                            const E = g.evaluate.apply(void 0, I)
                              , R = v.evaluate.apply(void 0, I);
                            if (E !== void 0 && R !== void 0)
                                return S(E, R, f, i.colorSpace)
                        }
                    } : S(g, v, f, i.colorSpace)
                }
                function fp(i, t, r) {
                    switch (t.type) {
                    case "color":
                        r = yr.parse(r);
                        break;
                    case "formatted":
                        r = ln.fromString(r.toString());
                        break;
                    case "resolvedImage":
                        r = Nn.fromString(r.toString());
                        break;
                    case "padding":
                        r = Ki.parse(r);
                        break;
                    case "colorArray":
                        r = Ni.parse(r);
                        break;
                    case "numberArray":
                        r = cn.parse(r);
                        break;
                    default:
                        ii(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0)
                    }
                    return is(r, i.default, t.default)
                }
                ca.register(Os, {
                    error: [{
                        kind: "error"
                    }, [jt], (i, [t]) => {
                        throw new wi(t.evaluate(i))
                    }
                    ],
                    typeof: [jt, [fr], (i, [t]) => Yr(wr(t.evaluate(i)))],
                    "to-rgba": [Qr(Ke, 4), [Dr], (i, [t]) => {
                        const [r,a,c,p] = t.evaluate(i).rgb;
                        return [255 * r, 255 * a, 255 * c, p]
                    }
                    ],
                    rgb: [Dr, [Ke, Ke, Ke], kh],
                    rgba: [Dr, [Ke, Ke, Ke, Ke], kh],
                    has: {
                        type: Gt,
                        overloads: [[[jt], (i, [t]) => Eh(t.evaluate(i), i.properties())], [[jt, li], (i, [t,r]) => Eh(t.evaluate(i), r.evaluate(i))]]
                    },
                    get: {
                        type: fr,
                        overloads: [[[jt], (i, [t]) => Ec(t.evaluate(i), i.properties())], [[jt, li], (i, [t,r]) => Ec(t.evaluate(i), r.evaluate(i))]]
                    },
                    "feature-state": [fr, [jt], (i, [t]) => Ec(t.evaluate(i), i.featureState || {})],
                    properties: [li, [], i => i.properties()],
                    "geometry-type": [jt, [], i => i.geometryType()],
                    id: [fr, [], i => i.id()],
                    zoom: [Ke, [], i => i.globals.zoom],
                    "heatmap-density": [Ke, [], i => i.globals.heatmapDensity || 0],
                    elevation: [Ke, [], i => i.globals.elevation || 0],
                    "line-progress": [Ke, [], i => i.globals.lineProgress || 0],
                    accumulated: [fr, [], i => i.globals.accumulated === void 0 ? null : i.globals.accumulated],
                    "+": [Ke, xs(Ke), (i, t) => {
                        let r = 0;
                        for (const a of t)
                            r += a.evaluate(i);
                        return r
                    }
                    ],
                    "*": [Ke, xs(Ke), (i, t) => {
                        let r = 1;
                        for (const a of t)
                            r *= a.evaluate(i);
                        return r
                    }
                    ],
                    "-": {
                        type: Ke,
                        overloads: [[[Ke, Ke], (i, [t,r]) => t.evaluate(i) - r.evaluate(i)], [[Ke], (i, [t]) => -t.evaluate(i)]]
                    },
                    "/": [Ke, [Ke, Ke], (i, [t,r]) => t.evaluate(i) / r.evaluate(i)],
                    "%": [Ke, [Ke, Ke], (i, [t,r]) => t.evaluate(i) % r.evaluate(i)],
                    ln2: [Ke, [], () => Math.LN2],
                    pi: [Ke, [], () => Math.PI],
                    e: [Ke, [], () => Math.E],
                    "^": [Ke, [Ke, Ke], (i, [t,r]) => Math.pow(t.evaluate(i), r.evaluate(i))],
                    sqrt: [Ke, [Ke], (i, [t]) => Math.sqrt(t.evaluate(i))],
                    log10: [Ke, [Ke], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10],
                    ln: [Ke, [Ke], (i, [t]) => Math.log(t.evaluate(i))],
                    log2: [Ke, [Ke], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2],
                    sin: [Ke, [Ke], (i, [t]) => Math.sin(t.evaluate(i))],
                    cos: [Ke, [Ke], (i, [t]) => Math.cos(t.evaluate(i))],
                    tan: [Ke, [Ke], (i, [t]) => Math.tan(t.evaluate(i))],
                    asin: [Ke, [Ke], (i, [t]) => Math.asin(t.evaluate(i))],
                    acos: [Ke, [Ke], (i, [t]) => Math.acos(t.evaluate(i))],
                    atan: [Ke, [Ke], (i, [t]) => Math.atan(t.evaluate(i))],
                    min: [Ke, xs(Ke), (i, t) => Math.min(...t.map((r => r.evaluate(i))))],
                    max: [Ke, xs(Ke), (i, t) => Math.max(...t.map((r => r.evaluate(i))))],
                    abs: [Ke, [Ke], (i, [t]) => Math.abs(t.evaluate(i))],
                    round: [Ke, [Ke], (i, [t]) => {
                        const r = t.evaluate(i);
                        return r < 0 ? -Math.round(-r) : Math.round(r)
                    }
                    ],
                    floor: [Ke, [Ke], (i, [t]) => Math.floor(t.evaluate(i))],
                    ceil: [Ke, [Ke], (i, [t]) => Math.ceil(t.evaluate(i))],
                    "filter-==": [Gt, [jt, fr], (i, [t,r]) => i.properties()[t.value] === r.value],
                    "filter-id-==": [Gt, [fr], (i, [t]) => i.id() === t.value],
                    "filter-type-==": [Gt, [jt], (i, [t]) => i.geometryType() === t.value],
                    "filter-<": [Gt, [jt, fr], (i, [t,r]) => {
                        const a = i.properties()[t.value]
                          , c = r.value;
                        return typeof a == typeof c && a < c
                    }
                    ],
                    "filter-id-<": [Gt, [fr], (i, [t]) => {
                        const r = i.id()
                          , a = t.value;
                        return typeof r == typeof a && r < a
                    }
                    ],
                    "filter->": [Gt, [jt, fr], (i, [t,r]) => {
                        const a = i.properties()[t.value]
                          , c = r.value;
                        return typeof a == typeof c && a > c
                    }
                    ],
                    "filter-id->": [Gt, [fr], (i, [t]) => {
                        const r = i.id()
                          , a = t.value;
                        return typeof r == typeof a && r > a
                    }
                    ],
                    "filter-<=": [Gt, [jt, fr], (i, [t,r]) => {
                        const a = i.properties()[t.value]
                          , c = r.value;
                        return typeof a == typeof c && a <= c
                    }
                    ],
                    "filter-id-<=": [Gt, [fr], (i, [t]) => {
                        const r = i.id()
                          , a = t.value;
                        return typeof r == typeof a && r <= a
                    }
                    ],
                    "filter->=": [Gt, [jt, fr], (i, [t,r]) => {
                        const a = i.properties()[t.value]
                          , c = r.value;
                        return typeof a == typeof c && a >= c
                    }
                    ],
                    "filter-id->=": [Gt, [fr], (i, [t]) => {
                        const r = i.id()
                          , a = t.value;
                        return typeof r == typeof a && r >= a
                    }
                    ],
                    "filter-has": [Gt, [fr], (i, [t]) => t.value in i.properties()],
                    "filter-has-id": [Gt, [], i => i.id() !== null && i.id() !== void 0],
                    "filter-type-in": [Gt, [Qr(jt)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0],
                    "filter-id-in": [Gt, [Qr(fr)], (i, [t]) => t.value.indexOf(i.id()) >= 0],
                    "filter-in-small": [Gt, [jt, Qr(fr)], (i, [t,r]) => r.value.indexOf(i.properties()[t.value]) >= 0],
                    "filter-in-large": [Gt, [jt, Qr(fr)], (i, [t,r]) => (function(a, c, p, f) {
                        for (; p <= f; ) {
                            const g = p + f >> 1;
                            if (c[g] === a)
                                return !0;
                            c[g] > a ? f = g - 1 : p = g + 1
                        }
                        return !1
                    }
                    )(i.properties()[t.value], r.value, 0, r.value.length - 1)],
                    all: {
                        type: Gt,
                        overloads: [[[Gt, Gt], (i, [t,r]) => t.evaluate(i) && r.evaluate(i)], [xs(Gt), (i, t) => {
                            for (const r of t)
                                if (!r.evaluate(i))
                                    return !1;
                            return !0
                        }
                        ]]
                    },
                    any: {
                        type: Gt,
                        overloads: [[[Gt, Gt], (i, [t,r]) => t.evaluate(i) || r.evaluate(i)], [xs(Gt), (i, t) => {
                            for (const r of t)
                                if (r.evaluate(i))
                                    return !0;
                            return !1
                        }
                        ]]
                    },
                    "!": [Gt, [Gt], (i, [t]) => !t.evaluate(i)],
                    "is-supported-script": [Gt, [jt], (i, [t]) => {
                        const r = i.globals && i.globals.isSupportedScript;
                        return !r || r(t.evaluate(i))
                    }
                    ],
                    upcase: [jt, [jt], (i, [t]) => t.evaluate(i).toUpperCase()],
                    downcase: [jt, [jt], (i, [t]) => t.evaluate(i).toLowerCase()],
                    concat: [jt, xs(fr), (i, t) => t.map((r => Vr(r.evaluate(i)))).join("")],
                    "resolved-locale": [jt, [bi], (i, [t]) => t.evaluate(i).resolvedLocale()]
                });
                class Lc {
                    constructor(t, r) {
                        this.expression = t,
                        this._warningHistory = {},
                        this._evaluator = new mc,
                        this._defaultValue = r ? (function(a) {
                            if (a.type === "color" && To(a.default))
                                return new yr(0,0,0,0);
                            switch (a.type) {
                            case "color":
                                return yr.parse(a.default) || null;
                            case "padding":
                                return Ki.parse(a.default) || null;
                            case "numberArray":
                                return cn.parse(a.default) || null;
                            case "colorArray":
                                return Ni.parse(a.default) || null;
                            case "variableAnchorOffsetCollection":
                                return un.parse(a.default) || null;
                            case "projectionDefinition":
                                return hn.parse(a.default) || null;
                            default:
                                return a.default === void 0 ? null : a.default
                            }
                        }
                        )(r) : null,
                        this._enumValues = r && r.type === "enum" ? r.values : null
                    }
                    evaluateWithoutErrorHandling(t, r, a, c, p, f) {
                        return this._evaluator.globals = t,
                        this._evaluator.feature = r,
                        this._evaluator.featureState = a,
                        this._evaluator.canonical = c,
                        this._evaluator.availableImages = p || null,
                        this._evaluator.formattedSection = f,
                        this.expression.evaluate(this._evaluator)
                    }
                    evaluate(t, r, a, c, p, f) {
                        this._evaluator.globals = t,
                        this._evaluator.feature = r || null,
                        this._evaluator.featureState = a || null,
                        this._evaluator.canonical = c,
                        this._evaluator.availableImages = p || null,
                        this._evaluator.formattedSection = f || null;
                        try {
                            const g = this.expression.evaluate(this._evaluator);
                            if (g == null || typeof g == "number" && g != g)
                                return this._defaultValue;
                            if (this._enumValues && !(g in this._enumValues))
                                throw new wi(`Expected value to be one of ${Object.keys(this._enumValues).map((v => JSON.stringify(v))).join(", ")}, but found ${JSON.stringify(g)} instead.`);
                            return g
                        } catch (g) {
                            return this._warningHistory[g.message] || (this._warningHistory[g.message] = !0,
                            typeof console < "u" && console.warn(g.message)),
                            this._defaultValue
                        }
                    }
                }
                function fl(i) {
                    return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0]in Os
                }
                function Co(i, t) {
                    const r = new Rs(Os,hl,[],t ? (function(c) {
                        const p = {
                            color: Dr,
                            string: jt,
                            number: Ke,
                            enum: jt,
                            boolean: Gt,
                            formatted: Si,
                            padding: zi,
                            numberArray: Li,
                            colorArray: mi,
                            projectionDefinition: Gr,
                            resolvedImage: rr,
                            variableAnchorOffsetCollection: yi
                        };
                        return c.type === "array" ? Qr(p[c.value] || fr, c.length) : p[c.type]
                    }
                    )(t) : void 0)
                      , a = r.parse(i, void 0, void 0, void 0, t && t.type === "string" ? {
                        typeAnnotation: "coerce"
                    } : void 0);
                    return a ? zh(new Lc(a,t)) : Ns(r.errors)
                }
                class So {
                    constructor(t, r) {
                        this.kind = t,
                        this._styleExpression = r,
                        this.isStateDependent = t !== "constant" && !wo(r.expression),
                        this.globalStateRefs = Mo(r.expression)
                    }
                    evaluateWithoutErrorHandling(t, r, a, c, p, f) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, r, a, c, p, f)
                    }
                    evaluate(t, r, a, c, p, f) {
                        return this._styleExpression.evaluate(t, r, a, c, p, f)
                    }
                }
                class Dc {
                    constructor(t, r, a, c) {
                        this.kind = t,
                        this.zoomStops = a,
                        this._styleExpression = r,
                        this.isStateDependent = t !== "camera" && !wo(r.expression),
                        this.globalStateRefs = Mo(r.expression),
                        this.interpolationType = c
                    }
                    evaluateWithoutErrorHandling(t, r, a, c, p, f) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, r, a, c, p, f)
                    }
                    evaluate(t, r, a, c, p, f) {
                        return this._styleExpression.evaluate(t, r, a, c, p, f)
                    }
                    interpolationFactor(t, r, a) {
                        return this.interpolationType ? In.interpolationFactor(this.interpolationType, t, r, a) : 0
                    }
                }
                function Fh(i, t) {
                    const r = Co(i, t);
                    if (r.result === "error")
                        return r;
                    const a = r.value.expression
                      , c = dl(a);
                    if (!c && !rs(t))
                        return Ns([new di("","data expressions not supported")]);
                    const p = pl(a, ["zoom"]);
                    if (!p && !Lh(t))
                        return Ns([new di("","zoom expressions not supported")]);
                    const f = Io(a);
                    return f || p ? f instanceof di ? Ns([f]) : f instanceof In && !zc(t) ? Ns([new di("",'"interpolate" expressions cannot be used with this property')]) : zh(f ? new Dc(c ? "camera" : "composite",r.value,f.labels,f instanceof In ? f.interpolation : void 0) : new So(c ? "constant" : "source",r.value)) : Ns([new di("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
                }
                class Po {
                    constructor(t, r) {
                        this._parameters = t,
                        this._specification = r,
                        Ci(this, Dh(this._parameters, this._specification))
                    }
                    static deserialize(t) {
                        return new Po(t._parameters,t._specification)
                    }
                    static serialize(t) {
                        return {
                            _parameters: t._parameters,
                            _specification: t._specification
                        }
                    }
                }
                function Io(i) {
                    let t = null;
                    if (i instanceof co)
                        t = Io(i.result);
                    else if (i instanceof fo) {
                        for (const r of i.args)
                            if (t = Io(r),
                            t)
                                break
                    } else
                        (i instanceof Gi || i instanceof In) && i.input instanceof ca && i.input.name === "zoom" && (t = i);
                    return t instanceof di || i.eachChild((r => {
                        const a = Io(r);
                        a instanceof di ? t = a : !t && a ? t = new di("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && a && t !== a && (t = new di("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                    }
                    )),
                    t
                }
                function Mo(i, t=new Set) {
                    return i instanceof bo && t.add(i.key),
                    i.eachChild((r => {
                        Mo(r, t)
                    }
                    )),
                    t
                }
                function ml(i) {
                    if (i === !0 || i === !1)
                        return !0;
                    if (!Array.isArray(i) || i.length === 0)
                        return !1;
                    switch (i[0]) {
                    case "has":
                        return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
                    case "in":
                        return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
                    case "!in":
                    case "!has":
                    case "none":
                        return !1;
                    case "==":
                    case "!=":
                    case ">":
                    case ">=":
                    case "<":
                    case "<=":
                        return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
                    case "any":
                    case "all":
                        for (const t of i.slice(1))
                            if (!ml(t) && typeof t != "boolean")
                                return !1;
                        return !0;
                    default:
                        return !0
                    }
                }
                const Rc = {
                    type: "boolean",
                    default: !1,
                    transition: !1,
                    "property-type": "data-driven",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    }
                };
                function bs(i) {
                    if (i == null)
                        return {
                            filter: () => !0,
                            needGeometry: !1,
                            getGlobalStateRefs: () => new Set
                        };
                    ml(i) || (i = ws(i));
                    const t = Co(i, Rc);
                    if (t.result === "error")
                        throw new Error(t.value.map((r => `${r.key}: ${r.message}`)).join(", "));
                    return {
                        filter: (r, a, c) => t.value.evaluate(r, a, {}, c),
                        needGeometry: _l(i),
                        getGlobalStateRefs: () => Mo(t.value.expression)
                    }
                }
                function Bc(i, t) {
                    return i < t ? -1 : i > t ? 1 : 0
                }
                function _l(i) {
                    if (!Array.isArray(i))
                        return !1;
                    if (i[0] === "within" || i[0] === "distance")
                        return !0;
                    for (let t = 1; t < i.length; t++)
                        if (_l(i[t]))
                            return !0;
                    return !1
                }
                function ws(i) {
                    if (!i)
                        return !0;
                    const t = i[0];
                    return i.length <= 1 ? t !== "any" : t === "==" ? Fc(i[1], i[2], "==") : t === "!=" ? gl(Fc(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Fc(i[1], i[2], t) : t === "any" ? (r = i.slice(1),
                    ["any"].concat(r.map(ws))) : t === "all" ? ["all"].concat(i.slice(1).map(ws)) : t === "none" ? ["all"].concat(i.slice(1).map(ws).map(gl)) : t === "in" ? Oh(i[1], i.slice(2)) : t === "!in" ? gl(Oh(i[1], i.slice(2))) : t === "has" ? Nh(i[1]) : t !== "!has" || gl(Nh(i[1]));
                    var r
                }
                function Fc(i, t, r) {
                    switch (i) {
                    case "$type":
                        return [`filter-type-${r}`, t];
                    case "$id":
                        return [`filter-id-${r}`, t];
                    default:
                        return [`filter-${r}`, i, t]
                    }
                }
                function Oh(i, t) {
                    if (t.length === 0)
                        return !1;
                    switch (i) {
                    case "$type":
                        return ["filter-type-in", ["literal", t]];
                    case "$id":
                        return ["filter-id-in", ["literal", t]];
                    default:
                        return t.length > 200 && !t.some((r => typeof r != typeof t[0])) ? ["filter-in-large", i, ["literal", t.sort(Bc)]] : ["filter-in-small", i, ["literal", t]]
                    }
                }
                function Nh(i) {
                    switch (i) {
                    case "$type":
                        return !0;
                    case "$id":
                        return ["filter-has-id"];
                    default:
                        return ["filter-has", i]
                    }
                }
                function gl(i) {
                    return ["!", i]
                }
                function Oc(i) {
                    const t = typeof i;
                    if (t === "number" || t === "boolean" || t === "string" || i == null)
                        return JSON.stringify(i);
                    if (Array.isArray(i)) {
                        let c = "[";
                        for (const p of i)
                            c += `${Oc(p)},`;
                        return `${c}]`
                    }
                    const r = Object.keys(i).sort();
                    let a = "{";
                    for (let c = 0; c < r.length; c++)
                        a += `${JSON.stringify(r[c])}:${Oc(i[r[c]])},`;
                    return `${a}}`
                }
                function mp(i) {
                    let t = "";
                    for (const r of At)
                        t += `/${Oc(i[r])}`;
                    return t
                }
                function Nc(i) {
                    const t = i.value;
                    return t ? [new Tt(i.key,t,"constants have been deprecated as of v8")] : []
                }
                function Vi(i) {
                    return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i
                }
                function Oa(i) {
                    if (Array.isArray(i))
                        return i.map(Oa);
                    if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
                        const t = {};
                        for (const r in i)
                            t[r] = Oa(i[r]);
                        return t
                    }
                    return Vi(i)
                }
                function ua(i) {
                    const t = i.key
                      , r = i.value
                      , a = i.valueSpec || {}
                      , c = i.objectElementValidators || {}
                      , p = i.style
                      , f = i.styleSpec
                      , g = i.validateSpec;
                    let v = [];
                    const S = ii(r);
                    if (S !== "object")
                        return [new Tt(t,r,`object expected, ${S} found`)];
                    for (const I in r) {
                        const E = I.split(".")[0]
                          , R = gi(a, E) || a["*"];
                        let N;
                        if (gi(c, E))
                            N = c[E];
                        else if (gi(a, E))
                            N = g;
                        else if (c["*"])
                            N = c["*"];
                        else {
                            if (!a["*"]) {
                                v.push(new Tt(t,r[I],`unknown property "${I}"`));
                                continue
                            }
                            N = g
                        }
                        v = v.concat(N({
                            key: (t && `${t}.`) + I,
                            value: r[I],
                            valueSpec: R,
                            style: p,
                            styleSpec: f,
                            object: r,
                            objectKey: I,
                            validateSpec: g
                        }, r))
                    }
                    for (const I in a)
                        c[I] || a[I].required && a[I].default === void 0 && r[I] === void 0 && v.push(new Tt(t,r,`missing required property "${I}"`));
                    return v
                }
                function vl(i) {
                    const t = i.value
                      , r = i.valueSpec
                      , a = i.style
                      , c = i.styleSpec
                      , p = i.key
                      , f = i.arrayElementValidator || i.validateSpec;
                    if (ii(t) !== "array")
                        return [new Tt(p,t,`array expected, ${ii(t)} found`)];
                    if (r.length && t.length !== r.length)
                        return [new Tt(p,t,`array length ${r.length} expected, length ${t.length} found`)];
                    if (r["min-length"] && t.length < r["min-length"])
                        return [new Tt(p,t,`array length at least ${r["min-length"]} expected, length ${t.length} found`)];
                    let g = {
                        type: r.value,
                        values: r.values
                    };
                    c.$version < 7 && (g.function = r.function),
                    ii(r.value) === "object" && (g = r.value);
                    let v = [];
                    for (let S = 0; S < t.length; S++)
                        v = v.concat(f({
                            array: t,
                            arrayIndex: S,
                            value: t[S],
                            valueSpec: g,
                            validateSpec: i.validateSpec,
                            style: a,
                            styleSpec: c,
                            key: `${p}[${S}]`
                        }));
                    return v
                }
                function Ao(i) {
                    const t = i.key
                      , r = i.value
                      , a = i.valueSpec;
                    let c = ii(r);
                    return c === "number" && r != r && (c = "NaN"),
                    c !== "number" ? [new Tt(t,r,`number expected, ${c} found`)] : "minimum"in a && r < a.minimum ? [new Tt(t,r,`${r} is less than the minimum value ${a.minimum}`)] : "maximum"in a && r > a.maximum ? [new Tt(t,r,`${r} is greater than the maximum value ${a.maximum}`)] : []
                }
                function jh(i) {
                    const t = i.valueSpec
                      , r = Vi(i.value.type);
                    let a, c, p, f = {};
                    const g = r !== "categorical" && i.value.property === void 0
                      , v = !g
                      , S = ii(i.value.stops) === "array" && ii(i.value.stops[0]) === "array" && ii(i.value.stops[0][0]) === "object"
                      , I = ua({
                        key: i.key,
                        value: i.value,
                        valueSpec: i.styleSpec.function,
                        validateSpec: i.validateSpec,
                        style: i.style,
                        styleSpec: i.styleSpec,
                        objectElementValidators: {
                            stops: function(N) {
                                if (r === "identity")
                                    return [new Tt(N.key,N.value,'identity function may not have a "stops" property')];
                                let j = [];
                                const Z = N.value;
                                return j = j.concat(vl({
                                    key: N.key,
                                    value: Z,
                                    valueSpec: N.valueSpec,
                                    validateSpec: N.validateSpec,
                                    style: N.style,
                                    styleSpec: N.styleSpec,
                                    arrayElementValidator: E
                                })),
                                ii(Z) === "array" && Z.length === 0 && j.push(new Tt(N.key,Z,"array must have at least one stop")),
                                j
                            },
                            default: function(N) {
                                return N.validateSpec({
                                    key: N.key,
                                    value: N.value,
                                    valueSpec: t,
                                    validateSpec: N.validateSpec,
                                    style: N.style,
                                    styleSpec: N.styleSpec
                                })
                            }
                        }
                    });
                    return r === "identity" && g && I.push(new Tt(i.key,i.value,'missing required property "property"')),
                    r === "identity" || i.value.stops || I.push(new Tt(i.key,i.value,'missing required property "stops"')),
                    r === "exponential" && i.valueSpec.expression && !zc(i.valueSpec) && I.push(new Tt(i.key,i.value,"exponential functions not supported")),
                    i.styleSpec.$version >= 8 && (v && !rs(i.valueSpec) ? I.push(new Tt(i.key,i.value,"property functions not supported")) : g && !Lh(i.valueSpec) && I.push(new Tt(i.key,i.value,"zoom functions not supported"))),
                    r !== "categorical" && !S || i.value.property !== void 0 || I.push(new Tt(i.key,i.value,'"property" property is required')),
                    I;
                    function E(N) {
                        let j = [];
                        const Z = N.value
                          , Y = N.key;
                        if (ii(Z) !== "array")
                            return [new Tt(Y,Z,`array expected, ${ii(Z)} found`)];
                        if (Z.length !== 2)
                            return [new Tt(Y,Z,`array length 2 expected, length ${Z.length} found`)];
                        if (S) {
                            if (ii(Z[0]) !== "object")
                                return [new Tt(Y,Z,`object expected, ${ii(Z[0])} found`)];
                            if (Z[0].zoom === void 0)
                                return [new Tt(Y,Z,"object stop key must have zoom")];
                            if (Z[0].value === void 0)
                                return [new Tt(Y,Z,"object stop key must have value")];
                            if (p && p > Vi(Z[0].zoom))
                                return [new Tt(Y,Z[0].zoom,"stop zoom values must appear in ascending order")];
                            Vi(Z[0].zoom) !== p && (p = Vi(Z[0].zoom),
                            c = void 0,
                            f = {}),
                            j = j.concat(ua({
                                key: `${Y}[0]`,
                                value: Z[0],
                                valueSpec: {
                                    zoom: {}
                                },
                                validateSpec: N.validateSpec,
                                style: N.style,
                                styleSpec: N.styleSpec,
                                objectElementValidators: {
                                    zoom: Ao,
                                    value: R
                                }
                            }))
                        } else
                            j = j.concat(R({
                                key: `${Y}[0]`,
                                value: Z[0],
                                validateSpec: N.validateSpec,
                                style: N.style,
                                styleSpec: N.styleSpec
                            }, Z));
                        return fl(Oa(Z[1])) ? j.concat([new Tt(`${Y}[1]`,Z[1],"expressions are not allowed in function stops.")]) : j.concat(N.validateSpec({
                            key: `${Y}[1]`,
                            value: Z[1],
                            valueSpec: t,
                            validateSpec: N.validateSpec,
                            style: N.style,
                            styleSpec: N.styleSpec
                        }))
                    }
                    function R(N, j) {
                        const Z = ii(N.value)
                          , Y = Vi(N.value)
                          , ae = N.value !== null ? N.value : j;
                        if (a) {
                            if (Z !== a)
                                return [new Tt(N.key,ae,`${Z} stop domain type must match previous stop domain type ${a}`)]
                        } else
                            a = Z;
                        if (Z !== "number" && Z !== "string" && Z !== "boolean")
                            return [new Tt(N.key,ae,"stop domain value must be a number, string, or boolean")];
                        if (Z !== "number" && r !== "categorical") {
                            let ze = `number expected, ${Z} found`;
                            return rs(t) && r === void 0 && (ze += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                            [new Tt(N.key,ae,ze)]
                        }
                        return r !== "categorical" || Z !== "number" || isFinite(Y) && Math.floor(Y) === Y ? r !== "categorical" && Z === "number" && c !== void 0 && Y < c ? [new Tt(N.key,ae,"stop domain values must appear in ascending order")] : (c = Y,
                        r === "categorical" && Y in f ? [new Tt(N.key,ae,"stop domain values must be unique")] : (f[Y] = !0,
                        [])) : [new Tt(N.key,ae,`integer expected, found ${Y}`)]
                    }
                }
                function Ts(i) {
                    const t = (i.expressionContext === "property" ? Fh : Co)(Oa(i.value), i.valueSpec);
                    if (t.result === "error")
                        return t.value.map((a => new Tt(`${i.key}${a.key}`,i.value,a.message)));
                    const r = t.value.expression || t.value._styleExpression.expression;
                    if (i.expressionContext === "property" && i.propertyKey === "text-font" && !r.outputDefined())
                        return [new Tt(i.key,i.value,`Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
                    if (i.expressionContext === "property" && i.propertyType === "layout" && !wo(r))
                        return [new Tt(i.key,i.value,'"feature-state" data expressions are not supported with layout properties.')];
                    if (i.expressionContext === "filter" && !wo(r))
                        return [new Tt(i.key,i.value,'"feature-state" data expressions are not supported with filters.')];
                    if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
                        if (!pl(r, ["zoom", "feature-state"]))
                            return [new Tt(i.key,i.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                        if (i.expressionContext === "cluster-initial" && !dl(r))
                            return [new Tt(i.key,i.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
                    }
                    return []
                }
                function yl(i) {
                    const t = i.key
                      , r = i.value
                      , a = ii(r);
                    return a !== "string" ? [new Tt(t,r,`color expected, ${a} found`)] : yr.parse(String(r)) ? [] : [new Tt(t,r,`color expected, "${r}" found`)]
                }
                function Ga(i) {
                    const t = i.key
                      , r = i.value
                      , a = i.valueSpec
                      , c = [];
                    return Array.isArray(a.values) ? a.values.indexOf(Vi(r)) === -1 && c.push(new Tt(t,r,`expected one of [${a.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(a.values).indexOf(Vi(r)) === -1 && c.push(new Tt(t,r,`expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(r)} found`)),
                    c
                }
                function jc(i) {
                    return ml(Oa(i.value)) ? Ts(Ci({}, i, {
                        expressionContext: "filter",
                        valueSpec: {
                            value: "boolean"
                        }
                    })) : qh(i)
                }
                function qh(i) {
                    const t = i.value
                      , r = i.key;
                    if (ii(t) !== "array")
                        return [new Tt(r,t,`array expected, ${ii(t)} found`)];
                    const a = i.styleSpec;
                    let c, p = [];
                    if (t.length < 1)
                        return [new Tt(r,t,"filter array must have at least 1 element")];
                    switch (p = p.concat(Ga({
                        key: `${r}[0]`,
                        value: t[0],
                        valueSpec: a.filter_operator,
                        style: i.style,
                        styleSpec: i.styleSpec
                    })),
                    Vi(t[0])) {
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                        t.length >= 2 && Vi(t[1]) === "$type" && p.push(new Tt(r,t,`"$type" cannot be use with operator "${t[0]}"`));
                    case "==":
                    case "!=":
                        t.length !== 3 && p.push(new Tt(r,t,`filter array for operator "${t[0]}" must have 3 elements`));
                    case "in":
                    case "!in":
                        t.length >= 2 && (c = ii(t[1]),
                        c !== "string" && p.push(new Tt(`${r}[1]`,t[1],`string expected, ${c} found`)));
                        for (let f = 2; f < t.length; f++)
                            c = ii(t[f]),
                            Vi(t[1]) === "$type" ? p = p.concat(Ga({
                                key: `${r}[${f}]`,
                                value: t[f],
                                valueSpec: a.geometry_type,
                                style: i.style,
                                styleSpec: i.styleSpec
                            })) : c !== "string" && c !== "number" && c !== "boolean" && p.push(new Tt(`${r}[${f}]`,t[f],`string, number, or boolean expected, ${c} found`));
                        break;
                    case "any":
                    case "all":
                    case "none":
                        for (let f = 1; f < t.length; f++)
                            p = p.concat(qh({
                                key: `${r}[${f}]`,
                                value: t[f],
                                style: i.style,
                                styleSpec: i.styleSpec
                            }));
                        break;
                    case "has":
                    case "!has":
                        c = ii(t[1]),
                        t.length !== 2 ? p.push(new Tt(r,t,`filter array for "${t[0]}" operator must have 2 elements`)) : c !== "string" && p.push(new Tt(`${r}[1]`,t[1],`string expected, ${c} found`))
                    }
                    return p
                }
                function Vh(i, t) {
                    const r = i.key
                      , a = i.validateSpec
                      , c = i.style
                      , p = i.styleSpec
                      , f = i.value
                      , g = i.objectKey
                      , v = p[`${t}_${i.layerType}`];
                    if (!v)
                        return [];
                    const S = g.match(/^(.*)-transition$/);
                    if (t === "paint" && S && v[S[1]] && v[S[1]].transition)
                        return a({
                            key: r,
                            value: f,
                            valueSpec: p.transition,
                            style: c,
                            styleSpec: p
                        });
                    const I = i.valueSpec || v[g];
                    if (!I)
                        return [new Tt(r,f,`unknown property "${g}"`)];
                    let E;
                    if (ii(f) === "string" && rs(I) && !I.tokens && (E = /^{([^}]+)}$/.exec(f)))
                        return [new Tt(r,f,`"${g}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(E[1])} }\`.`)];
                    const R = [];
                    return i.layerType === "symbol" && (g === "text-field" && c && !c.glyphs && R.push(new Tt(r,f,'use of "text-field" requires a style "glyphs" property')),
                    g === "text-font" && To(Oa(f)) && Vi(f.type) === "identity" && R.push(new Tt(r,f,'"text-font" does not support identity functions'))),
                    R.concat(a({
                        key: i.key,
                        value: f,
                        valueSpec: I,
                        style: c,
                        styleSpec: p,
                        expressionContext: "property",
                        propertyType: t,
                        propertyKey: g
                    }))
                }
                function Uh(i) {
                    return Vh(i, "paint")
                }
                function Zh(i) {
                    return Vh(i, "layout")
                }
                function $h(i) {
                    let t = [];
                    const r = i.value
                      , a = i.key
                      , c = i.style
                      , p = i.styleSpec;
                    if (ii(r) !== "object")
                        return [new Tt(a,r,`object expected, ${ii(r)} found`)];
                    r.type || r.ref || t.push(new Tt(a,r,'either "type" or "ref" is required'));
                    let f = Vi(r.type);
                    const g = Vi(r.ref);
                    if (r.id) {
                        const v = Vi(r.id);
                        for (let S = 0; S < i.arrayIndex; S++) {
                            const I = c.layers[S];
                            Vi(I.id) === v && t.push(new Tt(a,r.id,`duplicate layer id "${r.id}", previously used at line ${I.id.__line__}`))
                        }
                    }
                    if ("ref"in r) {
                        let v;
                        ["type", "source", "source-layer", "filter", "layout"].forEach((S => {
                            S in r && t.push(new Tt(a,r[S],`"${S}" is prohibited for ref layers`))
                        }
                        )),
                        c.layers.forEach((S => {
                            Vi(S.id) === g && (v = S)
                        }
                        )),
                        v ? v.ref ? t.push(new Tt(a,r.ref,"ref cannot reference another ref layer")) : f = Vi(v.type) : t.push(new Tt(a,r.ref,`ref layer "${g}" not found`))
                    } else if (f !== "background")
                        if (r.source) {
                            const v = c.sources && c.sources[r.source]
                              , S = v && Vi(v.type);
                            v ? S === "vector" && f === "raster" ? t.push(new Tt(a,r.source,`layer "${r.id}" requires a raster source`)) : S !== "raster-dem" && f === "hillshade" || S !== "raster-dem" && f === "color-relief" ? t.push(new Tt(a,r.source,`layer "${r.id}" requires a raster-dem source`)) : S === "raster" && f !== "raster" ? t.push(new Tt(a,r.source,`layer "${r.id}" requires a vector source`)) : S !== "vector" || r["source-layer"] ? S === "raster-dem" && f !== "hillshade" && f !== "color-relief" ? t.push(new Tt(a,r.source,"raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : f !== "line" || !r.paint || !r.paint["line-gradient"] || S === "geojson" && v.lineMetrics || t.push(new Tt(a,r,`layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new Tt(a,r,`layer "${r.id}" must specify a "source-layer"`)) : t.push(new Tt(a,r.source,`source "${r.source}" not found`))
                        } else
                            t.push(new Tt(a,r,'missing required property "source"'));
                    return t = t.concat(ua({
                        key: a,
                        value: r,
                        valueSpec: p.layer,
                        style: i.style,
                        styleSpec: i.styleSpec,
                        validateSpec: i.validateSpec,
                        objectElementValidators: {
                            "*": () => [],
                            type: () => i.validateSpec({
                                key: `${a}.type`,
                                value: r.type,
                                valueSpec: p.layer.type,
                                style: i.style,
                                styleSpec: i.styleSpec,
                                validateSpec: i.validateSpec,
                                object: r,
                                objectKey: "type"
                            }),
                            filter: jc,
                            layout: v => ua({
                                layer: r,
                                key: v.key,
                                value: v.value,
                                style: v.style,
                                styleSpec: v.styleSpec,
                                validateSpec: v.validateSpec,
                                objectElementValidators: {
                                    "*": S => Zh(Ci({
                                        layerType: f
                                    }, S))
                                }
                            }),
                            paint: v => ua({
                                layer: r,
                                key: v.key,
                                value: v.value,
                                style: v.style,
                                styleSpec: v.styleSpec,
                                validateSpec: v.validateSpec,
                                objectElementValidators: {
                                    "*": S => Uh(Ci({
                                        layerType: f
                                    }, S))
                                }
                            })
                        }
                    })),
                    t
                }
                function xa(i) {
                    const t = i.value
                      , r = i.key
                      , a = ii(t);
                    return a !== "string" ? [new Tt(r,t,`string expected, ${a} found`)] : []
                }
                const js = {
                    promoteId: function({key: i, value: t}) {
                        if (ii(t) === "string")
                            return xa({
                                key: i,
                                value: t
                            });
                        {
                            const r = [];
                            for (const a in t)
                                r.push(...xa({
                                    key: `${i}.${a}`,
                                    value: t[a]
                                }));
                            return r
                        }
                    }
                };
                function Wn(i) {
                    const t = i.value
                      , r = i.key
                      , a = i.styleSpec
                      , c = i.style
                      , p = i.validateSpec;
                    if (!t.type)
                        return [new Tt(r,t,'"type" is required')];
                    const f = Vi(t.type);
                    let g;
                    switch (f) {
                    case "vector":
                    case "raster":
                        return g = ua({
                            key: r,
                            value: t,
                            valueSpec: a[`source_${f.replace("-", "_")}`],
                            style: i.style,
                            styleSpec: a,
                            objectElementValidators: js,
                            validateSpec: p
                        }),
                        g;
                    case "raster-dem":
                        return g = (function(v) {
                            var S;
                            const I = (S = v.sourceName) !== null && S !== void 0 ? S : ""
                              , E = v.value
                              , R = v.styleSpec
                              , N = R.source_raster_dem
                              , j = v.style;
                            let Z = [];
                            const Y = ii(E);
                            if (E === void 0)
                                return Z;
                            if (Y !== "object")
                                return Z.push(new Tt("source_raster_dem",E,`object expected, ${Y} found`)),
                                Z;
                            const ae = Vi(E.encoding) === "custom"
                              , ze = ["redFactor", "greenFactor", "blueFactor", "baseShift"]
                              , me = v.value.encoding ? `"${v.value.encoding}"` : "Default";
                            for (const be in E)
                                !ae && ze.includes(be) ? Z.push(new Tt(be,E[be],`In "${I}": "${be}" is only valid when "encoding" is set to "custom". ${me} encoding found`)) : N[be] ? Z = Z.concat(v.validateSpec({
                                    key: be,
                                    value: E[be],
                                    valueSpec: N[be],
                                    validateSpec: v.validateSpec,
                                    style: j,
                                    styleSpec: R
                                })) : Z.push(new Tt(be,E[be],`unknown property "${be}"`));
                            return Z
                        }
                        )({
                            sourceName: r,
                            value: t,
                            style: i.style,
                            styleSpec: a,
                            validateSpec: p
                        }),
                        g;
                    case "geojson":
                        if (g = ua({
                            key: r,
                            value: t,
                            valueSpec: a.source_geojson,
                            style: c,
                            styleSpec: a,
                            validateSpec: p,
                            objectElementValidators: js
                        }),
                        t.cluster)
                            for (const v in t.clusterProperties) {
                                const [S,I] = t.clusterProperties[v]
                                  , E = typeof S == "string" ? [S, ["accumulated"], ["get", v]] : S;
                                g.push(...Ts({
                                    key: `${r}.${v}.map`,
                                    value: I,
                                    expressionContext: "cluster-map"
                                })),
                                g.push(...Ts({
                                    key: `${r}.${v}.reduce`,
                                    value: E,
                                    expressionContext: "cluster-reduce"
                                }))
                            }
                        return g;
                    case "video":
                        return ua({
                            key: r,
                            value: t,
                            valueSpec: a.source_video,
                            style: c,
                            validateSpec: p,
                            styleSpec: a
                        });
                    case "image":
                        return ua({
                            key: r,
                            value: t,
                            valueSpec: a.source_image,
                            style: c,
                            validateSpec: p,
                            styleSpec: a
                        });
                    case "canvas":
                        return [new Tt(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
                    default:
                        return Ga({
                            key: `${r}.type`,
                            value: t.type,
                            valueSpec: {
                                values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                            }
                        })
                    }
                }
                function qs(i) {
                    const t = i.value
                      , r = i.styleSpec
                      , a = r.light
                      , c = i.style;
                    let p = [];
                    const f = ii(t);
                    if (t === void 0)
                        return p;
                    if (f !== "object")
                        return p = p.concat([new Tt("light",t,`object expected, ${f} found`)]),
                        p;
                    for (const g in t) {
                        const v = g.match(/^(.*)-transition$/);
                        p = p.concat(v && a[v[1]] && a[v[1]].transition ? i.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: r.transition,
                            validateSpec: i.validateSpec,
                            style: c,
                            styleSpec: r
                        }) : a[g] ? i.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: a[g],
                            validateSpec: i.validateSpec,
                            style: c,
                            styleSpec: r
                        }) : [new Tt(g,t[g],`unknown property "${g}"`)])
                    }
                    return p
                }
                function qc(i) {
                    const t = i.value
                      , r = i.styleSpec
                      , a = r.sky
                      , c = i.style
                      , p = ii(t);
                    if (t === void 0)
                        return [];
                    if (p !== "object")
                        return [new Tt("sky",t,`object expected, ${p} found`)];
                    let f = [];
                    for (const g in t)
                        f = f.concat(a[g] ? i.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: a[g],
                            style: c,
                            styleSpec: r
                        }) : [new Tt(g,t[g],`unknown property "${g}"`)]);
                    return f
                }
                function Gh(i) {
                    const t = i.value
                      , r = i.styleSpec
                      , a = r.terrain
                      , c = i.style;
                    let p = [];
                    const f = ii(t);
                    if (t === void 0)
                        return p;
                    if (f !== "object")
                        return p = p.concat([new Tt("terrain",t,`object expected, ${f} found`)]),
                        p;
                    for (const g in t)
                        p = p.concat(a[g] ? i.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: a[g],
                            validateSpec: i.validateSpec,
                            style: c,
                            styleSpec: r
                        }) : [new Tt(g,t[g],`unknown property "${g}"`)]);
                    return p
                }
                function Hh(i) {
                    let t = [];
                    const r = i.value
                      , a = i.key;
                    if (Array.isArray(r)) {
                        const c = []
                          , p = [];
                        for (const f in r)
                            r[f].id && c.includes(r[f].id) && t.push(new Tt(a,r,`all the sprites' ids must be unique, but ${r[f].id} is duplicated`)),
                            c.push(r[f].id),
                            r[f].url && p.includes(r[f].url) && t.push(new Tt(a,r,`all the sprites' URLs must be unique, but ${r[f].url} is duplicated`)),
                            p.push(r[f].url),
                            t = t.concat(ua({
                                key: `${a}[${f}]`,
                                value: r[f],
                                valueSpec: {
                                    id: {
                                        type: "string",
                                        required: !0
                                    },
                                    url: {
                                        type: "string",
                                        required: !0
                                    }
                                },
                                validateSpec: i.validateSpec
                            }));
                        return t
                    }
                    return xa({
                        key: a,
                        value: r
                    })
                }
                function Vs(i) {
                    return t = i.value,
                    t && t.constructor === Object ? [] : [new Tt(i.key,i.value,`object expected, ${ii(i.value)} found`)];
                    var t
                }
                const Vc = {
                    "*": () => [],
                    array: vl,
                    boolean: function(i) {
                        const t = i.value
                          , r = i.key
                          , a = ii(t);
                        return a !== "boolean" ? [new Tt(r,t,`boolean expected, ${a} found`)] : []
                    },
                    number: Ao,
                    color: yl,
                    constants: Nc,
                    enum: Ga,
                    filter: jc,
                    function: jh,
                    layer: $h,
                    object: ua,
                    source: Wn,
                    light: qs,
                    sky: qc,
                    terrain: Gh,
                    projection: function(i) {
                        const t = i.value
                          , r = i.styleSpec
                          , a = r.projection
                          , c = i.style
                          , p = ii(t);
                        if (t === void 0)
                            return [];
                        if (p !== "object")
                            return [new Tt("projection",t,`object expected, ${p} found`)];
                        let f = [];
                        for (const g in t)
                            f = f.concat(a[g] ? i.validateSpec({
                                key: g,
                                value: t[g],
                                valueSpec: a[g],
                                style: c,
                                styleSpec: r
                            }) : [new Tt(g,t[g],`unknown property "${g}"`)]);
                        return f
                    },
                    projectionDefinition: function(i) {
                        const t = i.key;
                        let r = i.value;
                        r = r instanceof String ? r.valueOf() : r;
                        const a = ii(r);
                        return a !== "array" || (function(c) {
                            return Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number"
                        }
                        )(r) || (function(c) {
                            return !!["interpolate", "step", "literal"].includes(c[0])
                        }
                        )(r) ? ["array", "string"].includes(a) ? [] : [new Tt(t,r,`projection expected, invalid type "${a}" found`)] : [new Tt(t,r,`projection expected, invalid array ${JSON.stringify(r)} found`)]
                    },
                    string: xa,
                    formatted: function(i) {
                        return xa(i).length === 0 ? [] : Ts(i)
                    },
                    resolvedImage: function(i) {
                        return xa(i).length === 0 ? [] : Ts(i)
                    },
                    padding: function(i) {
                        const t = i.key
                          , r = i.value;
                        if (ii(r) === "array") {
                            if (r.length < 1 || r.length > 4)
                                return [new Tt(t,r,`padding requires 1 to 4 values; ${r.length} values found`)];
                            const a = {
                                type: "number"
                            };
                            let c = [];
                            for (let p = 0; p < r.length; p++)
                                c = c.concat(i.validateSpec({
                                    key: `${t}[${p}]`,
                                    value: r[p],
                                    validateSpec: i.validateSpec,
                                    valueSpec: a
                                }));
                            return c
                        }
                        return Ao({
                            key: t,
                            value: r,
                            valueSpec: {}
                        })
                    },
                    numberArray: function(i) {
                        const t = i.key
                          , r = i.value;
                        if (ii(r) === "array") {
                            const a = {
                                type: "number"
                            };
                            if (r.length < 1)
                                return [new Tt(t,r,"array length at least 1 expected, length 0 found")];
                            let c = [];
                            for (let p = 0; p < r.length; p++)
                                c = c.concat(i.validateSpec({
                                    key: `${t}[${p}]`,
                                    value: r[p],
                                    validateSpec: i.validateSpec,
                                    valueSpec: a
                                }));
                            return c
                        }
                        return Ao({
                            key: t,
                            value: r,
                            valueSpec: {}
                        })
                    },
                    colorArray: function(i) {
                        const t = i.key
                          , r = i.value;
                        if (ii(r) === "array") {
                            if (r.length < 1)
                                return [new Tt(t,r,"array length at least 1 expected, length 0 found")];
                            let a = [];
                            for (let c = 0; c < r.length; c++)
                                a = a.concat(yl({
                                    key: `${t}[${c}]`,
                                    value: r[c]
                                }));
                            return a
                        }
                        return yl({
                            key: t,
                            value: r
                        })
                    },
                    variableAnchorOffsetCollection: function(i) {
                        const t = i.key
                          , r = i.value
                          , a = ii(r)
                          , c = i.styleSpec;
                        if (a !== "array" || r.length < 1 || r.length % 2 != 0)
                            return [new Tt(t,r,"variableAnchorOffsetCollection requires a non-empty array of even length")];
                        let p = [];
                        for (let f = 0; f < r.length; f += 2)
                            p = p.concat(Ga({
                                key: `${t}[${f}]`,
                                value: r[f],
                                valueSpec: c.layout_symbol["text-anchor"]
                            })),
                            p = p.concat(vl({
                                key: `${t}[${f + 1}]`,
                                value: r[f + 1],
                                valueSpec: {
                                    length: 2,
                                    value: "number"
                                },
                                validateSpec: i.validateSpec,
                                style: i.style,
                                styleSpec: c
                            }));
                        return p
                    },
                    sprite: Hh,
                    state: Vs
                };
                function Us(i) {
                    const t = i.value
                      , r = i.valueSpec
                      , a = i.styleSpec;
                    return i.validateSpec = Us,
                    r.expression && To(Vi(t)) ? jh(i) : r.expression && fl(Oa(t)) ? Ts(i) : r.type && Vc[r.type] ? Vc[r.type](i) : ua(Ci({}, i, {
                        valueSpec: r.type ? a[r.type] : r
                    }))
                }
                function Wh(i) {
                    const t = i.value
                      , r = i.key
                      , a = xa(i);
                    return a.length || (t.indexOf("{fontstack}") === -1 && a.push(new Tt(r,t,'"glyphs" url must include a "{fontstack}" token')),
                    t.indexOf("{range}") === -1 && a.push(new Tt(r,t,'"glyphs" url must include a "{range}" token'))),
                    a
                }
                function Xn(i, t=xe) {
                    let r = [];
                    return r = r.concat(Us({
                        key: "",
                        value: i,
                        valueSpec: t.$root,
                        styleSpec: t,
                        style: i,
                        validateSpec: Us,
                        objectElementValidators: {
                            glyphs: Wh,
                            "*": () => []
                        }
                    })),
                    i.constants && (r = r.concat(Nc({
                        key: "constants",
                        value: i.constants
                    }))),
                    Zs(r)
                }
                function ba(i) {
                    return function(t) {
                        return i({
                            ...t,
                            validateSpec: Us
                        })
                    }
                }
                function Zs(i) {
                    return [].concat(i).sort(( (t, r) => t.line - r.line))
                }
                function wa(i) {
                    return function(...t) {
                        return Zs(i.apply(this, t))
                    }
                }
                Xn.source = wa(ba(Wn)),
                Xn.sprite = wa(ba(Hh)),
                Xn.glyphs = wa(ba(Wh)),
                Xn.light = wa(ba(qs)),
                Xn.sky = wa(ba(qc)),
                Xn.terrain = wa(ba(Gh)),
                Xn.state = wa(ba(Vs)),
                Xn.layer = wa(ba($h)),
                Xn.filter = wa(ba(jc)),
                Xn.paintProperty = wa(ba(Uh)),
                Xn.layoutProperty = wa(ba(Zh));
                const $s = Xn
                  , _p = $s.light
                  , ko = $s.sky
                  , gp = $s.paintProperty
                  , vp = $s.layoutProperty;
                function Eo(i, t) {
                    let r = !1;
                    if (t && t.length)
                        for (const a of t)
                            i.fire(new Ye(new Error(a.message))),
                            r = !0;
                    return r
                }
                class zo {
                    constructor(t, r, a) {
                        const c = this.cells = [];
                        if (t instanceof ArrayBuffer) {
                            this.arrayBuffer = t;
                            const f = new Int32Array(this.arrayBuffer);
                            t = f[0],
                            this.d = (r = f[1]) + 2 * (a = f[2]);
                            for (let v = 0; v < this.d * this.d; v++) {
                                const S = f[3 + v]
                                  , I = f[3 + v + 1];
                                c.push(S === I ? null : f.subarray(S, I))
                            }
                            const g = f[3 + c.length + 1];
                            this.keys = f.subarray(f[3 + c.length], g),
                            this.bboxes = f.subarray(g),
                            this.insert = this._insertReadonly
                        } else {
                            this.d = r + 2 * a;
                            for (let f = 0; f < this.d * this.d; f++)
                                c.push([]);
                            this.keys = [],
                            this.bboxes = []
                        }
                        this.n = r,
                        this.extent = t,
                        this.padding = a,
                        this.scale = r / t,
                        this.uid = 0;
                        const p = a / r * t;
                        this.min = -p,
                        this.max = t + p
                    }
                    insert(t, r, a, c, p) {
                        this._forEachCell(r, a, c, p, this._insertCell, this.uid++, void 0, void 0),
                        this.keys.push(t),
                        this.bboxes.push(r),
                        this.bboxes.push(a),
                        this.bboxes.push(c),
                        this.bboxes.push(p)
                    }
                    _insertReadonly() {
                        throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
                    }
                    _insertCell(t, r, a, c, p, f) {
                        this.cells[p].push(f)
                    }
                    query(t, r, a, c, p) {
                        const f = this.min
                          , g = this.max;
                        if (t <= f && r <= f && g <= a && g <= c && !p)
                            return Array.prototype.slice.call(this.keys);
                        {
                            const v = [];
                            return this._forEachCell(t, r, a, c, this._queryCell, v, {}, p),
                            v
                        }
                    }
                    _queryCell(t, r, a, c, p, f, g, v) {
                        const S = this.cells[p];
                        if (S !== null) {
                            const I = this.keys
                              , E = this.bboxes;
                            for (let R = 0; R < S.length; R++) {
                                const N = S[R];
                                if (g[N] === void 0) {
                                    const j = 4 * N;
                                    (v ? v(E[j + 0], E[j + 1], E[j + 2], E[j + 3]) : t <= E[j + 2] && r <= E[j + 3] && a >= E[j + 0] && c >= E[j + 1]) ? (g[N] = !0,
                                    f.push(I[N])) : g[N] = !1
                                }
                            }
                        }
                    }
                    _forEachCell(t, r, a, c, p, f, g, v) {
                        const S = this._convertToCellCoord(t)
                          , I = this._convertToCellCoord(r)
                          , E = this._convertToCellCoord(a)
                          , R = this._convertToCellCoord(c);
                        for (let N = S; N <= E; N++)
                            for (let j = I; j <= R; j++) {
                                const Z = this.d * j + N;
                                if ((!v || v(this._convertFromCellCoord(N), this._convertFromCellCoord(j), this._convertFromCellCoord(N + 1), this._convertFromCellCoord(j + 1))) && p.call(this, t, r, a, c, Z, f, g, v))
                                    return
                            }
                    }
                    _convertFromCellCoord(t) {
                        return (t - this.padding) / this.scale
                    }
                    _convertToCellCoord(t) {
                        return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
                    }
                    toArrayBuffer() {
                        if (this.arrayBuffer)
                            return this.arrayBuffer;
                        const t = this.cells
                          , r = 3 + this.cells.length + 1 + 1;
                        let a = 0;
                        for (let f = 0; f < this.cells.length; f++)
                            a += this.cells[f].length;
                        const c = new Int32Array(r + a + this.keys.length + this.bboxes.length);
                        c[0] = this.extent,
                        c[1] = this.n,
                        c[2] = this.padding;
                        let p = r;
                        for (let f = 0; f < t.length; f++) {
                            const g = t[f];
                            c[3 + f] = p,
                            c.set(g, p),
                            p += g.length
                        }
                        return c[3 + t.length] = p,
                        c.set(this.keys, p),
                        p += this.keys.length,
                        c[3 + t.length + 1] = p,
                        c.set(this.bboxes, p),
                        p += this.bboxes.length,
                        c.buffer
                    }
                    static serialize(t, r) {
                        const a = t.toArrayBuffer();
                        return r && r.push(a),
                        {
                            buffer: a
                        }
                    }
                    static deserialize(t) {
                        return new zo(t.buffer)
                    }
                }
                const Ta = {};
                function Kt(i, t, r={}) {
                    if (Ta[i])
                        throw new Error(`${i} is already registered.`);
                    Object.defineProperty(t, "_classRegistryKey", {
                        value: i,
                        writeable: !1
                    }),
                    Ta[i] = {
                        klass: t,
                        omit: r.omit || [],
                        shallow: r.shallow || []
                    }
                }
                Kt("Object", Object),
                Kt("Set", Set),
                Kt("TransferableGridIndex", zo),
                Kt("Color", yr),
                Kt("Error", Error),
                Kt("AJAXError", K),
                Kt("ResolvedImage", Nn),
                Kt("StylePropertyFunction", Po),
                Kt("StyleExpression", Lc, {
                    omit: ["_evaluator"]
                }),
                Kt("ZoomDependentExpression", Dc),
                Kt("ZoomConstantExpression", So),
                Kt("CompoundExpression", ca, {
                    omit: ["_evaluate"]
                });
                for (const i in Os)
                    Os[i]._classRegistryKey || Kt(`Expression_${i}`, Os[i]);
                function Uc(i) {
                    return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer")
                }
                function xl(i) {
                    return i.$name || i.constructor._classRegistryKey
                }
                function Zc(i) {
                    return !(function(t) {
                        if (t === null || typeof t != "object")
                            return !1;
                        const r = xl(t);
                        return !(!r || r === "Object")
                    }
                    )(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || Uc(i) || ar(i) || ArrayBuffer.isView(i) || i instanceof ImageData)
                }
                function Gs(i, t) {
                    if (Zc(i))
                        return (Uc(i) || ar(i)) && t && t.push(i),
                        ArrayBuffer.isView(i) && t && t.push(i.buffer),
                        i instanceof ImageData && t && t.push(i.data.buffer),
                        i;
                    if (Array.isArray(i)) {
                        const p = [];
                        for (const f of i)
                            p.push(Gs(f, t));
                        return p
                    }
                    if (typeof i != "object")
                        throw new Error("can't serialize object of type " + typeof i);
                    const r = xl(i);
                    if (!r)
                        throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
                    if (!Ta[r])
                        throw new Error(`${r} is not registered.`);
                    const {klass: a} = Ta[r]
                      , c = a.serialize ? a.serialize(i, t) : {};
                    if (a.serialize) {
                        if (t && c === t[t.length - 1])
                            throw new Error("statically serialized object won't survive transfer of $name property")
                    } else {
                        for (const p in i) {
                            if (!i.hasOwnProperty(p) || Ta[r].omit.indexOf(p) >= 0)
                                continue;
                            const f = i[p];
                            c[p] = Ta[r].shallow.indexOf(p) >= 0 ? f : Gs(f, t)
                        }
                        i instanceof Error && (c.message = i.message)
                    }
                    if (c.$name)
                        throw new Error("$name property is reserved for worker serialization logic.");
                    return r !== "Object" && (c.$name = r),
                    c
                }
                function Cs(i) {
                    if (Zc(i))
                        return i;
                    if (Array.isArray(i))
                        return i.map(Cs);
                    if (typeof i != "object")
                        throw new Error("can't deserialize object of type " + typeof i);
                    const t = xl(i) || "Object";
                    if (!Ta[t])
                        throw new Error(`can't deserialize unregistered class ${t}`);
                    const {klass: r} = Ta[t];
                    if (!r)
                        throw new Error(`can't deserialize unregistered class ${t}`);
                    if (r.deserialize)
                        return r.deserialize(i);
                    const a = Object.create(r.prototype);
                    for (const c of Object.keys(i)) {
                        if (c === "$name")
                            continue;
                        const p = i[c];
                        a[c] = Ta[t].shallow.indexOf(c) >= 0 ? p : Cs(p)
                    }
                    return a
                }
                class bl {
                    constructor() {
                        this.first = !0
                    }
                    update(t, r) {
                        const a = Math.floor(t);
                        return this.first ? (this.first = !1,
                        this.lastIntegerZoom = a,
                        this.lastIntegerZoomTime = 0,
                        this.lastZoom = t,
                        this.lastFloorZoom = a,
                        !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1,
                        this.lastIntegerZoomTime = r) : this.lastFloorZoom < a && (this.lastIntegerZoom = a,
                        this.lastIntegerZoomTime = r),
                        t !== this.lastZoom && (this.lastZoom = t,
                        this.lastFloorZoom = a,
                        !0))
                    }
                }
                const si = {
                    "Latin-1 Supplement": i => i >= 128 && i <= 255,
                    "Hangul Jamo": i => i >= 4352 && i <= 4607,
                    Khmer: i => i >= 6016 && i <= 6143,
                    "General Punctuation": i => i >= 8192 && i <= 8303,
                    "Letterlike Symbols": i => i >= 8448 && i <= 8527,
                    "Number Forms": i => i >= 8528 && i <= 8591,
                    "Miscellaneous Technical": i => i >= 8960 && i <= 9215,
                    "Control Pictures": i => i >= 9216 && i <= 9279,
                    "Optical Character Recognition": i => i >= 9280 && i <= 9311,
                    "Enclosed Alphanumerics": i => i >= 9312 && i <= 9471,
                    "Geometric Shapes": i => i >= 9632 && i <= 9727,
                    "Miscellaneous Symbols": i => i >= 9728 && i <= 9983,
                    "Miscellaneous Symbols and Arrows": i => i >= 11008 && i <= 11263,
                    "Ideographic Description Characters": i => i >= 12272 && i <= 12287,
                    "CJK Symbols and Punctuation": i => i >= 12288 && i <= 12351,
                    Hiragana: i => i >= 12352 && i <= 12447,
                    Katakana: i => i >= 12448 && i <= 12543,
                    Kanbun: i => i >= 12688 && i <= 12703,
                    "CJK Strokes": i => i >= 12736 && i <= 12783,
                    "Enclosed CJK Letters and Months": i => i >= 12800 && i <= 13055,
                    "CJK Compatibility": i => i >= 13056 && i <= 13311,
                    "Yijing Hexagram Symbols": i => i >= 19904 && i <= 19967,
                    "CJK Unified Ideographs": i => i >= 19968 && i <= 40959,
                    "Hangul Syllables": i => i >= 44032 && i <= 55215,
                    "Private Use Area": i => i >= 57344 && i <= 63743,
                    "Vertical Forms": i => i >= 65040 && i <= 65055,
                    "CJK Compatibility Forms": i => i >= 65072 && i <= 65103,
                    "Small Form Variants": i => i >= 65104 && i <= 65135,
                    "Halfwidth and Fullwidth Forms": i => i >= 65280 && i <= 65519
                };
                function wl(i) {
                    for (const t of i)
                        if (Gc(t.charCodeAt(0)))
                            return !0;
                    return !1
                }
                function yp(i) {
                    for (const t of i)
                        if (!Xh(t.charCodeAt(0)))
                            return !1;
                    return !0
                }
                function Tl(i) {
                    const t = i.map((r => {
                        try {
                            return new RegExp(`\\p{sc=${r}}`,"u").source
                        } catch {
                            return null
                        }
                    }
                    )).filter((r => r));
                    return new RegExp(t.join("|"),"u")
                }
                const xp = Tl(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
                function Xh(i) {
                    return !xp.test(String.fromCodePoint(i))
                }
                const $c = Tl(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
                function Gc(i) {
                    return !(i !== 746 && i !== 747 && (i < 4352 || !(si["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || si["CJK Compatibility"](i) || si["CJK Strokes"](i) || !(!si["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || si["Enclosed CJK Letters and Months"](i) || si["Ideographic Description Characters"](i) || si.Kanbun(i) || si.Katakana(i) && i !== 12540 || !(!si["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!si["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || si["Vertical Forms"](i) || si["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}","u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}","u").test(String.fromCodePoint(i)) || $c.test(String.fromCodePoint(i)))))
                }
                function Kh(i) {
                    return !(Gc(i) || (function(t) {
                        return !!(si["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || si["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || si["Letterlike Symbols"](t) || si["Number Forms"](t) || si["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || si["Control Pictures"](t) && t !== 9251 || si["Optical Character Recognition"](t) || si["Enclosed Alphanumerics"](t) || si["Geometric Shapes"](t) || si["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || si["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || si["CJK Symbols and Punctuation"](t) || si.Katakana(t) || si["Private Use Area"](t) || si["CJK Compatibility Forms"](t) || si["Small Form Variants"](t) || si["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
                    }
                    )(i))
                }
                const Yh = Tl(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
                function Hc(i) {
                    return Yh.test(String.fromCodePoint(i))
                }
                function Jh(i, t) {
                    return !(!t && Hc(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || si.Khmer(i))
                }
                function Qh(i) {
                    for (const t of i)
                        if (Hc(t.charCodeAt(0)))
                            return !0;
                    return !1
                }
                const Ca = new class {
                    constructor() {
                        this.TIMEOUT = 5e3,
                        this.applyArabicShaping = null,
                        this.processBidirectionalText = null,
                        this.processStyledBidirectionalText = null,
                        this.pluginStatus = "unavailable",
                        this.pluginURL = null,
                        this.loadScriptResolve = () => {}
                    }
                    setState(i) {
                        this.pluginStatus = i.pluginStatus,
                        this.pluginURL = i.pluginURL
                    }
                    getState() {
                        return {
                            pluginStatus: this.pluginStatus,
                            pluginURL: this.pluginURL
                        }
                    }
                    setMethods(i) {
                        if (Ca.isParsed())
                            throw new Error("RTL text plugin already registered.");
                        this.applyArabicShaping = i.applyArabicShaping,
                        this.processBidirectionalText = i.processBidirectionalText,
                        this.processStyledBidirectionalText = i.processStyledBidirectionalText,
                        this.loadScriptResolve()
                    }
                    isParsed() {
                        return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
                    }
                    getRTLTextPluginStatus() {
                        return this.pluginStatus
                    }
                    syncState(i, t) {
                        return o(this, void 0, void 0, (function*() {
                            if (this.isParsed())
                                return this.getState();
                            if (i.pluginStatus !== "loading")
                                return this.setState(i),
                                i;
                            const r = i.pluginURL
                              , a = new Promise((p => {
                                this.loadScriptResolve = p
                            }
                            ));
                            t(r);
                            const c = new Promise((p => setTimeout(( () => p()), this.TIMEOUT)));
                            if (yield Promise.race([a, c]),
                            this.isParsed()) {
                                const p = {
                                    pluginStatus: "loaded",
                                    pluginURL: r
                                };
                                return this.setState(p),
                                p
                            }
                            throw this.setState({
                                pluginStatus: "error",
                                pluginURL: ""
                            }),
                            new Error(`RTL Text Plugin failed to import scripts from ${r}`)
                        }
                        ))
                    }
                }
                ;
                class Oi {
                    constructor(t, r) {
                        this.zoom = t,
                        r ? (this.now = r.now || 0,
                        this.fadeDuration = r.fadeDuration || 0,
                        this.zoomHistory = r.zoomHistory || new bl,
                        this.transition = r.transition || {},
                        this.globalState = r.globalState || {}) : (this.now = 0,
                        this.fadeDuration = 0,
                        this.zoomHistory = new bl,
                        this.transition = {},
                        this.globalState = {})
                    }
                    isSupportedScript(t) {
                        return (function(r, a) {
                            for (const c of r)
                                if (!Jh(c.charCodeAt(0), a))
                                    return !1;
                            return !0
                        }
                        )(t, Ca.getRTLTextPluginStatus() === "loaded")
                    }
                    crossFadingFactor() {
                        return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
                    }
                    getCrossfadeParameters() {
                        const t = this.zoom
                          , r = t - Math.floor(t)
                          , a = this.crossFadingFactor();
                        return t > this.zoomHistory.lastIntegerZoom ? {
                            fromScale: 2,
                            toScale: 1,
                            t: r + (1 - r) * a
                        } : {
                            fromScale: .5,
                            toScale: 1,
                            t: 1 - (1 - a) * r
                        }
                    }
                }
                class Hs {
                    constructor(t, r) {
                        this.property = t,
                        this.value = r,
                        this.expression = (function(a, c) {
                            if (To(a))
                                return new Po(a,c);
                            if (fl(a)) {
                                const p = Fh(a, c);
                                if (p.result === "error")
                                    throw new Error(p.value.map((f => `${f.key}: ${f.message}`)).join(", "));
                                return p.value
                            }
                            {
                                let p = a;
                                return c.type === "color" && typeof a == "string" ? p = yr.parse(a) : c.type !== "padding" || typeof a != "number" && !Array.isArray(a) ? c.type !== "numberArray" || typeof a != "number" && !Array.isArray(a) ? c.type !== "colorArray" || typeof a != "string" && !Array.isArray(a) ? c.type === "variableAnchorOffsetCollection" && Array.isArray(a) ? p = un.parse(a) : c.type === "projectionDefinition" && typeof a == "string" && (p = hn.parse(a)) : p = Ni.parse(a) : p = cn.parse(a) : p = Ki.parse(a),
                                {
                                    globalStateRefs: new Set,
                                    kind: "constant",
                                    evaluate: () => p
                                }
                            }
                        }
                        )(r === void 0 ? t.specification.default : r, t.specification)
                    }
                    isDataDriven() {
                        return this.expression.kind === "source" || this.expression.kind === "composite"
                    }
                    getGlobalStateRefs() {
                        return this.expression.globalStateRefs || new Set
                    }
                    possiblyEvaluate(t, r, a) {
                        return this.property.possiblyEvaluate(this, t, r, a)
                    }
                }
                class Wc {
                    constructor(t) {
                        this.property = t,
                        this.value = new Hs(t,void 0)
                    }
                    transitioned(t, r) {
                        return new Xc(this.property,this.value,r,pt({}, t.transition, this.transition),t.now)
                    }
                    untransitioned() {
                        return new Xc(this.property,this.value,null,{},0)
                    }
                }
                class ed {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultTransitionablePropertyValues)
                    }
                    getValue(t) {
                        return wt(this._values[t].value.value)
                    }
                    setValue(t, r) {
                        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Wc(this._values[t].property)),
                        this._values[t].value = new Hs(this._values[t].property,r === null ? void 0 : wt(r))
                    }
                    getTransition(t) {
                        return wt(this._values[t].transition)
                    }
                    setTransition(t, r) {
                        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Wc(this._values[t].property)),
                        this._values[t].transition = wt(r) || void 0
                    }
                    serialize() {
                        const t = {};
                        for (const r of Object.keys(this._values)) {
                            const a = this.getValue(r);
                            a !== void 0 && (t[r] = a);
                            const c = this.getTransition(r);
                            c !== void 0 && (t[`${r}-transition`] = c)
                        }
                        return t
                    }
                    transitioned(t, r) {
                        const a = new Kc(this._properties);
                        for (const c of Object.keys(this._values))
                            a._values[c] = this._values[c].transitioned(t, r._values[c]);
                        return a
                    }
                    untransitioned() {
                        const t = new Kc(this._properties);
                        for (const r of Object.keys(this._values))
                            t._values[r] = this._values[r].untransitioned();
                        return t
                    }
                }
                class Xc {
                    constructor(t, r, a, c, p) {
                        this.property = t,
                        this.value = r,
                        this.begin = p + c.delay || 0,
                        this.end = this.begin + c.duration || 0,
                        t.specification.transition && (c.delay || c.duration) && (this.prior = a)
                    }
                    possiblyEvaluate(t, r, a) {
                        const c = t.now || 0
                          , p = this.value.possiblyEvaluate(t, r, a)
                          , f = this.prior;
                        if (f) {
                            if (c > this.end)
                                return this.prior = null,
                                p;
                            if (this.value.isDataDriven())
                                return this.prior = null,
                                p;
                            if (c < this.begin)
                                return f.possiblyEvaluate(t, r, a);
                            {
                                const g = (c - this.begin) / (this.end - this.begin);
                                return this.property.interpolate(f.possiblyEvaluate(t, r, a), p, We(g))
                            }
                        }
                        return p
                    }
                }
                class Kc {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultTransitioningPropertyValues)
                    }
                    possiblyEvaluate(t, r, a) {
                        const c = new Cl(this._properties);
                        for (const p of Object.keys(this._values))
                            c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
                        return c
                    }
                    hasTransition() {
                        for (const t of Object.keys(this._values))
                            if (this._values[t].prior)
                                return !0;
                        return !1
                    }
                }
                class td {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultPropertyValues)
                    }
                    hasValue(t) {
                        return this._values[t].value !== void 0
                    }
                    getValue(t) {
                        return wt(this._values[t].value)
                    }
                    setValue(t, r) {
                        this._values[t] = new Hs(this._values[t].property,r === null ? void 0 : wt(r))
                    }
                    serialize() {
                        const t = {};
                        for (const r of Object.keys(this._values)) {
                            const a = this.getValue(r);
                            a !== void 0 && (t[r] = a)
                        }
                        return t
                    }
                    possiblyEvaluate(t, r, a) {
                        const c = new Cl(this._properties);
                        for (const p of Object.keys(this._values))
                            c._values[p] = this._values[p].possiblyEvaluate(t, r, a);
                        return c
                    }
                }
                class Na {
                    constructor(t, r, a) {
                        this.property = t,
                        this.value = r,
                        this.parameters = a
                    }
                    isConstant() {
                        return this.value.kind === "constant"
                    }
                    constantOr(t) {
                        return this.value.kind === "constant" ? this.value.value : t
                    }
                    evaluate(t, r, a, c) {
                        return this.property.evaluate(this.value, this.parameters, t, r, a, c)
                    }
                }
                class Cl {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultPossiblyEvaluatedValues)
                    }
                    get(t) {
                        return this._values[t]
                    }
                }
                class hr {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, r) {
                        if (t.isDataDriven())
                            throw new Error("Value should not be data driven");
                        return t.expression.evaluate(r)
                    }
                    interpolate(t, r, a) {
                        const c = Fa[this.specification.type];
                        return c ? c(t, r, a) : t
                    }
                }
                class Rr {
                    constructor(t, r) {
                        this.specification = t,
                        this.overrides = r
                    }
                    possiblyEvaluate(t, r, a, c) {
                        return new Na(this,t.expression.kind === "constant" || t.expression.kind === "camera" ? {
                            kind: "constant",
                            value: t.expression.evaluate(r, null, {}, a, c)
                        } : t.expression,r)
                    }
                    interpolate(t, r, a) {
                        if (t.value.kind !== "constant" || r.value.kind !== "constant")
                            return t;
                        if (t.value.value === void 0 || r.value.value === void 0)
                            return new Na(this,{
                                kind: "constant",
                                value: void 0
                            },t.parameters);
                        const c = Fa[this.specification.type];
                        if (c) {
                            const p = c(t.value.value, r.value.value, a);
                            return new Na(this,{
                                kind: "constant",
                                value: p
                            },t.parameters)
                        }
                        return t
                    }
                    evaluate(t, r, a, c, p, f) {
                        return t.kind === "constant" ? t.value : t.evaluate(r, a, c, p, f)
                    }
                }
                class Sl extends Rr {
                    possiblyEvaluate(t, r, a, c) {
                        if (t.value === void 0)
                            return new Na(this,{
                                kind: "constant",
                                value: void 0
                            },r);
                        if (t.expression.kind === "constant") {
                            const p = t.expression.evaluate(r, null, {}, a, c)
                              , f = t.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p
                              , g = this._calculate(f, f, f, r);
                            return new Na(this,{
                                kind: "constant",
                                value: g
                            },r)
                        }
                        if (t.expression.kind === "camera") {
                            const p = this._calculate(t.expression.evaluate({
                                zoom: r.zoom - 1
                            }), t.expression.evaluate({
                                zoom: r.zoom
                            }), t.expression.evaluate({
                                zoom: r.zoom + 1
                            }), r);
                            return new Na(this,{
                                kind: "constant",
                                value: p
                            },r)
                        }
                        return new Na(this,t.expression,r)
                    }
                    evaluate(t, r, a, c, p, f) {
                        if (t.kind === "source") {
                            const g = t.evaluate(r, a, c, p, f);
                            return this._calculate(g, g, g, r)
                        }
                        return t.kind === "composite" ? this._calculate(t.evaluate({
                            zoom: Math.floor(r.zoom) - 1
                        }, a, c), t.evaluate({
                            zoom: Math.floor(r.zoom)
                        }, a, c), t.evaluate({
                            zoom: Math.floor(r.zoom) + 1
                        }, a, c), r) : t.value
                    }
                    _calculate(t, r, a, c) {
                        return c.zoom > c.zoomHistory.lastIntegerZoom ? {
                            from: t,
                            to: r
                        } : {
                            from: a,
                            to: r
                        }
                    }
                    interpolate(t) {
                        return t
                    }
                }
                class ns {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, r, a, c) {
                        if (t.value !== void 0) {
                            if (t.expression.kind === "constant") {
                                const p = t.expression.evaluate(r, null, {}, a, c);
                                return this._calculate(p, p, p, r)
                            }
                            return this._calculate(t.expression.evaluate(new Oi(Math.floor(r.zoom - 1),r)), t.expression.evaluate(new Oi(Math.floor(r.zoom),r)), t.expression.evaluate(new Oi(Math.floor(r.zoom + 1),r)), r)
                        }
                    }
                    _calculate(t, r, a, c) {
                        return c.zoom > c.zoomHistory.lastIntegerZoom ? {
                            from: t,
                            to: r
                        } : {
                            from: a,
                            to: r
                        }
                    }
                    interpolate(t) {
                        return t
                    }
                }
                class Pl {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, r, a, c) {
                        return !!t.expression.evaluate(r, null, {}, a, c)
                    }
                    interpolate() {
                        return !1
                    }
                }
                class jn {
                    constructor(t) {
                        this.properties = t,
                        this.defaultPropertyValues = {},
                        this.defaultTransitionablePropertyValues = {},
                        this.defaultTransitioningPropertyValues = {},
                        this.defaultPossiblyEvaluatedValues = {},
                        this.overridableProperties = [];
                        for (const r in t) {
                            const a = t[r];
                            a.specification.overridable && this.overridableProperties.push(r);
                            const c = this.defaultPropertyValues[r] = new Hs(a,void 0)
                              , p = this.defaultTransitionablePropertyValues[r] = new Wc(a);
                            this.defaultTransitioningPropertyValues[r] = p.untransitioned(),
                            this.defaultPossiblyEvaluatedValues[r] = c.possiblyEvaluate({})
                        }
                    }
                }
                Kt("DataDrivenProperty", Rr),
                Kt("DataConstantProperty", hr),
                Kt("CrossFadedDataDrivenProperty", Sl),
                Kt("CrossFadedProperty", ns),
                Kt("ColorRampProperty", Pl);
                const rd = "-transition";
                class ha extends Ot {
                    constructor(t, r) {
                        if (super(),
                        this.id = t.id,
                        this.type = t.type,
                        this._featureFilter = {
                            filter: () => !0,
                            needGeometry: !1,
                            getGlobalStateRefs: () => new Set
                        },
                        t.type !== "custom" && (this.metadata = t.metadata,
                        this.minzoom = t.minzoom,
                        this.maxzoom = t.maxzoom,
                        t.type !== "background" && (this.source = t.source,
                        this.sourceLayer = t["source-layer"],
                        this.filter = t.filter,
                        this._featureFilter = bs(t.filter)),
                        r.layout && (this._unevaluatedLayout = new td(r.layout)),
                        r.paint)) {
                            this._transitionablePaint = new ed(r.paint);
                            for (const a in t.paint)
                                this.setPaintProperty(a, t.paint[a], {
                                    validate: !1
                                });
                            for (const a in t.layout)
                                this.setLayoutProperty(a, t.layout[a], {
                                    validate: !1
                                });
                            this._transitioningPaint = this._transitionablePaint.untransitioned(),
                            this.paint = new Cl(r.paint)
                        }
                    }
                    setFilter(t) {
                        this.filter = t,
                        this._featureFilter = bs(t)
                    }
                    getCrossfadeParameters() {
                        return this._crossfadeParameters
                    }
                    getLayoutProperty(t) {
                        return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
                    }
                    getLayoutAffectingGlobalStateRefs() {
                        const t = new Set;
                        if (this._unevaluatedLayout)
                            for (const r in this._unevaluatedLayout._values) {
                                const a = this._unevaluatedLayout._values[r];
                                for (const c of a.getGlobalStateRefs())
                                    t.add(c)
                            }
                        for (const r of this._featureFilter.getGlobalStateRefs())
                            t.add(r);
                        return t
                    }
                    setLayoutProperty(t, r, a={}) {
                        r != null && this._validate(vp, `layers.${this.id}.layout.${t}`, t, r, a) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r)
                    }
                    getPaintProperty(t) {
                        return t.endsWith(rd) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
                    }
                    setPaintProperty(t, r, a={}) {
                        if (r != null && this._validate(gp, `layers.${this.id}.paint.${t}`, t, r, a))
                            return !1;
                        if (t.endsWith(rd))
                            return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0),
                            !1;
                        {
                            const c = this._transitionablePaint._values[t]
                              , p = c.property.specification["property-type"] === "cross-faded-data-driven"
                              , f = c.value.isDataDriven()
                              , g = c.value;
                            this._transitionablePaint.setValue(t, r),
                            this._handleSpecialPaintPropertyUpdate(t);
                            const v = this._transitionablePaint._values[t].value;
                            return v.isDataDriven() || f || p || this._handleOverridablePaintPropertyUpdate(t, g, v)
                        }
                    }
                    _handleSpecialPaintPropertyUpdate(t) {}
                    _handleOverridablePaintPropertyUpdate(t, r, a) {
                        return !1
                    }
                    isHidden(t) {
                        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
                    }
                    updateTransitions(t) {
                        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
                    }
                    hasTransition() {
                        return this._transitioningPaint.hasTransition()
                    }
                    recalculate(t, r) {
                        t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()),
                        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)),
                        this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r)
                    }
                    serialize() {
                        const t = {
                            id: this.id,
                            type: this.type,
                            source: this.source,
                            "source-layer": this.sourceLayer,
                            metadata: this.metadata,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            filter: this.filter,
                            layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                            paint: this._transitionablePaint && this._transitionablePaint.serialize()
                        };
                        return this.visibility && (t.layout = t.layout || {},
                        t.layout.visibility = this.visibility),
                        bt(t, ( (r, a) => !(r === void 0 || a === "layout" && !Object.keys(r).length || a === "paint" && !Object.keys(r).length)))
                    }
                    _validate(t, r, a, c, p={}) {
                        return (!p || p.validate !== !1) && Eo(this, t.call($s, {
                            key: r,
                            layerType: this.type,
                            objectKey: a,
                            value: c,
                            styleSpec: xe,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            }
                        }))
                    }
                    is3D() {
                        return !1
                    }
                    isTileClipped() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return !1
                    }
                    resize() {}
                    isStateDependent() {
                        for (const t in this.paint._values) {
                            const r = this.paint.get(t);
                            if (r instanceof Na && rs(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent)
                                return !0
                        }
                        return !1
                    }
                }
                const bp = {
                    Int8: Int8Array,
                    Uint8: Uint8Array,
                    Int16: Int16Array,
                    Uint16: Uint16Array,
                    Int32: Int32Array,
                    Uint32: Uint32Array,
                    Float32: Float32Array
                };
                class Lo {
                    constructor(t, r) {
                        this._structArray = t,
                        this._pos1 = r * this.size,
                        this._pos2 = this._pos1 / 2,
                        this._pos4 = this._pos1 / 4,
                        this._pos8 = this._pos1 / 8
                    }
                }
                class Ai {
                    constructor() {
                        this.isTransferred = !1,
                        this.capacity = -1,
                        this.resize(0)
                    }
                    static serialize(t, r) {
                        return t._trim(),
                        r && (t.isTransferred = !0,
                        r.push(t.arrayBuffer)),
                        {
                            length: t.length,
                            arrayBuffer: t.arrayBuffer
                        }
                    }
                    static deserialize(t) {
                        const r = Object.create(this.prototype);
                        return r.arrayBuffer = t.arrayBuffer,
                        r.length = t.length,
                        r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement,
                        r._refreshViews(),
                        r
                    }
                    _trim() {
                        this.length !== this.capacity && (this.capacity = this.length,
                        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement),
                        this._refreshViews())
                    }
                    clear() {
                        this.length = 0
                    }
                    resize(t) {
                        this.reserve(t),
                        this.length = t
                    }
                    reserve(t) {
                        if (t > this.capacity) {
                            this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128),
                            this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                            const r = this.uint8;
                            this._refreshViews(),
                            r && this.uint8.set(r)
                        }
                    }
                    _refreshViews() {
                        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
                    }
                }
                function Hi(i, t=1) {
                    let r = 0
                      , a = 0;
                    return {
                        members: i.map((c => {
                            const p = bp[c.type].BYTES_PER_ELEMENT
                              , f = r = Il(r, Math.max(t, p))
                              , g = c.components || 1;
                            return a = Math.max(a, p),
                            r += p * g,
                            {
                                name: c.name,
                                type: c.type,
                                components: g,
                                offset: f
                            }
                        }
                        )),
                        size: Il(r, Math.max(a, t)),
                        alignment: t
                    }
                }
                function Il(i, t) {
                    return Math.ceil(i / t) * t
                }
                class Ws extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, t, r)
                    }
                    emplace(t, r, a) {
                        const c = 2 * t;
                        return this.int16[c + 0] = r,
                        this.int16[c + 1] = a,
                        t
                    }
                }
                Ws.prototype.bytesPerElement = 4,
                Kt("StructArrayLayout2i4", Ws);
                class Xs extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, r, a)
                    }
                    emplace(t, r, a, c) {
                        const p = 3 * t;
                        return this.int16[p + 0] = r,
                        this.int16[p + 1] = a,
                        this.int16[p + 2] = c,
                        t
                    }
                }
                Xs.prototype.bytesPerElement = 6,
                Kt("StructArrayLayout3i6", Xs);
                class Yc extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, t, r, a, c)
                    }
                    emplace(t, r, a, c, p) {
                        const f = 4 * t;
                        return this.int16[f + 0] = r,
                        this.int16[f + 1] = a,
                        this.int16[f + 2] = c,
                        this.int16[f + 3] = p,
                        t
                    }
                }
                Yc.prototype.bytesPerElement = 8,
                Kt("StructArrayLayout4i8", Yc);
                class Ks extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p, f) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, r, a, c, p, f)
                    }
                    emplace(t, r, a, c, p, f, g) {
                        const v = 6 * t;
                        return this.int16[v + 0] = r,
                        this.int16[v + 1] = a,
                        this.int16[v + 2] = c,
                        this.int16[v + 3] = p,
                        this.int16[v + 4] = f,
                        this.int16[v + 5] = g,
                        t
                    }
                }
                Ks.prototype.bytesPerElement = 12,
                Kt("StructArrayLayout2i4i12", Ks);
                class Ss extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p, f) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, r, a, c, p, f)
                    }
                    emplace(t, r, a, c, p, f, g) {
                        const v = 4 * t
                          , S = 8 * t;
                        return this.int16[v + 0] = r,
                        this.int16[v + 1] = a,
                        this.uint8[S + 4] = c,
                        this.uint8[S + 5] = p,
                        this.uint8[S + 6] = f,
                        this.uint8[S + 7] = g,
                        t
                    }
                }
                Ss.prototype.bytesPerElement = 8,
                Kt("StructArrayLayout2i4ub8", Ss);
                class Do extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, t, r)
                    }
                    emplace(t, r, a) {
                        const c = 2 * t;
                        return this.float32[c + 0] = r,
                        this.float32[c + 1] = a,
                        t
                    }
                }
                Do.prototype.bytesPerElement = 8,
                Kt("StructArrayLayout2f8", Do);
                class Ml extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p, f, g, v, S, I) {
                        const E = this.length;
                        return this.resize(E + 1),
                        this.emplace(E, t, r, a, c, p, f, g, v, S, I)
                    }
                    emplace(t, r, a, c, p, f, g, v, S, I, E) {
                        const R = 10 * t;
                        return this.uint16[R + 0] = r,
                        this.uint16[R + 1] = a,
                        this.uint16[R + 2] = c,
                        this.uint16[R + 3] = p,
                        this.uint16[R + 4] = f,
                        this.uint16[R + 5] = g,
                        this.uint16[R + 6] = v,
                        this.uint16[R + 7] = S,
                        this.uint16[R + 8] = I,
                        this.uint16[R + 9] = E,
                        t
                    }
                }
                Ml.prototype.bytesPerElement = 20,
                Kt("StructArrayLayout10ui20", Ml);
                class Ps extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p, f, g, v, S, I, E, R) {
                        const N = this.length;
                        return this.resize(N + 1),
                        this.emplace(N, t, r, a, c, p, f, g, v, S, I, E, R)
                    }
                    emplace(t, r, a, c, p, f, g, v, S, I, E, R, N) {
                        const j = 12 * t;
                        return this.int16[j + 0] = r,
                        this.int16[j + 1] = a,
                        this.int16[j + 2] = c,
                        this.int16[j + 3] = p,
                        this.uint16[j + 4] = f,
                        this.uint16[j + 5] = g,
                        this.uint16[j + 6] = v,
                        this.uint16[j + 7] = S,
                        this.int16[j + 8] = I,
                        this.int16[j + 9] = E,
                        this.int16[j + 10] = R,
                        this.int16[j + 11] = N,
                        t
                    }
                }
                Ps.prototype.bytesPerElement = 24,
                Kt("StructArrayLayout4i4ui4i24", Ps);
                class Jc extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, r, a)
                    }
                    emplace(t, r, a, c) {
                        const p = 3 * t;
                        return this.float32[p + 0] = r,
                        this.float32[p + 1] = a,
                        this.float32[p + 2] = c,
                        t
                    }
                }
                Jc.prototype.bytesPerElement = 12,
                Kt("StructArrayLayout3f12", Jc);
                class Qc extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const r = this.length;
                        return this.resize(r + 1),
                        this.emplace(r, t)
                    }
                    emplace(t, r) {
                        return this.uint32[1 * t + 0] = r,
                        t
                    }
                }
                Qc.prototype.bytesPerElement = 4,
                Kt("StructArrayLayout1ul4", Qc);
                class Al extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p, f, g, v, S) {
                        const I = this.length;
                        return this.resize(I + 1),
                        this.emplace(I, t, r, a, c, p, f, g, v, S)
                    }
                    emplace(t, r, a, c, p, f, g, v, S, I) {
                        const E = 10 * t
                          , R = 5 * t;
                        return this.int16[E + 0] = r,
                        this.int16[E + 1] = a,
                        this.int16[E + 2] = c,
                        this.int16[E + 3] = p,
                        this.int16[E + 4] = f,
                        this.int16[E + 5] = g,
                        this.uint32[R + 3] = v,
                        this.uint16[E + 8] = S,
                        this.uint16[E + 9] = I,
                        t
                    }
                }
                Al.prototype.bytesPerElement = 20,
                Kt("StructArrayLayout6i1ul2ui20", Al);
                class eu extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p, f) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, r, a, c, p, f)
                    }
                    emplace(t, r, a, c, p, f, g) {
                        const v = 6 * t;
                        return this.int16[v + 0] = r,
                        this.int16[v + 1] = a,
                        this.int16[v + 2] = c,
                        this.int16[v + 3] = p,
                        this.int16[v + 4] = f,
                        this.int16[v + 5] = g,
                        t
                    }
                }
                eu.prototype.bytesPerElement = 12,
                Kt("StructArrayLayout2i2i2i12", eu);
                class h extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p) {
                        const f = this.length;
                        return this.resize(f + 1),
                        this.emplace(f, t, r, a, c, p)
                    }
                    emplace(t, r, a, c, p, f) {
                        const g = 4 * t
                          , v = 8 * t;
                        return this.float32[g + 0] = r,
                        this.float32[g + 1] = a,
                        this.float32[g + 2] = c,
                        this.int16[v + 6] = p,
                        this.int16[v + 7] = f,
                        t
                    }
                }
                h.prototype.bytesPerElement = 16,
                Kt("StructArrayLayout2f1f2i16", h);
                class e extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p, f) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, r, a, c, p, f)
                    }
                    emplace(t, r, a, c, p, f, g) {
                        const v = 16 * t
                          , S = 4 * t
                          , I = 8 * t;
                        return this.uint8[v + 0] = r,
                        this.uint8[v + 1] = a,
                        this.float32[S + 1] = c,
                        this.float32[S + 2] = p,
                        this.int16[I + 6] = f,
                        this.int16[I + 7] = g,
                        t
                    }
                }
                e.prototype.bytesPerElement = 16,
                Kt("StructArrayLayout2ub2f2i16", e);
                class n extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, r, a)
                    }
                    emplace(t, r, a, c) {
                        const p = 3 * t;
                        return this.uint16[p + 0] = r,
                        this.uint16[p + 1] = a,
                        this.uint16[p + 2] = c,
                        t
                    }
                }
                n.prototype.bytesPerElement = 6,
                Kt("StructArrayLayout3ui6", n);
                class s extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p, f, g, v, S, I, E, R, N, j, Z, Y, ae) {
                        const ze = this.length;
                        return this.resize(ze + 1),
                        this.emplace(ze, t, r, a, c, p, f, g, v, S, I, E, R, N, j, Z, Y, ae)
                    }
                    emplace(t, r, a, c, p, f, g, v, S, I, E, R, N, j, Z, Y, ae, ze) {
                        const me = 24 * t
                          , be = 12 * t
                          , Ve = 48 * t;
                        return this.int16[me + 0] = r,
                        this.int16[me + 1] = a,
                        this.uint16[me + 2] = c,
                        this.uint16[me + 3] = p,
                        this.uint32[be + 2] = f,
                        this.uint32[be + 3] = g,
                        this.uint32[be + 4] = v,
                        this.uint16[me + 10] = S,
                        this.uint16[me + 11] = I,
                        this.uint16[me + 12] = E,
                        this.float32[be + 7] = R,
                        this.float32[be + 8] = N,
                        this.uint8[Ve + 36] = j,
                        this.uint8[Ve + 37] = Z,
                        this.uint8[Ve + 38] = Y,
                        this.uint32[be + 10] = ae,
                        this.int16[me + 22] = ze,
                        t
                    }
                }
                s.prototype.bytesPerElement = 48,
                Kt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", s);
                class u extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c, p, f, g, v, S, I, E, R, N, j, Z, Y, ae, ze, me, be, Ve, rt, St, $t, Bt, Ut, pr, Vt) {
                        const Zt = this.length;
                        return this.resize(Zt + 1),
                        this.emplace(Zt, t, r, a, c, p, f, g, v, S, I, E, R, N, j, Z, Y, ae, ze, me, be, Ve, rt, St, $t, Bt, Ut, pr, Vt)
                    }
                    emplace(t, r, a, c, p, f, g, v, S, I, E, R, N, j, Z, Y, ae, ze, me, be, Ve, rt, St, $t, Bt, Ut, pr, Vt, Zt) {
                        const mt = 32 * t
                          , Br = 16 * t;
                        return this.int16[mt + 0] = r,
                        this.int16[mt + 1] = a,
                        this.int16[mt + 2] = c,
                        this.int16[mt + 3] = p,
                        this.int16[mt + 4] = f,
                        this.int16[mt + 5] = g,
                        this.int16[mt + 6] = v,
                        this.int16[mt + 7] = S,
                        this.uint16[mt + 8] = I,
                        this.uint16[mt + 9] = E,
                        this.uint16[mt + 10] = R,
                        this.uint16[mt + 11] = N,
                        this.uint16[mt + 12] = j,
                        this.uint16[mt + 13] = Z,
                        this.uint16[mt + 14] = Y,
                        this.uint16[mt + 15] = ae,
                        this.uint16[mt + 16] = ze,
                        this.uint16[mt + 17] = me,
                        this.uint16[mt + 18] = be,
                        this.uint16[mt + 19] = Ve,
                        this.uint16[mt + 20] = rt,
                        this.uint16[mt + 21] = St,
                        this.uint16[mt + 22] = $t,
                        this.uint32[Br + 12] = Bt,
                        this.float32[Br + 13] = Ut,
                        this.float32[Br + 14] = pr,
                        this.uint16[mt + 30] = Vt,
                        this.uint16[mt + 31] = Zt,
                        t
                    }
                }
                u.prototype.bytesPerElement = 64,
                Kt("StructArrayLayout8i15ui1ul2f2ui64", u);
                class d extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const r = this.length;
                        return this.resize(r + 1),
                        this.emplace(r, t)
                    }
                    emplace(t, r) {
                        return this.float32[1 * t + 0] = r,
                        t
                    }
                }
                d.prototype.bytesPerElement = 4,
                Kt("StructArrayLayout1f4", d);
                class m extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, r, a)
                    }
                    emplace(t, r, a, c) {
                        const p = 3 * t;
                        return this.uint16[6 * t + 0] = r,
                        this.float32[p + 1] = a,
                        this.float32[p + 2] = c,
                        t
                    }
                }
                m.prototype.bytesPerElement = 12,
                Kt("StructArrayLayout1ui2f12", m);
                class y extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, r, a)
                    }
                    emplace(t, r, a, c) {
                        const p = 4 * t;
                        return this.uint32[2 * t + 0] = r,
                        this.uint16[p + 2] = a,
                        this.uint16[p + 3] = c,
                        t
                    }
                }
                y.prototype.bytesPerElement = 8,
                Kt("StructArrayLayout1ul2ui8", y);
                class w extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, t, r)
                    }
                    emplace(t, r, a) {
                        const c = 2 * t;
                        return this.uint16[c + 0] = r,
                        this.uint16[c + 1] = a,
                        t
                    }
                }
                w.prototype.bytesPerElement = 4,
                Kt("StructArrayLayout2ui4", w);
                class P extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const r = this.length;
                        return this.resize(r + 1),
                        this.emplace(r, t)
                    }
                    emplace(t, r) {
                        return this.uint16[1 * t + 0] = r,
                        t
                    }
                }
                P.prototype.bytesPerElement = 2,
                Kt("StructArrayLayout1ui2", P);
                class M extends Ai {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, r, a, c) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, t, r, a, c)
                    }
                    emplace(t, r, a, c, p) {
                        const f = 4 * t;
                        return this.float32[f + 0] = r,
                        this.float32[f + 1] = a,
                        this.float32[f + 2] = c,
                        this.float32[f + 3] = p,
                        t
                    }
                }
                M.prototype.bytesPerElement = 16,
                Kt("StructArrayLayout4f16", M);
                class D extends Lo {
                    get anchorPointX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorPointY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get x1() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get y1() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get x2() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get y2() {
                        return this._structArray.int16[this._pos2 + 5]
                    }
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 3]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get anchorPoint() {
                        return new $(this.anchorPointX,this.anchorPointY)
                    }
                }
                D.prototype.size = 20;
                class z extends Al {
                    get(t) {
                        return new D(this,t)
                    }
                }
                Kt("CollisionBoxArray", z);
                class B extends Lo {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get glyphStartIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get numGlyphs() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                    get vertexStartIndex() {
                        return this._structArray.uint32[this._pos4 + 2]
                    }
                    get lineStartIndex() {
                        return this._structArray.uint32[this._pos4 + 3]
                    }
                    get lineLength() {
                        return this._structArray.uint32[this._pos4 + 4]
                    }
                    get segment() {
                        return this._structArray.uint16[this._pos2 + 10]
                    }
                    get lowerSize() {
                        return this._structArray.uint16[this._pos2 + 11]
                    }
                    get upperSize() {
                        return this._structArray.uint16[this._pos2 + 12]
                    }
                    get lineOffsetX() {
                        return this._structArray.float32[this._pos4 + 7]
                    }
                    get lineOffsetY() {
                        return this._structArray.float32[this._pos4 + 8]
                    }
                    get writingMode() {
                        return this._structArray.uint8[this._pos1 + 36]
                    }
                    get placedOrientation() {
                        return this._structArray.uint8[this._pos1 + 37]
                    }
                    set placedOrientation(t) {
                        this._structArray.uint8[this._pos1 + 37] = t
                    }
                    get hidden() {
                        return this._structArray.uint8[this._pos1 + 38]
                    }
                    set hidden(t) {
                        this._structArray.uint8[this._pos1 + 38] = t
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 10]
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 10] = t
                    }
                    get associatedIconIndex() {
                        return this._structArray.int16[this._pos2 + 22]
                    }
                }
                B.prototype.size = 48;
                class U extends s {
                    get(t) {
                        return new B(this,t)
                    }
                }
                Kt("PlacedSymbolArray", U);
                class ee extends Lo {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get rightJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get centerJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get leftJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get verticalPlacedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 5]
                    }
                    get placedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 6]
                    }
                    get verticalPlacedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 7]
                    }
                    get key() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get textBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get textBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 10]
                    }
                    get verticalTextBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 11]
                    }
                    get verticalTextBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 12]
                    }
                    get iconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 13]
                    }
                    get iconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 14]
                    }
                    get verticalIconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 15]
                    }
                    get verticalIconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 16]
                    }
                    get featureIndex() {
                        return this._structArray.uint16[this._pos2 + 17]
                    }
                    get numHorizontalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get numVerticalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 19]
                    }
                    get numIconVertices() {
                        return this._structArray.uint16[this._pos2 + 20]
                    }
                    get numVerticalIconVertices() {
                        return this._structArray.uint16[this._pos2 + 21]
                    }
                    get useRuntimeCollisionCircles() {
                        return this._structArray.uint16[this._pos2 + 22]
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 12]
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 12] = t
                    }
                    get textBoxScale() {
                        return this._structArray.float32[this._pos4 + 13]
                    }
                    get collisionCircleDiameter() {
                        return this._structArray.float32[this._pos4 + 14]
                    }
                    get textAnchorOffsetStartIndex() {
                        return this._structArray.uint16[this._pos2 + 30]
                    }
                    get textAnchorOffsetEndIndex() {
                        return this._structArray.uint16[this._pos2 + 31]
                    }
                }
                ee.prototype.size = 64;
                class J extends u {
                    get(t) {
                        return new ee(this,t)
                    }
                }
                Kt("SymbolInstanceArray", J);
                class re extends d {
                    getoffsetX(t) {
                        return this.float32[1 * t + 0]
                    }
                }
                Kt("GlyphOffsetArray", re);
                class se extends Xs {
                    getx(t) {
                        return this.int16[3 * t + 0]
                    }
                    gety(t) {
                        return this.int16[3 * t + 1]
                    }
                    gettileUnitDistanceFromAnchor(t) {
                        return this.int16[3 * t + 2]
                    }
                }
                Kt("SymbolLineVertexArray", se);
                class de extends Lo {
                    get textAnchor() {
                        return this._structArray.uint16[this._pos2 + 0]
                    }
                    get textOffset0() {
                        return this._structArray.float32[this._pos4 + 1]
                    }
                    get textOffset1() {
                        return this._structArray.float32[this._pos4 + 2]
                    }
                }
                de.prototype.size = 12;
                class ue extends m {
                    get(t) {
                        return new de(this,t)
                    }
                }
                Kt("TextAnchorOffsetArray", ue);
                class ge extends Lo {
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 0]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                }
                ge.prototype.size = 8;
                class Te extends y {
                    get(t) {
                        return new ge(this,t)
                    }
                }
                Kt("FeatureIndexArray", Te);
                class he extends Ws {
                }
                class De extends Ws {
                }
                class He extends Ws {
                }
                class je extends Ks {
                }
                class qe extends Ss {
                }
                class $e extends Do {
                }
                class Rt extends Ml {
                }
                class Nt extends Ps {
                }
                class yt extends Jc {
                }
                class sr extends Qc {
                }
                class Xr extends eu {
                }
                class xi extends e {
                }
                class ki extends n {
                }
                class Pi extends w {
                }
                const ji = Hi([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: Ui} = ji;
                class Wr {
                    constructor(t=[]) {
                        this._forceNewSegmentOnNextPrepare = !1,
                        this.segments = t
                    }
                    prepareSegment(t, r, a, c) {
                        const p = this.segments[this.segments.length - 1];
                        return t > Wr.MAX_VERTEX_ARRAY_LENGTH && Lt(`Max vertices per segment is ${Wr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Wr.MAX_VERTEX_ARRAY_LENGTH} vertices.`),
                        this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + t > Wr.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== c ? this.createNewSegment(r, a, c) : p
                    }
                    createNewSegment(t, r, a) {
                        const c = {
                            vertexOffset: t.length,
                            primitiveOffset: r.length,
                            vertexLength: 0,
                            primitiveLength: 0,
                            vaos: {}
                        };
                        return a !== void 0 && (c.sortKey = a),
                        this._forceNewSegmentOnNextPrepare = !1,
                        this.segments.push(c),
                        c
                    }
                    getOrCreateLatestSegment(t, r, a) {
                        return this.prepareSegment(0, t, r, a)
                    }
                    forceNewSegmentOnNextPrepare() {
                        this._forceNewSegmentOnNextPrepare = !0
                    }
                    get() {
                        return this.segments
                    }
                    destroy() {
                        for (const t of this.segments)
                            for (const r in t.vaos)
                                t.vaos[r].destroy()
                    }
                    static simpleSegment(t, r, a, c) {
                        return new Wr([{
                            vertexOffset: t,
                            primitiveOffset: r,
                            vertexLength: a,
                            primitiveLength: c,
                            vaos: {},
                            sortKey: 0
                        }])
                    }
                }
                function Ei(i, t) {
                    return 256 * (i = xt(Math.floor(i), 0, 255)) + xt(Math.floor(t), 0, 255)
                }
                Wr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1,
                Kt("SegmentVector", Wr);
                const Qi = Hi([{
                    name: "a_pattern_from",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pattern_to",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio_from",
                    components: 1,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio_to",
                    components: 1,
                    type: "Uint16"
                }]);
                var dn, xn, qn, Sa = {
                    exports: {}
                }, as = {
                    exports: {}
                }, ss = {
                    exports: {}
                }, Ys = (function() {
                    if (qn)
                        return Sa.exports;
                    qn = 1;
                    var i = (dn || (dn = 1,
                    as.exports = function(r, a) {
                        var c, p, f, g, v, S, I, E;
                        for (p = r.length - (c = 3 & r.length),
                        f = a,
                        v = 3432918353,
                        S = 461845907,
                        E = 0; E < p; )
                            I = 255 & r.charCodeAt(E) | (255 & r.charCodeAt(++E)) << 8 | (255 & r.charCodeAt(++E)) << 16 | (255 & r.charCodeAt(++E)) << 24,
                            ++E,
                            f = 27492 + (65535 & (g = 5 * (65535 & (f = (f ^= I = (65535 & (I = (I = (65535 & I) * v + (((I >>> 16) * v & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (g >>> 16) & 65535) << 16);
                        switch (I = 0,
                        c) {
                        case 3:
                            I ^= (255 & r.charCodeAt(E + 2)) << 16;
                        case 2:
                            I ^= (255 & r.charCodeAt(E + 1)) << 8;
                        case 1:
                            f ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & r.charCodeAt(E))) * v + (((I >>> 16) * v & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295
                        }
                        return f ^= r.length,
                        f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295,
                        f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295,
                        (f ^= f >>> 16) >>> 0
                    }
                    ),
                    as.exports)
                      , t = (xn || (xn = 1,
                    ss.exports = function(r, a) {
                        for (var c, p = r.length, f = a ^ p, g = 0; p >= 4; )
                            c = 1540483477 * (65535 & (c = 255 & r.charCodeAt(g) | (255 & r.charCodeAt(++g)) << 8 | (255 & r.charCodeAt(++g)) << 16 | (255 & r.charCodeAt(++g)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16),
                            f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)),
                            p -= 4,
                            ++g;
                        switch (p) {
                        case 3:
                            f ^= (255 & r.charCodeAt(g + 2)) << 16;
                        case 2:
                            f ^= (255 & r.charCodeAt(g + 1)) << 8;
                        case 1:
                            f = 1540483477 * (65535 & (f ^= 255 & r.charCodeAt(g))) + ((1540483477 * (f >>> 16) & 65535) << 16)
                        }
                        return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16),
                        (f ^= f >>> 15) >>> 0
                    }
                    ),
                    ss.exports);
                    return Sa.exports = i,
                    Sa.exports.murmur3 = i,
                    Sa.exports.murmur2 = t,
                    Sa.exports
                }
                )(), Js = W(Ys);
                class Is {
                    constructor() {
                        this.ids = [],
                        this.positions = [],
                        this.indexed = !1
                    }
                    add(t, r, a, c) {
                        this.ids.push(Ms(t)),
                        this.positions.push(r, a, c)
                    }
                    getPositions(t) {
                        if (!this.indexed)
                            throw new Error("Trying to get index, but feature positions are not indexed");
                        const r = Ms(t);
                        let a = 0
                          , c = this.ids.length - 1;
                        for (; a < c; ) {
                            const f = a + c >> 1;
                            this.ids[f] >= r ? c = f : a = f + 1
                        }
                        const p = [];
                        for (; this.ids[a] === r; )
                            p.push({
                                index: this.positions[3 * a],
                                start: this.positions[3 * a + 1],
                                end: this.positions[3 * a + 2]
                            }),
                            a++;
                        return p
                    }
                    static serialize(t, r) {
                        const a = new Float64Array(t.ids)
                          , c = new Uint32Array(t.positions);
                        return Kn(a, c, 0, a.length - 1),
                        r && r.push(a.buffer, c.buffer),
                        {
                            ids: a,
                            positions: c
                        }
                    }
                    static deserialize(t) {
                        const r = new Is;
                        return r.ids = t.ids,
                        r.positions = t.positions,
                        r.indexed = !0,
                        r
                    }
                }
                function Ms(i) {
                    const t = +i;
                    return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Js(String(i))
                }
                function Kn(i, t, r, a) {
                    for (; r < a; ) {
                        const c = i[r + a >> 1];
                        let p = r - 1
                          , f = a + 1;
                        for (; ; ) {
                            do
                                p++;
                            while (i[p] < c);
                            do
                                f--;
                            while (i[f] > c);
                            if (p >= f)
                                break;
                            Pa(i, p, f),
                            Pa(t, 3 * p, 3 * f),
                            Pa(t, 3 * p + 1, 3 * f + 1),
                            Pa(t, 3 * p + 2, 3 * f + 2)
                        }
                        f - r < a - f ? (Kn(i, t, r, f),
                        r = f + 1) : (Kn(i, t, f + 1, a),
                        a = f)
                    }
                }
                function Pa(i, t, r) {
                    const a = i[t];
                    i[t] = i[r],
                    i[r] = a
                }
                Kt("FeaturePositionMap", Is);
                class Vn {
                    constructor(t, r) {
                        this.gl = t.gl,
                        this.location = r
                    }
                }
                class os extends Vn {
                    constructor(t, r) {
                        super(t, r),
                        this.current = 0
                    }
                    set(t) {
                        this.current !== t && (this.current = t,
                        this.gl.uniform1f(this.location, t))
                    }
                }
                class en extends Vn {
                    constructor(t, r) {
                        super(t, r),
                        this.current = [0, 0, 0, 0]
                    }
                    set(t) {
                        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t,
                        this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
                    }
                }
                class pn extends Vn {
                    constructor(t, r) {
                        super(t, r),
                        this.current = yr.transparent
                    }
                    set(t) {
                        t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t,
                        this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
                    }
                }
                const da = new Float32Array(16);
                function tn(i) {
                    return [Ei(255 * i.r, 255 * i.g), Ei(255 * i.b, 255 * i.a)]
                }
                class Ro {
                    constructor(t, r, a) {
                        this.value = t,
                        this.uniformNames = r.map((c => `u_${c}`)),
                        this.type = a
                    }
                    setUniform(t, r, a) {
                        t.set(a.constantOr(this.value))
                    }
                    getBinding(t, r, a) {
                        return this.type === "color" ? new pn(t,r) : new os(t,r)
                    }
                }
                class Qs {
                    constructor(t, r) {
                        this.uniformNames = r.map((a => `u_${a}`)),
                        this.patternFrom = null,
                        this.patternTo = null,
                        this.pixelRatioFrom = 1,
                        this.pixelRatioTo = 1
                    }
                    setConstantPatternPositions(t, r) {
                        this.pixelRatioFrom = r.pixelRatio,
                        this.pixelRatioTo = t.pixelRatio,
                        this.patternFrom = r.tlbr,
                        this.patternTo = t.tlbr
                    }
                    setUniform(t, r, a, c) {
                        const p = c === "u_pattern_to" ? this.patternTo : c === "u_pattern_from" ? this.patternFrom : c === "u_pixel_ratio_to" ? this.pixelRatioTo : c === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
                        p && t.set(p)
                    }
                    getBinding(t, r, a) {
                        return a.substr(0, 9) === "u_pattern" ? new en(t,r) : new os(t,r)
                    }
                }
                class Ha {
                    constructor(t, r, a, c) {
                        this.expression = t,
                        this.type = a,
                        this.maxValue = 0,
                        this.paintVertexAttributes = r.map((p => ({
                            name: `a_${p}`,
                            type: "Float32",
                            components: a === "color" ? 2 : 1,
                            offset: 0
                        }))),
                        this.paintVertexArray = new c
                    }
                    populatePaintArray(t, r, a, c, p) {
                        const f = this.paintVertexArray.length
                          , g = this.expression.evaluate(new Oi(0), r, {}, c, [], p);
                        this.paintVertexArray.resize(t),
                        this._setPaintValue(f, t, g)
                    }
                    updatePaintArray(t, r, a, c) {
                        const p = this.expression.evaluate({
                            zoom: 0
                        }, a, c);
                        this._setPaintValue(t, r, p)
                    }
                    _setPaintValue(t, r, a) {
                        if (this.type === "color") {
                            const c = tn(a);
                            for (let p = t; p < r; p++)
                                this.paintVertexArray.emplace(p, c[0], c[1])
                        } else {
                            for (let c = t; c < r; c++)
                                this.paintVertexArray.emplace(c, a);
                            this.maxValue = Math.max(this.maxValue, Math.abs(a))
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                }
                class Ia {
                    constructor(t, r, a, c, p, f) {
                        this.expression = t,
                        this.uniformNames = r.map((g => `u_${g}_t`)),
                        this.type = a,
                        this.useIntegerZoom = c,
                        this.zoom = p,
                        this.maxValue = 0,
                        this.paintVertexAttributes = r.map((g => ({
                            name: `a_${g}`,
                            type: "Float32",
                            components: a === "color" ? 4 : 2,
                            offset: 0
                        }))),
                        this.paintVertexArray = new f
                    }
                    populatePaintArray(t, r, a, c, p) {
                        const f = this.expression.evaluate(new Oi(this.zoom), r, {}, c, [], p)
                          , g = this.expression.evaluate(new Oi(this.zoom + 1), r, {}, c, [], p)
                          , v = this.paintVertexArray.length;
                        this.paintVertexArray.resize(t),
                        this._setPaintValue(v, t, f, g)
                    }
                    updatePaintArray(t, r, a, c) {
                        const p = this.expression.evaluate({
                            zoom: this.zoom
                        }, a, c)
                          , f = this.expression.evaluate({
                            zoom: this.zoom + 1
                        }, a, c);
                        this._setPaintValue(t, r, p, f)
                    }
                    _setPaintValue(t, r, a, c) {
                        if (this.type === "color") {
                            const p = tn(a)
                              , f = tn(c);
                            for (let g = t; g < r; g++)
                                this.paintVertexArray.emplace(g, p[0], p[1], f[0], f[1])
                        } else {
                            for (let p = t; p < r; p++)
                                this.paintVertexArray.emplace(p, a, c);
                            this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(c))
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                    setUniform(t, r) {
                        const a = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom
                          , c = xt(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);
                        t.set(c)
                    }
                    getBinding(t, r, a) {
                        return new os(t,r)
                    }
                }
                class ls {
                    constructor(t, r, a, c, p, f) {
                        this.expression = t,
                        this.type = r,
                        this.useIntegerZoom = a,
                        this.zoom = c,
                        this.layerId = f,
                        this.zoomInPaintVertexArray = new p,
                        this.zoomOutPaintVertexArray = new p
                    }
                    populatePaintArray(t, r, a) {
                        const c = this.zoomInPaintVertexArray.length;
                        this.zoomInPaintVertexArray.resize(t),
                        this.zoomOutPaintVertexArray.resize(t),
                        this._setPaintValues(c, t, r.patterns && r.patterns[this.layerId], a)
                    }
                    updatePaintArray(t, r, a, c, p) {
                        this._setPaintValues(t, r, a.patterns && a.patterns[this.layerId], p)
                    }
                    _setPaintValues(t, r, a, c) {
                        if (!c || !a)
                            return;
                        const {min: p, mid: f, max: g} = a
                          , v = c[p]
                          , S = c[f]
                          , I = c[g];
                        if (v && S && I)
                            for (let E = t; E < r; E++)
                                this.zoomInPaintVertexArray.emplace(E, S.tl[0], S.tl[1], S.br[0], S.br[1], v.tl[0], v.tl[1], v.br[0], v.br[1], S.pixelRatio, v.pixelRatio),
                                this.zoomOutPaintVertexArray.emplace(E, S.tl[0], S.tl[1], S.br[0], S.br[1], I.tl[0], I.tl[1], I.br[0], I.br[1], S.pixelRatio, I.pixelRatio)
                    }
                    upload(t) {
                        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Qi.members, this.expression.isStateDependent),
                        this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Qi.members, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(),
                        this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
                    }
                }
                class id {
                    constructor(t, r, a) {
                        this.binders = {},
                        this._buffers = [];
                        const c = [];
                        for (const p in t.paint._values) {
                            if (!a(p))
                                continue;
                            const f = t.paint.get(p);
                            if (!(f instanceof Na && rs(f.property.specification)))
                                continue;
                            const g = nd(p, t.type)
                              , v = f.value
                              , S = f.property.specification.type
                              , I = f.property.useIntegerZoom
                              , E = f.property.specification["property-type"]
                              , R = E === "cross-faded" || E === "cross-faded-data-driven";
                            if (v.kind === "constant")
                                this.binders[p] = R ? new Qs(v.value,g) : new Ro(v.value,g,S),
                                c.push(`/u_${p}`);
                            else if (v.kind === "source" || R) {
                                const N = tu(p, S, "source");
                                this.binders[p] = R ? new ls(v,S,I,r,N,t.id) : new Ha(v,g,S,N),
                                c.push(`/a_${p}`)
                            } else {
                                const N = tu(p, S, "composite");
                                this.binders[p] = new Ia(v,g,S,I,r,N),
                                c.push(`/z_${p}`)
                            }
                        }
                        this.cacheKey = c.sort().join("")
                    }
                    getMaxValue(t) {
                        const r = this.binders[t];
                        return r instanceof Ha || r instanceof Ia ? r.maxValue : 0
                    }
                    populatePaintArrays(t, r, a, c, p) {
                        for (const f in this.binders) {
                            const g = this.binders[f];
                            (g instanceof Ha || g instanceof Ia || g instanceof ls) && g.populatePaintArray(t, r, a, c, p)
                        }
                    }
                    setConstantPatternPositions(t, r) {
                        for (const a in this.binders) {
                            const c = this.binders[a];
                            c instanceof Qs && c.setConstantPatternPositions(t, r)
                        }
                    }
                    updatePaintArrays(t, r, a, c, p) {
                        let f = !1;
                        for (const g in t) {
                            const v = r.getPositions(g);
                            for (const S of v) {
                                const I = a.feature(S.index);
                                for (const E in this.binders) {
                                    const R = this.binders[E];
                                    if ((R instanceof Ha || R instanceof Ia || R instanceof ls) && R.expression.isStateDependent === !0) {
                                        const N = c.paint.get(E);
                                        R.expression = N.value,
                                        R.updatePaintArray(S.start, S.end, I, t[g], p),
                                        f = !0
                                    }
                                }
                            }
                        }
                        return f
                    }
                    defines() {
                        const t = [];
                        for (const r in this.binders) {
                            const a = this.binders[r];
                            (a instanceof Ro || a instanceof Qs) && t.push(...a.uniformNames.map((c => `#define HAS_UNIFORM_${c}`)))
                        }
                        return t
                    }
                    getBinderAttributes() {
                        const t = [];
                        for (const r in this.binders) {
                            const a = this.binders[r];
                            if (a instanceof Ha || a instanceof Ia)
                                for (let c = 0; c < a.paintVertexAttributes.length; c++)
                                    t.push(a.paintVertexAttributes[c].name);
                            else if (a instanceof ls)
                                for (let c = 0; c < Qi.members.length; c++)
                                    t.push(Qi.members[c].name)
                        }
                        return t
                    }
                    getBinderUniforms() {
                        const t = [];
                        for (const r in this.binders) {
                            const a = this.binders[r];
                            if (a instanceof Ro || a instanceof Qs || a instanceof Ia)
                                for (const c of a.uniformNames)
                                    t.push(c)
                        }
                        return t
                    }
                    getPaintVertexBuffers() {
                        return this._buffers
                    }
                    getUniforms(t, r) {
                        const a = [];
                        for (const c in this.binders) {
                            const p = this.binders[c];
                            if (p instanceof Ro || p instanceof Qs || p instanceof Ia) {
                                for (const f of p.uniformNames)
                                    if (r[f]) {
                                        const g = p.getBinding(t, r[f], f);
                                        a.push({
                                            name: f,
                                            property: c,
                                            binding: g
                                        })
                                    }
                            }
                        }
                        return a
                    }
                    setUniforms(t, r, a, c) {
                        for (const {name: p, property: f, binding: g} of r)
                            this.binders[f].setUniform(g, c, a.get(f), p)
                    }
                    updatePaintBuffers(t) {
                        this._buffers = [];
                        for (const r in this.binders) {
                            const a = this.binders[r];
                            if (t && a instanceof ls) {
                                const c = t.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer;
                                c && this._buffers.push(c)
                            } else
                                (a instanceof Ha || a instanceof Ia) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer)
                        }
                    }
                    upload(t) {
                        for (const r in this.binders) {
                            const a = this.binders[r];
                            (a instanceof Ha || a instanceof Ia || a instanceof ls) && a.upload(t)
                        }
                        this.updatePaintBuffers()
                    }
                    destroy() {
                        for (const t in this.binders) {
                            const r = this.binders[t];
                            (r instanceof Ha || r instanceof Ia || r instanceof ls) && r.destroy()
                        }
                    }
                }
                class ia {
                    constructor(t, r, a= () => !0) {
                        this.programConfigurations = {};
                        for (const c of t)
                            this.programConfigurations[c.id] = new id(c,r,a);
                        this.needsUpload = !1,
                        this._featureMap = new Is,
                        this._bufferOffset = 0
                    }
                    populatePaintArrays(t, r, a, c, p, f) {
                        for (const g in this.programConfigurations)
                            this.programConfigurations[g].populatePaintArrays(t, r, c, p, f);
                        r.id !== void 0 && this._featureMap.add(r.id, a, this._bufferOffset, t),
                        this._bufferOffset = t,
                        this.needsUpload = !0
                    }
                    updatePaintArrays(t, r, a, c) {
                        for (const p of a)
                            this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(t, this._featureMap, r, p, c) || this.needsUpload
                    }
                    get(t) {
                        return this.programConfigurations[t]
                    }
                    upload(t) {
                        if (this.needsUpload) {
                            for (const r in this.programConfigurations)
                                this.programConfigurations[r].upload(t);
                            this.needsUpload = !1
                        }
                    }
                    destroy() {
                        for (const t in this.programConfigurations)
                            this.programConfigurations[t].destroy()
                    }
                }
                function nd(i, t) {
                    return {
                        "text-opacity": ["opacity"],
                        "icon-opacity": ["opacity"],
                        "text-color": ["fill_color"],
                        "icon-color": ["fill_color"],
                        "text-halo-color": ["halo_color"],
                        "icon-halo-color": ["halo_color"],
                        "text-halo-blur": ["halo_blur"],
                        "icon-halo-blur": ["halo_blur"],
                        "text-halo-width": ["halo_width"],
                        "icon-halo-width": ["halo_width"],
                        "line-gap-width": ["gapwidth"],
                        "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                        "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                        "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
                    }[i] || [i.replace(`${t}-`, "").replace(/-/g, "_")]
                }
                function tu(i, t, r) {
                    const a = {
                        color: {
                            source: Do,
                            composite: M
                        },
                        number: {
                            source: d,
                            composite: Do
                        }
                    }
                      , c = (function(p) {
                        return {
                            "line-pattern": {
                                source: Rt,
                                composite: Rt
                            },
                            "fill-pattern": {
                                source: Rt,
                                composite: Rt
                            },
                            "fill-extrusion-pattern": {
                                source: Rt,
                                composite: Rt
                            }
                        }[p]
                    }
                    )(i);
                    return c && c[r] || a[t][r]
                }
                Kt("ConstantBinder", Ro),
                Kt("CrossFadedConstantBinder", Qs),
                Kt("SourceExpressionBinder", Ha),
                Kt("CrossFadedCompositeBinder", ls),
                Kt("CompositeExpressionBinder", Ia),
                Kt("ProgramConfiguration", id, {
                    omit: ["_buffers"]
                }),
                Kt("ProgramConfigurationSet", ia);
                const kl = Math.pow(2, 14) - 1
                  , El = -kl - 1;
                function cs(i) {
                    const t = ne / i.extent
                      , r = i.loadGeometry();
                    for (let a = 0; a < r.length; a++) {
                        const c = r[a];
                        for (let p = 0; p < c.length; p++) {
                            const f = c[p]
                              , g = Math.round(f.x * t)
                              , v = Math.round(f.y * t);
                            f.x = xt(g, El, kl),
                            f.y = xt(v, El, kl),
                            (g < f.x || g > f.x + 1 || v < f.y || v > f.y + 1) && Lt("Geometry exceeds allowed extent, reduce your vector tile buffer size")
                        }
                    }
                    return r
                }
                function Wa(i, t) {
                    return {
                        type: i.type,
                        id: i.id,
                        properties: i.properties,
                        geometry: t ? cs(i) : []
                    }
                }
                const Cm = -32768;
                function Bv(i, t, r, a, c) {
                    i.emplaceBack(Cm + 8 * t + a, Cm + 8 * r + c)
                }
                class wp {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((r => r.id)),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.layoutVertexArray = new De,
                        this.indexArray = new ki,
                        this.segments = new Wr,
                        this.programConfigurations = new ia(t.layers,t.zoom),
                        this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
                    }
                    populate(t, r, a) {
                        const c = this.layers[0]
                          , p = [];
                        let f = null
                          , g = !1
                          , v = c.type === "heatmap";
                        if (c.type === "circle") {
                            const I = c;
                            f = I.layout.get("circle-sort-key"),
                            g = !f.isConstant(),
                            v = v || I.paint.get("circle-pitch-alignment") === "map"
                        }
                        const S = v ? r.subdivisionGranularity.circle : 1;
                        for (const {feature: I, id: E, index: R, sourceLayerIndex: N} of t) {
                            const j = this.layers[0]._featureFilter.needGeometry
                              , Z = Wa(I, j);
                            if (!this.layers[0]._featureFilter.filter(new Oi(this.zoom,{
                                globalState: this.globalState
                            }), Z, a))
                                continue;
                            const Y = g ? f.evaluate(Z, {}, a) : void 0
                              , ae = {
                                id: E,
                                properties: I.properties,
                                type: I.type,
                                sourceLayerIndex: N,
                                index: R,
                                geometry: j ? Z.geometry : cs(I),
                                patterns: {},
                                sortKey: Y
                            };
                            p.push(ae)
                        }
                        g && p.sort(( (I, E) => I.sortKey - E.sortKey));
                        for (const I of p) {
                            const {geometry: E, index: R, sourceLayerIndex: N} = I
                              , j = t[R].feature;
                            this.addFeature(I, E, R, a, S),
                            r.featureIndex.insert(j, E, R, N, this.index)
                        }
                    }
                    update(t, r, a) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ui),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    addFeature(t, r, a, c, p=1) {
                        let f;
                        switch (p) {
                        case 1:
                            f = [0, 7];
                            break;
                        case 3:
                            f = [0, 2, 5, 7];
                            break;
                        case 5:
                            f = [0, 1, 3, 4, 6, 7];
                            break;
                        case 7:
                            f = [0, 1, 2, 3, 4, 5, 6, 7];
                            break;
                        default:
                            throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`)
                        }
                        const g = f.length;
                        for (const v of r)
                            for (const S of v) {
                                const I = S.x
                                  , E = S.y;
                                if (I < 0 || I >= ne || E < 0 || E >= ne)
                                    continue;
                                const R = this.segments.prepareSegment(g * g, this.layoutVertexArray, this.indexArray, t.sortKey)
                                  , N = R.vertexLength;
                                for (let j = 0; j < g; j++)
                                    for (let Z = 0; Z < g; Z++)
                                        Bv(this.layoutVertexArray, I, E, f[Z], f[j]);
                                for (let j = 0; j < g - 1; j++)
                                    for (let Z = 0; Z < g - 1; Z++) {
                                        const Y = N + j * g + Z
                                          , ae = N + (j + 1) * g + Z;
                                        this.indexArray.emplaceBack(Y, ae + 1, Y + 1),
                                        this.indexArray.emplaceBack(Y, ae, ae + 1)
                                    }
                                R.vertexLength += g * g,
                                R.primitiveLength += (g - 1) * (g - 1) * 2
                            }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {}, c)
                    }
                }
                function Sm(i, t) {
                    for (let r = 0; r < i.length; r++)
                        if (zl(t, i[r]))
                            return !0;
                    for (let r = 0; r < t.length; r++)
                        if (zl(i, t[r]))
                            return !0;
                    return !!Tp(i, t)
                }
                function Fv(i, t, r) {
                    return !!zl(i, t) || !!Cp(t, i, r)
                }
                function Pm(i, t) {
                    if (i.length === 1)
                        return Mm(t, i[0]);
                    for (let r = 0; r < t.length; r++) {
                        const a = t[r];
                        for (let c = 0; c < a.length; c++)
                            if (zl(i, a[c]))
                                return !0
                    }
                    for (let r = 0; r < i.length; r++)
                        if (Mm(t, i[r]))
                            return !0;
                    for (let r = 0; r < t.length; r++)
                        if (Tp(i, t[r]))
                            return !0;
                    return !1
                }
                function Ov(i, t, r) {
                    if (i.length > 1) {
                        if (Tp(i, t))
                            return !0;
                        for (let a = 0; a < t.length; a++)
                            if (Cp(t[a], i, r))
                                return !0
                    }
                    for (let a = 0; a < i.length; a++)
                        if (Cp(i[a], t, r))
                            return !0;
                    return !1
                }
                function Tp(i, t) {
                    if (i.length === 0 || t.length === 0)
                        return !1;
                    for (let r = 0; r < i.length - 1; r++) {
                        const a = i[r]
                          , c = i[r + 1];
                        for (let p = 0; p < t.length - 1; p++)
                            if (Nv(a, c, t[p], t[p + 1]))
                                return !0
                    }
                    return !1
                }
                function Nv(i, t, r, a) {
                    return Xt(i, r, a) !== Xt(t, r, a) && Xt(i, t, r) !== Xt(i, t, a)
                }
                function Cp(i, t, r) {
                    const a = r * r;
                    if (t.length === 1)
                        return i.distSqr(t[0]) < a;
                    for (let c = 1; c < t.length; c++)
                        if (Im(i, t[c - 1], t[c]) < a)
                            return !0;
                    return !1
                }
                function Im(i, t, r) {
                    const a = t.distSqr(r);
                    if (a === 0)
                        return i.distSqr(t);
                    const c = ((i.x - t.x) * (r.x - t.x) + (i.y - t.y) * (r.y - t.y)) / a;
                    return i.distSqr(c < 0 ? t : c > 1 ? r : r.sub(t)._mult(c)._add(t))
                }
                function Mm(i, t) {
                    let r, a, c, p = !1;
                    for (let f = 0; f < i.length; f++) {
                        r = i[f];
                        for (let g = 0, v = r.length - 1; g < r.length; v = g++)
                            a = r[g],
                            c = r[v],
                            a.y > t.y != c.y > t.y && t.x < (c.x - a.x) * (t.y - a.y) / (c.y - a.y) + a.x && (p = !p)
                    }
                    return p
                }
                function zl(i, t) {
                    let r = !1;
                    for (let a = 0, c = i.length - 1; a < i.length; c = a++) {
                        const p = i[a]
                          , f = i[c];
                        p.y > t.y != f.y > t.y && t.x < (f.x - p.x) * (t.y - p.y) / (f.y - p.y) + p.x && (r = !r)
                    }
                    return r
                }
                function jv(i, t, r) {
                    const a = r[0]
                      , c = r[2];
                    if (i.x < a.x && t.x < a.x || i.x > c.x && t.x > c.x || i.y < a.y && t.y < a.y || i.y > c.y && t.y > c.y)
                        return !1;
                    const p = Xt(i, t, r[0]);
                    return p !== Xt(i, t, r[1]) || p !== Xt(i, t, r[2]) || p !== Xt(i, t, r[3])
                }
                function ru(i, t, r) {
                    const a = t.paint.get(i).value;
                    return a.kind === "constant" ? a.value : r.programConfigurations.get(t.id).getMaxValue(i)
                }
                function ad(i) {
                    return Math.sqrt(i[0] * i[0] + i[1] * i[1])
                }
                function sd(i, t, r, a, c) {
                    if (!t[0] && !t[1])
                        return i;
                    const p = $.convert(t)._mult(c);
                    r === "viewport" && p._rotate(-a);
                    const f = [];
                    for (let g = 0; g < i.length; g++)
                        f.push(i[g].sub(p));
                    return f
                }
                let Am, km;
                Kt("CircleBucket", wp, {
                    omit: ["layers"]
                });
                var qv = {
                    get paint() {
                        return km = km || new jn({
                            "circle-radius": new Rr(xe.paint_circle["circle-radius"]),
                            "circle-color": new Rr(xe.paint_circle["circle-color"]),
                            "circle-blur": new Rr(xe.paint_circle["circle-blur"]),
                            "circle-opacity": new Rr(xe.paint_circle["circle-opacity"]),
                            "circle-translate": new hr(xe.paint_circle["circle-translate"]),
                            "circle-translate-anchor": new hr(xe.paint_circle["circle-translate-anchor"]),
                            "circle-pitch-scale": new hr(xe.paint_circle["circle-pitch-scale"]),
                            "circle-pitch-alignment": new hr(xe.paint_circle["circle-pitch-alignment"]),
                            "circle-stroke-width": new Rr(xe.paint_circle["circle-stroke-width"]),
                            "circle-stroke-color": new Rr(xe.paint_circle["circle-stroke-color"]),
                            "circle-stroke-opacity": new Rr(xe.paint_circle["circle-stroke-opacity"])
                        })
                    },
                    get layout() {
                        return Am = Am || new jn({
                            "circle-sort-key": new Rr(xe.layout_circle["circle-sort-key"])
                        })
                    }
                };
                class Vv extends ha {
                    constructor(t) {
                        super(t, qv)
                    }
                    createBucket(t) {
                        return new wp(t)
                    }
                    queryRadius(t) {
                        const r = t;
                        return ru("circle-radius", this, r) + ru("circle-stroke-width", this, r) + ad(this.paint.get("circle-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: t, feature: r, featureState: a, geometry: c, transform: p, pixelsToTileUnits: f, unwrappedTileID: g, getElevation: v}) {
                        const S = sd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, f)
                          , I = this.paint.get("circle-radius").evaluate(r, a) + this.paint.get("circle-stroke-width").evaluate(r, a)
                          , E = this.paint.get("circle-pitch-alignment") === "map"
                          , R = E ? S : (function(j, Z, Y, ae) {
                            return j.map((ze => Em(ze, Z, Y, ae)))
                        }
                        )(S, p, g, v)
                          , N = E ? I * f : I;
                        for (const j of c)
                            for (const Z of j) {
                                const Y = E ? Z : Em(Z, p, g, v);
                                let ae = N;
                                const ze = p.projectTileCoordinates(Z.x, Z.y, g, v).signedDistanceFromCamera;
                                if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? ae *= ze / p.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (ae *= p.cameraToCenterDistance / ze),
                                Fv(R, Y, ae))
                                    return !0
                            }
                        return !1
                    }
                }
                function Em(i, t, r, a) {
                    const c = t.projectTileCoordinates(i.x, i.y, r, a).point;
                    return new $((.5 * c.x + .5) * t.width,(.5 * -c.y + .5) * t.height)
                }
                class zm extends wp {
                }
                let Lm;
                Kt("HeatmapBucket", zm, {
                    omit: ["layers"]
                });
                var Uv = {
                    get paint() {
                        return Lm = Lm || new jn({
                            "heatmap-radius": new Rr(xe.paint_heatmap["heatmap-radius"]),
                            "heatmap-weight": new Rr(xe.paint_heatmap["heatmap-weight"]),
                            "heatmap-intensity": new hr(xe.paint_heatmap["heatmap-intensity"]),
                            "heatmap-color": new Pl(xe.paint_heatmap["heatmap-color"]),
                            "heatmap-opacity": new hr(xe.paint_heatmap["heatmap-opacity"])
                        })
                    }
                };
                function Sp(i, {width: t, height: r}, a, c) {
                    if (c) {
                        if (c instanceof Uint8ClampedArray)
                            c = new Uint8Array(c.buffer);
                        else if (c.length !== t * r * a)
                            throw new RangeError(`mismatched image size. expected: ${c.length} but got: ${t * r * a}`)
                    } else
                        c = new Uint8Array(t * r * a);
                    return i.width = t,
                    i.height = r,
                    i.data = c,
                    i
                }
                function Dm(i, {width: t, height: r}, a) {
                    if (t === i.width && r === i.height)
                        return;
                    const c = Sp({}, {
                        width: t,
                        height: r
                    }, a);
                    Pp(i, c, {
                        x: 0,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, {
                        width: Math.min(i.width, t),
                        height: Math.min(i.height, r)
                    }, a),
                    i.width = t,
                    i.height = r,
                    i.data = c.data
                }
                function Pp(i, t, r, a, c, p) {
                    if (c.width === 0 || c.height === 0)
                        return t;
                    if (c.width > i.width || c.height > i.height || r.x > i.width - c.width || r.y > i.height - c.height)
                        throw new RangeError("out of range source coordinates for image copy");
                    if (c.width > t.width || c.height > t.height || a.x > t.width - c.width || a.y > t.height - c.height)
                        throw new RangeError("out of range destination coordinates for image copy");
                    const f = i.data
                      , g = t.data;
                    if (f === g)
                        throw new Error("srcData equals dstData, so image is already copied");
                    for (let v = 0; v < c.height; v++) {
                        const S = ((r.y + v) * i.width + r.x) * p
                          , I = ((a.y + v) * t.width + a.x) * p;
                        for (let E = 0; E < c.width * p; E++)
                            g[I + E] = f[S + E]
                    }
                    return t
                }
                class iu {
                    constructor(t, r) {
                        Sp(this, t, 1, r)
                    }
                    resize(t) {
                        Dm(this, t, 1)
                    }
                    clone() {
                        return new iu({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(t, r, a, c, p) {
                        Pp(t, r, a, c, p, 1)
                    }
                }
                class na {
                    constructor(t, r) {
                        Sp(this, t, 4, r)
                    }
                    resize(t) {
                        Dm(this, t, 4)
                    }
                    replace(t, r) {
                        r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
                    }
                    clone() {
                        return new na({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(t, r, a, c, p) {
                        Pp(t, r, a, c, p, 4)
                    }
                    setPixel(t, r, a) {
                        const c = 4 * (t * this.width + r);
                        this.data[c + 0] = Math.round(255 * a.r / a.a),
                        this.data[c + 1] = Math.round(255 * a.g / a.a),
                        this.data[c + 2] = Math.round(255 * a.b / a.a),
                        this.data[c + 3] = Math.round(255 * a.a)
                    }
                }
                function Rm(i) {
                    const t = {}
                      , r = i.resolution || 256
                      , a = i.clips ? i.clips.length : 1
                      , c = i.image || new na({
                        width: r,
                        height: a
                    });
                    if (Math.log(r) / Math.LN2 % 1 != 0)
                        throw new Error(`width is not a power of 2 - ${r}`);
                    const p = (f, g, v) => {
                        t[i.evaluationKey] = v;
                        const S = i.expression.evaluate(t);
                        c.setPixel(f / 4 / r, g / 4, S)
                    }
                    ;
                    if (i.clips)
                        for (let f = 0, g = 0; f < a; ++f,
                        g += 4 * r)
                            for (let v = 0, S = 0; v < r; v++,
                            S += 4) {
                                const I = v / (r - 1)
                                  , {start: E, end: R} = i.clips[f];
                                p(g, S, E * (1 - I) + R * I)
                            }
                    else
                        for (let f = 0, g = 0; f < r; f++,
                        g += 4)
                            p(0, g, f / (r - 1));
                    return c
                }
                Kt("AlphaImage", iu),
                Kt("RGBAImage", na);
                const Ip = "big-fb";
                class Zv extends ha {
                    createBucket(t) {
                        return new zm(t)
                    }
                    constructor(t) {
                        super(t, Uv),
                        this.heatmapFbos = new Map,
                        this._updateColorRamp()
                    }
                    _handleSpecialPaintPropertyUpdate(t) {
                        t === "heatmap-color" && this._updateColorRamp()
                    }
                    _updateColorRamp() {
                        this.colorRamp = Rm({
                            expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                            evaluationKey: "heatmapDensity",
                            image: this.colorRamp
                        }),
                        this.colorRampTexture = null
                    }
                    resize() {
                        this.heatmapFbos.has(Ip) && this.heatmapFbos.delete(Ip)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
                    }
                }
                let Bm;
                var $v = {
                    get paint() {
                        return Bm = Bm || new jn({
                            "hillshade-illumination-direction": new hr(xe.paint_hillshade["hillshade-illumination-direction"]),
                            "hillshade-illumination-altitude": new hr(xe.paint_hillshade["hillshade-illumination-altitude"]),
                            "hillshade-illumination-anchor": new hr(xe.paint_hillshade["hillshade-illumination-anchor"]),
                            "hillshade-exaggeration": new hr(xe.paint_hillshade["hillshade-exaggeration"]),
                            "hillshade-shadow-color": new hr(xe.paint_hillshade["hillshade-shadow-color"]),
                            "hillshade-highlight-color": new hr(xe.paint_hillshade["hillshade-highlight-color"]),
                            "hillshade-accent-color": new hr(xe.paint_hillshade["hillshade-accent-color"]),
                            "hillshade-method": new hr(xe.paint_hillshade["hillshade-method"])
                        })
                    }
                };
                class Gv extends ha {
                    constructor(t) {
                        super(t, $v),
                        this.recalculate({
                            zoom: 0,
                            zoomHistory: {}
                        }, void 0)
                    }
                    getIlluminationProperties() {
                        let t = this.paint.get("hillshade-illumination-direction").values
                          , r = this.paint.get("hillshade-illumination-altitude").values
                          , a = this.paint.get("hillshade-highlight-color").values
                          , c = this.paint.get("hillshade-shadow-color").values;
                        const p = Math.max(t.length, r.length, a.length, c.length);
                        t = t.concat(Array(p - t.length).fill(t.at(-1))),
                        r = r.concat(Array(p - r.length).fill(r.at(-1))),
                        a = a.concat(Array(p - a.length).fill(a.at(-1))),
                        c = c.concat(Array(p - c.length).fill(c.at(-1)));
                        const f = r.map(ur);
                        return {
                            directionRadians: t.map(ur),
                            altitudeRadians: f,
                            shadowColor: c,
                            highlightColor: a
                        }
                    }
                    hasOffscreenPass() {
                        return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
                    }
                }
                let Fm;
                var Hv = {
                    get paint() {
                        return Fm = Fm || new jn({
                            "color-relief-opacity": new hr(xe["paint_color-relief"]["color-relief-opacity"]),
                            "color-relief-color": new Pl(xe["paint_color-relief"]["color-relief-color"])
                        })
                    }
                };
                class Mp {
                    constructor(t, r, a, c) {
                        this.context = t,
                        this.format = a,
                        this.texture = t.gl.createTexture(),
                        this.update(r, c)
                    }
                    update(t, r, a) {
                        const {width: c, height: p} = t
                          , f = !(this.size && this.size[0] === c && this.size[1] === p || a)
                          , {context: g} = this
                          , {gl: v} = g;
                        if (this.useMipmap = !!(r && r.useMipmap),
                        v.bindTexture(v.TEXTURE_2D, this.texture),
                        g.pixelStoreUnpackFlipY.set(!1),
                        g.pixelStoreUnpack.set(1),
                        g.pixelStoreUnpackPremultiplyAlpha.set(this.format === v.RGBA && (!r || r.premultiply !== !1)),
                        f)
                            this.size = [c, p],
                            t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ar(t) ? v.texImage2D(v.TEXTURE_2D, 0, this.format, this.format, v.UNSIGNED_BYTE, t) : v.texImage2D(v.TEXTURE_2D, 0, this.format, c, p, 0, this.format, v.UNSIGNED_BYTE, t.data);
                        else {
                            const {x: S, y: I} = a || {
                                x: 0,
                                y: 0
                            };
                            t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ar(t) ? v.texSubImage2D(v.TEXTURE_2D, 0, S, I, v.RGBA, v.UNSIGNED_BYTE, t) : v.texSubImage2D(v.TEXTURE_2D, 0, S, I, c, p, v.RGBA, v.UNSIGNED_BYTE, t.data)
                        }
                        this.useMipmap && this.isSizePowerOfTwo() && v.generateMipmap(v.TEXTURE_2D),
                        g.pixelStoreUnpackFlipY.setDefault(),
                        g.pixelStoreUnpack.setDefault(),
                        g.pixelStoreUnpackPremultiplyAlpha.setDefault()
                    }
                    bind(t, r, a) {
                        const {context: c} = this
                          , {gl: p} = c;
                        p.bindTexture(p.TEXTURE_2D, this.texture),
                        a !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (a = p.LINEAR),
                        t !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, t),
                        p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, a || t),
                        this.filter = t),
                        r !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, r),
                        p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, r),
                        this.wrap = r)
                    }
                    isSizePowerOfTwo() {
                        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
                    }
                    destroy() {
                        const {gl: t} = this.context;
                        t.deleteTexture(this.texture),
                        this.texture = null
                    }
                }
                class Om {
                    constructor(t, r, a, c=1, p=1, f=1, g=0) {
                        if (this.uid = t,
                        r.height !== r.width)
                            throw new RangeError("DEM tiles must be square");
                        if (a && !["mapbox", "terrarium", "custom"].includes(a))
                            return void Lt(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
                        this.stride = r.height;
                        const v = this.dim = r.height - 2;
                        switch (this.data = new Uint32Array(r.data.buffer),
                        a) {
                        case "terrarium":
                            this.redFactor = 256,
                            this.greenFactor = 1,
                            this.blueFactor = 1 / 256,
                            this.baseShift = 32768;
                            break;
                        case "custom":
                            this.redFactor = c,
                            this.greenFactor = p,
                            this.blueFactor = f,
                            this.baseShift = g;
                            break;
                        default:
                            this.redFactor = 6553.6,
                            this.greenFactor = 25.6,
                            this.blueFactor = .1,
                            this.baseShift = 1e4
                        }
                        for (let S = 0; S < v; S++)
                            this.data[this._idx(-1, S)] = this.data[this._idx(0, S)],
                            this.data[this._idx(v, S)] = this.data[this._idx(v - 1, S)],
                            this.data[this._idx(S, -1)] = this.data[this._idx(S, 0)],
                            this.data[this._idx(S, v)] = this.data[this._idx(S, v - 1)];
                        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)],
                        this.data[this._idx(v, -1)] = this.data[this._idx(v - 1, 0)],
                        this.data[this._idx(-1, v)] = this.data[this._idx(0, v - 1)],
                        this.data[this._idx(v, v)] = this.data[this._idx(v - 1, v - 1)],
                        this.min = Number.MAX_SAFE_INTEGER,
                        this.max = Number.MIN_SAFE_INTEGER;
                        for (let S = 0; S < v; S++)
                            for (let I = 0; I < v; I++) {
                                const E = this.get(S, I);
                                E > this.max && (this.max = E),
                                E < this.min && (this.min = E)
                            }
                    }
                    get(t, r) {
                        const a = new Uint8Array(this.data.buffer)
                          , c = 4 * this._idx(t, r);
                        return this.unpack(a[c], a[c + 1], a[c + 2])
                    }
                    getUnpackVector() {
                        return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
                    }
                    _idx(t, r) {
                        if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1)
                            throw new RangeError("out of range source coordinates for DEM data");
                        return (r + 1) * this.stride + (t + 1)
                    }
                    unpack(t, r, a) {
                        return t * this.redFactor + r * this.greenFactor + a * this.blueFactor - this.baseShift
                    }
                    pack(t) {
                        return Nm(t, this.getUnpackVector())
                    }
                    getPixels() {
                        return new na({
                            width: this.stride,
                            height: this.stride
                        },new Uint8Array(this.data.buffer))
                    }
                    backfillBorder(t, r, a) {
                        if (this.dim !== t.dim)
                            throw new Error("dem dimension mismatch");
                        let c = r * this.dim
                          , p = r * this.dim + this.dim
                          , f = a * this.dim
                          , g = a * this.dim + this.dim;
                        switch (r) {
                        case -1:
                            c = p - 1;
                            break;
                        case 1:
                            p = c + 1
                        }
                        switch (a) {
                        case -1:
                            f = g - 1;
                            break;
                        case 1:
                            g = f + 1
                        }
                        const v = -r * this.dim
                          , S = -a * this.dim;
                        for (let I = f; I < g; I++)
                            for (let E = c; E < p; E++)
                                this.data[this._idx(E, I)] = t.data[this._idx(E + v, I + S)]
                    }
                }
                function Nm(i, t) {
                    const r = t[0]
                      , a = t[1]
                      , c = t[2]
                      , p = t[3]
                      , f = Math.min(r, a, c)
                      , g = Math.round((i + p) / f);
                    return {
                        r: Math.floor(g * f / r) % 256,
                        g: Math.floor(g * f / a) % 256,
                        b: Math.floor(g * f / c) % 256
                    }
                }
                Kt("DEMData", Om);
                class Wv extends ha {
                    constructor(t) {
                        super(t, Hv)
                    }
                    _createColorRamp(t) {
                        const r = {
                            elevationStops: [],
                            colorStops: []
                        }
                          , a = this._transitionablePaint._values["color-relief-color"].value.expression;
                        if (a instanceof So && a._styleExpression.expression instanceof In) {
                            this.colorRampExpression = a;
                            const f = a._styleExpression.expression;
                            r.elevationStops = f.labels,
                            r.colorStops = [];
                            for (const g of r.elevationStops)
                                r.colorStops.push(f.evaluate({
                                    globals: {
                                        elevation: g
                                    }
                                }))
                        }
                        if (r.elevationStops.length < 1 && (r.elevationStops = [0],
                        r.colorStops = [yr.transparent]),
                        r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1),
                        r.colorStops.push(r.colorStops[0])),
                        r.elevationStops.length <= t)
                            return r;
                        const c = {
                            elevationStops: [],
                            colorStops: []
                        }
                          , p = (r.elevationStops.length - 1) / (t - 1);
                        for (let f = 0; f < r.elevationStops.length - .5; f += p)
                            c.elevationStops.push(r.elevationStops[Math.round(f)]),
                            c.colorStops.push(r.colorStops[Math.round(f)]);
                        return Lt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`),
                        c
                    }
                    _colorRampChanged() {
                        return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
                    }
                    getColorRampTextures(t, r, a) {
                        if (this.colorRampTextures && !this._colorRampChanged())
                            return this.colorRampTextures;
                        const c = this._createColorRamp(r)
                          , p = new na({
                            width: c.colorStops.length,
                            height: 1
                        })
                          , f = new na({
                            width: c.colorStops.length,
                            height: 1
                        });
                        for (let g = 0; g < c.elevationStops.length; g++) {
                            const v = Nm(c.elevationStops[g], a);
                            f.setPixel(0, g, new yr(v.r / 255,v.g / 255,v.b / 255,1)),
                            p.setPixel(0, g, c.colorStops[g])
                        }
                        return this.colorRampTextures = {
                            elevationTexture: new Mp(t,f,t.gl.RGBA),
                            colorTexture: new Mp(t,p,t.gl.RGBA)
                        },
                        this.colorRampTextures
                    }
                    hasOffscreenPass() {
                        return this.visibility !== "none" && !!this.colorRampTextures
                    }
                }
                const Xv = Hi([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: Kv} = Xv;
                function Ap(i, t, r) {
                    const a = r.patternDependencies;
                    let c = !1;
                    for (const p of t) {
                        const f = p.paint.get(`${i}-pattern`);
                        f.isConstant() || (c = !0);
                        const g = f.constantOr(null);
                        g && (c = !0,
                        a[g.to] = !0,
                        a[g.from] = !0)
                    }
                    return c
                }
                function kp(i, t, r, a, c) {
                    const p = c.patternDependencies;
                    for (const f of t) {
                        const g = f.paint.get(`${i}-pattern`).value;
                        if (g.kind !== "constant") {
                            let v = g.evaluate({
                                zoom: a - 1
                            }, r, {}, c.availableImages)
                              , S = g.evaluate({
                                zoom: a
                            }, r, {}, c.availableImages)
                              , I = g.evaluate({
                                zoom: a + 1
                            }, r, {}, c.availableImages);
                            v = v && v.name ? v.name : v,
                            S = S && S.name ? S.name : S,
                            I = I && I.name ? I.name : I,
                            p[v] = !0,
                            p[S] = !0,
                            p[I] = !0,
                            r.patterns[f.id] = {
                                min: v,
                                mid: S,
                                max: I
                            }
                        }
                    }
                    return r
                }
                function jm(i, t, r, a, c) {
                    let p;
                    if (c === (function(f, g, v, S) {
                        let I = 0;
                        for (let E = g, R = v - S; E < v; E += S)
                            I += (f[R] - f[E]) * (f[E + 1] + f[R + 1]),
                            R = E;
                        return I
                    }
                    )(i, t, r, a) > 0)
                        for (let f = t; f < r; f += a)
                            p = Zm(f / a | 0, i[f], i[f + 1], p);
                    else
                        for (let f = r - a; f >= t; f -= a)
                            p = Zm(f / a | 0, i[f], i[f + 1], p);
                    return p && Ll(p, p.next) && (ou(p),
                    p = p.next),
                    p
                }
                function Bo(i, t) {
                    if (!i)
                        return i;
                    t || (t = i);
                    let r, a = i;
                    do
                        if (r = !1,
                        a.steiner || !Ll(a, a.next) && Yi(a.prev, a, a.next) !== 0)
                            a = a.next;
                        else {
                            if (ou(a),
                            a = t = a.prev,
                            a === a.next)
                                break;
                            r = !0
                        }
                    while (r || a !== t);
                    return t
                }
                function nu(i, t, r, a, c, p, f) {
                    if (!i)
                        return;
                    !f && p && (function(v, S, I, E) {
                        let R = v;
                        do
                            R.z === 0 && (R.z = Ep(R.x, R.y, S, I, E)),
                            R.prevZ = R.prev,
                            R.nextZ = R.next,
                            R = R.next;
                        while (R !== v);
                        R.prevZ.nextZ = null,
                        R.prevZ = null,
                        (function(N) {
                            let j, Z = 1;
                            do {
                                let Y, ae = N;
                                N = null;
                                let ze = null;
                                for (j = 0; ae; ) {
                                    j++;
                                    let me = ae
                                      , be = 0;
                                    for (let rt = 0; rt < Z && (be++,
                                    me = me.nextZ,
                                    me); rt++)
                                        ;
                                    let Ve = Z;
                                    for (; be > 0 || Ve > 0 && me; )
                                        be !== 0 && (Ve === 0 || !me || ae.z <= me.z) ? (Y = ae,
                                        ae = ae.nextZ,
                                        be--) : (Y = me,
                                        me = me.nextZ,
                                        Ve--),
                                        ze ? ze.nextZ = Y : N = Y,
                                        Y.prevZ = ze,
                                        ze = Y;
                                    ae = me
                                }
                                ze.nextZ = null,
                                Z *= 2
                            } while (j > 1)
                        }
                        )(R)
                    }
                    )(i, a, c, p);
                    let g = i;
                    for (; i.prev !== i.next; ) {
                        const v = i.prev
                          , S = i.next;
                        if (p ? Jv(i, a, c, p) : Yv(i))
                            t.push(v.i, i.i, S.i),
                            ou(i),
                            i = S.next,
                            g = S.next;
                        else if ((i = S) === g) {
                            f ? f === 1 ? nu(i = Qv(Bo(i), t), t, r, a, c, p, 2) : f === 2 && e0(i, t, r, a, c, p) : nu(Bo(i), t, r, a, c, p, 1);
                            break
                        }
                    }
                }
                function Yv(i) {
                    const t = i.prev
                      , r = i
                      , a = i.next;
                    if (Yi(t, r, a) >= 0)
                        return !1;
                    const c = t.x
                      , p = r.x
                      , f = a.x
                      , g = t.y
                      , v = r.y
                      , S = a.y
                      , I = Math.min(c, p, f)
                      , E = Math.min(g, v, S)
                      , R = Math.max(c, p, f)
                      , N = Math.max(g, v, S);
                    let j = a.next;
                    for (; j !== t; ) {
                        if (j.x >= I && j.x <= R && j.y >= E && j.y <= N && au(c, g, p, v, f, S, j.x, j.y) && Yi(j.prev, j, j.next) >= 0)
                            return !1;
                        j = j.next
                    }
                    return !0
                }
                function Jv(i, t, r, a) {
                    const c = i.prev
                      , p = i
                      , f = i.next;
                    if (Yi(c, p, f) >= 0)
                        return !1;
                    const g = c.x
                      , v = p.x
                      , S = f.x
                      , I = c.y
                      , E = p.y
                      , R = f.y
                      , N = Math.min(g, v, S)
                      , j = Math.min(I, E, R)
                      , Z = Math.max(g, v, S)
                      , Y = Math.max(I, E, R)
                      , ae = Ep(N, j, t, r, a)
                      , ze = Ep(Z, Y, t, r, a);
                    let me = i.prevZ
                      , be = i.nextZ;
                    for (; me && me.z >= ae && be && be.z <= ze; ) {
                        if (me.x >= N && me.x <= Z && me.y >= j && me.y <= Y && me !== c && me !== f && au(g, I, v, E, S, R, me.x, me.y) && Yi(me.prev, me, me.next) >= 0 || (me = me.prevZ,
                        be.x >= N && be.x <= Z && be.y >= j && be.y <= Y && be !== c && be !== f && au(g, I, v, E, S, R, be.x, be.y) && Yi(be.prev, be, be.next) >= 0))
                            return !1;
                        be = be.nextZ
                    }
                    for (; me && me.z >= ae; ) {
                        if (me.x >= N && me.x <= Z && me.y >= j && me.y <= Y && me !== c && me !== f && au(g, I, v, E, S, R, me.x, me.y) && Yi(me.prev, me, me.next) >= 0)
                            return !1;
                        me = me.prevZ
                    }
                    for (; be && be.z <= ze; ) {
                        if (be.x >= N && be.x <= Z && be.y >= j && be.y <= Y && be !== c && be !== f && au(g, I, v, E, S, R, be.x, be.y) && Yi(be.prev, be, be.next) >= 0)
                            return !1;
                        be = be.nextZ
                    }
                    return !0
                }
                function Qv(i, t) {
                    let r = i;
                    do {
                        const a = r.prev
                          , c = r.next.next;
                        !Ll(a, c) && Vm(a, r, r.next, c) && su(a, c) && su(c, a) && (t.push(a.i, r.i, c.i),
                        ou(r),
                        ou(r.next),
                        r = i = c),
                        r = r.next
                    } while (r !== i);
                    return Bo(r)
                }
                function e0(i, t, r, a, c, p) {
                    let f = i;
                    do {
                        let g = f.next.next;
                        for (; g !== f.prev; ) {
                            if (f.i !== g.i && a0(f, g)) {
                                let v = Um(f, g);
                                return f = Bo(f, f.next),
                                v = Bo(v, v.next),
                                nu(f, t, r, a, c, p, 0),
                                void nu(v, t, r, a, c, p, 0)
                            }
                            g = g.next
                        }
                        f = f.next
                    } while (f !== i)
                }
                function t0(i, t) {
                    let r = i.x - t.x;
                    return r === 0 && (r = i.y - t.y,
                    r === 0) && (r = (i.next.y - i.y) / (i.next.x - i.x) - (t.next.y - t.y) / (t.next.x - t.x)),
                    r
                }
                function r0(i, t) {
                    const r = (function(c, p) {
                        let f = p;
                        const g = c.x
                          , v = c.y;
                        let S, I = -1 / 0;
                        if (Ll(c, f))
                            return f;
                        do {
                            if (Ll(c, f.next))
                                return f.next;
                            if (v <= f.y && v >= f.next.y && f.next.y !== f.y) {
                                const Z = f.x + (v - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
                                if (Z <= g && Z > I && (I = Z,
                                S = f.x < f.next.x ? f : f.next,
                                Z === g))
                                    return S
                            }
                            f = f.next
                        } while (f !== p);
                        if (!S)
                            return null;
                        const E = S
                          , R = S.x
                          , N = S.y;
                        let j = 1 / 0;
                        f = S;
                        do {
                            if (g >= f.x && f.x >= R && g !== f.x && qm(v < N ? g : I, v, R, N, v < N ? I : g, v, f.x, f.y)) {
                                const Z = Math.abs(v - f.y) / (g - f.x);
                                su(f, c) && (Z < j || Z === j && (f.x > S.x || f.x === S.x && i0(S, f))) && (S = f,
                                j = Z)
                            }
                            f = f.next
                        } while (f !== E);
                        return S
                    }
                    )(i, t);
                    if (!r)
                        return t;
                    const a = Um(r, i);
                    return Bo(a, a.next),
                    Bo(r, r.next)
                }
                function i0(i, t) {
                    return Yi(i.prev, i, t.prev) < 0 && Yi(t.next, i, i.next) < 0
                }
                function Ep(i, t, r, a, c) {
                    return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - r) * c | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - a) * c | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
                }
                function n0(i) {
                    let t = i
                      , r = i;
                    do
                        (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t),
                        t = t.next;
                    while (t !== i);
                    return r
                }
                function qm(i, t, r, a, c, p, f, g) {
                    return (c - f) * (t - g) >= (i - f) * (p - g) && (i - f) * (a - g) >= (r - f) * (t - g) && (r - f) * (p - g) >= (c - f) * (a - g)
                }
                function au(i, t, r, a, c, p, f, g) {
                    return !(i === f && t === g) && qm(i, t, r, a, c, p, f, g)
                }
                function a0(i, t) {
                    return i.next.i !== t.i && i.prev.i !== t.i && !(function(r, a) {
                        let c = r;
                        do {
                            if (c.i !== r.i && c.next.i !== r.i && c.i !== a.i && c.next.i !== a.i && Vm(c, c.next, r, a))
                                return !0;
                            c = c.next
                        } while (c !== r);
                        return !1
                    }
                    )(i, t) && (su(i, t) && su(t, i) && (function(r, a) {
                        let c = r
                          , p = !1;
                        const f = (r.x + a.x) / 2
                          , g = (r.y + a.y) / 2;
                        do
                            c.y > g != c.next.y > g && c.next.y !== c.y && f < (c.next.x - c.x) * (g - c.y) / (c.next.y - c.y) + c.x && (p = !p),
                            c = c.next;
                        while (c !== r);
                        return p
                    }
                    )(i, t) && (Yi(i.prev, i, t.prev) || Yi(i, t.prev, t)) || Ll(i, t) && Yi(i.prev, i, i.next) > 0 && Yi(t.prev, t, t.next) > 0)
                }
                function Yi(i, t, r) {
                    return (t.y - i.y) * (r.x - t.x) - (t.x - i.x) * (r.y - t.y)
                }
                function Ll(i, t) {
                    return i.x === t.x && i.y === t.y
                }
                function Vm(i, t, r, a) {
                    const c = ld(Yi(i, t, r))
                      , p = ld(Yi(i, t, a))
                      , f = ld(Yi(r, a, i))
                      , g = ld(Yi(r, a, t));
                    return c !== p && f !== g || !(c !== 0 || !od(i, r, t)) || !(p !== 0 || !od(i, a, t)) || !(f !== 0 || !od(r, i, a)) || !(g !== 0 || !od(r, t, a))
                }
                function od(i, t, r) {
                    return t.x <= Math.max(i.x, r.x) && t.x >= Math.min(i.x, r.x) && t.y <= Math.max(i.y, r.y) && t.y >= Math.min(i.y, r.y)
                }
                function ld(i) {
                    return i > 0 ? 1 : i < 0 ? -1 : 0
                }
                function su(i, t) {
                    return Yi(i.prev, i, i.next) < 0 ? Yi(i, t, i.next) >= 0 && Yi(i, i.prev, t) >= 0 : Yi(i, t, i.prev) < 0 || Yi(i, i.next, t) < 0
                }
                function Um(i, t) {
                    const r = zp(i.i, i.x, i.y)
                      , a = zp(t.i, t.x, t.y)
                      , c = i.next
                      , p = t.prev;
                    return i.next = t,
                    t.prev = i,
                    r.next = c,
                    c.prev = r,
                    a.next = r,
                    r.prev = a,
                    p.next = a,
                    a.prev = p,
                    a
                }
                function Zm(i, t, r, a) {
                    const c = zp(i, t, r);
                    return a ? (c.next = a.next,
                    c.prev = a,
                    a.next.prev = c,
                    a.next = c) : (c.prev = c,
                    c.next = c),
                    c
                }
                function ou(i) {
                    i.next.prev = i.prev,
                    i.prev.next = i.next,
                    i.prevZ && (i.prevZ.nextZ = i.nextZ),
                    i.nextZ && (i.nextZ.prevZ = i.prevZ)
                }
                function zp(i, t, r) {
                    return {
                        i,
                        x: t,
                        y: r,
                        prev: null,
                        next: null,
                        z: 0,
                        prevZ: null,
                        nextZ: null,
                        steiner: !1
                    }
                }
                class Dl {
                    constructor(t, r) {
                        if (r > t)
                            throw new Error("Min granularity must not be greater than base granularity.");
                        this._baseZoomGranularity = t,
                        this._minGranularity = r
                    }
                    getGranularityForZoomLevel(t) {
                        return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
                    }
                }
                class cd {
                    constructor(t) {
                        this.fill = t.fill,
                        this.line = t.line,
                        this.tile = t.tile,
                        this.stencil = t.stencil,
                        this.circle = t.circle
                    }
                }
                cd.noSubdivision = new cd({
                    fill: new Dl(0,0),
                    line: new Dl(0,0),
                    tile: new Dl(0,0),
                    stencil: new Dl(0,0),
                    circle: 1
                }),
                Kt("SubdivisionGranularityExpression", Dl),
                Kt("SubdivisionGranularitySetting", cd);
                const Rl = -32768
                  , lu = 32767;
                class s0 {
                    constructor(t, r) {
                        this._vertexBuffer = [],
                        this._vertexDictionary = new Map,
                        this._used = !1,
                        this._granularity = t,
                        this._granularityCellSize = ne / t,
                        this._canonical = r
                    }
                    _getKey(t, r) {
                        return (t += 32768) << 16 | r + 32768
                    }
                    _vertexToIndex(t, r) {
                        if (t < -32768 || r < -32768 || t > 32767 || r > 32767)
                            throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
                        const a = 0 | Math.round(t)
                          , c = 0 | Math.round(r)
                          , p = this._getKey(a, c);
                        if (this._vertexDictionary.has(p))
                            return this._vertexDictionary.get(p);
                        const f = this._vertexBuffer.length / 2;
                        return this._vertexDictionary.set(p, f),
                        this._vertexBuffer.push(a, c),
                        f
                    }
                    _subdivideTrianglesScanline(t) {
                        if (this._granularity < 2)
                            return (function(c, p) {
                                const f = [];
                                for (let g = 0; g < p.length; g += 3) {
                                    const v = p[g]
                                      , S = p[g + 1]
                                      , I = p[g + 2]
                                      , E = c[2 * v]
                                      , R = c[2 * v + 1];
                                    (c[2 * S] - E) * (c[2 * I + 1] - R) - (c[2 * S + 1] - R) * (c[2 * I] - E) > 0 ? (f.push(v),
                                    f.push(I),
                                    f.push(S)) : (f.push(v),
                                    f.push(S),
                                    f.push(I))
                                }
                                return f
                            }
                            )(this._vertexBuffer, t);
                        const r = []
                          , a = t.length;
                        for (let c = 0; c < a; c += 3) {
                            const p = [t[c + 0], t[c + 1], t[c + 2]]
                              , f = [this._vertexBuffer[2 * t[c + 0] + 0], this._vertexBuffer[2 * t[c + 0] + 1], this._vertexBuffer[2 * t[c + 1] + 0], this._vertexBuffer[2 * t[c + 1] + 1], this._vertexBuffer[2 * t[c + 2] + 0], this._vertexBuffer[2 * t[c + 2] + 1]];
                            let g = 1 / 0
                              , v = 1 / 0
                              , S = -1 / 0
                              , I = -1 / 0;
                            for (let Z = 0; Z < 3; Z++) {
                                const Y = f[2 * Z]
                                  , ae = f[2 * Z + 1];
                                g = Math.min(g, Y),
                                S = Math.max(S, Y),
                                v = Math.min(v, ae),
                                I = Math.max(I, ae)
                            }
                            if (g === S || v === I)
                                continue;
                            const E = Math.floor(g / this._granularityCellSize)
                              , R = Math.ceil(S / this._granularityCellSize)
                              , N = Math.floor(v / this._granularityCellSize)
                              , j = Math.ceil(I / this._granularityCellSize);
                            if (E !== R || N !== j)
                                for (let Z = N; Z < j; Z++) {
                                    const Y = this._scanlineGenerateVertexRingForCellRow(Z, f, p);
                                    o0(this._vertexBuffer, Y, r)
                                }
                            else
                                r.push(...p)
                        }
                        return r
                    }
                    _scanlineGenerateVertexRingForCellRow(t, r, a) {
                        const c = t * this._granularityCellSize
                          , p = c + this._granularityCellSize
                          , f = [];
                        for (let g = 0; g < 3; g++) {
                            const v = r[2 * g]
                              , S = r[2 * g + 1]
                              , I = r[2 * (g + 1) % 6]
                              , E = r[(2 * (g + 1) + 1) % 6]
                              , R = r[2 * (g + 2) % 6]
                              , N = r[(2 * (g + 2) + 1) % 6]
                              , j = I - v
                              , Z = E - S
                              , Y = j === 0
                              , ae = Z === 0
                              , ze = (c - S) / Z
                              , me = (p - S) / Z
                              , be = Math.min(ze, me)
                              , Ve = Math.max(ze, me);
                            if (!ae && (be >= 1 || Ve <= 0) || ae && (S < c || S > p)) {
                                E >= c && E <= p && f.push(a[(g + 1) % 3]);
                                continue
                            }
                            !ae && be > 0 && f.push(this._vertexToIndex(v + j * be, S + Z * be));
                            const rt = v + j * Math.max(be, 0)
                              , St = v + j * Math.min(Ve, 1);
                            Y || this._generateIntraEdgeVertices(f, v, S, I, E, rt, St),
                            !ae && Ve < 1 && f.push(this._vertexToIndex(v + j * Ve, S + Z * Ve)),
                            (ae || E >= c && E <= p) && f.push(a[(g + 1) % 3]),
                            !ae && (E <= c || E >= p) && this._generateInterEdgeVertices(f, v, S, I, E, R, N, St, c, p)
                        }
                        return f
                    }
                    _generateIntraEdgeVertices(t, r, a, c, p, f, g) {
                        const v = c - r
                          , S = p - a
                          , I = S === 0
                          , E = I ? Math.min(r, c) : Math.min(f, g)
                          , R = I ? Math.max(r, c) : Math.max(f, g)
                          , N = Math.floor(E / this._granularityCellSize) + 1
                          , j = Math.ceil(R / this._granularityCellSize) - 1;
                        if (I ? r < c : f < g)
                            for (let Z = N; Z <= j; Z++) {
                                const Y = Z * this._granularityCellSize;
                                t.push(this._vertexToIndex(Y, a + S * (Y - r) / v))
                            }
                        else
                            for (let Z = j; Z >= N; Z--) {
                                const Y = Z * this._granularityCellSize;
                                t.push(this._vertexToIndex(Y, a + S * (Y - r) / v))
                            }
                    }
                    _generateInterEdgeVertices(t, r, a, c, p, f, g, v, S, I) {
                        const E = p - a
                          , R = f - c
                          , N = g - p
                          , j = (S - p) / N
                          , Z = (I - p) / N
                          , Y = Math.min(j, Z)
                          , ae = Math.max(j, Z)
                          , ze = c + R * Y;
                        let me = Math.floor(Math.min(ze, v) / this._granularityCellSize) + 1
                          , be = Math.ceil(Math.max(ze, v) / this._granularityCellSize) - 1
                          , Ve = v < ze;
                        const rt = N === 0;
                        if (rt && (g === S || g === I))
                            return;
                        if (rt || Y >= 1 || ae <= 0) {
                            const $t = a - g
                              , Bt = f + (r - f) * Math.min((S - g) / $t, (I - g) / $t);
                            me = Math.floor(Math.min(Bt, v) / this._granularityCellSize) + 1,
                            be = Math.ceil(Math.max(Bt, v) / this._granularityCellSize) - 1,
                            Ve = v < Bt
                        }
                        const St = E > 0 ? I : S;
                        if (Ve)
                            for (let $t = me; $t <= be; $t++)
                                t.push(this._vertexToIndex($t * this._granularityCellSize, St));
                        else
                            for (let $t = be; $t >= me; $t--)
                                t.push(this._vertexToIndex($t * this._granularityCellSize, St))
                    }
                    _generateOutline(t) {
                        const r = [];
                        for (const a of t) {
                            const c = Fo(a, this._granularity, !0)
                              , p = this._pointArrayToIndices(c)
                              , f = [];
                            for (let g = 1; g < p.length; g++)
                                f.push(p[g - 1]),
                                f.push(p[g]);
                            r.push(f)
                        }
                        return r
                    }
                    _handlePoles(t) {
                        let r = !1
                          , a = !1;
                        this._canonical && (this._canonical.y === 0 && (r = !0),
                        this._canonical.y === (1 << this._canonical.z) - 1 && (a = !0)),
                        (r || a) && this._fillPoles(t, r, a)
                    }
                    _ensureNoPoleVertices() {
                        const t = this._vertexBuffer;
                        for (let r = 0; r < t.length; r += 2) {
                            const a = t[r + 1];
                            a === Rl && (t[r + 1] = -32767),
                            a === lu && (t[r + 1] = 32766)
                        }
                    }
                    _generatePoleQuad(t, r, a, c, p, f) {
                        c > p != (f === Rl) ? (t.push(r),
                        t.push(a),
                        t.push(this._vertexToIndex(c, f)),
                        t.push(a),
                        t.push(this._vertexToIndex(p, f)),
                        t.push(this._vertexToIndex(c, f))) : (t.push(a),
                        t.push(r),
                        t.push(this._vertexToIndex(c, f)),
                        t.push(this._vertexToIndex(p, f)),
                        t.push(a),
                        t.push(this._vertexToIndex(c, f)))
                    }
                    _fillPoles(t, r, a) {
                        const c = this._vertexBuffer
                          , p = ne
                          , f = t.length;
                        for (let g = 2; g < f; g += 3) {
                            const v = t[g - 2]
                              , S = t[g - 1]
                              , I = t[g]
                              , E = c[2 * v]
                              , R = c[2 * v + 1]
                              , N = c[2 * S]
                              , j = c[2 * S + 1]
                              , Z = c[2 * I]
                              , Y = c[2 * I + 1];
                            r && (R === 0 && j === 0 && this._generatePoleQuad(t, v, S, E, N, Rl),
                            j === 0 && Y === 0 && this._generatePoleQuad(t, S, I, N, Z, Rl),
                            Y === 0 && R === 0 && this._generatePoleQuad(t, I, v, Z, E, Rl)),
                            a && (R === p && j === p && this._generatePoleQuad(t, v, S, E, N, lu),
                            j === p && Y === p && this._generatePoleQuad(t, S, I, N, Z, lu),
                            Y === p && R === p && this._generatePoleQuad(t, I, v, Z, E, lu))
                        }
                    }
                    _initializeVertices(t) {
                        for (let r = 0; r < t.length; r += 2)
                            this._vertexToIndex(t[r], t[r + 1])
                    }
                    subdividePolygonInternal(t, r) {
                        if (this._used)
                            throw new Error("Subdivision: multiple use not allowed.");
                        this._used = !0;
                        const {flattened: a, holeIndices: c} = (function(g) {
                            const v = []
                              , S = [];
                            for (const I of g)
                                if (I.length !== 0) {
                                    I !== g[0] && v.push(S.length / 2);
                                    for (let E = 0; E < I.length; E++)
                                        S.push(I[E].x),
                                        S.push(I[E].y)
                                }
                            return {
                                flattened: S,
                                holeIndices: v
                            }
                        }
                        )(t);
                        let p;
                        this._initializeVertices(a);
                        try {
                            const g = (function(S, I, E=2) {
                                const R = I && I.length
                                  , N = R ? I[0] * E : S.length;
                                let j = jm(S, 0, N, E, !0);
                                const Z = [];
                                if (!j || j.next === j.prev)
                                    return Z;
                                let Y, ae, ze;
                                if (R && (j = (function(me, be, Ve, rt) {
                                    const St = [];
                                    for (let $t = 0, Bt = be.length; $t < Bt; $t++) {
                                        const Ut = jm(me, be[$t] * rt, $t < Bt - 1 ? be[$t + 1] * rt : me.length, rt, !1);
                                        Ut === Ut.next && (Ut.steiner = !0),
                                        St.push(n0(Ut))
                                    }
                                    St.sort(t0);
                                    for (let $t = 0; $t < St.length; $t++)
                                        Ve = r0(St[$t], Ve);
                                    return Ve
                                }
                                )(S, I, j, E)),
                                S.length > 80 * E) {
                                    Y = S[0],
                                    ae = S[1];
                                    let me = Y
                                      , be = ae;
                                    for (let Ve = E; Ve < N; Ve += E) {
                                        const rt = S[Ve]
                                          , St = S[Ve + 1];
                                        rt < Y && (Y = rt),
                                        St < ae && (ae = St),
                                        rt > me && (me = rt),
                                        St > be && (be = St)
                                    }
                                    ze = Math.max(me - Y, be - ae),
                                    ze = ze !== 0 ? 32767 / ze : 0
                                }
                                return nu(j, Z, E, Y, ae, ze, 0),
                                Z
                            }
                            )(a, c)
                              , v = this._convertIndices(a, g);
                            p = this._subdivideTrianglesScanline(v)
                        } catch (g) {
                            console.error(g)
                        }
                        let f = [];
                        return r && (f = this._generateOutline(t)),
                        this._ensureNoPoleVertices(),
                        this._handlePoles(p),
                        {
                            verticesFlattened: this._vertexBuffer,
                            indicesTriangles: p,
                            indicesLineList: f
                        }
                    }
                    _convertIndices(t, r) {
                        const a = [];
                        for (let c = 0; c < r.length; c++)
                            a.push(this._vertexToIndex(t[2 * r[c]], t[2 * r[c] + 1]));
                        return a
                    }
                    _pointArrayToIndices(t) {
                        const r = [];
                        for (let a = 0; a < t.length; a++) {
                            const c = t[a];
                            r.push(this._vertexToIndex(c.x, c.y))
                        }
                        return r
                    }
                }
                function $m(i, t, r, a=!0) {
                    return new s0(r,t).subdividePolygonInternal(i, a)
                }
                function Fo(i, t, r=!1) {
                    if (!i || i.length < 1)
                        return [];
                    if (i.length < 2)
                        return [];
                    const a = i[0]
                      , c = i[i.length - 1]
                      , p = r && (a.x !== c.x || a.y !== c.y);
                    if (t < 2)
                        return p ? [...i, i[0]] : [...i];
                    const f = Math.floor(ne / t)
                      , g = [];
                    g.push(new $(i[0].x,i[0].y));
                    const v = i.length
                      , S = p ? v : v - 1;
                    for (let I = 0; I < S; I++) {
                        const E = i[I]
                          , R = I < v - 1 ? i[I + 1] : i[0]
                          , N = E.x
                          , j = E.y
                          , Z = R.x
                          , Y = R.y
                          , ae = N !== Z
                          , ze = j !== Y;
                        if (!ae && !ze)
                            continue;
                        const me = Z - N
                          , be = Y - j
                          , Ve = Math.abs(me)
                          , rt = Math.abs(be);
                        let St = N
                          , $t = j;
                        for (; ; ) {
                            const Ut = me > 0 ? (Math.floor(St / f) + 1) * f : (Math.ceil(St / f) - 1) * f
                              , pr = be > 0 ? (Math.floor($t / f) + 1) * f : (Math.ceil($t / f) - 1) * f
                              , Vt = Math.abs(St - Ut)
                              , Zt = Math.abs($t - pr)
                              , mt = Math.abs(St - Z)
                              , Br = Math.abs($t - Y)
                              , Ur = ae ? Vt / Ve : Number.POSITIVE_INFINITY
                              , xr = ze ? Zt / rt : Number.POSITIVE_INFINITY;
                            if ((mt <= Vt || !ae) && (Br <= Zt || !ze))
                                break;
                            if (Ur < xr && ae || !ze) {
                                St = Ut,
                                $t += be * Ur;
                                const or = new $(St,Math.round($t));
                                g[g.length - 1].x === or.x && g[g.length - 1].y === or.y || g.push(or)
                            } else {
                                St += me * xr,
                                $t = pr;
                                const or = new $(Math.round(St),$t);
                                g[g.length - 1].x === or.x && g[g.length - 1].y === or.y || g.push(or)
                            }
                        }
                        const Bt = new $(Z,Y);
                        g[g.length - 1].x === Bt.x && g[g.length - 1].y === Bt.y || g.push(Bt)
                    }
                    return g
                }
                function o0(i, t, r) {
                    if (t.length === 0)
                        throw new Error("Subdivision vertex ring is empty.");
                    let a = 0
                      , c = i[2 * t[0]];
                    for (let v = 1; v < t.length; v++) {
                        const S = i[2 * t[v]];
                        S < c && (c = S,
                        a = v)
                    }
                    const p = t.length;
                    let f = a
                      , g = (f + 1) % p;
                    for (; ; ) {
                        const v = f - 1 >= 0 ? f - 1 : p - 1
                          , S = (g + 1) % p
                          , I = i[2 * t[v]]
                          , E = i[2 * t[S]]
                          , R = i[2 * t[f]]
                          , N = i[2 * t[f] + 1]
                          , j = i[2 * t[g] + 1];
                        let Z = !1;
                        if (I < E)
                            Z = !0;
                        else if (I > E)
                            Z = !1;
                        else {
                            const Y = j - N
                              , ae = -(i[2 * t[g]] - R)
                              , ze = N < j ? 1 : -1;
                            ((I - R) * Y + (i[2 * t[v] + 1] - N) * ae) * ze > ((E - R) * Y + (i[2 * t[S] + 1] - N) * ae) * ze && (Z = !0)
                        }
                        if (Z) {
                            const Y = t[v]
                              , ae = t[f]
                              , ze = t[g];
                            Y !== ae && Y !== ze && ae !== ze && r.push(ze, ae, Y),
                            f--,
                            f < 0 && (f = p - 1)
                        } else {
                            const Y = t[S]
                              , ae = t[f]
                              , ze = t[g];
                            Y !== ae && Y !== ze && ae !== ze && r.push(ze, ae, Y),
                            g++,
                            g >= p && (g = 0)
                        }
                        if (v === S)
                            break
                    }
                }
                function Gm(i, t, r, a, c, p, f, g, v) {
                    const S = c.length / 2
                      , I = f && g && v;
                    if (S < Wr.MAX_VERTEX_ARRAY_LENGTH) {
                        const E = t.prepareSegment(S, r, a)
                          , R = E.vertexLength;
                        for (let Z = 0; Z < p.length; Z += 3)
                            a.emplaceBack(R + p[Z], R + p[Z + 1], R + p[Z + 2]);
                        let N, j;
                        E.vertexLength += S,
                        E.primitiveLength += p.length / 3,
                        I && (j = f.prepareSegment(S, r, g),
                        N = j.vertexLength,
                        j.vertexLength += S);
                        for (let Z = 0; Z < c.length; Z += 2)
                            i(c[Z], c[Z + 1]);
                        if (I)
                            for (let Z = 0; Z < v.length; Z++) {
                                const Y = v[Z];
                                for (let ae = 1; ae < Y.length; ae += 2)
                                    g.emplaceBack(N + Y[ae - 1], N + Y[ae]);
                                j.primitiveLength += Y.length / 2
                            }
                    } else
                        (function(E, R, N, j, Z, Y) {
                            const ae = [];
                            for (let rt = 0; rt < j.length / 2; rt++)
                                ae.push(-1);
                            const ze = {
                                count: 0
                            };
                            let me = 0
                              , be = E.getOrCreateLatestSegment(R, N)
                              , Ve = be.vertexLength;
                            for (let rt = 2; rt < Z.length; rt += 3) {
                                const St = Z[rt - 2]
                                  , $t = Z[rt - 1]
                                  , Bt = Z[rt];
                                let Ut = ae[St] < me
                                  , pr = ae[$t] < me
                                  , Vt = ae[Bt] < me;
                                be.vertexLength + ((Ut ? 1 : 0) + (pr ? 1 : 0) + (Vt ? 1 : 0)) > Wr.MAX_VERTEX_ARRAY_LENGTH && (be = E.createNewSegment(R, N),
                                me = ze.count,
                                Ut = !0,
                                pr = !0,
                                Vt = !0,
                                Ve = 0);
                                const Zt = cu(ae, j, Y, ze, St, Ut, be)
                                  , mt = cu(ae, j, Y, ze, $t, pr, be)
                                  , Br = cu(ae, j, Y, ze, Bt, Vt, be);
                                N.emplaceBack(Ve + Zt - me, Ve + mt - me, Ve + Br - me),
                                be.primitiveLength++
                            }
                        }
                        )(t, r, a, c, p, i),
                        I && (function(E, R, N, j, Z, Y) {
                            const ae = [];
                            for (let rt = 0; rt < j.length / 2; rt++)
                                ae.push(-1);
                            const ze = {
                                count: 0
                            };
                            let me = 0
                              , be = E.getOrCreateLatestSegment(R, N)
                              , Ve = be.vertexLength;
                            for (let rt = 0; rt < Z.length; rt++) {
                                const St = Z[rt];
                                for (let $t = 1; $t < Z[rt].length; $t += 2) {
                                    const Bt = St[$t - 1]
                                      , Ut = St[$t];
                                    let pr = ae[Bt] < me
                                      , Vt = ae[Ut] < me;
                                    be.vertexLength + ((pr ? 1 : 0) + (Vt ? 1 : 0)) > Wr.MAX_VERTEX_ARRAY_LENGTH && (be = E.createNewSegment(R, N),
                                    me = ze.count,
                                    pr = !0,
                                    Vt = !0,
                                    Ve = 0);
                                    const Zt = cu(ae, j, Y, ze, Bt, pr, be)
                                      , mt = cu(ae, j, Y, ze, Ut, Vt, be);
                                    N.emplaceBack(Ve + Zt - me, Ve + mt - me),
                                    be.primitiveLength++
                                }
                            }
                        }
                        )(f, r, g, c, v, i),
                        t.forceNewSegmentOnNextPrepare(),
                        f == null || f.forceNewSegmentOnNextPrepare()
                }
                function cu(i, t, r, a, c, p, f) {
                    if (p) {
                        const g = a.count;
                        return r(t[2 * c], t[2 * c + 1]),
                        i[c] = a.count,
                        a.count++,
                        f.vertexLength++,
                        g
                    }
                    return i[c]
                }
                class Lp {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((r => r.id)),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.layoutVertexArray = new He,
                        this.indexArray = new ki,
                        this.indexArray2 = new Pi,
                        this.programConfigurations = new ia(t.layers,t.zoom),
                        this.segments = new Wr,
                        this.segments2 = new Wr,
                        this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
                    }
                    populate(t, r, a) {
                        this.hasPattern = Ap("fill", this.layers, r);
                        const c = this.layers[0].layout.get("fill-sort-key")
                          , p = !c.isConstant()
                          , f = [];
                        for (const {feature: g, id: v, index: S, sourceLayerIndex: I} of t) {
                            const E = this.layers[0]._featureFilter.needGeometry
                              , R = Wa(g, E);
                            if (!this.layers[0]._featureFilter.filter(new Oi(this.zoom,{
                                globalState: this.globalState
                            }), R, a))
                                continue;
                            const N = p ? c.evaluate(R, {}, a, r.availableImages) : void 0
                              , j = {
                                id: v,
                                properties: g.properties,
                                type: g.type,
                                sourceLayerIndex: I,
                                index: S,
                                geometry: E ? R.geometry : cs(g),
                                patterns: {},
                                sortKey: N
                            };
                            f.push(j)
                        }
                        p && f.sort(( (g, v) => g.sortKey - v.sortKey));
                        for (const g of f) {
                            const {geometry: v, index: S, sourceLayerIndex: I} = g;
                            if (this.hasPattern) {
                                const E = kp("fill", this.layers, g, this.zoom, r);
                                this.patternFeatures.push(E)
                            } else
                                this.addFeature(g, v, S, a, {}, r.subdivisionGranularity);
                            r.featureIndex.insert(t[S].feature, v, S, I, this.index)
                        }
                    }
                    update(t, r, a) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
                    }
                    addFeatures(t, r, a) {
                        for (const c of this.patternFeatures)
                            this.addFeature(c, c.geometry, c.index, r, a, t.subdivisionGranularity)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Kv),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.indexBuffer2.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.segments2.destroy())
                    }
                    addFeature(t, r, a, c, p, f) {
                        for (const g of xo(r, 500)) {
                            const v = $m(g, c, f.fill.getGranularityForZoomLevel(c.z))
                              , S = this.layoutVertexArray;
                            Gm(( (I, E) => {
                                S.emplaceBack(I, E)
                            }
                            ), this.segments, this.layoutVertexArray, this.indexArray, v.verticesFlattened, v.indicesTriangles, this.segments2, this.indexArray2, v.indicesLineList)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, c)
                    }
                }
                let Hm, Wm;
                Kt("FillBucket", Lp, {
                    omit: ["layers", "patternFeatures"]
                });
                var l0 = {
                    get paint() {
                        return Wm = Wm || new jn({
                            "fill-antialias": new hr(xe.paint_fill["fill-antialias"]),
                            "fill-opacity": new Rr(xe.paint_fill["fill-opacity"]),
                            "fill-color": new Rr(xe.paint_fill["fill-color"]),
                            "fill-outline-color": new Rr(xe.paint_fill["fill-outline-color"]),
                            "fill-translate": new hr(xe.paint_fill["fill-translate"]),
                            "fill-translate-anchor": new hr(xe.paint_fill["fill-translate-anchor"]),
                            "fill-pattern": new Sl(xe.paint_fill["fill-pattern"])
                        })
                    },
                    get layout() {
                        return Hm = Hm || new jn({
                            "fill-sort-key": new Rr(xe.layout_fill["fill-sort-key"])
                        })
                    }
                };
                class c0 extends ha {
                    constructor(t) {
                        super(t, l0)
                    }
                    recalculate(t, r) {
                        super.recalculate(t, r);
                        const a = this.paint._values["fill-outline-color"];
                        a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                    }
                    createBucket(t) {
                        return new Lp(t)
                    }
                    queryRadius() {
                        return ad(this.paint.get("fill-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: t, geometry: r, transform: a, pixelsToTileUnits: c}) {
                        return Pm(sd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -a.bearingInRadians, c), r)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                const u0 = Hi([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_normal_ed",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , h0 = Hi([{
                    name: "a_centroid",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: d0} = u0;
                class Bl {
                    constructor(t, r, a, c, p) {
                        this.properties = {},
                        this.extent = a,
                        this.type = 0,
                        this.id = void 0,
                        this._pbf = t,
                        this._geometry = -1,
                        this._keys = c,
                        this._values = p,
                        t.readFields(p0, this, r)
                    }
                    loadGeometry() {
                        const t = this._pbf;
                        t.pos = this._geometry;
                        const r = t.readVarint() + t.pos
                          , a = [];
                        let c, p = 1, f = 0, g = 0, v = 0;
                        for (; t.pos < r; ) {
                            if (f <= 0) {
                                const S = t.readVarint();
                                p = 7 & S,
                                f = S >> 3
                            }
                            if (f--,
                            p === 1 || p === 2)
                                g += t.readSVarint(),
                                v += t.readSVarint(),
                                p === 1 && (c && a.push(c),
                                c = []),
                                c && c.push(new $(g,v));
                            else {
                                if (p !== 7)
                                    throw new Error(`unknown command ${p}`);
                                c && c.push(c[0].clone())
                            }
                        }
                        return c && a.push(c),
                        a
                    }
                    bbox() {
                        const t = this._pbf;
                        t.pos = this._geometry;
                        const r = t.readVarint() + t.pos;
                        let a = 1
                          , c = 0
                          , p = 0
                          , f = 0
                          , g = 1 / 0
                          , v = -1 / 0
                          , S = 1 / 0
                          , I = -1 / 0;
                        for (; t.pos < r; ) {
                            if (c <= 0) {
                                const E = t.readVarint();
                                a = 7 & E,
                                c = E >> 3
                            }
                            if (c--,
                            a === 1 || a === 2)
                                p += t.readSVarint(),
                                f += t.readSVarint(),
                                p < g && (g = p),
                                p > v && (v = p),
                                f < S && (S = f),
                                f > I && (I = f);
                            else if (a !== 7)
                                throw new Error(`unknown command ${a}`)
                        }
                        return [g, S, v, I]
                    }
                    toGeoJSON(t, r, a) {
                        const c = this.extent * Math.pow(2, a)
                          , p = this.extent * t
                          , f = this.extent * r
                          , g = this.loadGeometry();
                        function v(R) {
                            return [360 * (R.x + p) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (R.y + f) / c) * Math.PI)) - 90]
                        }
                        function S(R) {
                            return R.map(v)
                        }
                        let I;
                        if (this.type === 1) {
                            const R = [];
                            for (const j of g)
                                R.push(j[0]);
                            const N = S(R);
                            I = R.length === 1 ? {
                                type: "Point",
                                coordinates: N[0]
                            } : {
                                type: "MultiPoint",
                                coordinates: N
                            }
                        } else if (this.type === 2) {
                            const R = g.map(S);
                            I = R.length === 1 ? {
                                type: "LineString",
                                coordinates: R[0]
                            } : {
                                type: "MultiLineString",
                                coordinates: R
                            }
                        } else {
                            if (this.type !== 3)
                                throw new Error("unknown feature type");
                            {
                                const R = (function(j) {
                                    const Z = j.length;
                                    if (Z <= 1)
                                        return [j];
                                    const Y = [];
                                    let ae, ze;
                                    for (let me = 0; me < Z; me++) {
                                        const be = f0(j[me]);
                                        be !== 0 && (ze === void 0 && (ze = be < 0),
                                        ze === be < 0 ? (ae && Y.push(ae),
                                        ae = [j[me]]) : ae && ae.push(j[me]))
                                    }
                                    return ae && Y.push(ae),
                                    Y
                                }
                                )(g)
                                  , N = [];
                                for (const j of R)
                                    N.push(j.map(S));
                                I = N.length === 1 ? {
                                    type: "Polygon",
                                    coordinates: N[0]
                                } : {
                                    type: "MultiPolygon",
                                    coordinates: N
                                }
                            }
                        }
                        const E = {
                            type: "Feature",
                            geometry: I,
                            properties: this.properties
                        };
                        return this.id != null && (E.id = this.id),
                        E
                    }
                }
                function p0(i, t, r) {
                    i === 1 ? t.id = r.readVarint() : i === 2 ? (function(a, c) {
                        const p = a.readVarint() + a.pos;
                        for (; a.pos < p; ) {
                            const f = c._keys[a.readVarint()]
                              , g = c._values[a.readVarint()];
                            c.properties[f] = g
                        }
                    }
                    )(r, t) : i === 3 ? t.type = r.readVarint() : i === 4 && (t._geometry = r.pos)
                }
                function f0(i) {
                    let t = 0;
                    for (let r, a, c = 0, p = i.length, f = p - 1; c < p; f = c++)
                        r = i[c],
                        a = i[f],
                        t += (a.x - r.x) * (r.y + a.y);
                    return t
                }
                Bl.types = ["Unknown", "Point", "LineString", "Polygon"];
                class Xm {
                    constructor(t, r) {
                        this.version = 1,
                        this.name = "",
                        this.extent = 4096,
                        this.length = 0,
                        this._pbf = t,
                        this._keys = [],
                        this._values = [],
                        this._features = [],
                        t.readFields(m0, this, r),
                        this.length = this._features.length
                    }
                    feature(t) {
                        if (t < 0 || t >= this._features.length)
                            throw new Error("feature index out of bounds");
                        this._pbf.pos = this._features[t];
                        const r = this._pbf.readVarint() + this._pbf.pos;
                        return new Bl(this._pbf,r,this.extent,this._keys,this._values)
                    }
                }
                function m0(i, t, r) {
                    i === 15 ? t.version = r.readVarint() : i === 1 ? t.name = r.readString() : i === 5 ? t.extent = r.readVarint() : i === 2 ? t._features.push(r.pos) : i === 3 ? t._keys.push(r.readString()) : i === 4 && t._values.push((function(a) {
                        let c = null;
                        const p = a.readVarint() + a.pos;
                        for (; a.pos < p; ) {
                            const f = a.readVarint() >> 3;
                            c = f === 1 ? a.readString() : f === 2 ? a.readFloat() : f === 3 ? a.readDouble() : f === 4 ? a.readVarint64() : f === 5 ? a.readVarint() : f === 6 ? a.readSVarint() : f === 7 ? a.readBoolean() : null
                        }
                        if (c == null)
                            throw new Error("unknown feature value");
                        return c
                    }
                    )(r))
                }
                class Km {
                    constructor(t, r) {
                        this.layers = t.readFields(_0, {}, r)
                    }
                }
                function _0(i, t, r) {
                    if (i === 3) {
                        const a = new Xm(r,r.readVarint() + r.pos);
                        a.length && (t[a.name] = a)
                    }
                }
                const Dp = Math.pow(2, 13);
                function uu(i, t, r, a, c, p, f, g) {
                    i.emplaceBack(t, r, 2 * Math.floor(a * Dp) + f, c * Dp * 2, p * Dp * 2, Math.round(g))
                }
                class Rp {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((r => r.id)),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.layoutVertexArray = new je,
                        this.centroidVertexArray = new he,
                        this.indexArray = new ki,
                        this.programConfigurations = new ia(t.layers,t.zoom),
                        this.segments = new Wr,
                        this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
                    }
                    populate(t, r, a) {
                        this.features = [],
                        this.hasPattern = Ap("fill-extrusion", this.layers, r);
                        for (const {feature: c, id: p, index: f, sourceLayerIndex: g} of t) {
                            const v = this.layers[0]._featureFilter.needGeometry
                              , S = Wa(c, v);
                            if (!this.layers[0]._featureFilter.filter(new Oi(this.zoom,{
                                globalState: this.globalState
                            }), S, a))
                                continue;
                            const I = {
                                id: p,
                                sourceLayerIndex: g,
                                index: f,
                                geometry: v ? S.geometry : cs(c),
                                properties: c.properties,
                                type: c.type,
                                patterns: {}
                            };
                            this.hasPattern ? this.features.push(kp("fill-extrusion", this.layers, I, this.zoom, r)) : this.addFeature(I, I.geometry, f, a, {}, r.subdivisionGranularity),
                            r.featureIndex.insert(c, I.geometry, f, g, this.index, !0)
                        }
                    }
                    addFeatures(t, r, a) {
                        for (const c of this.features) {
                            const {geometry: p} = c;
                            this.addFeature(c, p, c.index, r, a, t.subdivisionGranularity)
                        }
                    }
                    update(t, r, a) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, d0),
                        this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, h0.members, !0),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.centroidVertexBuffer.destroy())
                    }
                    addFeature(t, r, a, c, p, f) {
                        for (const g of xo(r, 500)) {
                            const v = {
                                x: 0,
                                y: 0,
                                sampleCount: 0
                            }
                              , S = this.layoutVertexArray.length;
                            this.processPolygon(v, c, t, g, f);
                            const I = this.layoutVertexArray.length - S
                              , E = Math.floor(v.x / v.sampleCount)
                              , R = Math.floor(v.y / v.sampleCount);
                            for (let N = 0; N < I; N++)
                                this.centroidVertexArray.emplaceBack(E, R)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, c)
                    }
                    processPolygon(t, r, a, c, p) {
                        if (c.length < 1 || Ym(c[0]))
                            return;
                        for (const E of c)
                            E.length !== 0 && g0(t, E);
                        const f = {
                            segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
                        }
                          , g = p.fill.getGranularityForZoomLevel(r.z)
                          , v = Bl.types[a.type] === "Polygon";
                        for (const E of c) {
                            if (E.length === 0 || Ym(E))
                                continue;
                            const R = Fo(E, g, v);
                            this._generateSideFaces(R, f)
                        }
                        if (!v)
                            return;
                        const S = $m(c, r, g, !1)
                          , I = this.layoutVertexArray;
                        Gm(( (E, R) => {
                            uu(I, E, R, 0, 0, 1, 1, 0)
                        }
                        ), this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles)
                    }
                    _generateSideFaces(t, r) {
                        let a = 0;
                        for (let c = 1; c < t.length; c++) {
                            const p = t[c]
                              , f = t[c - 1];
                            if (v0(p, f))
                                continue;
                            r.segment.vertexLength + 4 > Wr.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                            const g = p.sub(f)._perp()._unit()
                              , v = f.dist(p);
                            a + v > 32768 && (a = 0),
                            uu(this.layoutVertexArray, p.x, p.y, g.x, g.y, 0, 0, a),
                            uu(this.layoutVertexArray, p.x, p.y, g.x, g.y, 0, 1, a),
                            a += v,
                            uu(this.layoutVertexArray, f.x, f.y, g.x, g.y, 0, 0, a),
                            uu(this.layoutVertexArray, f.x, f.y, g.x, g.y, 0, 1, a);
                            const S = r.segment.vertexLength;
                            this.indexArray.emplaceBack(S, S + 2, S + 1),
                            this.indexArray.emplaceBack(S + 1, S + 2, S + 3),
                            r.segment.vertexLength += 4,
                            r.segment.primitiveLength += 2
                        }
                    }
                }
                function g0(i, t) {
                    for (let r = 0; r < t.length; r++) {
                        const a = t[r];
                        r === t.length - 1 && t[0].x === a.x && t[0].y === a.y || (i.x += a.x,
                        i.y += a.y,
                        i.sampleCount++)
                    }
                }
                function v0(i, t) {
                    return i.x === t.x && (i.x < 0 || i.x > ne) || i.y === t.y && (i.y < 0 || i.y > ne)
                }
                function Ym(i) {
                    return i.every((t => t.x < 0)) || i.every((t => t.x > ne)) || i.every((t => t.y < 0)) || i.every((t => t.y > ne))
                }
                let Jm;
                Kt("FillExtrusionBucket", Rp, {
                    omit: ["layers", "features"]
                });
                var y0 = {
                    get paint() {
                        return Jm = Jm || new jn({
                            "fill-extrusion-opacity": new hr(xe["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                            "fill-extrusion-color": new Rr(xe["paint_fill-extrusion"]["fill-extrusion-color"]),
                            "fill-extrusion-translate": new hr(xe["paint_fill-extrusion"]["fill-extrusion-translate"]),
                            "fill-extrusion-translate-anchor": new hr(xe["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                            "fill-extrusion-pattern": new Sl(xe["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                            "fill-extrusion-height": new Rr(xe["paint_fill-extrusion"]["fill-extrusion-height"]),
                            "fill-extrusion-base": new Rr(xe["paint_fill-extrusion"]["fill-extrusion-base"]),
                            "fill-extrusion-vertical-gradient": new hr(xe["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
                        })
                    }
                };
                class x0 extends ha {
                    constructor(t) {
                        super(t, y0)
                    }
                    createBucket(t) {
                        return new Rp(t)
                    }
                    queryRadius() {
                        return ad(this.paint.get("fill-extrusion-translate"))
                    }
                    is3D() {
                        return !0
                    }
                    queryIntersectsFeature({queryGeometry: t, feature: r, featureState: a, geometry: c, transform: p, pixelsToTileUnits: f, pixelPosMatrix: g}) {
                        const v = sd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, f)
                          , S = this.paint.get("fill-extrusion-height").evaluate(r, a)
                          , I = this.paint.get("fill-extrusion-base").evaluate(r, a)
                          , E = (function(N, j) {
                            const Z = [];
                            for (const Y of N) {
                                const ae = [Y.x, Y.y, 0, 1];
                                Ae(ae, ae, j),
                                Z.push(new $(ae[0] / ae[3],ae[1] / ae[3]))
                            }
                            return Z
                        }
                        )(v, g)
                          , R = (function(N, j, Z, Y) {
                            const ae = []
                              , ze = []
                              , me = Y[8] * j
                              , be = Y[9] * j
                              , Ve = Y[10] * j
                              , rt = Y[11] * j
                              , St = Y[8] * Z
                              , $t = Y[9] * Z
                              , Bt = Y[10] * Z
                              , Ut = Y[11] * Z;
                            for (const pr of N) {
                                const Vt = []
                                  , Zt = [];
                                for (const mt of pr) {
                                    const Br = mt.x
                                      , Ur = mt.y
                                      , xr = Y[0] * Br + Y[4] * Ur + Y[12]
                                      , or = Y[1] * Br + Y[5] * Ur + Y[13]
                                      , oi = Y[2] * Br + Y[6] * Ur + Y[14]
                                      , Zi = Y[3] * Br + Y[7] * Ur + Y[15]
                                      , fn = oi + Ve
                                      , Bn = Zi + rt
                                      , Aa = xr + St
                                      , aa = or + $t
                                      , Mn = oi + Bt
                                      , qi = Zi + Ut
                                      , wn = new $((xr + me) / Bn,(or + be) / Bn);
                                    wn.z = fn / Bn,
                                    Vt.push(wn);
                                    const An = new $(Aa / qi,aa / qi);
                                    An.z = Mn / qi,
                                    Zt.push(An)
                                }
                                ae.push(Vt),
                                ze.push(Zt)
                            }
                            return [ae, ze]
                        }
                        )(c, I, S, g);
                        return (function(N, j, Z) {
                            let Y = 1 / 0;
                            Pm(Z, j) && (Y = Qm(Z, j[0]));
                            for (let ae = 0; ae < j.length; ae++) {
                                const ze = j[ae]
                                  , me = N[ae];
                                for (let be = 0; be < ze.length - 1; be++) {
                                    const Ve = ze[be]
                                      , rt = [Ve, ze[be + 1], me[be + 1], me[be], Ve];
                                    Sm(Z, rt) && (Y = Math.min(Y, Qm(Z, rt)))
                                }
                            }
                            return Y !== 1 / 0 && Y
                        }
                        )(R[0], R[1], E)
                    }
                }
                function hu(i, t) {
                    return i.x * t.x + i.y * t.y
                }
                function Qm(i, t) {
                    if (i.length === 1) {
                        let r = 0;
                        const a = t[r++];
                        let c;
                        for (; !c || a.equals(c); )
                            if (c = t[r++],
                            !c)
                                return 1 / 0;
                        for (; r < t.length; r++) {
                            const p = t[r]
                              , f = i[0]
                              , g = c.sub(a)
                              , v = p.sub(a)
                              , S = f.sub(a)
                              , I = hu(g, g)
                              , E = hu(g, v)
                              , R = hu(v, v)
                              , N = hu(S, g)
                              , j = hu(S, v)
                              , Z = I * R - E * E
                              , Y = (R * N - E * j) / Z
                              , ae = (I * j - E * N) / Z
                              , ze = a.z * (1 - Y - ae) + c.z * Y + p.z * ae;
                            if (isFinite(ze))
                                return ze
                        }
                        return 1 / 0
                    }
                    {
                        let r = 1 / 0;
                        for (const a of t)
                            r = Math.min(r, a.z);
                        return r
                    }
                }
                const b0 = Hi([{
                    name: "a_pos_normal",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint8"
                }], 4)
                  , {members: w0} = b0
                  , T0 = Hi([{
                    name: "a_uv_x",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_split_index",
                    components: 1,
                    type: "Float32"
                }])
                  , {members: C0} = T0
                  , S0 = Math.cos(Math.PI / 180 * 37.5)
                  , e_ = Math.pow(2, 14) / .5;
                class Bp {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((r => r.id)),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.lineClipsArray = [],
                        this.gradients = {},
                        this.layers.forEach((r => {
                            this.gradients[r.id] = {}
                        }
                        )),
                        this.layoutVertexArray = new qe,
                        this.layoutVertexArray2 = new $e,
                        this.indexArray = new ki,
                        this.programConfigurations = new ia(t.layers,t.zoom),
                        this.segments = new Wr,
                        this.maxLineLength = 0,
                        this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
                    }
                    populate(t, r, a) {
                        this.hasPattern = Ap("line", this.layers, r);
                        const c = this.layers[0].layout.get("line-sort-key")
                          , p = !c.isConstant()
                          , f = [];
                        for (const {feature: g, id: v, index: S, sourceLayerIndex: I} of t) {
                            const E = this.layers[0]._featureFilter.needGeometry
                              , R = Wa(g, E);
                            if (!this.layers[0]._featureFilter.filter(new Oi(this.zoom,{
                                globalState: this.globalState
                            }), R, a))
                                continue;
                            const N = p ? c.evaluate(R, {}, a) : void 0
                              , j = {
                                id: v,
                                properties: g.properties,
                                type: g.type,
                                sourceLayerIndex: I,
                                index: S,
                                geometry: E ? R.geometry : cs(g),
                                patterns: {},
                                sortKey: N
                            };
                            f.push(j)
                        }
                        p && f.sort(( (g, v) => g.sortKey - v.sortKey));
                        for (const g of f) {
                            const {geometry: v, index: S, sourceLayerIndex: I} = g;
                            if (this.hasPattern) {
                                const E = kp("line", this.layers, g, this.zoom, r);
                                this.patternFeatures.push(E)
                            } else
                                this.addFeature(g, v, S, a, {}, r.subdivisionGranularity);
                            r.featureIndex.insert(t[S].feature, v, S, I, this.index)
                        }
                    }
                    update(t, r, a) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, a)
                    }
                    addFeatures(t, r, a) {
                        for (const c of this.patternFeatures)
                            this.addFeature(c, c.geometry, c.index, r, a, t.subdivisionGranularity)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, C0)),
                        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, w0),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    lineFeatureClips(t) {
                        if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end"))
                            return {
                                start: +t.properties.mapbox_clip_start,
                                end: +t.properties.mapbox_clip_end
                            }
                    }
                    addFeature(t, r, a, c, p, f) {
                        const g = this.layers[0].layout
                          , v = g.get("line-join").evaluate(t, {})
                          , S = g.get("line-cap")
                          , I = g.get("line-miter-limit")
                          , E = g.get("line-round-limit");
                        this.lineClips = this.lineFeatureClips(t);
                        for (const R of r)
                            this.addLine(R, t, v, S, I, E, c, f);
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, c)
                    }
                    addLine(t, r, a, c, p, f, g, v) {
                        if (this.distance = 0,
                        this.scaledDistance = 0,
                        this.totalDistance = 0,
                        t = Fo(t, g ? v.line.getGranularityForZoomLevel(g.z) : 1),
                        this.lineClips) {
                            this.lineClipsArray.push(this.lineClips);
                            for (let me = 0; me < t.length - 1; me++)
                                this.totalDistance += t[me].dist(t[me + 1]);
                            this.updateScaledDistance(),
                            this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                        }
                        const S = Bl.types[r.type] === "Polygon";
                        let I = t.length;
                        for (; I >= 2 && t[I - 1].equals(t[I - 2]); )
                            I--;
                        let E = 0;
                        for (; E < I - 1 && t[E].equals(t[E + 1]); )
                            E++;
                        if (I < (S ? 3 : 2))
                            return;
                        a === "bevel" && (p = 1.05);
                        const R = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0
                          , N = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
                        let j, Z, Y, ae, ze;
                        this.e1 = this.e2 = -1,
                        S && (j = t[I - 2],
                        ze = t[E].sub(j)._unit()._perp());
                        for (let me = E; me < I; me++) {
                            if (Y = me === I - 1 ? S ? t[E + 1] : void 0 : t[me + 1],
                            Y && t[me].equals(Y))
                                continue;
                            ze && (ae = ze),
                            j && (Z = j),
                            j = t[me],
                            ze = Y ? Y.sub(j)._unit()._perp() : ae,
                            ae = ae || ze;
                            let be = ae.add(ze);
                            be.x === 0 && be.y === 0 || be._unit();
                            const Ve = ae.x * ze.x + ae.y * ze.y
                              , rt = be.x * ze.x + be.y * ze.y
                              , St = rt !== 0 ? 1 / rt : 1 / 0
                              , $t = 2 * Math.sqrt(2 - 2 * rt)
                              , Bt = rt < S0 && Z && Y
                              , Ut = ae.x * ze.y - ae.y * ze.x > 0;
                            if (Bt && me > E) {
                                const Zt = j.dist(Z);
                                if (Zt > 2 * R) {
                                    const mt = j.sub(j.sub(Z)._mult(R / Zt)._round());
                                    this.updateDistance(Z, mt),
                                    this.addCurrentVertex(mt, ae, 0, 0, N),
                                    Z = mt
                                }
                            }
                            const pr = Z && Y;
                            let Vt = pr ? a : S ? "butt" : c;
                            if (pr && Vt === "round" && (St < f ? Vt = "miter" : St <= 2 && (Vt = "fakeround")),
                            Vt === "miter" && St > p && (Vt = "bevel"),
                            Vt === "bevel" && (St > 2 && (Vt = "flipbevel"),
                            St < p && (Vt = "miter")),
                            Z && this.updateDistance(Z, j),
                            Vt === "miter")
                                be._mult(St),
                                this.addCurrentVertex(j, be, 0, 0, N);
                            else if (Vt === "flipbevel") {
                                if (St > 100)
                                    be = ze.mult(-1);
                                else {
                                    const Zt = St * ae.add(ze).mag() / ae.sub(ze).mag();
                                    be._perp()._mult(Zt * (Ut ? -1 : 1))
                                }
                                this.addCurrentVertex(j, be, 0, 0, N),
                                this.addCurrentVertex(j, be.mult(-1), 0, 0, N)
                            } else if (Vt === "bevel" || Vt === "fakeround") {
                                const Zt = -Math.sqrt(St * St - 1)
                                  , mt = Ut ? Zt : 0
                                  , Br = Ut ? 0 : Zt;
                                if (Z && this.addCurrentVertex(j, ae, mt, Br, N),
                                Vt === "fakeround") {
                                    const Ur = Math.round(180 * $t / Math.PI / 20);
                                    for (let xr = 1; xr < Ur; xr++) {
                                        let or = xr / Ur;
                                        if (or !== .5) {
                                            const Zi = or - .5;
                                            or += or * Zi * (or - 1) * ((1.0904 + Ve * (Ve * (3.55645 - 1.43519 * Ve) - 3.2452)) * Zi * Zi + (.848013 + Ve * (.215638 * Ve - 1.06021)))
                                        }
                                        const oi = ze.sub(ae)._mult(or)._add(ae)._unit()._mult(Ut ? -1 : 1);
                                        this.addHalfVertex(j, oi.x, oi.y, !1, Ut, 0, N)
                                    }
                                }
                                Y && this.addCurrentVertex(j, ze, -mt, -Br, N)
                            } else if (Vt === "butt")
                                this.addCurrentVertex(j, be, 0, 0, N);
                            else if (Vt === "square") {
                                const Zt = Z ? 1 : -1;
                                this.addCurrentVertex(j, be, Zt, Zt, N)
                            } else
                                Vt === "round" && (Z && (this.addCurrentVertex(j, ae, 0, 0, N),
                                this.addCurrentVertex(j, ae, 1, 1, N, !0)),
                                Y && (this.addCurrentVertex(j, ze, -1, -1, N, !0),
                                this.addCurrentVertex(j, ze, 0, 0, N)));
                            if (Bt && me < I - 1) {
                                const Zt = j.dist(Y);
                                if (Zt > 2 * R) {
                                    const mt = j.add(Y.sub(j)._mult(R / Zt)._round());
                                    this.updateDistance(j, mt),
                                    this.addCurrentVertex(mt, ze, 0, 0, N),
                                    j = mt
                                }
                            }
                        }
                    }
                    addCurrentVertex(t, r, a, c, p, f=!1) {
                        const g = r.y * c - r.x
                          , v = -r.y - r.x * c;
                        this.addHalfVertex(t, r.x + r.y * a, r.y - r.x * a, f, !1, a, p),
                        this.addHalfVertex(t, g, v, f, !0, -c, p),
                        this.distance > e_ / 2 && this.totalDistance === 0 && (this.distance = 0,
                        this.updateScaledDistance(),
                        this.addCurrentVertex(t, r, a, c, p, f))
                    }
                    addHalfVertex({x: t, y: r}, a, c, p, f, g, v) {
                        const S = .5 * (this.lineClips ? this.scaledDistance * (e_ - 1) : this.scaledDistance);
                        this.layoutVertexArray.emplaceBack((t << 1) + (p ? 1 : 0), (r << 1) + (f ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * c) + 128, 1 + (g === 0 ? 0 : g < 0 ? -1 : 1) | (63 & S) << 2, S >> 6),
                        this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
                        const I = v.vertexLength++;
                        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, I, this.e2),
                        v.primitiveLength++),
                        f ? this.e2 = I : this.e1 = I
                    }
                    updateScaledDistance() {
                        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
                    }
                    updateDistance(t, r) {
                        this.distance += t.dist(r),
                        this.updateScaledDistance()
                    }
                }
                let t_, r_;
                Kt("LineBucket", Bp, {
                    omit: ["layers", "patternFeatures"]
                });
                var i_ = {
                    get paint() {
                        return r_ = r_ || new jn({
                            "line-opacity": new Rr(xe.paint_line["line-opacity"]),
                            "line-color": new Rr(xe.paint_line["line-color"]),
                            "line-translate": new hr(xe.paint_line["line-translate"]),
                            "line-translate-anchor": new hr(xe.paint_line["line-translate-anchor"]),
                            "line-width": new Rr(xe.paint_line["line-width"]),
                            "line-gap-width": new Rr(xe.paint_line["line-gap-width"]),
                            "line-offset": new Rr(xe.paint_line["line-offset"]),
                            "line-blur": new Rr(xe.paint_line["line-blur"]),
                            "line-dasharray": new ns(xe.paint_line["line-dasharray"]),
                            "line-pattern": new Sl(xe.paint_line["line-pattern"]),
                            "line-gradient": new Pl(xe.paint_line["line-gradient"])
                        })
                    },
                    get layout() {
                        return t_ = t_ || new jn({
                            "line-cap": new hr(xe.layout_line["line-cap"]),
                            "line-join": new Rr(xe.layout_line["line-join"]),
                            "line-miter-limit": new hr(xe.layout_line["line-miter-limit"]),
                            "line-round-limit": new hr(xe.layout_line["line-round-limit"]),
                            "line-sort-key": new Rr(xe.layout_line["line-sort-key"])
                        })
                    }
                };
                class P0 extends Rr {
                    possiblyEvaluate(t, r) {
                        return r = new Oi(Math.floor(r.zoom),{
                            now: r.now,
                            fadeDuration: r.fadeDuration,
                            zoomHistory: r.zoomHistory,
                            transition: r.transition
                        }),
                        super.possiblyEvaluate(t, r)
                    }
                    evaluate(t, r, a, c) {
                        return r = pt({}, r, {
                            zoom: Math.floor(r.zoom)
                        }),
                        super.evaluate(t, r, a, c)
                    }
                }
                let ud;
                class I0 extends ha {
                    constructor(t) {
                        super(t, i_),
                        this.gradientVersion = 0,
                        ud || (ud = new P0(i_.paint.properties["line-width"].specification),
                        ud.useIntegerZoom = !0)
                    }
                    _handleSpecialPaintPropertyUpdate(t) {
                        if (t === "line-gradient") {
                            const r = this.gradientExpression();
                            this.stepInterpolant = !!(function(a) {
                                return a._styleExpression !== void 0
                            }
                            )(r) && r._styleExpression.expression instanceof Gi,
                            this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                        }
                    }
                    gradientExpression() {
                        return this._transitionablePaint._values["line-gradient"].value.expression
                    }
                    recalculate(t, r) {
                        super.recalculate(t, r),
                        this.paint._values["line-floorwidth"] = ud.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
                    }
                    createBucket(t) {
                        return new Bp(t)
                    }
                    queryRadius(t) {
                        const r = t
                          , a = n_(ru("line-width", this, r), ru("line-gap-width", this, r))
                          , c = ru("line-offset", this, r);
                        return a / 2 + Math.abs(c) + ad(this.paint.get("line-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: t, feature: r, featureState: a, geometry: c, transform: p, pixelsToTileUnits: f}) {
                        const g = sd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, f)
                          , v = f / 2 * n_(this.paint.get("line-width").evaluate(r, a), this.paint.get("line-gap-width").evaluate(r, a))
                          , S = this.paint.get("line-offset").evaluate(r, a);
                        return S && (c = (function(I, E) {
                            const R = [];
                            for (let N = 0; N < I.length; N++) {
                                const j = I[N]
                                  , Z = [];
                                for (let Y = 0; Y < j.length; Y++) {
                                    const ae = j[Y - 1]
                                      , ze = j[Y]
                                      , me = j[Y + 1]
                                      , be = Y === 0 ? new $(0,0) : ze.sub(ae)._unit()._perp()
                                      , Ve = Y === j.length - 1 ? new $(0,0) : me.sub(ze)._unit()._perp()
                                      , rt = be._add(Ve)._unit()
                                      , St = rt.x * Ve.x + rt.y * Ve.y;
                                    St !== 0 && rt._mult(1 / St),
                                    Z.push(rt._mult(E)._add(ze))
                                }
                                R.push(Z)
                            }
                            return R
                        }
                        )(c, S * f)),
                        (function(I, E, R) {
                            for (let N = 0; N < E.length; N++) {
                                const j = E[N];
                                if (I.length >= 3) {
                                    for (let Z = 0; Z < j.length; Z++)
                                        if (zl(I, j[Z]))
                                            return !0
                                }
                                if (Ov(I, j, R))
                                    return !0
                            }
                            return !1
                        }
                        )(g, c, v)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                function n_(i, t) {
                    return t > 0 ? t + 2 * i : i
                }
                const M0 = Hi([{
                    name: "a_pos_offset",
                    components: 4,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixeloffset",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , A0 = Hi([{
                    name: "a_projected_pos",
                    components: 3,
                    type: "Float32"
                }], 4);
                Hi([{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint32"
                }], 4);
                const k0 = Hi([{
                    name: "a_placed",
                    components: 2,
                    type: "Uint8"
                }, {
                    name: "a_shift",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_box_real",
                    components: 2,
                    type: "Int16"
                }]);
                Hi([{
                    type: "Int16",
                    name: "anchorPointX"
                }, {
                    type: "Int16",
                    name: "anchorPointY"
                }, {
                    type: "Int16",
                    name: "x1"
                }, {
                    type: "Int16",
                    name: "y1"
                }, {
                    type: "Int16",
                    name: "x2"
                }, {
                    type: "Int16",
                    name: "y2"
                }, {
                    type: "Uint32",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "sourceLayerIndex"
                }, {
                    type: "Uint16",
                    name: "bucketIndex"
                }]);
                const a_ = Hi([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_extrude",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , E0 = Hi([{
                    name: "a_pos",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_radius",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_flags",
                    components: 2,
                    type: "Int16"
                }], 4);
                function z0(i, t, r) {
                    return i.sections.forEach((a => {
                        a.text = (function(c, p, f) {
                            const g = p.layout.get("text-transform").evaluate(f, {});
                            return g === "uppercase" ? c = c.toLocaleUpperCase() : g === "lowercase" && (c = c.toLocaleLowerCase()),
                            Ca.applyArabicShaping && (c = Ca.applyArabicShaping(c)),
                            c
                        }
                        )(a.text, t, r)
                    }
                    )),
                    i
                }
                Hi([{
                    name: "triangle",
                    components: 3,
                    type: "Uint16"
                }]),
                Hi([{
                    type: "Int16",
                    name: "anchorX"
                }, {
                    type: "Int16",
                    name: "anchorY"
                }, {
                    type: "Uint16",
                    name: "glyphStartIndex"
                }, {
                    type: "Uint16",
                    name: "numGlyphs"
                }, {
                    type: "Uint32",
                    name: "vertexStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineLength"
                }, {
                    type: "Uint16",
                    name: "segment"
                }, {
                    type: "Uint16",
                    name: "lowerSize"
                }, {
                    type: "Uint16",
                    name: "upperSize"
                }, {
                    type: "Float32",
                    name: "lineOffsetX"
                }, {
                    type: "Float32",
                    name: "lineOffsetY"
                }, {
                    type: "Uint8",
                    name: "writingMode"
                }, {
                    type: "Uint8",
                    name: "placedOrientation"
                }, {
                    type: "Uint8",
                    name: "hidden"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Int16",
                    name: "associatedIconIndex"
                }]),
                Hi([{
                    type: "Int16",
                    name: "anchorX"
                }, {
                    type: "Int16",
                    name: "anchorY"
                }, {
                    type: "Int16",
                    name: "rightJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "centerJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "leftJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "placedIconSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedIconSymbolIndex"
                }, {
                    type: "Uint16",
                    name: "key"
                }, {
                    type: "Uint16",
                    name: "textBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "textBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "numHorizontalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numIconVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalIconVertices"
                }, {
                    type: "Uint16",
                    name: "useRuntimeCollisionCircles"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Float32",
                    name: "textBoxScale"
                }, {
                    type: "Float32",
                    name: "collisionCircleDiameter"
                }, {
                    type: "Uint16",
                    name: "textAnchorOffsetStartIndex"
                }, {
                    type: "Uint16",
                    name: "textAnchorOffsetEndIndex"
                }]),
                Hi([{
                    type: "Float32",
                    name: "offsetX"
                }]),
                Hi([{
                    type: "Int16",
                    name: "x"
                }, {
                    type: "Int16",
                    name: "y"
                }, {
                    type: "Int16",
                    name: "tileUnitDistanceFromAnchor"
                }]),
                Hi([{
                    type: "Uint16",
                    name: "textAnchor"
                }, {
                    type: "Float32",
                    components: 2,
                    name: "textOffset"
                }]);
                const du = {
                    "!": "︕",
                    "#": "＃",
                    $: "＄",
                    "%": "％",
                    "&": "＆",
                    "(": "︵",
                    ")": "︶",
                    "*": "＊",
                    "+": "＋",
                    ",": "︐",
                    "-": "︲",
                    ".": "・",
                    "/": "／",
                    ":": "︓",
                    ";": "︔",
                    "<": "︿",
                    "=": "＝",
                    ">": "﹀",
                    "?": "︖",
                    "@": "＠",
                    "[": "﹇",
                    "\\": "＼",
                    "]": "﹈",
                    "^": "＾",
                    _: "︳",
                    "`": "｀",
                    "{": "︷",
                    "|": "―",
                    "}": "︸",
                    "~": "～",
                    "¢": "￠",
                    "£": "￡",
                    "¥": "￥",
                    "¦": "￤",
                    "¬": "￢",
                    "¯": "￣",
                    "–": "︲",
                    "—": "︱",
                    "‘": "﹃",
                    "’": "﹄",
                    "“": "﹁",
                    "”": "﹂",
                    "…": "︙",
                    "‧": "・",
                    "₩": "￦",
                    "、": "︑",
                    "。": "︒",
                    "〈": "︿",
                    "〉": "﹀",
                    "《": "︽",
                    "》": "︾",
                    "「": "﹁",
                    "」": "﹂",
                    "『": "﹃",
                    "』": "﹄",
                    "【": "︻",
                    "】": "︼",
                    "〔": "︹",
                    "〕": "︺",
                    "〖": "︗",
                    "〗": "︘",
                    "！": "︕",
                    "（": "︵",
                    "）": "︶",
                    "，": "︐",
                    "－": "︲",
                    "．": "・",
                    "：": "︓",
                    "；": "︔",
                    "＜": "︿",
                    "＞": "﹀",
                    "？": "︖",
                    "［": "﹇",
                    "］": "﹈",
                    "＿": "︳",
                    "｛": "︷",
                    "｜": "―",
                    "｝": "︸",
                    "｟": "︵",
                    "｠": "︶",
                    "｡": "︒",
                    "｢": "﹁",
                    "｣": "﹂"
                };
                var bn = 24;
                const Fp = 4294967296
                  , s_ = 1 / Fp
                  , o_ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
                class Op {
                    constructor(t=new Uint8Array(16)) {
                        this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t),
                        this.dataView = new DataView(this.buf.buffer),
                        this.pos = 0,
                        this.type = 0,
                        this.length = this.buf.length
                    }
                    readFields(t, r, a=this.length) {
                        for (; this.pos < a; ) {
                            const c = this.readVarint()
                              , p = c >> 3
                              , f = this.pos;
                            this.type = 7 & c,
                            t(p, r, this),
                            this.pos === f && this.skip(c)
                        }
                        return r
                    }
                    readMessage(t, r) {
                        return this.readFields(t, r, this.readVarint() + this.pos)
                    }
                    readFixed32() {
                        const t = this.dataView.getUint32(this.pos, !0);
                        return this.pos += 4,
                        t
                    }
                    readSFixed32() {
                        const t = this.dataView.getInt32(this.pos, !0);
                        return this.pos += 4,
                        t
                    }
                    readFixed64() {
                        const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Fp;
                        return this.pos += 8,
                        t
                    }
                    readSFixed64() {
                        const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Fp;
                        return this.pos += 8,
                        t
                    }
                    readFloat() {
                        const t = this.dataView.getFloat32(this.pos, !0);
                        return this.pos += 4,
                        t
                    }
                    readDouble() {
                        const t = this.dataView.getFloat64(this.pos, !0);
                        return this.pos += 8,
                        t
                    }
                    readVarint(t) {
                        const r = this.buf;
                        let a, c;
                        return c = r[this.pos++],
                        a = 127 & c,
                        c < 128 ? a : (c = r[this.pos++],
                        a |= (127 & c) << 7,
                        c < 128 ? a : (c = r[this.pos++],
                        a |= (127 & c) << 14,
                        c < 128 ? a : (c = r[this.pos++],
                        a |= (127 & c) << 21,
                        c < 128 ? a : (c = r[this.pos],
                        a |= (15 & c) << 28,
                        (function(p, f, g) {
                            const v = g.buf;
                            let S, I;
                            if (I = v[g.pos++],
                            S = (112 & I) >> 4,
                            I < 128 || (I = v[g.pos++],
                            S |= (127 & I) << 3,
                            I < 128) || (I = v[g.pos++],
                            S |= (127 & I) << 10,
                            I < 128) || (I = v[g.pos++],
                            S |= (127 & I) << 17,
                            I < 128) || (I = v[g.pos++],
                            S |= (127 & I) << 24,
                            I < 128) || (I = v[g.pos++],
                            S |= (1 & I) << 31,
                            I < 128))
                                return Fl(p, S, f);
                            throw new Error("Expected varint not more than 10 bytes")
                        }
                        )(a, t, this)))))
                    }
                    readVarint64() {
                        return this.readVarint(!0)
                    }
                    readSVarint() {
                        const t = this.readVarint();
                        return t % 2 == 1 ? (t + 1) / -2 : t / 2
                    }
                    readBoolean() {
                        return !!this.readVarint()
                    }
                    readString() {
                        const t = this.readVarint() + this.pos
                          , r = this.pos;
                        return this.pos = t,
                        t - r >= 12 && o_ ? o_.decode(this.buf.subarray(r, t)) : (function(a, c, p) {
                            let f = ""
                              , g = c;
                            for (; g < p; ) {
                                const v = a[g];
                                let S, I, E, R = null, N = v > 239 ? 4 : v > 223 ? 3 : v > 191 ? 2 : 1;
                                if (g + N > p)
                                    break;
                                N === 1 ? v < 128 && (R = v) : N === 2 ? (S = a[g + 1],
                                (192 & S) == 128 && (R = (31 & v) << 6 | 63 & S,
                                R <= 127 && (R = null))) : N === 3 ? (S = a[g + 1],
                                I = a[g + 2],
                                (192 & S) == 128 && (192 & I) == 128 && (R = (15 & v) << 12 | (63 & S) << 6 | 63 & I,
                                (R <= 2047 || R >= 55296 && R <= 57343) && (R = null))) : N === 4 && (S = a[g + 1],
                                I = a[g + 2],
                                E = a[g + 3],
                                (192 & S) == 128 && (192 & I) == 128 && (192 & E) == 128 && (R = (15 & v) << 18 | (63 & S) << 12 | (63 & I) << 6 | 63 & E,
                                (R <= 65535 || R >= 1114112) && (R = null))),
                                R === null ? (R = 65533,
                                N = 1) : R > 65535 && (R -= 65536,
                                f += String.fromCharCode(R >>> 10 & 1023 | 55296),
                                R = 56320 | 1023 & R),
                                f += String.fromCharCode(R),
                                g += N
                            }
                            return f
                        }
                        )(this.buf, r, t)
                    }
                    readBytes() {
                        const t = this.readVarint() + this.pos
                          , r = this.buf.subarray(this.pos, t);
                        return this.pos = t,
                        r
                    }
                    readPackedVarint(t=[], r) {
                        const a = this.readPackedEnd();
                        for (; this.pos < a; )
                            t.push(this.readVarint(r));
                        return t
                    }
                    readPackedSVarint(t=[]) {
                        const r = this.readPackedEnd();
                        for (; this.pos < r; )
                            t.push(this.readSVarint());
                        return t
                    }
                    readPackedBoolean(t=[]) {
                        const r = this.readPackedEnd();
                        for (; this.pos < r; )
                            t.push(this.readBoolean());
                        return t
                    }
                    readPackedFloat(t=[]) {
                        const r = this.readPackedEnd();
                        for (; this.pos < r; )
                            t.push(this.readFloat());
                        return t
                    }
                    readPackedDouble(t=[]) {
                        const r = this.readPackedEnd();
                        for (; this.pos < r; )
                            t.push(this.readDouble());
                        return t
                    }
                    readPackedFixed32(t=[]) {
                        const r = this.readPackedEnd();
                        for (; this.pos < r; )
                            t.push(this.readFixed32());
                        return t
                    }
                    readPackedSFixed32(t=[]) {
                        const r = this.readPackedEnd();
                        for (; this.pos < r; )
                            t.push(this.readSFixed32());
                        return t
                    }
                    readPackedFixed64(t=[]) {
                        const r = this.readPackedEnd();
                        for (; this.pos < r; )
                            t.push(this.readFixed64());
                        return t
                    }
                    readPackedSFixed64(t=[]) {
                        const r = this.readPackedEnd();
                        for (; this.pos < r; )
                            t.push(this.readSFixed64());
                        return t
                    }
                    readPackedEnd() {
                        return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
                    }
                    skip(t) {
                        const r = 7 & t;
                        if (r === 0)
                            for (; this.buf[this.pos++] > 127; )
                                ;
                        else if (r === 2)
                            this.pos = this.readVarint() + this.pos;
                        else if (r === 5)
                            this.pos += 4;
                        else {
                            if (r !== 1)
                                throw new Error(`Unimplemented type: ${r}`);
                            this.pos += 8
                        }
                    }
                    writeTag(t, r) {
                        this.writeVarint(t << 3 | r)
                    }
                    realloc(t) {
                        let r = this.length || 16;
                        for (; r < this.pos + t; )
                            r *= 2;
                        if (r !== this.length) {
                            const a = new Uint8Array(r);
                            a.set(this.buf),
                            this.buf = a,
                            this.dataView = new DataView(a.buffer),
                            this.length = r
                        }
                    }
                    finish() {
                        return this.length = this.pos,
                        this.pos = 0,
                        this.buf.subarray(0, this.length)
                    }
                    writeFixed32(t) {
                        this.realloc(4),
                        this.dataView.setInt32(this.pos, t, !0),
                        this.pos += 4
                    }
                    writeSFixed32(t) {
                        this.realloc(4),
                        this.dataView.setInt32(this.pos, t, !0),
                        this.pos += 4
                    }
                    writeFixed64(t) {
                        this.realloc(8),
                        this.dataView.setInt32(this.pos, -1 & t, !0),
                        this.dataView.setInt32(this.pos + 4, Math.floor(t * s_), !0),
                        this.pos += 8
                    }
                    writeSFixed64(t) {
                        this.realloc(8),
                        this.dataView.setInt32(this.pos, -1 & t, !0),
                        this.dataView.setInt32(this.pos + 4, Math.floor(t * s_), !0),
                        this.pos += 8
                    }
                    writeVarint(t) {
                        (t = +t || 0) > 268435455 || t < 0 ? (function(r, a) {
                            let c, p;
                            if (r >= 0 ? (c = r % 4294967296 | 0,
                            p = r / 4294967296 | 0) : (c = ~(-r % 4294967296),
                            p = ~(-r / 4294967296),
                            4294967295 ^ c ? c = c + 1 | 0 : (c = 0,
                            p = p + 1 | 0)),
                            r >= 18446744073709552e3 || r < -18446744073709552e3)
                                throw new Error("Given varint doesn't fit into 10 bytes");
                            a.realloc(10),
                            (function(f, g, v) {
                                v.buf[v.pos++] = 127 & f | 128,
                                f >>>= 7,
                                v.buf[v.pos++] = 127 & f | 128,
                                f >>>= 7,
                                v.buf[v.pos++] = 127 & f | 128,
                                f >>>= 7,
                                v.buf[v.pos++] = 127 & f | 128,
                                v.buf[v.pos] = 127 & (f >>>= 7)
                            }
                            )(c, 0, a),
                            (function(f, g) {
                                const v = (7 & f) << 4;
                                g.buf[g.pos++] |= v | ((f >>>= 3) ? 128 : 0),
                                f && (g.buf[g.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0),
                                f && (g.buf[g.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0),
                                f && (g.buf[g.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0),
                                f && (g.buf[g.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0),
                                f && (g.buf[g.pos++] = 127 & f)))))
                            }
                            )(p, a)
                        }
                        )(t, this) : (this.realloc(4),
                        this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0),
                        t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0),
                        t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0),
                        t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
                    }
                    writeSVarint(t) {
                        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
                    }
                    writeBoolean(t) {
                        this.writeVarint(+t)
                    }
                    writeString(t) {
                        t = String(t),
                        this.realloc(4 * t.length),
                        this.pos++;
                        const r = this.pos;
                        this.pos = (function(c, p, f) {
                            for (let g, v, S = 0; S < p.length; S++) {
                                if (g = p.charCodeAt(S),
                                g > 55295 && g < 57344) {
                                    if (!v) {
                                        g > 56319 || S + 1 === p.length ? (c[f++] = 239,
                                        c[f++] = 191,
                                        c[f++] = 189) : v = g;
                                        continue
                                    }
                                    if (g < 56320) {
                                        c[f++] = 239,
                                        c[f++] = 191,
                                        c[f++] = 189,
                                        v = g;
                                        continue
                                    }
                                    g = v - 55296 << 10 | g - 56320 | 65536,
                                    v = null
                                } else
                                    v && (c[f++] = 239,
                                    c[f++] = 191,
                                    c[f++] = 189,
                                    v = null);
                                g < 128 ? c[f++] = g : (g < 2048 ? c[f++] = g >> 6 | 192 : (g < 65536 ? c[f++] = g >> 12 | 224 : (c[f++] = g >> 18 | 240,
                                c[f++] = g >> 12 & 63 | 128),
                                c[f++] = g >> 6 & 63 | 128),
                                c[f++] = 63 & g | 128)
                            }
                            return f
                        }
                        )(this.buf, t, this.pos);
                        const a = this.pos - r;
                        a >= 128 && l_(r, a, this),
                        this.pos = r - 1,
                        this.writeVarint(a),
                        this.pos += a
                    }
                    writeFloat(t) {
                        this.realloc(4),
                        this.dataView.setFloat32(this.pos, t, !0),
                        this.pos += 4
                    }
                    writeDouble(t) {
                        this.realloc(8),
                        this.dataView.setFloat64(this.pos, t, !0),
                        this.pos += 8
                    }
                    writeBytes(t) {
                        const r = t.length;
                        this.writeVarint(r),
                        this.realloc(r);
                        for (let a = 0; a < r; a++)
                            this.buf[this.pos++] = t[a]
                    }
                    writeRawMessage(t, r) {
                        this.pos++;
                        const a = this.pos;
                        t(r, this);
                        const c = this.pos - a;
                        c >= 128 && l_(a, c, this),
                        this.pos = a - 1,
                        this.writeVarint(c),
                        this.pos += c
                    }
                    writeMessage(t, r, a) {
                        this.writeTag(t, 2),
                        this.writeRawMessage(r, a)
                    }
                    writePackedVarint(t, r) {
                        r.length && this.writeMessage(t, L0, r)
                    }
                    writePackedSVarint(t, r) {
                        r.length && this.writeMessage(t, D0, r)
                    }
                    writePackedBoolean(t, r) {
                        r.length && this.writeMessage(t, F0, r)
                    }
                    writePackedFloat(t, r) {
                        r.length && this.writeMessage(t, R0, r)
                    }
                    writePackedDouble(t, r) {
                        r.length && this.writeMessage(t, B0, r)
                    }
                    writePackedFixed32(t, r) {
                        r.length && this.writeMessage(t, O0, r)
                    }
                    writePackedSFixed32(t, r) {
                        r.length && this.writeMessage(t, N0, r)
                    }
                    writePackedFixed64(t, r) {
                        r.length && this.writeMessage(t, j0, r)
                    }
                    writePackedSFixed64(t, r) {
                        r.length && this.writeMessage(t, q0, r)
                    }
                    writeBytesField(t, r) {
                        this.writeTag(t, 2),
                        this.writeBytes(r)
                    }
                    writeFixed32Field(t, r) {
                        this.writeTag(t, 5),
                        this.writeFixed32(r)
                    }
                    writeSFixed32Field(t, r) {
                        this.writeTag(t, 5),
                        this.writeSFixed32(r)
                    }
                    writeFixed64Field(t, r) {
                        this.writeTag(t, 1),
                        this.writeFixed64(r)
                    }
                    writeSFixed64Field(t, r) {
                        this.writeTag(t, 1),
                        this.writeSFixed64(r)
                    }
                    writeVarintField(t, r) {
                        this.writeTag(t, 0),
                        this.writeVarint(r)
                    }
                    writeSVarintField(t, r) {
                        this.writeTag(t, 0),
                        this.writeSVarint(r)
                    }
                    writeStringField(t, r) {
                        this.writeTag(t, 2),
                        this.writeString(r)
                    }
                    writeFloatField(t, r) {
                        this.writeTag(t, 5),
                        this.writeFloat(r)
                    }
                    writeDoubleField(t, r) {
                        this.writeTag(t, 1),
                        this.writeDouble(r)
                    }
                    writeBooleanField(t, r) {
                        this.writeVarintField(t, +r)
                    }
                }
                function Fl(i, t, r) {
                    return r ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0)
                }
                function l_(i, t, r) {
                    const a = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
                    r.realloc(a);
                    for (let c = r.pos - 1; c >= i; c--)
                        r.buf[c + a] = r.buf[c]
                }
                function L0(i, t) {
                    for (let r = 0; r < i.length; r++)
                        t.writeVarint(i[r])
                }
                function D0(i, t) {
                    for (let r = 0; r < i.length; r++)
                        t.writeSVarint(i[r])
                }
                function R0(i, t) {
                    for (let r = 0; r < i.length; r++)
                        t.writeFloat(i[r])
                }
                function B0(i, t) {
                    for (let r = 0; r < i.length; r++)
                        t.writeDouble(i[r])
                }
                function F0(i, t) {
                    for (let r = 0; r < i.length; r++)
                        t.writeBoolean(i[r])
                }
                function O0(i, t) {
                    for (let r = 0; r < i.length; r++)
                        t.writeFixed32(i[r])
                }
                function N0(i, t) {
                    for (let r = 0; r < i.length; r++)
                        t.writeSFixed32(i[r])
                }
                function j0(i, t) {
                    for (let r = 0; r < i.length; r++)
                        t.writeFixed64(i[r])
                }
                function q0(i, t) {
                    for (let r = 0; r < i.length; r++)
                        t.writeSFixed64(i[r])
                }
                function V0(i, t, r) {
                    i === 1 && r.readMessage(U0, t)
                }
                function U0(i, t, r) {
                    if (i === 3) {
                        const {id: a, bitmap: c, width: p, height: f, left: g, top: v, advance: S} = r.readMessage(Z0, {});
                        t.push({
                            id: a,
                            bitmap: new iu({
                                width: p + 6,
                                height: f + 6
                            },c),
                            metrics: {
                                width: p,
                                height: f,
                                left: g,
                                top: v,
                                advance: S
                            }
                        })
                    }
                }
                function Z0(i, t, r) {
                    i === 1 ? t.id = r.readVarint() : i === 2 ? t.bitmap = r.readBytes() : i === 3 ? t.width = r.readVarint() : i === 4 ? t.height = r.readVarint() : i === 5 ? t.left = r.readSVarint() : i === 6 ? t.top = r.readSVarint() : i === 7 && (t.advance = r.readVarint())
                }
                function c_(i) {
                    let t = 0
                      , r = 0;
                    for (const f of i)
                        t += f.w * f.h,
                        r = Math.max(r, f.w);
                    i.sort(( (f, g) => g.h - f.h));
                    const a = [{
                        x: 0,
                        y: 0,
                        w: Math.max(Math.ceil(Math.sqrt(t / .95)), r),
                        h: 1 / 0
                    }];
                    let c = 0
                      , p = 0;
                    for (const f of i)
                        for (let g = a.length - 1; g >= 0; g--) {
                            const v = a[g];
                            if (!(f.w > v.w || f.h > v.h)) {
                                if (f.x = v.x,
                                f.y = v.y,
                                p = Math.max(p, f.y + f.h),
                                c = Math.max(c, f.x + f.w),
                                f.w === v.w && f.h === v.h) {
                                    const S = a.pop();
                                    S && g < a.length && (a[g] = S)
                                } else
                                    f.h === v.h ? (v.x += f.w,
                                    v.w -= f.w) : f.w === v.w ? (v.y += f.h,
                                    v.h -= f.h) : (a.push({
                                        x: v.x + f.w,
                                        y: v.y,
                                        w: v.w - f.w,
                                        h: f.h
                                    }),
                                    v.y += f.h,
                                    v.h -= f.h);
                                break
                            }
                        }
                    return {
                        w: c,
                        h: p,
                        fill: t / (c * p) || 0
                    }
                }
                class Np {
                    constructor(t, {pixelRatio: r, version: a, stretchX: c, stretchY: p, content: f, textFitWidth: g, textFitHeight: v}) {
                        this.paddedRect = t,
                        this.pixelRatio = r,
                        this.stretchX = c,
                        this.stretchY = p,
                        this.content = f,
                        this.version = a,
                        this.textFitWidth = g,
                        this.textFitHeight = v
                    }
                    get tl() {
                        return [this.paddedRect.x + 1, this.paddedRect.y + 1]
                    }
                    get br() {
                        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
                    }
                    get tlbr() {
                        return this.tl.concat(this.br)
                    }
                    get displaySize() {
                        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
                    }
                }
                class u_ {
                    constructor(t, r) {
                        const a = {}
                          , c = {};
                        this.haveRenderCallbacks = [];
                        const p = [];
                        this.addImages(t, a, p),
                        this.addImages(r, c, p);
                        const {w: f, h: g} = c_(p)
                          , v = new na({
                            width: f || 1,
                            height: g || 1
                        });
                        for (const S in t) {
                            const I = t[S]
                              , E = a[S].paddedRect;
                            na.copy(I.data, v, {
                                x: 0,
                                y: 0
                            }, {
                                x: E.x + 1,
                                y: E.y + 1
                            }, I.data)
                        }
                        for (const S in r) {
                            const I = r[S]
                              , E = c[S].paddedRect
                              , R = E.x + 1
                              , N = E.y + 1
                              , j = I.data.width
                              , Z = I.data.height;
                            na.copy(I.data, v, {
                                x: 0,
                                y: 0
                            }, {
                                x: R,
                                y: N
                            }, I.data),
                            na.copy(I.data, v, {
                                x: 0,
                                y: Z - 1
                            }, {
                                x: R,
                                y: N - 1
                            }, {
                                width: j,
                                height: 1
                            }),
                            na.copy(I.data, v, {
                                x: 0,
                                y: 0
                            }, {
                                x: R,
                                y: N + Z
                            }, {
                                width: j,
                                height: 1
                            }),
                            na.copy(I.data, v, {
                                x: j - 1,
                                y: 0
                            }, {
                                x: R - 1,
                                y: N
                            }, {
                                width: 1,
                                height: Z
                            }),
                            na.copy(I.data, v, {
                                x: 0,
                                y: 0
                            }, {
                                x: R + j,
                                y: N
                            }, {
                                width: 1,
                                height: Z
                            })
                        }
                        this.image = v,
                        this.iconPositions = a,
                        this.patternPositions = c
                    }
                    addImages(t, r, a) {
                        for (const c in t) {
                            const p = t[c]
                              , f = {
                                x: 0,
                                y: 0,
                                w: p.data.width + 2,
                                h: p.data.height + 2
                            };
                            a.push(f),
                            r[c] = new Np(f,p),
                            p.hasRenderCallback && this.haveRenderCallbacks.push(c)
                        }
                    }
                    patchUpdatedImages(t, r) {
                        t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                        for (const a in t.updatedImages)
                            this.patchUpdatedImage(this.iconPositions[a], t.getImage(a), r),
                            this.patchUpdatedImage(this.patternPositions[a], t.getImage(a), r)
                    }
                    patchUpdatedImage(t, r, a) {
                        if (!t || !r || t.version === r.version)
                            return;
                        t.version = r.version;
                        const [c,p] = t.tl;
                        a.update(r.data, void 0, {
                            x: c,
                            y: p
                        })
                    }
                }
                var eo;
                Kt("ImagePosition", Np),
                Kt("ImageAtlas", u_),
                T.ao = void 0,
                (eo = T.ao || (T.ao = {}))[eo.none = 0] = "none",
                eo[eo.horizontal = 1] = "horizontal",
                eo[eo.vertical = 2] = "vertical",
                eo[eo.horizontalOnly = 3] = "horizontalOnly";
                class pu {
                    constructor() {
                        this.scale = 1,
                        this.fontStack = "",
                        this.imageName = null,
                        this.verticalAlign = "bottom"
                    }
                    static forText(t, r, a) {
                        const c = new pu;
                        return c.scale = t || 1,
                        c.fontStack = r,
                        c.verticalAlign = a || "bottom",
                        c
                    }
                    static forImage(t, r) {
                        const a = new pu;
                        return a.imageName = t,
                        a.verticalAlign = r || "bottom",
                        a
                    }
                }
                class Ol {
                    constructor() {
                        this.text = "",
                        this.sectionIndex = [],
                        this.sections = [],
                        this.imageSectionID = null
                    }
                    static fromFeature(t, r) {
                        const a = new Ol;
                        for (let c = 0; c < t.sections.length; c++) {
                            const p = t.sections[c];
                            p.image ? a.addImageSection(p) : a.addTextSection(p, r)
                        }
                        return a
                    }
                    length() {
                        return this.text.length
                    }
                    getSection(t) {
                        return this.sections[this.sectionIndex[t]]
                    }
                    getSectionIndex(t) {
                        return this.sectionIndex[t]
                    }
                    getCharCode(t) {
                        return this.text.charCodeAt(t)
                    }
                    verticalizePunctuation() {
                        this.text = (function(t) {
                            let r = "";
                            for (let a = 0; a < t.length; a++) {
                                const c = t.charCodeAt(a + 1) || null
                                  , p = t.charCodeAt(a - 1) || null;
                                r += c && Kh(c) && !du[t[a + 1]] || p && Kh(p) && !du[t[a - 1]] || !du[t[a]] ? t[a] : du[t[a]]
                            }
                            return r
                        }
                        )(this.text)
                    }
                    trim() {
                        let t = 0;
                        for (let a = 0; a < this.text.length && dd[this.text.charCodeAt(a)]; a++)
                            t++;
                        let r = this.text.length;
                        for (let a = this.text.length - 1; a >= 0 && a >= t && dd[this.text.charCodeAt(a)]; a--)
                            r--;
                        this.text = this.text.substring(t, r),
                        this.sectionIndex = this.sectionIndex.slice(t, r)
                    }
                    substring(t, r) {
                        const a = new Ol;
                        return a.text = this.text.substring(t, r),
                        a.sectionIndex = this.sectionIndex.slice(t, r),
                        a.sections = this.sections,
                        a
                    }
                    toString() {
                        return this.text
                    }
                    getMaxScale() {
                        return this.sectionIndex.reduce(( (t, r) => Math.max(t, this.sections[r].scale)), 0)
                    }
                    getMaxImageSize(t) {
                        let r = 0
                          , a = 0;
                        for (let c = 0; c < this.length(); c++) {
                            const p = this.getSection(c);
                            if (p.imageName) {
                                const f = t[p.imageName];
                                if (!f)
                                    continue;
                                const g = f.displaySize;
                                r = Math.max(r, g[0]),
                                a = Math.max(a, g[1])
                            }
                        }
                        return {
                            maxImageWidth: r,
                            maxImageHeight: a
                        }
                    }
                    addTextSection(t, r) {
                        this.text += t.text,
                        this.sections.push(pu.forText(t.scale, t.fontStack || r, t.verticalAlign));
                        const a = this.sections.length - 1;
                        for (let c = 0; c < t.text.length; ++c)
                            this.sectionIndex.push(a)
                    }
                    addImageSection(t) {
                        const r = t.image ? t.image.name : "";
                        if (r.length === 0)
                            return void Lt("Can't add FormattedSection with an empty image.");
                        const a = this.getNextImageSectionCharCode();
                        a ? (this.text += String.fromCharCode(a),
                        this.sections.push(pu.forImage(r, t.verticalAlign)),
                        this.sectionIndex.push(this.sections.length - 1)) : Lt("Reached maximum number of images 6401")
                    }
                    getNextImageSectionCharCode() {
                        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344,
                        this.imageSectionID)
                    }
                }
                function hd(i, t, r, a, c, p, f, g, v, S, I, E, R, N, j) {
                    const Z = Ol.fromFeature(i, c);
                    let Y;
                    E === T.ao.vertical && Z.verticalizePunctuation();
                    const {processBidirectionalText: ae, processStyledBidirectionalText: ze} = Ca;
                    if (ae && Z.sections.length === 1) {
                        Y = [];
                        const Ve = ae(Z.toString(), jp(Z, S, p, t, a, N));
                        for (const rt of Ve) {
                            const St = new Ol;
                            St.text = rt,
                            St.sections = Z.sections;
                            for (let $t = 0; $t < rt.length; $t++)
                                St.sectionIndex.push(0);
                            Y.push(St)
                        }
                    } else if (ze) {
                        Y = [];
                        const Ve = ze(Z.text, Z.sectionIndex, jp(Z, S, p, t, a, N));
                        for (const rt of Ve) {
                            const St = new Ol;
                            St.text = rt[0],
                            St.sectionIndex = rt[1],
                            St.sections = Z.sections,
                            Y.push(St)
                        }
                    } else
                        Y = (function(Ve, rt) {
                            const St = []
                              , $t = Ve.text;
                            let Bt = 0;
                            for (const Ut of rt)
                                St.push(Ve.substring(Bt, Ut)),
                                Bt = Ut;
                            return Bt < $t.length && St.push(Ve.substring(Bt, $t.length)),
                            St
                        }
                        )(Z, jp(Z, S, p, t, a, N));
                    const me = []
                      , be = {
                        positionedLines: me,
                        text: Z.toString(),
                        top: I[1],
                        bottom: I[1],
                        left: I[0],
                        right: I[0],
                        writingMode: E,
                        iconsInText: !1,
                        verticalizable: !1
                    };
                    return (function(Ve, rt, St, $t, Bt, Ut, pr, Vt, Zt, mt, Br, Ur) {
                        let xr = 0
                          , or = 0
                          , oi = 0
                          , Zi = 0;
                        const fn = Vt === "right" ? 1 : Vt === "left" ? 0 : .5
                          , Bn = bn / Ur;
                        let Aa = 0;
                        for (const qi of Bt) {
                            qi.trim();
                            const wn = qi.getMaxScale()
                              , An = {
                                positionedGlyphs: [],
                                lineOffset: 0
                            };
                            Ve.positionedLines[Aa] = An;
                            const kn = An.positionedGlyphs;
                            let Yn = 0;
                            if (!qi.length()) {
                                or += Ut,
                                ++Aa;
                                continue
                            }
                            const ka = W0($t, qi, Bn);
                            for (let sa = 0; sa < qi.length(); sa++) {
                                const mn = qi.getSection(sa)
                                  , Cn = qi.getSectionIndex(sa)
                                  , Sn = qi.getCharCode(sa)
                                  , rn = X0(Zt, Br, Sn);
                                let Bi;
                                if (mn.imageName) {
                                    if (Ve.iconsInText = !0,
                                    mn.scale = mn.scale * Bn,
                                    Bi = Y0(mn, rn, wn, ka, $t),
                                    !Bi)
                                        continue;
                                    Yn = Math.max(Yn, Bi.imageOffset)
                                } else if (Bi = K0(mn, Sn, rn, ka, rt, St),
                                !Bi)
                                    continue;
                                const {rect: Xa, metrics: Vl, baselineOffset: Ka} = Bi;
                                kn.push({
                                    glyph: Sn,
                                    imageName: mn.imageName,
                                    x: xr,
                                    y: or + Ka + -17,
                                    vertical: rn,
                                    scale: mn.scale,
                                    fontStack: mn.fontStack,
                                    sectionIndex: Cn,
                                    metrics: Vl,
                                    rect: Xa
                                }),
                                rn ? (Ve.verticalizable = !0,
                                xr += (mn.imageName ? Vl.advance : bn) * mn.scale + mt) : xr += Vl.advance * mn.scale + mt
                            }
                            kn.length !== 0 && (oi = Math.max(xr - mt, oi),
                            J0(kn, 0, kn.length - 1, fn)),
                            xr = 0,
                            An.lineOffset = Math.max(Yn, (wn - 1) * bn);
                            const Tn = Ut * wn + Yn;
                            or += Tn,
                            Zi = Math.max(Tn, Zi),
                            ++Aa
                        }
                        const {horizontalAlign: aa, verticalAlign: Mn} = qp(pr);
                        (function(qi, wn, An, kn, Yn, ka, Tn, sa, mn) {
                            const Cn = (wn - An) * Yn;
                            let Sn = 0;
                            Sn = ka !== Tn ? -sa * kn - -17 : -kn * mn * Tn + .5 * Tn;
                            for (const rn of qi)
                                for (const Bi of rn.positionedGlyphs)
                                    Bi.x += Cn,
                                    Bi.y += Sn
                        }
                        )(Ve.positionedLines, fn, aa, Mn, oi, Zi, Ut, or, Bt.length),
                        Ve.top += -Mn * or,
                        Ve.bottom = Ve.top + or,
                        Ve.left += -aa * oi,
                        Ve.right = Ve.left + oi
                    }
                    )(be, t, r, a, Y, f, g, v, E, S, R, j),
                    !(function(Ve) {
                        for (const rt of Ve)
                            if (rt.positionedGlyphs.length !== 0)
                                return !1;
                        return !0
                    }
                    )(me) && be
                }
                const dd = {
                    9: !0,
                    10: !0,
                    11: !0,
                    12: !0,
                    13: !0,
                    32: !0
                }
                  , $0 = {
                    10: !0,
                    32: !0,
                    38: !0,
                    41: !0,
                    43: !0,
                    45: !0,
                    47: !0,
                    173: !0,
                    183: !0,
                    8203: !0,
                    8208: !0,
                    8211: !0,
                    8231: !0
                }
                  , G0 = {
                    40: !0
                };
                function h_(i, t, r, a, c, p) {
                    if (t.imageName) {
                        const f = a[t.imageName];
                        return f ? f.displaySize[0] * t.scale * bn / p + c : 0
                    }
                    {
                        const f = r[t.fontStack]
                          , g = f && f[i];
                        return g ? g.metrics.advance * t.scale + c : 0
                    }
                }
                function d_(i, t, r, a) {
                    const c = Math.pow(i - t, 2);
                    return a ? i < t ? c / 2 : 2 * c : c + Math.abs(r) * r
                }
                function H0(i, t, r) {
                    let a = 0;
                    return i === 10 && (a -= 1e4),
                    r && (a += 150),
                    i !== 40 && i !== 65288 || (a += 50),
                    t !== 41 && t !== 65289 || (a += 50),
                    a
                }
                function p_(i, t, r, a, c, p) {
                    let f = null
                      , g = d_(t, r, c, p);
                    for (const v of a) {
                        const S = d_(t - v.x, r, c, p) + v.badness;
                        S <= g && (f = v,
                        g = S)
                    }
                    return {
                        index: i,
                        x: t,
                        priorBreak: f,
                        badness: g
                    }
                }
                function f_(i) {
                    return i ? f_(i.priorBreak).concat(i.index) : []
                }
                function jp(i, t, r, a, c, p) {
                    if (!i)
                        return [];
                    const f = []
                      , g = (function(E, R, N, j, Z, Y) {
                        let ae = 0;
                        for (let ze = 0; ze < E.length(); ze++) {
                            const me = E.getSection(ze);
                            ae += h_(E.getCharCode(ze), me, j, Z, R, Y)
                        }
                        return ae / Math.max(1, Math.ceil(ae / N))
                    }
                    )(i, t, r, a, c, p)
                      , v = i.text.indexOf("​") >= 0;
                    let S = 0;
                    for (let E = 0; E < i.length(); E++) {
                        const R = i.getSection(E)
                          , N = i.getCharCode(E);
                        if (dd[N] || (S += h_(N, R, a, c, t, p)),
                        E < i.length() - 1) {
                            const j = !((I = N) < 11904) && (!!si["CJK Compatibility Forms"](I) || !!si["CJK Compatibility"](I) || !!si["CJK Strokes"](I) || !!si["CJK Symbols and Punctuation"](I) || !!si["Enclosed CJK Letters and Months"](I) || !!si["Halfwidth and Fullwidth Forms"](I) || !!si["Ideographic Description Characters"](I) || !!si["Vertical Forms"](I) || $c.test(String.fromCodePoint(I)));
                            ($0[N] || j || R.imageName || E !== i.length() - 2 && G0[i.getCharCode(E + 1)]) && f.push(p_(E + 1, S, g, f, H0(N, i.getCharCode(E + 1), j && v), !1))
                        }
                    }
                    var I;
                    return f_(p_(i.length(), S, g, f, 0, !0))
                }
                function qp(i) {
                    let t = .5
                      , r = .5;
                    switch (i) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        t = 1;
                        break;
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        t = 0
                    }
                    switch (i) {
                    case "bottom":
                    case "bottom-right":
                    case "bottom-left":
                        r = 1;
                        break;
                    case "top":
                    case "top-right":
                    case "top-left":
                        r = 0
                    }
                    return {
                        horizontalAlign: t,
                        verticalAlign: r
                    }
                }
                function W0(i, t, r) {
                    const a = t.getMaxScale() * bn
                      , {maxImageWidth: c, maxImageHeight: p} = t.getMaxImageSize(i)
                      , f = Math.max(a, p * r);
                    return {
                        verticalLineContentWidth: Math.max(a, c * r),
                        horizontalLineContentHeight: f
                    }
                }
                function m_(i) {
                    switch (i) {
                    case "top":
                        return 0;
                    case "center":
                        return .5;
                    default:
                        return 1
                    }
                }
                function X0(i, t, r) {
                    return !(i === T.ao.horizontal || !t && !Gc(r) || t && (dd[r] || (a = r,
                    new RegExp("\\p{sc=Arab}","u").test(String.fromCodePoint(a)))));
                    var a
                }
                function K0(i, t, r, a, c, p) {
                    const f = p[i.fontStack]
                      , g = (function(S, I, E, R) {
                        if (S && S.rect)
                            return S;
                        const N = I[E.fontStack]
                          , j = N && N[R];
                        return j ? {
                            rect: null,
                            metrics: j.metrics
                        } : null
                    }
                    )(f && f[t], c, i, t);
                    if (g === null)
                        return null;
                    let v;
                    if (r)
                        v = a.verticalLineContentWidth - i.scale * bn;
                    else {
                        const S = m_(i.verticalAlign);
                        v = (a.horizontalLineContentHeight - i.scale * bn) * S
                    }
                    return {
                        rect: g.rect,
                        metrics: g.metrics,
                        baselineOffset: v
                    }
                }
                function Y0(i, t, r, a, c) {
                    const p = c[i.imageName];
                    if (!p)
                        return null;
                    const f = p.paddedRect
                      , g = p.displaySize
                      , v = {
                        width: g[0],
                        height: g[1],
                        left: 1,
                        top: -3,
                        advance: t ? g[1] : g[0]
                    };
                    let S;
                    if (t)
                        S = a.verticalLineContentWidth - g[1] * i.scale;
                    else {
                        const I = m_(i.verticalAlign);
                        S = (a.horizontalLineContentHeight - g[1] * i.scale) * I
                    }
                    return {
                        rect: f,
                        metrics: v,
                        baselineOffset: S,
                        imageOffset: (t ? g[0] : g[1]) * i.scale - bn * r
                    }
                }
                function J0(i, t, r, a) {
                    if (a === 0)
                        return;
                    const c = i[r]
                      , p = (i[r].x + c.metrics.advance * c.scale) * a;
                    for (let f = t; f <= r; f++)
                        i[f].x -= p
                }
                function Q0(i, t, r) {
                    const {horizontalAlign: a, verticalAlign: c} = qp(r)
                      , p = t[0] - i.displaySize[0] * a
                      , f = t[1] - i.displaySize[1] * c;
                    return {
                        image: i,
                        top: f,
                        bottom: f + i.displaySize[1],
                        left: p,
                        right: p + i.displaySize[0]
                    }
                }
                function __(i) {
                    var t, r;
                    let a = i.left
                      , c = i.top
                      , p = i.right - a
                      , f = i.bottom - c;
                    const g = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink"
                      , v = (r = i.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink"
                      , S = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
                    if (v === "proportional") {
                        if (g === "stretchOnly" && p / f < S || g === "proportional") {
                            const I = Math.ceil(f * S);
                            a *= I / p,
                            p = I
                        }
                    } else if (g === "proportional" && v === "stretchOnly" && S !== 0 && p / f > S) {
                        const I = Math.ceil(p / S);
                        c *= I / f,
                        f = I
                    }
                    return {
                        x1: a,
                        y1: c,
                        x2: a + p,
                        y2: c + f
                    }
                }
                function g_(i, t, r, a, c, p) {
                    const f = i.image;
                    let g;
                    if (f.content) {
                        const Y = f.content
                          , ae = f.pixelRatio || 1;
                        g = [Y[0] / ae, Y[1] / ae, f.displaySize[0] - Y[2] / ae, f.displaySize[1] - Y[3] / ae]
                    }
                    const v = t.left * p
                      , S = t.right * p;
                    let I, E, R, N;
                    r === "width" || r === "both" ? (N = c[0] + v - a[3],
                    E = c[0] + S + a[1]) : (N = c[0] + (v + S - f.displaySize[0]) / 2,
                    E = N + f.displaySize[0]);
                    const j = t.top * p
                      , Z = t.bottom * p;
                    return r === "height" || r === "both" ? (I = c[1] + j - a[0],
                    R = c[1] + Z + a[2]) : (I = c[1] + (j + Z - f.displaySize[1]) / 2,
                    R = I + f.displaySize[1]),
                    {
                        image: f,
                        top: I,
                        right: E,
                        bottom: R,
                        left: N,
                        collisionPadding: g
                    }
                }
                const As = 128
                  , to = 32640;
                function v_(i, t) {
                    const {expression: r} = t;
                    if (r.kind === "constant")
                        return {
                            kind: "constant",
                            layoutSize: r.evaluate(new Oi(i + 1))
                        };
                    if (r.kind === "source")
                        return {
                            kind: "source"
                        };
                    {
                        const {zoomStops: a, interpolationType: c} = r;
                        let p = 0;
                        for (; p < a.length && a[p] <= i; )
                            p++;
                        p = Math.max(0, p - 1);
                        let f = p;
                        for (; f < a.length && a[f] < i + 1; )
                            f++;
                        f = Math.min(a.length - 1, f);
                        const g = a[p]
                          , v = a[f];
                        return r.kind === "composite" ? {
                            kind: "composite",
                            minZoom: g,
                            maxZoom: v,
                            interpolationType: c
                        } : {
                            kind: "camera",
                            minZoom: g,
                            maxZoom: v,
                            minSize: r.evaluate(new Oi(g)),
                            maxSize: r.evaluate(new Oi(v)),
                            interpolationType: c
                        }
                    }
                }
                function Vp(i, t, r) {
                    let a = "never";
                    const c = i.get(t);
                    return c ? a = c : i.get(r) && (a = "always"),
                    a
                }
                const ey = [{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint8",
                    offset: 0
                }];
                function pd(i, t, r, a, c, p, f, g, v, S, I, E, R) {
                    const N = g ? Math.min(to, Math.round(g[0])) : 0
                      , j = g ? Math.min(to, Math.round(g[1])) : 0;
                    i.emplaceBack(t, r, Math.round(32 * a), Math.round(32 * c), p, f, (N << 1) + (v ? 1 : 0), j, 16 * S, 16 * I, 256 * E, 256 * R)
                }
                function Up(i, t, r) {
                    i.emplaceBack(t.x, t.y, r),
                    i.emplaceBack(t.x, t.y, r),
                    i.emplaceBack(t.x, t.y, r),
                    i.emplaceBack(t.x, t.y, r)
                }
                function ty(i) {
                    for (const t of i.sections)
                        if (Qh(t.text))
                            return !0;
                    return !1
                }
                class Zp {
                    constructor(t) {
                        this.layoutVertexArray = new Nt,
                        this.indexArray = new ki,
                        this.programConfigurations = t,
                        this.segments = new Wr,
                        this.dynamicLayoutVertexArray = new yt,
                        this.opacityVertexArray = new sr,
                        this.hasVisibleVertices = !1,
                        this.placedSymbolArray = new U
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
                    }
                    upload(t, r, a, c) {
                        this.isEmpty() || (a && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, M0.members),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray, r),
                        this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, A0.members, !0),
                        this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, ey, !0),
                        this.opacityVertexBuffer.itemSize = 1),
                        (a || c) && this.programConfigurations.upload(t))
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.dynamicLayoutVertexBuffer.destroy(),
                        this.opacityVertexBuffer.destroy())
                    }
                }
                Kt("SymbolBuffers", Zp);
                class $p {
                    constructor(t, r, a) {
                        this.layoutVertexArray = new t,
                        this.layoutAttributes = r,
                        this.indexArray = new a,
                        this.segments = new Wr,
                        this.collisionVertexArray = new xi
                    }
                    upload(t) {
                        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, k0.members, !0)
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.collisionVertexBuffer.destroy())
                    }
                }
                Kt("CollisionBuffers", $p);
                class Nl {
                    constructor(t) {
                        this.collisionBoxArray = t.collisionBoxArray,
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((f => f.id)),
                        this.index = t.index,
                        this.pixelRatio = t.pixelRatio,
                        this.sourceLayerIndex = t.sourceLayerIndex,
                        this.hasPattern = !1,
                        this.hasRTLText = !1,
                        this.sortKeyRanges = [],
                        this.collisionCircleArray = [];
                        const r = this.layers[0]._unevaluatedLayout._values;
                        this.textSizeData = v_(this.zoom, r["text-size"]),
                        this.iconSizeData = v_(this.zoom, r["icon-size"]);
                        const a = this.layers[0].layout
                          , c = a.get("symbol-sort-key")
                          , p = a.get("symbol-z-order");
                        this.canOverlap = Vp(a, "text-overlap", "text-allow-overlap") !== "never" || Vp(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"),
                        this.sortFeaturesByKey = p !== "viewport-y" && !c.isConstant(),
                        this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap,
                        a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map((f => T.ao[f]))),
                        this.stateDependentLayerIds = this.layers.filter((f => f.isStateDependent())).map((f => f.id)),
                        this.sourceID = t.sourceID
                    }
                    createArrays() {
                        this.text = new Zp(new ia(this.layers,this.zoom,(t => /^text/.test(t)))),
                        this.icon = new Zp(new ia(this.layers,this.zoom,(t => /^icon/.test(t)))),
                        this.glyphOffsetArray = new re,
                        this.lineVertexArray = new se,
                        this.symbolInstances = new J,
                        this.textAnchorOffsets = new ue
                    }
                    calculateGlyphDependencies(t, r, a, c, p) {
                        for (let f = 0; f < t.length; f++)
                            if (r[t.charCodeAt(f)] = !0,
                            (a || c) && p) {
                                const g = du[t.charAt(f)];
                                g && (r[g.charCodeAt(0)] = !0)
                            }
                    }
                    populate(t, r, a) {
                        const c = this.layers[0]
                          , p = c.layout
                          , f = p.get("text-font")
                          , g = p.get("text-field")
                          , v = p.get("icon-image")
                          , S = (g.value.kind !== "constant" || g.value.value instanceof ln && !g.value.value.isEmpty() || g.value.value.toString().length > 0) && (f.value.kind !== "constant" || f.value.value.length > 0)
                          , I = v.value.kind !== "constant" || !!v.value.value || Object.keys(v.parameters).length > 0
                          , E = p.get("symbol-sort-key");
                        if (this.features = [],
                        !S && !I)
                            return;
                        const R = r.iconDependencies
                          , N = r.glyphDependencies
                          , j = r.availableImages
                          , Z = new Oi(this.zoom,{
                            globalState: this.globalState
                        });
                        for (const {feature: Y, id: ae, index: ze, sourceLayerIndex: me} of t) {
                            const be = c._featureFilter.needGeometry
                              , Ve = Wa(Y, be);
                            if (!c._featureFilter.filter(Z, Ve, a))
                                continue;
                            let rt, St;
                            if (be || (Ve.geometry = cs(Y)),
                            S) {
                                const Bt = c.getValueAndResolveTokens("text-field", Ve, a, j)
                                  , Ut = ln.factory(Bt)
                                  , pr = this.hasRTLText = this.hasRTLText || ty(Ut);
                                (!pr || Ca.getRTLTextPluginStatus() === "unavailable" || pr && Ca.isParsed()) && (rt = z0(Ut, c, Ve))
                            }
                            if (I) {
                                const Bt = c.getValueAndResolveTokens("icon-image", Ve, a, j);
                                St = Bt instanceof Nn ? Bt : Nn.fromString(Bt)
                            }
                            if (!rt && !St)
                                continue;
                            const $t = this.sortFeaturesByKey ? E.evaluate(Ve, {}, a) : void 0;
                            if (this.features.push({
                                id: ae,
                                text: rt,
                                icon: St,
                                index: ze,
                                sourceLayerIndex: me,
                                geometry: Ve.geometry,
                                properties: Y.properties,
                                type: Bl.types[Y.type],
                                sortKey: $t
                            }),
                            St && (R[St.name] = !0),
                            rt) {
                                const Bt = f.evaluate(Ve, {}, a).join(",")
                                  , Ut = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point";
                                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(T.ao.vertical) >= 0;
                                for (const pr of rt.sections)
                                    if (pr.image)
                                        R[pr.image.name] = !0;
                                    else {
                                        const Vt = wl(rt.toString())
                                          , Zt = pr.fontStack || Bt
                                          , mt = N[Zt] = N[Zt] || {};
                                        this.calculateGlyphDependencies(pr.text, mt, Ut, this.allowVerticalPlacement, Vt)
                                    }
                            }
                        }
                        p.get("symbol-placement") === "line" && (this.features = (function(Y) {
                            const ae = {}
                              , ze = {}
                              , me = [];
                            let be = 0;
                            function Ve(Bt) {
                                me.push(Y[Bt]),
                                be++
                            }
                            function rt(Bt, Ut, pr) {
                                const Vt = ze[Bt];
                                return delete ze[Bt],
                                ze[Ut] = Vt,
                                me[Vt].geometry[0].pop(),
                                me[Vt].geometry[0] = me[Vt].geometry[0].concat(pr[0]),
                                Vt
                            }
                            function St(Bt, Ut, pr) {
                                const Vt = ae[Ut];
                                return delete ae[Ut],
                                ae[Bt] = Vt,
                                me[Vt].geometry[0].shift(),
                                me[Vt].geometry[0] = pr[0].concat(me[Vt].geometry[0]),
                                Vt
                            }
                            function $t(Bt, Ut, pr) {
                                const Vt = pr ? Ut[0][Ut[0].length - 1] : Ut[0][0];
                                return `${Bt}:${Vt.x}:${Vt.y}`
                            }
                            for (let Bt = 0; Bt < Y.length; Bt++) {
                                const Ut = Y[Bt]
                                  , pr = Ut.geometry
                                  , Vt = Ut.text ? Ut.text.toString() : null;
                                if (!Vt) {
                                    Ve(Bt);
                                    continue
                                }
                                const Zt = $t(Vt, pr)
                                  , mt = $t(Vt, pr, !0);
                                if (Zt in ze && mt in ae && ze[Zt] !== ae[mt]) {
                                    const Br = St(Zt, mt, pr)
                                      , Ur = rt(Zt, mt, me[Br].geometry);
                                    delete ae[Zt],
                                    delete ze[mt],
                                    ze[$t(Vt, me[Ur].geometry, !0)] = Ur,
                                    me[Br].geometry = null
                                } else
                                    Zt in ze ? rt(Zt, mt, pr) : mt in ae ? St(Zt, mt, pr) : (Ve(Bt),
                                    ae[Zt] = be - 1,
                                    ze[mt] = be - 1)
                            }
                            return me.filter((Bt => Bt.geometry))
                        }
                        )(this.features)),
                        this.sortFeaturesByKey && this.features.sort(( (Y, ae) => Y.sortKey - ae.sortKey))
                    }
                    update(t, r, a) {
                        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, a),
                        this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, a))
                    }
                    isEmpty() {
                        return this.symbolInstances.length === 0 && !this.hasRTLText
                    }
                    uploadPending() {
                        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                    }
                    upload(t) {
                        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t),
                        this.iconCollisionBox.upload(t)),
                        this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload),
                        this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload),
                        this.uploaded = !0
                    }
                    destroyDebugData() {
                        this.textCollisionBox.destroy(),
                        this.iconCollisionBox.destroy()
                    }
                    destroy() {
                        this.text.destroy(),
                        this.icon.destroy(),
                        this.hasDebugData() && this.destroyDebugData()
                    }
                    addToLineVertexArray(t, r) {
                        const a = this.lineVertexArray.length;
                        if (t.segment !== void 0) {
                            let c = t.dist(r[t.segment + 1])
                              , p = t.dist(r[t.segment]);
                            const f = {};
                            for (let g = t.segment + 1; g < r.length; g++)
                                f[g] = {
                                    x: r[g].x,
                                    y: r[g].y,
                                    tileUnitDistanceFromAnchor: c
                                },
                                g < r.length - 1 && (c += r[g + 1].dist(r[g]));
                            for (let g = t.segment || 0; g >= 0; g--)
                                f[g] = {
                                    x: r[g].x,
                                    y: r[g].y,
                                    tileUnitDistanceFromAnchor: p
                                },
                                g > 0 && (p += r[g - 1].dist(r[g]));
                            for (let g = 0; g < r.length; g++) {
                                const v = f[g];
                                this.lineVertexArray.emplaceBack(v.x, v.y, v.tileUnitDistanceFromAnchor)
                            }
                        }
                        return {
                            lineStartIndex: a,
                            lineLength: this.lineVertexArray.length - a
                        }
                    }
                    addSymbols(t, r, a, c, p, f, g, v, S, I, E, R) {
                        const N = t.indexArray
                          , j = t.layoutVertexArray
                          , Z = t.segments.prepareSegment(4 * r.length, j, N, this.canOverlap ? f.sortKey : void 0)
                          , Y = this.glyphOffsetArray.length
                          , ae = Z.vertexLength
                          , ze = this.allowVerticalPlacement && g === T.ao.vertical ? Math.PI / 2 : 0
                          , me = f.text && f.text.sections;
                        for (let be = 0; be < r.length; be++) {
                            const {tl: Ve, tr: rt, bl: St, br: $t, tex: Bt, pixelOffsetTL: Ut, pixelOffsetBR: pr, minFontScaleX: Vt, minFontScaleY: Zt, glyphOffset: mt, isSDF: Br, sectionIndex: Ur} = r[be]
                              , xr = Z.vertexLength
                              , or = mt[1];
                            pd(j, v.x, v.y, Ve.x, or + Ve.y, Bt.x, Bt.y, a, Br, Ut.x, Ut.y, Vt, Zt),
                            pd(j, v.x, v.y, rt.x, or + rt.y, Bt.x + Bt.w, Bt.y, a, Br, pr.x, Ut.y, Vt, Zt),
                            pd(j, v.x, v.y, St.x, or + St.y, Bt.x, Bt.y + Bt.h, a, Br, Ut.x, pr.y, Vt, Zt),
                            pd(j, v.x, v.y, $t.x, or + $t.y, Bt.x + Bt.w, Bt.y + Bt.h, a, Br, pr.x, pr.y, Vt, Zt),
                            Up(t.dynamicLayoutVertexArray, v, ze),
                            N.emplaceBack(xr, xr + 2, xr + 1),
                            N.emplaceBack(xr + 1, xr + 2, xr + 3),
                            Z.vertexLength += 4,
                            Z.primitiveLength += 2,
                            this.glyphOffsetArray.emplaceBack(mt[0]),
                            be !== r.length - 1 && Ur === r[be + 1].sectionIndex || t.programConfigurations.populatePaintArrays(j.length, f, f.index, {}, R, me && me[Ur])
                        }
                        t.placedSymbolArray.emplaceBack(v.x, v.y, Y, this.glyphOffsetArray.length - Y, ae, S, I, v.segment, a ? a[0] : 0, a ? a[1] : 0, c[0], c[1], g, 0, !1, 0, E)
                    }
                    _addCollisionDebugVertex(t, r, a, c, p, f) {
                        return r.emplaceBack(0, 0),
                        t.emplaceBack(a.x, a.y, c, p, Math.round(f.x), Math.round(f.y))
                    }
                    addCollisionDebugVertices(t, r, a, c, p, f, g) {
                        const v = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray)
                          , S = v.vertexLength
                          , I = p.layoutVertexArray
                          , E = p.collisionVertexArray
                          , R = g.anchorX
                          , N = g.anchorY;
                        this._addCollisionDebugVertex(I, E, f, R, N, new $(t,r)),
                        this._addCollisionDebugVertex(I, E, f, R, N, new $(a,r)),
                        this._addCollisionDebugVertex(I, E, f, R, N, new $(a,c)),
                        this._addCollisionDebugVertex(I, E, f, R, N, new $(t,c)),
                        v.vertexLength += 4;
                        const j = p.indexArray;
                        j.emplaceBack(S, S + 1),
                        j.emplaceBack(S + 1, S + 2),
                        j.emplaceBack(S + 2, S + 3),
                        j.emplaceBack(S + 3, S),
                        v.primitiveLength += 4
                    }
                    addDebugCollisionBoxes(t, r, a, c) {
                        for (let p = t; p < r; p++) {
                            const f = this.collisionBoxArray.get(p);
                            this.addCollisionDebugVertices(f.x1, f.y1, f.x2, f.y2, c ? this.textCollisionBox : this.iconCollisionBox, f.anchorPoint, a)
                        }
                    }
                    generateCollisionDebugBuffers() {
                        this.hasDebugData() && this.destroyDebugData(),
                        this.textCollisionBox = new $p(Xr,a_.members,Pi),
                        this.iconCollisionBox = new $p(Xr,a_.members,Pi);
                        for (let t = 0; t < this.symbolInstances.length; t++) {
                            const r = this.symbolInstances.get(t);
                            this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0),
                            this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0),
                            this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1),
                            this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1)
                        }
                    }
                    _deserializeCollisionBoxesForSymbol(t, r, a, c, p, f, g, v, S) {
                        const I = {};
                        for (let E = r; E < a; E++) {
                            const R = t.get(E);
                            I.textBox = {
                                x1: R.x1,
                                y1: R.y1,
                                x2: R.x2,
                                y2: R.y2,
                                anchorPointX: R.anchorPointX,
                                anchorPointY: R.anchorPointY
                            },
                            I.textFeatureIndex = R.featureIndex;
                            break
                        }
                        for (let E = c; E < p; E++) {
                            const R = t.get(E);
                            I.verticalTextBox = {
                                x1: R.x1,
                                y1: R.y1,
                                x2: R.x2,
                                y2: R.y2,
                                anchorPointX: R.anchorPointX,
                                anchorPointY: R.anchorPointY
                            },
                            I.verticalTextFeatureIndex = R.featureIndex;
                            break
                        }
                        for (let E = f; E < g; E++) {
                            const R = t.get(E);
                            I.iconBox = {
                                x1: R.x1,
                                y1: R.y1,
                                x2: R.x2,
                                y2: R.y2,
                                anchorPointX: R.anchorPointX,
                                anchorPointY: R.anchorPointY
                            },
                            I.iconFeatureIndex = R.featureIndex;
                            break
                        }
                        for (let E = v; E < S; E++) {
                            const R = t.get(E);
                            I.verticalIconBox = {
                                x1: R.x1,
                                y1: R.y1,
                                x2: R.x2,
                                y2: R.y2,
                                anchorPointX: R.anchorPointX,
                                anchorPointY: R.anchorPointY
                            },
                            I.verticalIconFeatureIndex = R.featureIndex;
                            break
                        }
                        return I
                    }
                    deserializeCollisionBoxes(t) {
                        this.collisionArrays = [];
                        for (let r = 0; r < this.symbolInstances.length; r++) {
                            const a = this.symbolInstances.get(r);
                            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex))
                        }
                    }
                    hasTextData() {
                        return this.text.segments.get().length > 0
                    }
                    hasIconData() {
                        return this.icon.segments.get().length > 0
                    }
                    hasDebugData() {
                        return this.textCollisionBox && this.iconCollisionBox
                    }
                    hasTextCollisionBoxData() {
                        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                    }
                    hasIconCollisionBoxData() {
                        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                    }
                    addIndicesForPlacedSymbol(t, r) {
                        const a = t.placedSymbolArray.get(r)
                          , c = a.vertexStartIndex + 4 * a.numGlyphs;
                        for (let p = a.vertexStartIndex; p < c; p += 4)
                            t.indexArray.emplaceBack(p, p + 2, p + 1),
                            t.indexArray.emplaceBack(p + 1, p + 2, p + 3)
                    }
                    getSortedSymbolIndexes(t) {
                        if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0)
                            return this.symbolInstanceIndexes;
                        const r = Math.sin(t)
                          , a = Math.cos(t)
                          , c = []
                          , p = []
                          , f = [];
                        for (let g = 0; g < this.symbolInstances.length; ++g) {
                            f.push(g);
                            const v = this.symbolInstances.get(g);
                            c.push(0 | Math.round(r * v.anchorX + a * v.anchorY)),
                            p.push(v.featureIndex)
                        }
                        return f.sort(( (g, v) => c[g] - c[v] || p[v] - p[g])),
                        f
                    }
                    addToSortKeyRanges(t, r) {
                        const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                        a && a.sortKey === r ? a.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
                            sortKey: r,
                            symbolInstanceStart: t,
                            symbolInstanceEnd: t + 1
                        })
                    }
                    sortFeatures(t) {
                        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t),
                            this.sortedAngle = t,
                            this.text.indexArray.clear(),
                            this.icon.indexArray.clear(),
                            this.featureSortOrder = [];
                            for (const r of this.symbolInstanceIndexes) {
                                const a = this.symbolInstances.get(r);
                                this.featureSortOrder.push(a.featureIndex),
                                [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(( (c, p, f) => {
                                    c >= 0 && f.indexOf(c) === p && this.addIndicesForPlacedSymbol(this.text, c)
                                }
                                )),
                                a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex),
                                a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex),
                                a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex)
                            }
                            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
                            this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                        }
                    }
                }
                let y_, x_;
                Kt("SymbolBucket", Nl, {
                    omit: ["layers", "collisionBoxArray", "features", "compareText"]
                }),
                Nl.MAX_GLYPHS = 65535,
                Nl.addDynamicAttributes = Up;
                var Gp = {
                    get paint() {
                        return x_ = x_ || new jn({
                            "icon-opacity": new Rr(xe.paint_symbol["icon-opacity"]),
                            "icon-color": new Rr(xe.paint_symbol["icon-color"]),
                            "icon-halo-color": new Rr(xe.paint_symbol["icon-halo-color"]),
                            "icon-halo-width": new Rr(xe.paint_symbol["icon-halo-width"]),
                            "icon-halo-blur": new Rr(xe.paint_symbol["icon-halo-blur"]),
                            "icon-translate": new hr(xe.paint_symbol["icon-translate"]),
                            "icon-translate-anchor": new hr(xe.paint_symbol["icon-translate-anchor"]),
                            "text-opacity": new Rr(xe.paint_symbol["text-opacity"]),
                            "text-color": new Rr(xe.paint_symbol["text-color"],{
                                runtimeType: Dr,
                                getOverride: i => i.textColor,
                                hasOverride: i => !!i.textColor
                            }),
                            "text-halo-color": new Rr(xe.paint_symbol["text-halo-color"]),
                            "text-halo-width": new Rr(xe.paint_symbol["text-halo-width"]),
                            "text-halo-blur": new Rr(xe.paint_symbol["text-halo-blur"]),
                            "text-translate": new hr(xe.paint_symbol["text-translate"]),
                            "text-translate-anchor": new hr(xe.paint_symbol["text-translate-anchor"])
                        })
                    },
                    get layout() {
                        return y_ = y_ || new jn({
                            "symbol-placement": new hr(xe.layout_symbol["symbol-placement"]),
                            "symbol-spacing": new hr(xe.layout_symbol["symbol-spacing"]),
                            "symbol-avoid-edges": new hr(xe.layout_symbol["symbol-avoid-edges"]),
                            "symbol-sort-key": new Rr(xe.layout_symbol["symbol-sort-key"]),
                            "symbol-z-order": new hr(xe.layout_symbol["symbol-z-order"]),
                            "icon-allow-overlap": new hr(xe.layout_symbol["icon-allow-overlap"]),
                            "icon-overlap": new hr(xe.layout_symbol["icon-overlap"]),
                            "icon-ignore-placement": new hr(xe.layout_symbol["icon-ignore-placement"]),
                            "icon-optional": new hr(xe.layout_symbol["icon-optional"]),
                            "icon-rotation-alignment": new hr(xe.layout_symbol["icon-rotation-alignment"]),
                            "icon-size": new Rr(xe.layout_symbol["icon-size"]),
                            "icon-text-fit": new hr(xe.layout_symbol["icon-text-fit"]),
                            "icon-text-fit-padding": new hr(xe.layout_symbol["icon-text-fit-padding"]),
                            "icon-image": new Rr(xe.layout_symbol["icon-image"]),
                            "icon-rotate": new Rr(xe.layout_symbol["icon-rotate"]),
                            "icon-padding": new Rr(xe.layout_symbol["icon-padding"]),
                            "icon-keep-upright": new hr(xe.layout_symbol["icon-keep-upright"]),
                            "icon-offset": new Rr(xe.layout_symbol["icon-offset"]),
                            "icon-anchor": new Rr(xe.layout_symbol["icon-anchor"]),
                            "icon-pitch-alignment": new hr(xe.layout_symbol["icon-pitch-alignment"]),
                            "text-pitch-alignment": new hr(xe.layout_symbol["text-pitch-alignment"]),
                            "text-rotation-alignment": new hr(xe.layout_symbol["text-rotation-alignment"]),
                            "text-field": new Rr(xe.layout_symbol["text-field"]),
                            "text-font": new Rr(xe.layout_symbol["text-font"]),
                            "text-size": new Rr(xe.layout_symbol["text-size"]),
                            "text-max-width": new Rr(xe.layout_symbol["text-max-width"]),
                            "text-line-height": new hr(xe.layout_symbol["text-line-height"]),
                            "text-letter-spacing": new Rr(xe.layout_symbol["text-letter-spacing"]),
                            "text-justify": new Rr(xe.layout_symbol["text-justify"]),
                            "text-radial-offset": new Rr(xe.layout_symbol["text-radial-offset"]),
                            "text-variable-anchor": new hr(xe.layout_symbol["text-variable-anchor"]),
                            "text-variable-anchor-offset": new Rr(xe.layout_symbol["text-variable-anchor-offset"]),
                            "text-anchor": new Rr(xe.layout_symbol["text-anchor"]),
                            "text-max-angle": new hr(xe.layout_symbol["text-max-angle"]),
                            "text-writing-mode": new hr(xe.layout_symbol["text-writing-mode"]),
                            "text-rotate": new Rr(xe.layout_symbol["text-rotate"]),
                            "text-padding": new hr(xe.layout_symbol["text-padding"]),
                            "text-keep-upright": new hr(xe.layout_symbol["text-keep-upright"]),
                            "text-transform": new Rr(xe.layout_symbol["text-transform"]),
                            "text-offset": new Rr(xe.layout_symbol["text-offset"]),
                            "text-allow-overlap": new hr(xe.layout_symbol["text-allow-overlap"]),
                            "text-overlap": new hr(xe.layout_symbol["text-overlap"]),
                            "text-ignore-placement": new hr(xe.layout_symbol["text-ignore-placement"]),
                            "text-optional": new hr(xe.layout_symbol["text-optional"])
                        })
                    }
                };
                class b_ {
                    constructor(t) {
                        if (t.property.overrides === void 0)
                            throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
                        this.type = t.property.overrides ? t.property.overrides.runtimeType : Mt,
                        this.defaultValue = t
                    }
                    evaluate(t) {
                        if (t.formattedSection) {
                            const r = this.defaultValue.property.overrides;
                            if (r && r.hasOverride(t.formattedSection))
                                return r.getOverride(t.formattedSection)
                        }
                        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
                    }
                    eachChild(t) {
                        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return null
                    }
                }
                Kt("FormatSectionOverride", b_, {
                    omit: ["defaultValue"]
                });
                class fd extends ha {
                    constructor(t) {
                        super(t, Gp)
                    }
                    recalculate(t, r) {
                        if (super.recalculate(t, r),
                        this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                        this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                        this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"),
                        this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")),
                        this.layout.get("symbol-placement") === "point") {
                            const a = this.layout.get("text-writing-mode");
                            if (a) {
                                const c = [];
                                for (const p of a)
                                    c.indexOf(p) < 0 && c.push(p);
                                this.layout._values["text-writing-mode"] = c
                            } else
                                this.layout._values["text-writing-mode"] = ["horizontal"]
                        }
                        this._setPaintOverrides()
                    }
                    getValueAndResolveTokens(t, r, a, c) {
                        const p = this.layout.get(t).evaluate(r, {}, a, c)
                          , f = this._unevaluatedLayout._values[t];
                        return f.isDataDriven() || fl(f.value) || !p ? p : (function(g, v) {
                            return v.replace(/{([^{}]+)}/g, ( (S, I) => g && I in g ? String(g[I]) : ""))
                        }
                        )(r.properties, p)
                    }
                    createBucket(t) {
                        return new Nl(t)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        throw new Error("Should take a different path in FeatureIndex")
                    }
                    _setPaintOverrides() {
                        for (const t of Gp.paint.overridableProperties) {
                            if (!fd.hasPaintOverride(this.layout, t))
                                continue;
                            const r = this.paint.get(t)
                              , a = new b_(r)
                              , c = new Lc(a,r.property.specification);
                            let p = null;
                            p = r.value.kind === "constant" || r.value.kind === "source" ? new So("source",c) : new Dc("composite",c,r.value.zoomStops),
                            this.paint._values[t] = new Na(r.property,p,r.parameters)
                        }
                    }
                    _handleOverridablePaintPropertyUpdate(t, r, a) {
                        return !(!this.layout || r.isDataDriven() || a.isDataDriven()) && fd.hasPaintOverride(this.layout, t)
                    }
                    static hasPaintOverride(t, r) {
                        const a = t.get("text-field")
                          , c = Gp.paint.properties[r];
                        let p = !1;
                        const f = g => {
                            for (const v of g)
                                if (c.overrides && c.overrides.hasOverride(v))
                                    return void (p = !0)
                        }
                        ;
                        if (a.value.kind === "constant" && a.value.value instanceof ln)
                            f(a.value.value.sections);
                        else if (a.value.kind === "source") {
                            const g = S => {
                                p || (S instanceof ga && wr(S.value) === Si ? f(S.value.sections) : S instanceof ms ? f(S.sections) : S.eachChild(g))
                            }
                              , v = a.value;
                            v._styleExpression && g(v._styleExpression.expression)
                        }
                        return p
                    }
                }
                let w_;
                var ry = {
                    get paint() {
                        return w_ = w_ || new jn({
                            "background-color": new hr(xe.paint_background["background-color"]),
                            "background-pattern": new ns(xe.paint_background["background-pattern"]),
                            "background-opacity": new hr(xe.paint_background["background-opacity"])
                        })
                    }
                };
                class iy extends ha {
                    constructor(t) {
                        super(t, ry)
                    }
                }
                let T_;
                var ny = {
                    get paint() {
                        return T_ = T_ || new jn({
                            "raster-opacity": new hr(xe.paint_raster["raster-opacity"]),
                            "raster-hue-rotate": new hr(xe.paint_raster["raster-hue-rotate"]),
                            "raster-brightness-min": new hr(xe.paint_raster["raster-brightness-min"]),
                            "raster-brightness-max": new hr(xe.paint_raster["raster-brightness-max"]),
                            "raster-saturation": new hr(xe.paint_raster["raster-saturation"]),
                            "raster-contrast": new hr(xe.paint_raster["raster-contrast"]),
                            "raster-resampling": new hr(xe.paint_raster["raster-resampling"]),
                            "raster-fade-duration": new hr(xe.paint_raster["raster-fade-duration"])
                        })
                    }
                };
                class ay extends ha {
                    constructor(t) {
                        super(t, ny)
                    }
                }
                class sy extends ha {
                    constructor(t) {
                        super(t, {}),
                        this.onAdd = r => {
                            this.implementation.onAdd && this.implementation.onAdd(r, r.painter.context.gl)
                        }
                        ,
                        this.onRemove = r => {
                            this.implementation.onRemove && this.implementation.onRemove(r, r.painter.context.gl)
                        }
                        ,
                        this.implementation = t
                    }
                    is3D() {
                        return this.implementation.renderingMode === "3d"
                    }
                    hasOffscreenPass() {
                        return this.implementation.prerender !== void 0
                    }
                    recalculate() {}
                    updateTransitions() {}
                    hasTransition() {
                        return !1
                    }
                    serialize() {
                        throw new Error("Custom layers cannot be serialized")
                    }
                }
                class oy {
                    constructor(t) {
                        this._methodToThrottle = t,
                        this._triggered = !1,
                        typeof MessageChannel < "u" && (this._channel = new MessageChannel,
                        this._channel.port2.onmessage = () => {
                            this._triggered = !1,
                            this._methodToThrottle()
                        }
                        )
                    }
                    trigger() {
                        this._triggered || (this._triggered = !0,
                        this._channel ? this._channel.port1.postMessage(!0) : setTimeout(( () => {
                            this._triggered = !1,
                            this._methodToThrottle()
                        }
                        ), 0))
                    }
                    remove() {
                        delete this._channel,
                        this._methodToThrottle = () => {}
                    }
                }
                const ly = {
                    once: !0
                }
                  , Hp = 63710088e-1;
                class ro {
                    constructor(t, r) {
                        if (isNaN(t) || isNaN(r))
                            throw new Error(`Invalid LngLat object: (${t}, ${r})`);
                        if (this.lng = +t,
                        this.lat = +r,
                        this.lat > 90 || this.lat < -90)
                            throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                    }
                    wrap() {
                        return new ro(tt(this.lng, -180, 180),this.lat)
                    }
                    toArray() {
                        return [this.lng, this.lat]
                    }
                    toString() {
                        return `LngLat(${this.lng}, ${this.lat})`
                    }
                    distanceTo(t) {
                        const r = Math.PI / 180
                          , a = this.lat * r
                          , c = t.lat * r
                          , p = Math.sin(a) * Math.sin(c) + Math.cos(a) * Math.cos(c) * Math.cos((t.lng - this.lng) * r);
                        return Hp * Math.acos(Math.min(p, 1))
                    }
                    static convert(t) {
                        if (t instanceof ro)
                            return t;
                        if (Array.isArray(t) && (t.length === 2 || t.length === 3))
                            return new ro(Number(t[0]),Number(t[1]));
                        if (!Array.isArray(t) && typeof t == "object" && t !== null)
                            return new ro(Number("lng"in t ? t.lng : t.lon),Number(t.lat));
                        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                    }
                }
                const C_ = 2 * Math.PI * Hp;
                function S_(i) {
                    return C_ * Math.cos(i * Math.PI / 180)
                }
                function P_(i) {
                    return (180 + i) / 360
                }
                function I_(i) {
                    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360
                }
                function M_(i, t) {
                    return i / S_(t)
                }
                function Wp(i) {
                    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90
                }
                function A_(i, t) {
                    return i * S_(Wp(t))
                }
                class fu {
                    constructor(t, r, a=0) {
                        this.x = +t,
                        this.y = +r,
                        this.z = +a
                    }
                    static fromLngLat(t, r=0) {
                        const a = ro.convert(t);
                        return new fu(P_(a.lng),I_(a.lat),M_(r, a.lat))
                    }
                    toLngLat() {
                        return new ro(360 * this.x - 180,Wp(this.y))
                    }
                    toAltitude() {
                        return A_(this.z, this.y)
                    }
                    meterInMercatorCoordinateUnits() {
                        return 1 / C_ * (t = Wp(this.y),
                        1 / Math.cos(t * Math.PI / 180));
                        var t
                    }
                }
                function k_(i, t, r) {
                    var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
                    return [i * a - 2 * Math.PI * 6378137 / 2, t * a - 2 * Math.PI * 6378137 / 2]
                }
                class Xp {
                    constructor(t, r, a) {
                        if (!(function(c, p, f) {
                            return !(c < 0 || c > 25 || f < 0 || f >= Math.pow(2, c) || p < 0 || p >= Math.pow(2, c))
                        }
                        )(t, r, a))
                            throw new Error(`x=${r}, y=${a}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
                        this.z = t,
                        this.x = r,
                        this.y = a,
                        this.key = jl(0, t, t, r, a)
                    }
                    equals(t) {
                        return this.z === t.z && this.x === t.x && this.y === t.y
                    }
                    url(t, r, a) {
                        const c = (f = this.y,
                        g = this.z,
                        v = k_(256 * (p = this.x), 256 * (f = Math.pow(2, g) - f - 1), g),
                        S = k_(256 * (p + 1), 256 * (f + 1), g),
                        v[0] + "," + v[1] + "," + S[0] + "," + S[1]);
                        var p, f, g, v, S;
                        const I = (function(E, R, N) {
                            let j, Z = "";
                            for (let Y = E; Y > 0; Y--)
                                j = 1 << Y - 1,
                                Z += (R & j ? 1 : 0) + (N & j ? 2 : 0);
                            return Z
                        }
                        )(this.z, this.x, this.y);
                        return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, I).replace(/{bbox-epsg-3857}/g, c)
                    }
                    isChildOf(t) {
                        const r = this.z - t.z;
                        return r > 0 && t.x === this.x >> r && t.y === this.y >> r
                    }
                    getTilePoint(t) {
                        const r = Math.pow(2, this.z);
                        return new $((t.x * r - this.x) * ne,(t.y * r - this.y) * ne)
                    }
                    toString() {
                        return `${this.z}/${this.x}/${this.y}`
                    }
                }
                class E_ {
                    constructor(t, r) {
                        this.wrap = t,
                        this.canonical = r,
                        this.key = jl(t, r.z, r.z, r.x, r.y)
                    }
                }
                class Ma {
                    constructor(t, r, a, c, p) {
                        if (this.terrainRttPosMatrix32f = null,
                        t < a)
                            throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${a}`);
                        this.overscaledZ = t,
                        this.wrap = r,
                        this.canonical = new Xp(a,+c,+p),
                        this.key = jl(r, t, a, c, p)
                    }
                    clone() {
                        return new Ma(this.overscaledZ,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    equals(t) {
                        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
                    }
                    scaledTo(t) {
                        if (t > this.overscaledZ)
                            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                        const r = this.canonical.z - t;
                        return t > this.canonical.z ? new Ma(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y) : new Ma(t,this.wrap,t,this.canonical.x >> r,this.canonical.y >> r)
                    }
                    calculateScaledKey(t, r) {
                        if (t > this.overscaledZ)
                            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                        const a = this.canonical.z - t;
                        return t > this.canonical.z ? jl(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : jl(this.wrap * +r, t, t, this.canonical.x >> a, this.canonical.y >> a)
                    }
                    isChildOf(t) {
                        if (t.wrap !== this.wrap)
                            return !1;
                        const r = this.canonical.z - t.canonical.z;
                        return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r
                    }
                    children(t) {
                        if (this.overscaledZ >= t)
                            return [new Ma(this.overscaledZ + 1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];
                        const r = this.canonical.z + 1
                          , a = 2 * this.canonical.x
                          , c = 2 * this.canonical.y;
                        return [new Ma(r,this.wrap,r,a,c), new Ma(r,this.wrap,r,a + 1,c), new Ma(r,this.wrap,r,a,c + 1), new Ma(r,this.wrap,r,a + 1,c + 1)]
                    }
                    isLessThan(t) {
                        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
                    }
                    wrapped() {
                        return new Ma(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    unwrapTo(t) {
                        return new Ma(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    overscaleFactor() {
                        return Math.pow(2, this.overscaledZ - this.canonical.z)
                    }
                    toUnwrapped() {
                        return new E_(this.wrap,this.canonical)
                    }
                    toString() {
                        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
                    }
                    getTilePoint(t) {
                        return this.canonical.getTilePoint(new fu(t.x - this.wrap,t.y))
                    }
                }
                function jl(i, t, r, a, c) {
                    (i *= 2) < 0 && (i = -1 * i - 1);
                    const p = 1 << r;
                    return (p * p * i + p * c + a).toString(36) + r.toString(36) + t.toString(36)
                }
                function mu(i, t) {
                    return t ? i.properties[t] : i.id
                }
                Kt("CanonicalTileID", Xp),
                Kt("OverscaledTileID", Ma, {
                    omit: ["terrainRttPosMatrix32f"]
                });
                class Oo {
                    constructor() {
                        this.minX = 1 / 0,
                        this.maxX = -1 / 0,
                        this.minY = 1 / 0,
                        this.maxY = -1 / 0
                    }
                    extend(t) {
                        return this.minX = Math.min(this.minX, t.x),
                        this.minY = Math.min(this.minY, t.y),
                        this.maxX = Math.max(this.maxX, t.x),
                        this.maxY = Math.max(this.maxY, t.y),
                        this
                    }
                    expandBy(t) {
                        return this.minX -= t,
                        this.minY -= t,
                        this.maxX += t,
                        this.maxY += t,
                        (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0,
                        this.maxX = -1 / 0,
                        this.minY = 1 / 0,
                        this.maxY = -1 / 0),
                        this
                    }
                    shrinkBy(t) {
                        return this.expandBy(-t)
                    }
                    map(t) {
                        const r = new Oo;
                        return r.extend(t(new $(this.minX,this.minY))),
                        r.extend(t(new $(this.maxX,this.minY))),
                        r.extend(t(new $(this.minX,this.maxY))),
                        r.extend(t(new $(this.maxX,this.maxY))),
                        r
                    }
                    static fromPoints(t) {
                        const r = new Oo;
                        for (const a of t)
                            r.extend(a);
                        return r
                    }
                    contains(t) {
                        return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
                    }
                    empty() {
                        return this.minX > this.maxX
                    }
                    width() {
                        return this.maxX - this.minX
                    }
                    height() {
                        return this.maxY - this.minY
                    }
                    covers(t) {
                        return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
                    }
                    intersects(t) {
                        return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
                    }
                }
                class z_ {
                    constructor(t) {
                        this._stringToNumber = {},
                        this._numberToString = [];
                        for (let r = 0; r < t.length; r++) {
                            const a = t[r];
                            this._stringToNumber[a] = r,
                            this._numberToString[r] = a
                        }
                    }
                    encode(t) {
                        return this._stringToNumber[t]
                    }
                    decode(t) {
                        if (t >= this._numberToString.length)
                            throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
                        return this._numberToString[t]
                    }
                }
                class L_ {
                    constructor(t, r, a, c, p) {
                        this.type = "Feature",
                        this._vectorTileFeature = t,
                        t._z = r,
                        t._x = a,
                        t._y = c,
                        this.properties = t.properties,
                        this.id = p
                    }
                    get geometry() {
                        return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry),
                        this._geometry
                    }
                    set geometry(t) {
                        this._geometry = t
                    }
                    toJSON() {
                        const t = {
                            geometry: this.geometry
                        };
                        for (const r in this)
                            r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
                        return t
                    }
                }
                class D_ {
                    constructor(t, r) {
                        this.tileID = t,
                        this.x = t.canonical.x,
                        this.y = t.canonical.y,
                        this.z = t.canonical.z,
                        this.grid = new zo(ne,16,0),
                        this.grid3D = new zo(ne,16,0),
                        this.featureIndexArray = new Te,
                        this.promoteId = r
                    }
                    insert(t, r, a, c, p, f) {
                        const g = this.featureIndexArray.length;
                        this.featureIndexArray.emplaceBack(a, c, p);
                        const v = f ? this.grid3D : this.grid;
                        for (let S = 0; S < r.length; S++) {
                            const I = r[S]
                              , E = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                            for (let R = 0; R < I.length; R++) {
                                const N = I[R];
                                E[0] = Math.min(E[0], N.x),
                                E[1] = Math.min(E[1], N.y),
                                E[2] = Math.max(E[2], N.x),
                                E[3] = Math.max(E[3], N.y)
                            }
                            E[0] < ne && E[1] < ne && E[2] >= 0 && E[3] >= 0 && v.insert(g, E[0], E[1], E[2], E[3])
                        }
                    }
                    loadVTLayers() {
                        return this.vtLayers || (this.vtLayers = new Km(new Op(this.rawTileData)).layers,
                        this.sourceLayerCoder = new z_(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])),
                        this.vtLayers
                    }
                    query(t, r, a, c) {
                        this.loadVTLayers();
                        const p = t.params
                          , f = ne / t.tileSize / t.scale
                          , g = bs(p.filter)
                          , v = t.queryGeometry
                          , S = t.queryPadding * f
                          , I = Oo.fromPoints(v)
                          , E = this.grid.query(I.minX - S, I.minY - S, I.maxX + S, I.maxY + S)
                          , R = Oo.fromPoints(t.cameraQueryGeometry).expandBy(S)
                          , N = this.grid3D.query(R.minX, R.minY, R.maxX, R.maxY, ( (Y, ae, ze, me) => (function(be, Ve, rt, St, $t) {
                            for (const Ut of be)
                                if (Ve <= Ut.x && rt <= Ut.y && St >= Ut.x && $t >= Ut.y)
                                    return !0;
                            const Bt = [new $(Ve,rt), new $(Ve,$t), new $(St,$t), new $(St,rt)];
                            if (be.length > 2) {
                                for (const Ut of Bt)
                                    if (zl(be, Ut))
                                        return !0
                            }
                            for (let Ut = 0; Ut < be.length - 1; Ut++)
                                if (jv(be[Ut], be[Ut + 1], Bt))
                                    return !0;
                            return !1
                        }
                        )(t.cameraQueryGeometry, Y - S, ae - S, ze + S, me + S)));
                        for (const Y of N)
                            E.push(Y);
                        E.sort(cy);
                        const j = {};
                        let Z;
                        for (let Y = 0; Y < E.length; Y++) {
                            const ae = E[Y];
                            if (ae === Z)
                                continue;
                            Z = ae;
                            const ze = this.featureIndexArray.get(ae);
                            let me = null;
                            this.loadMatchingFeature(j, ze.bucketIndex, ze.sourceLayerIndex, ze.featureIndex, g, p.layers, p.availableImages, r, a, c, ( (be, Ve, rt) => (me || (me = cs(be)),
                            Ve.queryIntersectsFeature({
                                queryGeometry: v,
                                feature: be,
                                featureState: rt,
                                geometry: me,
                                zoom: this.z,
                                transform: t.transform,
                                pixelsToTileUnits: f,
                                pixelPosMatrix: t.pixelPosMatrix,
                                unwrappedTileID: this.tileID.toUnwrapped(),
                                getElevation: t.getElevation
                            }))))
                        }
                        return j
                    }
                    loadMatchingFeature(t, r, a, c, p, f, g, v, S, I, E) {
                        const R = this.bucketLayerIDs[r];
                        if (f && !R.some((Y => f.has(Y))))
                            return;
                        const N = this.sourceLayerCoder.decode(a)
                          , j = this.vtLayers[N].feature(c);
                        if (p.needGeometry) {
                            const Y = Wa(j, !0);
                            if (!p.filter(new Oi(this.tileID.overscaledZ), Y, this.tileID.canonical))
                                return
                        } else if (!p.filter(new Oi(this.tileID.overscaledZ), j))
                            return;
                        const Z = this.getId(j, N);
                        for (let Y = 0; Y < R.length; Y++) {
                            const ae = R[Y];
                            if (f && !f.has(ae))
                                continue;
                            const ze = v[ae];
                            if (!ze)
                                continue;
                            let me = {};
                            Z && I && (me = I.getState(ze.sourceLayer || "_geojsonTileLayer", Z));
                            const be = pt({}, S[ae]);
                            be.paint = R_(be.paint, ze.paint, j, me, g),
                            be.layout = R_(be.layout, ze.layout, j, me, g);
                            const Ve = !E || E(j, ze, me);
                            if (!Ve)
                                continue;
                            const rt = new L_(j,this.z,this.x,this.y,Z);
                            rt.layer = be;
                            let St = t[ae];
                            St === void 0 && (St = t[ae] = []),
                            St.push({
                                featureIndex: c,
                                feature: rt,
                                intersectionZ: Ve
                            })
                        }
                    }
                    lookupSymbolFeatures(t, r, a, c, p, f, g, v) {
                        const S = {};
                        this.loadVTLayers();
                        const I = bs(p);
                        for (const E of t)
                            this.loadMatchingFeature(S, a, c, E, I, f, g, v, r);
                        return S
                    }
                    hasLayer(t) {
                        for (const r of this.bucketLayerIDs)
                            for (const a of r)
                                if (t === a)
                                    return !0;
                        return !1
                    }
                    getId(t, r) {
                        var a;
                        let c = t.id;
                        return this.promoteId && (c = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]],
                        typeof c == "boolean" && (c = Number(c)),
                        c === void 0 && (!((a = t.properties) === null || a === void 0) && a.cluster) && this.promoteId && (c = Number(t.properties.cluster_id))),
                        c
                    }
                }
                function R_(i, t, r, a, c) {
                    return ut(i, ( (p, f) => {
                        const g = t instanceof Cl ? t.get(f) : null;
                        return g && g.evaluate ? g.evaluate(r, a, c) : g
                    }
                    ))
                }
                function cy(i, t) {
                    return t - i
                }
                function B_(i, t, r, a, c) {
                    const p = [];
                    for (let f = 0; f < i.length; f++) {
                        const g = i[f];
                        let v;
                        for (let S = 0; S < g.length - 1; S++) {
                            let I = g[S]
                              , E = g[S + 1];
                            I.x < t && E.x < t || (I.x < t ? I = new $(t,I.y + (t - I.x) / (E.x - I.x) * (E.y - I.y))._round() : E.x < t && (E = new $(t,I.y + (t - I.x) / (E.x - I.x) * (E.y - I.y))._round()),
                            I.y < r && E.y < r || (I.y < r ? I = new $(I.x + (r - I.y) / (E.y - I.y) * (E.x - I.x),r)._round() : E.y < r && (E = new $(I.x + (r - I.y) / (E.y - I.y) * (E.x - I.x),r)._round()),
                            I.x >= a && E.x >= a || (I.x >= a ? I = new $(a,I.y + (a - I.x) / (E.x - I.x) * (E.y - I.y))._round() : E.x >= a && (E = new $(a,I.y + (a - I.x) / (E.x - I.x) * (E.y - I.y))._round()),
                            I.y >= c && E.y >= c || (I.y >= c ? I = new $(I.x + (c - I.y) / (E.y - I.y) * (E.x - I.x),c)._round() : E.y >= c && (E = new $(I.x + (c - I.y) / (E.y - I.y) * (E.x - I.x),c)._round()),
                            v && I.equals(v[v.length - 1]) || (v = [I],
                            p.push(v)),
                            v.push(E)))))
                        }
                    }
                    return p
                }
                Kt("FeatureIndex", D_, {
                    omit: ["rawTileData", "sourceLayerCoder"]
                });
                class io extends $ {
                    constructor(t, r, a, c) {
                        super(t, r),
                        this.angle = a,
                        c !== void 0 && (this.segment = c)
                    }
                    clone() {
                        return new io(this.x,this.y,this.angle,this.segment)
                    }
                }
                function F_(i, t, r, a, c) {
                    if (t.segment === void 0 || r === 0)
                        return !0;
                    let p = t
                      , f = t.segment + 1
                      , g = 0;
                    for (; g > -r / 2; ) {
                        if (f--,
                        f < 0)
                            return !1;
                        g -= i[f].dist(p),
                        p = i[f]
                    }
                    g += i[f].dist(i[f + 1]),
                    f++;
                    const v = [];
                    let S = 0;
                    for (; g < r / 2; ) {
                        const I = i[f]
                          , E = i[f + 1];
                        if (!E)
                            return !1;
                        let R = i[f - 1].angleTo(I) - I.angleTo(E);
                        for (R = Math.abs((R + 3 * Math.PI) % (2 * Math.PI) - Math.PI),
                        v.push({
                            distance: g,
                            angleDelta: R
                        }),
                        S += R; g - v[0].distance > a; )
                            S -= v.shift().angleDelta;
                        if (S > c)
                            return !1;
                        f++,
                        g += I.dist(E)
                    }
                    return !0
                }
                function O_(i) {
                    let t = 0;
                    for (let r = 0; r < i.length - 1; r++)
                        t += i[r].dist(i[r + 1]);
                    return t
                }
                function N_(i, t, r) {
                    return i ? .6 * t * r : 0
                }
                function j_(i, t) {
                    return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0)
                }
                function uy(i, t, r, a, c, p) {
                    const f = N_(r, c, p)
                      , g = j_(r, a) * p;
                    let v = 0;
                    const S = O_(i) / 2;
                    for (let I = 0; I < i.length - 1; I++) {
                        const E = i[I]
                          , R = i[I + 1]
                          , N = E.dist(R);
                        if (v + N > S) {
                            const j = (S - v) / N
                              , Z = Fa.number(E.x, R.x, j)
                              , Y = Fa.number(E.y, R.y, j)
                              , ae = new io(Z,Y,R.angleTo(E),I);
                            return ae._round(),
                            !f || F_(i, ae, g, f, t) ? ae : void 0
                        }
                        v += N
                    }
                }
                function hy(i, t, r, a, c, p, f, g, v) {
                    const S = N_(a, p, f)
                      , I = j_(a, c)
                      , E = I * f
                      , R = i[0].x === 0 || i[0].x === v || i[0].y === 0 || i[0].y === v;
                    return t - E < t / 4 && (t = E + t / 4),
                    q_(i, R ? t / 2 * g % t : (I / 2 + 2 * p) * f * g % t, t, S, r, E, R, !1, v)
                }
                function q_(i, t, r, a, c, p, f, g, v) {
                    const S = p / 2
                      , I = O_(i);
                    let E = 0
                      , R = t - r
                      , N = [];
                    for (let j = 0; j < i.length - 1; j++) {
                        const Z = i[j]
                          , Y = i[j + 1]
                          , ae = Z.dist(Y)
                          , ze = Y.angleTo(Z);
                        for (; R + r < E + ae; ) {
                            R += r;
                            const me = (R - E) / ae
                              , be = Fa.number(Z.x, Y.x, me)
                              , Ve = Fa.number(Z.y, Y.y, me);
                            if (be >= 0 && be < v && Ve >= 0 && Ve < v && R - S >= 0 && R + S <= I) {
                                const rt = new io(be,Ve,ze,j);
                                rt._round(),
                                a && !F_(i, rt, p, a, c) || N.push(rt)
                            }
                        }
                        E += ae
                    }
                    return g || N.length || f || (N = q_(i, E / 2, r, a, c, p, f, !0, v)),
                    N
                }
                function V_(i, t, r, a) {
                    const c = []
                      , p = i.image
                      , f = p.pixelRatio
                      , g = p.paddedRect.w - 2
                      , v = p.paddedRect.h - 2;
                    let S = {
                        x1: i.left,
                        y1: i.top,
                        x2: i.right,
                        y2: i.bottom
                    };
                    const I = p.stretchX || [[0, g]]
                      , E = p.stretchY || [[0, v]]
                      , R = (mt, Br) => mt + Br[1] - Br[0]
                      , N = I.reduce(R, 0)
                      , j = E.reduce(R, 0)
                      , Z = g - N
                      , Y = v - j;
                    let ae = 0
                      , ze = N
                      , me = 0
                      , be = j
                      , Ve = 0
                      , rt = Z
                      , St = 0
                      , $t = Y;
                    if (p.content && a) {
                        const mt = p.content
                          , Br = mt[2] - mt[0]
                          , Ur = mt[3] - mt[1];
                        (p.textFitWidth || p.textFitHeight) && (S = __(i)),
                        ae = md(I, 0, mt[0]),
                        me = md(E, 0, mt[1]),
                        ze = md(I, mt[0], mt[2]),
                        be = md(E, mt[1], mt[3]),
                        Ve = mt[0] - ae,
                        St = mt[1] - me,
                        rt = Br - ze,
                        $t = Ur - be
                    }
                    const Bt = S.x1
                      , Ut = S.y1
                      , pr = S.x2 - Bt
                      , Vt = S.y2 - Ut
                      , Zt = (mt, Br, Ur, xr) => {
                        const or = _d(mt.stretch - ae, ze, pr, Bt)
                          , oi = gd(mt.fixed - Ve, rt, mt.stretch, N)
                          , Zi = _d(Br.stretch - me, be, Vt, Ut)
                          , fn = gd(Br.fixed - St, $t, Br.stretch, j)
                          , Bn = _d(Ur.stretch - ae, ze, pr, Bt)
                          , Aa = gd(Ur.fixed - Ve, rt, Ur.stretch, N)
                          , aa = _d(xr.stretch - me, be, Vt, Ut)
                          , Mn = gd(xr.fixed - St, $t, xr.stretch, j)
                          , qi = new $(or,Zi)
                          , wn = new $(Bn,Zi)
                          , An = new $(Bn,aa)
                          , kn = new $(or,aa)
                          , Yn = new $(oi / f,fn / f)
                          , ka = new $(Aa / f,Mn / f)
                          , Tn = t * Math.PI / 180;
                        if (Tn) {
                            const Cn = Math.sin(Tn)
                              , Sn = Math.cos(Tn)
                              , rn = [Sn, -Cn, Cn, Sn];
                            qi._matMult(rn),
                            wn._matMult(rn),
                            kn._matMult(rn),
                            An._matMult(rn)
                        }
                        const sa = mt.stretch + mt.fixed
                          , mn = Br.stretch + Br.fixed;
                        return {
                            tl: qi,
                            tr: wn,
                            bl: kn,
                            br: An,
                            tex: {
                                x: p.paddedRect.x + 1 + sa,
                                y: p.paddedRect.y + 1 + mn,
                                w: Ur.stretch + Ur.fixed - sa,
                                h: xr.stretch + xr.fixed - mn
                            },
                            writingMode: void 0,
                            glyphOffset: [0, 0],
                            sectionIndex: 0,
                            pixelOffsetTL: Yn,
                            pixelOffsetBR: ka,
                            minFontScaleX: rt / f / pr,
                            minFontScaleY: $t / f / Vt,
                            isSDF: r
                        }
                    }
                    ;
                    if (a && (p.stretchX || p.stretchY)) {
                        const mt = U_(I, Z, N)
                          , Br = U_(E, Y, j);
                        for (let Ur = 0; Ur < mt.length - 1; Ur++) {
                            const xr = mt[Ur]
                              , or = mt[Ur + 1];
                            for (let oi = 0; oi < Br.length - 1; oi++)
                                c.push(Zt(xr, Br[oi], or, Br[oi + 1]))
                        }
                    } else
                        c.push(Zt({
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: g + 1
                        }, {
                            fixed: 0,
                            stretch: v + 1
                        }));
                    return c
                }
                function md(i, t, r) {
                    let a = 0;
                    for (const c of i)
                        a += Math.max(t, Math.min(r, c[1])) - Math.max(t, Math.min(r, c[0]));
                    return a
                }
                function U_(i, t, r) {
                    const a = [{
                        fixed: -1,
                        stretch: 0
                    }];
                    for (const [c,p] of i) {
                        const f = a[a.length - 1];
                        a.push({
                            fixed: c - f.stretch,
                            stretch: f.stretch
                        }),
                        a.push({
                            fixed: c - f.stretch,
                            stretch: f.stretch + (p - c)
                        })
                    }
                    return a.push({
                        fixed: t + 1,
                        stretch: r
                    }),
                    a
                }
                function _d(i, t, r, a) {
                    return i / t * r + a
                }
                function gd(i, t, r, a) {
                    return i - t * r / a
                }
                Kt("Anchor", io);
                class vd {
                    constructor(t, r, a, c, p, f, g, v, S, I) {
                        var E;
                        if (this.boxStartIndex = t.length,
                        S) {
                            let R = f.top
                              , N = f.bottom;
                            const j = f.collisionPadding;
                            j && (R -= j[1],
                            N += j[3]);
                            let Z = N - R;
                            Z > 0 && (Z = Math.max(10, Z),
                            this.circleDiameter = Z)
                        } else {
                            const R = !((E = f.image) === null || E === void 0) && E.content && (f.image.textFitWidth || f.image.textFitHeight) ? __(f) : {
                                x1: f.left,
                                y1: f.top,
                                x2: f.right,
                                y2: f.bottom
                            };
                            R.y1 = R.y1 * g - v[0],
                            R.y2 = R.y2 * g + v[2],
                            R.x1 = R.x1 * g - v[3],
                            R.x2 = R.x2 * g + v[1];
                            const N = f.collisionPadding;
                            if (N && (R.x1 -= N[0] * g,
                            R.y1 -= N[1] * g,
                            R.x2 += N[2] * g,
                            R.y2 += N[3] * g),
                            I) {
                                const j = new $(R.x1,R.y1)
                                  , Z = new $(R.x2,R.y1)
                                  , Y = new $(R.x1,R.y2)
                                  , ae = new $(R.x2,R.y2)
                                  , ze = I * Math.PI / 180;
                                j._rotate(ze),
                                Z._rotate(ze),
                                Y._rotate(ze),
                                ae._rotate(ze),
                                R.x1 = Math.min(j.x, Z.x, Y.x, ae.x),
                                R.x2 = Math.max(j.x, Z.x, Y.x, ae.x),
                                R.y1 = Math.min(j.y, Z.y, Y.y, ae.y),
                                R.y2 = Math.max(j.y, Z.y, Y.y, ae.y)
                            }
                            t.emplaceBack(r.x, r.y, R.x1, R.y1, R.x2, R.y2, a, c, p)
                        }
                        this.boxEndIndex = t.length
                    }
                }
                class dy {
                    constructor(t=[], r= (a, c) => a < c ? -1 : a > c ? 1 : 0) {
                        if (this.data = t,
                        this.length = this.data.length,
                        this.compare = r,
                        this.length > 0)
                            for (let a = (this.length >> 1) - 1; a >= 0; a--)
                                this._down(a)
                    }
                    push(t) {
                        this.data.push(t),
                        this._up(this.length++)
                    }
                    pop() {
                        if (this.length === 0)
                            return;
                        const t = this.data[0]
                          , r = this.data.pop();
                        return --this.length > 0 && (this.data[0] = r,
                        this._down(0)),
                        t
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(t) {
                        const {data: r, compare: a} = this
                          , c = r[t];
                        for (; t > 0; ) {
                            const p = t - 1 >> 1
                              , f = r[p];
                            if (a(c, f) >= 0)
                                break;
                            r[t] = f,
                            t = p
                        }
                        r[t] = c
                    }
                    _down(t) {
                        const {data: r, compare: a} = this
                          , c = this.length >> 1
                          , p = r[t];
                        for (; t < c; ) {
                            let f = 1 + (t << 1);
                            const g = f + 1;
                            if (g < this.length && a(r[g], r[f]) < 0 && (f = g),
                            a(r[f], p) >= 0)
                                break;
                            r[t] = r[f],
                            t = f
                        }
                        r[t] = p
                    }
                }
                function py(i, t=1, r=!1) {
                    const a = Oo.fromPoints(i[0])
                      , c = Math.min(a.width(), a.height());
                    let p = c / 2;
                    const f = new dy([],fy)
                      , {minX: g, minY: v, maxX: S, maxY: I} = a;
                    if (c === 0)
                        return new $(g,v);
                    for (let N = g; N < S; N += c)
                        for (let j = v; j < I; j += c)
                            f.push(new ql(N + p,j + p,p,i));
                    let E = (function(N) {
                        let j = 0
                          , Z = 0
                          , Y = 0;
                        const ae = N[0];
                        for (let ze = 0, me = ae.length, be = me - 1; ze < me; be = ze++) {
                            const Ve = ae[ze]
                              , rt = ae[be]
                              , St = Ve.x * rt.y - rt.x * Ve.y;
                            Z += (Ve.x + rt.x) * St,
                            Y += (Ve.y + rt.y) * St,
                            j += 3 * St
                        }
                        return new ql(Z / j,Y / j,0,N)
                    }
                    )(i)
                      , R = f.length;
                    for (; f.length; ) {
                        const N = f.pop();
                        (N.d > E.d || !E.d) && (E = N,
                        r && console.log("found best %d after %d probes", Math.round(1e4 * N.d) / 1e4, R)),
                        N.max - E.d <= t || (p = N.h / 2,
                        f.push(new ql(N.p.x - p,N.p.y - p,p,i)),
                        f.push(new ql(N.p.x + p,N.p.y - p,p,i)),
                        f.push(new ql(N.p.x - p,N.p.y + p,p,i)),
                        f.push(new ql(N.p.x + p,N.p.y + p,p,i)),
                        R += 4)
                    }
                    return r && (console.log(`num probes: ${R}`),
                    console.log(`best distance: ${E.d}`)),
                    E.p
                }
                function fy(i, t) {
                    return t.max - i.max
                }
                function ql(i, t, r, a) {
                    this.p = new $(i,t),
                    this.h = r,
                    this.d = (function(c, p) {
                        let f = !1
                          , g = 1 / 0;
                        for (let v = 0; v < p.length; v++) {
                            const S = p[v];
                            for (let I = 0, E = S.length, R = E - 1; I < E; R = I++) {
                                const N = S[I]
                                  , j = S[R];
                                N.y > c.y != j.y > c.y && c.x < (j.x - N.x) * (c.y - N.y) / (j.y - N.y) + N.x && (f = !f),
                                g = Math.min(g, Im(c, N, j))
                            }
                        }
                        return (f ? 1 : -1) * Math.sqrt(g)
                    }
                    )(this.p, a),
                    this.max = this.d + this.h * Math.SQRT2
                }
                var Rn;
                T.aE = void 0,
                (Rn = T.aE || (T.aE = {}))[Rn.center = 1] = "center",
                Rn[Rn.left = 2] = "left",
                Rn[Rn.right = 3] = "right",
                Rn[Rn.top = 4] = "top",
                Rn[Rn.bottom = 5] = "bottom",
                Rn[Rn["top-left"] = 6] = "top-left",
                Rn[Rn["top-right"] = 7] = "top-right",
                Rn[Rn["bottom-left"] = 8] = "bottom-left",
                Rn[Rn["bottom-right"] = 9] = "bottom-right";
                const Kp = Number.POSITIVE_INFINITY;
                function Z_(i, t) {
                    return t[1] !== Kp ? (function(r, a, c) {
                        let p = 0
                          , f = 0;
                        switch (a = Math.abs(a),
                        c = Math.abs(c),
                        r) {
                        case "top-right":
                        case "top-left":
                        case "top":
                            f = c - 7;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                        case "bottom":
                            f = 7 - c
                        }
                        switch (r) {
                        case "top-right":
                        case "bottom-right":
                        case "right":
                            p = -a;
                            break;
                        case "top-left":
                        case "bottom-left":
                        case "left":
                            p = a
                        }
                        return [p, f]
                    }
                    )(i, t[0], t[1]) : (function(r, a) {
                        let c = 0
                          , p = 0;
                        a < 0 && (a = 0);
                        const f = a / Math.SQRT2;
                        switch (r) {
                        case "top-right":
                        case "top-left":
                            p = f - 7;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                            p = 7 - f;
                            break;
                        case "bottom":
                            p = 7 - a;
                            break;
                        case "top":
                            p = a - 7
                        }
                        switch (r) {
                        case "top-right":
                        case "bottom-right":
                            c = -f;
                            break;
                        case "top-left":
                        case "bottom-left":
                            c = f;
                            break;
                        case "left":
                            c = a;
                            break;
                        case "right":
                            c = -a
                        }
                        return [c, p]
                    }
                    )(i, t[0])
                }
                function $_(i, t, r) {
                    var a;
                    const c = i.layout
                      , p = (a = c.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(t, {}, r);
                    if (p) {
                        const g = p.values
                          , v = [];
                        for (let S = 0; S < g.length; S += 2) {
                            const I = v[S] = g[S]
                              , E = g[S + 1].map((R => R * bn));
                            I.startsWith("top") ? E[1] -= 7 : I.startsWith("bottom") && (E[1] += 7),
                            v[S + 1] = E
                        }
                        return new un(v)
                    }
                    const f = c.get("text-variable-anchor");
                    if (f) {
                        let g;
                        g = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [c.get("text-radial-offset").evaluate(t, {}, r) * bn, Kp] : c.get("text-offset").evaluate(t, {}, r).map((S => S * bn));
                        const v = [];
                        for (const S of f)
                            v.push(S, Z_(S, g));
                        return new un(v)
                    }
                    return null
                }
                function Yp(i) {
                    switch (i) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        return "right";
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        return "left"
                    }
                    return "center"
                }
                function my(i, t, r, a, c, p, f, g, v, S, I, E) {
                    let R = p.textMaxSize.evaluate(t, {});
                    R === void 0 && (R = f);
                    const N = i.layers[0].layout
                      , j = N.get("icon-offset").evaluate(t, {}, I)
                      , Z = H_(r.horizontal)
                      , Y = f / 24
                      , ae = i.tilePixelRatio * Y
                      , ze = i.tilePixelRatio * R / 24
                      , me = i.tilePixelRatio * g
                      , be = i.tilePixelRatio * N.get("symbol-spacing")
                      , Ve = N.get("text-padding") * i.tilePixelRatio
                      , rt = (function(Ur, xr, or, oi=1) {
                        const Zi = Ur.get("icon-padding").evaluate(xr, {}, or)
                          , fn = Zi && Zi.values;
                        return [fn[0] * oi, fn[1] * oi, fn[2] * oi, fn[3] * oi]
                    }
                    )(N, t, I, i.tilePixelRatio)
                      , St = N.get("text-max-angle") / 180 * Math.PI
                      , $t = N.get("text-rotation-alignment") !== "viewport" && N.get("symbol-placement") !== "point"
                      , Bt = N.get("icon-rotation-alignment") === "map" && N.get("symbol-placement") !== "point"
                      , Ut = N.get("symbol-placement")
                      , pr = be / 2
                      , Vt = N.get("icon-text-fit");
                    let Zt;
                    a && Vt !== "none" && (i.allowVerticalPlacement && r.vertical && (Zt = g_(a, r.vertical, Vt, N.get("icon-text-fit-padding"), j, Y)),
                    Z && (a = g_(a, Z, Vt, N.get("icon-text-fit-padding"), j, Y)));
                    const mt = I ? E.line.getGranularityForZoomLevel(I.z) : 1
                      , Br = (Ur, xr) => {
                        xr.x < 0 || xr.x >= ne || xr.y < 0 || xr.y >= ne || (function(or, oi, Zi, fn, Bn, Aa, aa, Mn, qi, wn, An, kn, Yn, ka, Tn, sa, mn, Cn, Sn, rn, Bi, Xa, Vl, Ka, vy) {
                            const Ul = or.addToLineVertexArray(oi, Zi);
                            let No, Zl, $l, Gl, Y_ = 0, J_ = 0, Q_ = 0, eg = 0, sf = -1, of = -1;
                            const ks = {};
                            let tg = Js("");
                            if (or.allowVerticalPlacement && fn.vertical) {
                                const Un = Mn.layout.get("text-rotate").evaluate(Bi, {}, Ka) + 90;
                                $l = new vd(qi,oi,wn,An,kn,fn.vertical,Yn,ka,Tn,Un),
                                aa && (Gl = new vd(qi,oi,wn,An,kn,aa,mn,Cn,Tn,Un))
                            }
                            if (Bn) {
                                const Un = Mn.layout.get("icon-rotate").evaluate(Bi, {})
                                  , Ea = Mn.layout.get("icon-text-fit") !== "none"
                                  , jo = V_(Bn, Un, Vl, Ea)
                                  , Ja = aa ? V_(aa, Un, Vl, Ea) : void 0;
                                Zl = new vd(qi,oi,wn,An,kn,Bn,mn,Cn,!1,Un),
                                Y_ = 4 * jo.length;
                                const qo = or.iconSizeData;
                                let us = null;
                                qo.kind === "source" ? (us = [As * Mn.layout.get("icon-size").evaluate(Bi, {})],
                                us[0] > to && Lt(`${or.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : qo.kind === "composite" && (us = [As * Xa.compositeIconSizes[0].evaluate(Bi, {}, Ka), As * Xa.compositeIconSizes[1].evaluate(Bi, {}, Ka)],
                                (us[0] > to || us[1] > to) && Lt(`${or.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)),
                                or.addSymbols(or.icon, jo, us, rn, Sn, Bi, T.ao.none, oi, Ul.lineStartIndex, Ul.lineLength, -1, Ka),
                                sf = or.icon.placedSymbolArray.length - 1,
                                Ja && (J_ = 4 * Ja.length,
                                or.addSymbols(or.icon, Ja, us, rn, Sn, Bi, T.ao.vertical, oi, Ul.lineStartIndex, Ul.lineLength, -1, Ka),
                                of = or.icon.placedSymbolArray.length - 1)
                            }
                            const rg = Object.keys(fn.horizontal);
                            for (const Un of rg) {
                                const Ea = fn.horizontal[Un];
                                if (!No) {
                                    tg = Js(Ea.text);
                                    const Ja = Mn.layout.get("text-rotate").evaluate(Bi, {}, Ka);
                                    No = new vd(qi,oi,wn,An,kn,Ea,Yn,ka,Tn,Ja)
                                }
                                const jo = Ea.positionedLines.length === 1;
                                if (Q_ += G_(or, oi, Ea, Aa, Mn, Tn, Bi, sa, Ul, fn.vertical ? T.ao.horizontal : T.ao.horizontalOnly, jo ? rg : [Un], ks, sf, Xa, Ka),
                                jo)
                                    break
                            }
                            fn.vertical && (eg += G_(or, oi, fn.vertical, Aa, Mn, Tn, Bi, sa, Ul, T.ao.vertical, ["vertical"], ks, of, Xa, Ka));
                            const yy = No ? No.boxStartIndex : or.collisionBoxArray.length
                              , xy = No ? No.boxEndIndex : or.collisionBoxArray.length
                              , by = $l ? $l.boxStartIndex : or.collisionBoxArray.length
                              , wy = $l ? $l.boxEndIndex : or.collisionBoxArray.length
                              , Ty = Zl ? Zl.boxStartIndex : or.collisionBoxArray.length
                              , Cy = Zl ? Zl.boxEndIndex : or.collisionBoxArray.length
                              , Sy = Gl ? Gl.boxStartIndex : or.collisionBoxArray.length
                              , Py = Gl ? Gl.boxEndIndex : or.collisionBoxArray.length;
                            let Ya = -1;
                            const xd = (Un, Ea) => Un && Un.circleDiameter ? Math.max(Un.circleDiameter, Ea) : Ea;
                            Ya = xd(No, Ya),
                            Ya = xd($l, Ya),
                            Ya = xd(Zl, Ya),
                            Ya = xd(Gl, Ya);
                            const ig = Ya > -1 ? 1 : 0;
                            ig && (Ya *= vy / bn),
                            or.glyphOffsetArray.length >= Nl.MAX_GLYPHS && Lt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),
                            Bi.sortKey !== void 0 && or.addToSortKeyRanges(or.symbolInstances.length, Bi.sortKey);
                            const Iy = $_(Mn, Bi, Ka)
                              , [My,Ay] = (function(Un, Ea) {
                                const jo = Un.length
                                  , Ja = Ea == null ? void 0 : Ea.values;
                                if ((Ja == null ? void 0 : Ja.length) > 0)
                                    for (let qo = 0; qo < Ja.length; qo += 2) {
                                        const us = Ja[qo + 1];
                                        Un.emplaceBack(T.aE[Ja[qo]], us[0], us[1])
                                    }
                                return [jo, Un.length]
                            }
                            )(or.textAnchorOffsets, Iy);
                            or.symbolInstances.emplaceBack(oi.x, oi.y, ks.right >= 0 ? ks.right : -1, ks.center >= 0 ? ks.center : -1, ks.left >= 0 ? ks.left : -1, ks.vertical || -1, sf, of, tg, yy, xy, by, wy, Ty, Cy, Sy, Py, wn, Q_, eg, Y_, J_, ig, 0, Yn, Ya, My, Ay)
                        }
                        )(i, xr, Ur, r, a, c, Zt, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, ae, [Ve, Ve, Ve, Ve], $t, v, me, rt, Bt, j, t, p, S, I, f)
                    }
                    ;
                    if (Ut === "line")
                        for (const Ur of B_(t.geometry, 0, 0, ne, ne)) {
                            const xr = Fo(Ur, mt)
                              , or = hy(xr, be, St, r.vertical || Z, a, 24, ze, i.overscaling, ne);
                            for (const oi of or)
                                Z && _y(i, Z.text, pr, oi) || Br(xr, oi)
                        }
                    else if (Ut === "line-center") {
                        for (const Ur of t.geometry)
                            if (Ur.length > 1) {
                                const xr = Fo(Ur, mt)
                                  , or = uy(xr, St, r.vertical || Z, a, 24, ze);
                                or && Br(xr, or)
                            }
                    } else if (t.type === "Polygon")
                        for (const Ur of xo(t.geometry, 0)) {
                            const xr = py(Ur, 16);
                            Br(Fo(Ur[0], mt, !0), new io(xr.x,xr.y,0))
                        }
                    else if (t.type === "LineString")
                        for (const Ur of t.geometry) {
                            const xr = Fo(Ur, mt);
                            Br(xr, new io(xr[0].x,xr[0].y,0))
                        }
                    else if (t.type === "Point")
                        for (const Ur of t.geometry)
                            for (const xr of Ur)
                                Br([xr], new io(xr.x,xr.y,0))
                }
                function G_(i, t, r, a, c, p, f, g, v, S, I, E, R, N, j) {
                    const Z = (function(ze, me, be, Ve, rt, St, $t, Bt) {
                        const Ut = Ve.layout.get("text-rotate").evaluate(St, {}) * Math.PI / 180
                          , pr = [];
                        for (const Vt of me.positionedLines)
                            for (const Zt of Vt.positionedGlyphs) {
                                if (!Zt.rect)
                                    continue;
                                const mt = Zt.rect || {};
                                let Br = 4
                                  , Ur = !0
                                  , xr = 1
                                  , or = 0;
                                const oi = (rt || Bt) && Zt.vertical
                                  , Zi = Zt.metrics.advance * Zt.scale / 2;
                                if (Bt && me.verticalizable && (or = Vt.lineOffset / 2 - (Zt.imageName ? -(bn - Zt.metrics.width * Zt.scale) / 2 : (Zt.scale - 1) * bn)),
                                Zt.imageName) {
                                    const Cn = $t[Zt.imageName];
                                    Ur = Cn.sdf,
                                    xr = Cn.pixelRatio,
                                    Br = 1 / xr
                                }
                                const fn = rt ? [Zt.x + Zi, Zt.y] : [0, 0];
                                let Bn = rt ? [0, 0] : [Zt.x + Zi + be[0], Zt.y + be[1] - or]
                                  , Aa = [0, 0];
                                oi && (Aa = Bn,
                                Bn = [0, 0]);
                                const aa = Zt.metrics.isDoubleResolution ? 2 : 1
                                  , Mn = (Zt.metrics.left - Br) * Zt.scale - Zi + Bn[0]
                                  , qi = (-Zt.metrics.top - Br) * Zt.scale + Bn[1]
                                  , wn = Mn + mt.w / aa * Zt.scale / xr
                                  , An = qi + mt.h / aa * Zt.scale / xr
                                  , kn = new $(Mn,qi)
                                  , Yn = new $(wn,qi)
                                  , ka = new $(Mn,An)
                                  , Tn = new $(wn,An);
                                if (oi) {
                                    const Cn = new $(-Zi,Zi - -17)
                                      , Sn = -Math.PI / 2
                                      , rn = 12 - Zi
                                      , Bi = new $(22 - rn,-(Zt.imageName ? rn : 0))
                                      , Xa = new $(...Aa);
                                    kn._rotateAround(Sn, Cn)._add(Bi)._add(Xa),
                                    Yn._rotateAround(Sn, Cn)._add(Bi)._add(Xa),
                                    ka._rotateAround(Sn, Cn)._add(Bi)._add(Xa),
                                    Tn._rotateAround(Sn, Cn)._add(Bi)._add(Xa)
                                }
                                if (Ut) {
                                    const Cn = Math.sin(Ut)
                                      , Sn = Math.cos(Ut)
                                      , rn = [Sn, -Cn, Cn, Sn];
                                    kn._matMult(rn),
                                    Yn._matMult(rn),
                                    ka._matMult(rn),
                                    Tn._matMult(rn)
                                }
                                const sa = new $(0,0)
                                  , mn = new $(0,0);
                                pr.push({
                                    tl: kn,
                                    tr: Yn,
                                    bl: ka,
                                    br: Tn,
                                    tex: mt,
                                    writingMode: me.writingMode,
                                    glyphOffset: fn,
                                    sectionIndex: Zt.sectionIndex,
                                    isSDF: Ur,
                                    pixelOffsetTL: sa,
                                    pixelOffsetBR: mn,
                                    minFontScaleX: 0,
                                    minFontScaleY: 0
                                })
                            }
                        return pr
                    }
                    )(0, r, g, c, p, f, a, i.allowVerticalPlacement)
                      , Y = i.textSizeData;
                    let ae = null;
                    Y.kind === "source" ? (ae = [As * c.layout.get("text-size").evaluate(f, {})],
                    ae[0] > to && Lt(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : Y.kind === "composite" && (ae = [As * N.compositeTextSizes[0].evaluate(f, {}, j), As * N.compositeTextSizes[1].evaluate(f, {}, j)],
                    (ae[0] > to || ae[1] > to) && Lt(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)),
                    i.addSymbols(i.text, Z, ae, g, p, f, S, t, v.lineStartIndex, v.lineLength, R, j);
                    for (const ze of I)
                        E[ze] = i.text.placedSymbolArray.length - 1;
                    return 4 * Z.length
                }
                function H_(i) {
                    for (const t in i)
                        return i[t];
                    return null
                }
                function _y(i, t, r, a) {
                    const c = i.compareText;
                    if (t in c) {
                        const p = c[t];
                        for (let f = p.length - 1; f >= 0; f--)
                            if (a.dist(p[f]) < r)
                                return !0
                    } else
                        c[t] = [];
                    return c[t].push(a),
                    !1
                }
                const W_ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
                class Jp {
                    static from(t) {
                        if (!(t instanceof ArrayBuffer))
                            throw new Error("Data must be an instance of ArrayBuffer.");
                        const [r,a] = new Uint8Array(t,0,2);
                        if (r !== 219)
                            throw new Error("Data does not appear to be in a KDBush format.");
                        const c = a >> 4;
                        if (c !== 1)
                            throw new Error(`Got v${c} data when expected v1.`);
                        const p = W_[15 & a];
                        if (!p)
                            throw new Error("Unrecognized array type.");
                        const [f] = new Uint16Array(t,2,1)
                          , [g] = new Uint32Array(t,4,1);
                        return new Jp(g,f,p,t)
                    }
                    constructor(t, r=64, a=Float64Array, c) {
                        if (isNaN(t) || t < 0)
                            throw new Error(`Unpexpected numItems value: ${t}.`);
                        this.numItems = +t,
                        this.nodeSize = Math.min(Math.max(+r, 2), 65535),
                        this.ArrayType = a,
                        this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
                        const p = W_.indexOf(this.ArrayType)
                          , f = 2 * t * this.ArrayType.BYTES_PER_ELEMENT
                          , g = t * this.IndexArrayType.BYTES_PER_ELEMENT
                          , v = (8 - g % 8) % 8;
                        if (p < 0)
                            throw new Error(`Unexpected typed array class: ${a}.`);
                        c && c instanceof ArrayBuffer ? (this.data = c,
                        this.ids = new this.IndexArrayType(this.data,8,t),
                        this.coords = new this.ArrayType(this.data,8 + g + v,2 * t),
                        this._pos = 2 * t,
                        this._finished = !0) : (this.data = new ArrayBuffer(8 + f + g + v),
                        this.ids = new this.IndexArrayType(this.data,8,t),
                        this.coords = new this.ArrayType(this.data,8 + g + v,2 * t),
                        this._pos = 0,
                        this._finished = !1,
                        new Uint8Array(this.data,0,2).set([219, 16 + p]),
                        new Uint16Array(this.data,2,1)[0] = r,
                        new Uint32Array(this.data,4,1)[0] = t)
                    }
                    add(t, r) {
                        const a = this._pos >> 1;
                        return this.ids[a] = a,
                        this.coords[this._pos++] = t,
                        this.coords[this._pos++] = r,
                        a
                    }
                    finish() {
                        const t = this._pos >> 1;
                        if (t !== this.numItems)
                            throw new Error(`Added ${t} items when expected ${this.numItems}.`);
                        return Qp(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
                        this._finished = !0,
                        this
                    }
                    range(t, r, a, c) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: p, coords: f, nodeSize: g} = this
                          , v = [0, p.length - 1, 0]
                          , S = [];
                        for (; v.length; ) {
                            const I = v.pop() || 0
                              , E = v.pop() || 0
                              , R = v.pop() || 0;
                            if (E - R <= g) {
                                for (let Y = R; Y <= E; Y++) {
                                    const ae = f[2 * Y]
                                      , ze = f[2 * Y + 1];
                                    ae >= t && ae <= a && ze >= r && ze <= c && S.push(p[Y])
                                }
                                continue
                            }
                            const N = R + E >> 1
                              , j = f[2 * N]
                              , Z = f[2 * N + 1];
                            j >= t && j <= a && Z >= r && Z <= c && S.push(p[N]),
                            (I === 0 ? t <= j : r <= Z) && (v.push(R),
                            v.push(N - 1),
                            v.push(1 - I)),
                            (I === 0 ? a >= j : c >= Z) && (v.push(N + 1),
                            v.push(E),
                            v.push(1 - I))
                        }
                        return S
                    }
                    within(t, r, a) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: c, coords: p, nodeSize: f} = this
                          , g = [0, c.length - 1, 0]
                          , v = []
                          , S = a * a;
                        for (; g.length; ) {
                            const I = g.pop() || 0
                              , E = g.pop() || 0
                              , R = g.pop() || 0;
                            if (E - R <= f) {
                                for (let Y = R; Y <= E; Y++)
                                    K_(p[2 * Y], p[2 * Y + 1], t, r) <= S && v.push(c[Y]);
                                continue
                            }
                            const N = R + E >> 1
                              , j = p[2 * N]
                              , Z = p[2 * N + 1];
                            K_(j, Z, t, r) <= S && v.push(c[N]),
                            (I === 0 ? t - a <= j : r - a <= Z) && (g.push(R),
                            g.push(N - 1),
                            g.push(1 - I)),
                            (I === 0 ? t + a >= j : r + a >= Z) && (g.push(N + 1),
                            g.push(E),
                            g.push(1 - I))
                        }
                        return v
                    }
                }
                function Qp(i, t, r, a, c, p) {
                    if (c - a <= r)
                        return;
                    const f = a + c >> 1;
                    X_(i, t, f, a, c, p),
                    Qp(i, t, r, a, f - 1, 1 - p),
                    Qp(i, t, r, f + 1, c, 1 - p)
                }
                function X_(i, t, r, a, c, p) {
                    for (; c > a; ) {
                        if (c - a > 600) {
                            const S = c - a + 1
                              , I = r - a + 1
                              , E = Math.log(S)
                              , R = .5 * Math.exp(2 * E / 3)
                              , N = .5 * Math.sqrt(E * R * (S - R) / S) * (I - S / 2 < 0 ? -1 : 1);
                            X_(i, t, r, Math.max(a, Math.floor(r - I * R / S + N)), Math.min(c, Math.floor(r + (S - I) * R / S + N)), p)
                        }
                        const f = t[2 * r + p];
                        let g = a
                          , v = c;
                        for (_u(i, t, a, r),
                        t[2 * c + p] > f && _u(i, t, a, c); g < v; ) {
                            for (_u(i, t, g, v),
                            g++,
                            v--; t[2 * g + p] < f; )
                                g++;
                            for (; t[2 * v + p] > f; )
                                v--
                        }
                        t[2 * a + p] === f ? _u(i, t, a, v) : (v++,
                        _u(i, t, v, c)),
                        v <= r && (a = v + 1),
                        r <= v && (c = v - 1)
                    }
                }
                function _u(i, t, r, a) {
                    ef(i, r, a),
                    ef(t, 2 * r, 2 * a),
                    ef(t, 2 * r + 1, 2 * a + 1)
                }
                function ef(i, t, r) {
                    const a = i[t];
                    i[t] = i[r],
                    i[r] = a
                }
                function K_(i, t, r, a) {
                    const c = i - r
                      , p = t - a;
                    return c * c + p * p
                }
                var tf;
                T.cx = void 0,
                (tf = T.cx || (T.cx = {})).create = "create",
                tf.load = "load",
                tf.fullLoad = "fullLoad";
                let yd = null
                  , gu = [];
                const rf = 1e3 / 60
                  , nf = "loadTime"
                  , af = "fullLoadTime"
                  , gy = {
                    mark(i) {
                        performance.mark(i)
                    },
                    frame(i) {
                        const t = i;
                        yd != null && gu.push(t - yd),
                        yd = t
                    },
                    clearMetrics() {
                        yd = null,
                        gu = [],
                        performance.clearMeasures(nf),
                        performance.clearMeasures(af);
                        for (const i in T.cx)
                            performance.clearMarks(T.cx[i])
                    },
                    getPerformanceMetrics() {
                        performance.measure(nf, T.cx.create, T.cx.load),
                        performance.measure(af, T.cx.create, T.cx.fullLoad);
                        const i = performance.getEntriesByName(nf)[0].duration
                          , t = performance.getEntriesByName(af)[0].duration
                          , r = gu.length
                          , a = 1 / (gu.reduce(( (p, f) => p + f), 0) / r / 1e3)
                          , c = gu.filter((p => p > rf)).reduce(( (p, f) => p + (f - rf) / rf), 0);
                        return {
                            loadTime: i,
                            fullLoadTime: t,
                            fps: a,
                            percentDroppedFrames: c / (r + c) * 100,
                            totalFrames: r
                        }
                    }
                };
                T.$ = ne,
                T.A = Ee,
                T.B = function([i,t,r]) {
                    return t += 90,
                    t *= Math.PI / 180,
                    r *= Math.PI / 180,
                    {
                        x: i * Math.cos(t) * Math.sin(r),
                        y: i * Math.sin(t) * Math.sin(r),
                        z: i * Math.cos(r)
                    }
                }
                ,
                T.C = Fa,
                T.D = hr,
                T.E = Ot,
                T.F = Oi,
                T.G = ko,
                T.H = function(i) {
                    if (nr == null) {
                        const t = i.navigator ? i.navigator.userAgent : null;
                        nr = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
                    }
                    return nr
                }
                ,
                T.I = Np,
                T.J = class {
                    constructor(i, t) {
                        this.target = i,
                        this.mapId = t,
                        this.resolveRejects = {},
                        this.tasks = {},
                        this.taskQueue = [],
                        this.abortControllers = {},
                        this.messageHandlers = {},
                        this.invoker = new oy(( () => this.process())),
                        this.subscription = jr(this.target, "message", (r => this.receive(r)), !1),
                        this.globalScope = Yt(self) ? i : window
                    }
                    registerMessageHandler(i, t) {
                        this.messageHandlers[i] = t
                    }
                    sendAsync(i, t) {
                        return new Promise(( (r, a) => {
                            const c = Math.round(1e18 * Math.random()).toString(36).substring(0, 10)
                              , p = t ? jr(t.signal, "abort", ( () => {
                                p == null || p.unsubscribe(),
                                delete this.resolveRejects[c];
                                const v = {
                                    id: c,
                                    type: "<cancel>",
                                    origin: location.origin,
                                    targetMapId: i.targetMapId,
                                    sourceMapId: this.mapId
                                };
                                this.target.postMessage(v)
                            }
                            ), ly) : null;
                            this.resolveRejects[c] = {
                                resolve: v => {
                                    p == null || p.unsubscribe(),
                                    r(v)
                                }
                                ,
                                reject: v => {
                                    p == null || p.unsubscribe(),
                                    a(v)
                                }
                            };
                            const f = []
                              , g = Object.assign(Object.assign({}, i), {
                                id: c,
                                sourceMapId: this.mapId,
                                origin: location.origin,
                                data: Gs(i.data, f)
                            });
                            this.target.postMessage(g, {
                                transfer: f
                            })
                        }
                        ))
                    }
                    receive(i) {
                        const t = i.data
                          , r = t.id;
                        if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
                            if (t.type === "<cancel>") {
                                delete this.tasks[r];
                                const a = this.abortControllers[r];
                                return delete this.abortControllers[r],
                                void (a && a.abort())
                            }
                            if (Yt(self) || t.mustQueue)
                                return this.tasks[r] = t,
                                this.taskQueue.push(r),
                                void this.invoker.trigger();
                            this.processTask(r, t)
                        }
                    }
                    process() {
                        if (this.taskQueue.length === 0)
                            return;
                        const i = this.taskQueue.shift()
                          , t = this.tasks[i];
                        delete this.tasks[i],
                        this.taskQueue.length > 0 && this.invoker.trigger(),
                        t && this.processTask(i, t)
                    }
                    processTask(i, t) {
                        return o(this, void 0, void 0, (function*() {
                            if (t.type === "<response>") {
                                const c = this.resolveRejects[i];
                                return delete this.resolveRejects[i],
                                c ? void (t.error ? c.reject(Cs(t.error)) : c.resolve(Cs(t.data))) : void 0
                            }
                            if (!this.messageHandlers[t.type])
                                return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
                            const r = Cs(t.data)
                              , a = new AbortController;
                            this.abortControllers[i] = a;
                            try {
                                const c = yield this.messageHandlers[t.type](t.sourceMapId, r, a);
                                this.completeTask(i, null, c)
                            } catch (c) {
                                this.completeTask(i, c)
                            }
                        }
                        ))
                    }
                    completeTask(i, t, r) {
                        const a = [];
                        delete this.abortControllers[i];
                        const c = {
                            id: i,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            origin: location.origin,
                            error: t ? Gs(t) : null,
                            data: Gs(r, a)
                        };
                        this.target.postMessage(c, {
                            transfer: a
                        })
                    }
                    remove() {
                        this.invoker.remove(),
                        this.subscription.unsubscribe()
                    }
                }
                ,
                T.K = G,
                T.L = function() {
                    var i = new Ee(16);
                    return Ee != Float32Array && (i[1] = 0,
                    i[2] = 0,
                    i[3] = 0,
                    i[4] = 0,
                    i[6] = 0,
                    i[7] = 0,
                    i[8] = 0,
                    i[9] = 0,
                    i[11] = 0,
                    i[12] = 0,
                    i[13] = 0,
                    i[14] = 0),
                    i[0] = 1,
                    i[5] = 1,
                    i[10] = 1,
                    i[15] = 1,
                    i
                }
                ,
                T.M = function(i, t, r) {
                    var a, c, p, f, g, v, S, I, E, R, N, j, Z = r[0], Y = r[1], ae = r[2];
                    return t === i ? (i[12] = t[0] * Z + t[4] * Y + t[8] * ae + t[12],
                    i[13] = t[1] * Z + t[5] * Y + t[9] * ae + t[13],
                    i[14] = t[2] * Z + t[6] * Y + t[10] * ae + t[14],
                    i[15] = t[3] * Z + t[7] * Y + t[11] * ae + t[15]) : (c = t[1],
                    p = t[2],
                    f = t[3],
                    g = t[4],
                    v = t[5],
                    S = t[6],
                    I = t[7],
                    E = t[8],
                    R = t[9],
                    N = t[10],
                    j = t[11],
                    i[0] = a = t[0],
                    i[1] = c,
                    i[2] = p,
                    i[3] = f,
                    i[4] = g,
                    i[5] = v,
                    i[6] = S,
                    i[7] = I,
                    i[8] = E,
                    i[9] = R,
                    i[10] = N,
                    i[11] = j,
                    i[12] = a * Z + g * Y + E * ae + t[12],
                    i[13] = c * Z + v * Y + R * ae + t[13],
                    i[14] = p * Z + S * Y + N * ae + t[14],
                    i[15] = f * Z + I * Y + j * ae + t[15]),
                    i
                }
                ,
                T.N = function(i, t, r) {
                    var a = r[0]
                      , c = r[1]
                      , p = r[2];
                    return i[0] = t[0] * a,
                    i[1] = t[1] * a,
                    i[2] = t[2] * a,
                    i[3] = t[3] * a,
                    i[4] = t[4] * c,
                    i[5] = t[5] * c,
                    i[6] = t[6] * c,
                    i[7] = t[7] * c,
                    i[8] = t[8] * p,
                    i[9] = t[9] * p,
                    i[10] = t[10] * p,
                    i[11] = t[11] * p,
                    i[12] = t[12],
                    i[13] = t[13],
                    i[14] = t[14],
                    i[15] = t[15],
                    i
                }
                ,
                T.O = function(i, t, r) {
                    var a = t[0]
                      , c = t[1]
                      , p = t[2]
                      , f = t[3]
                      , g = t[4]
                      , v = t[5]
                      , S = t[6]
                      , I = t[7]
                      , E = t[8]
                      , R = t[9]
                      , N = t[10]
                      , j = t[11]
                      , Z = t[12]
                      , Y = t[13]
                      , ae = t[14]
                      , ze = t[15]
                      , me = r[0]
                      , be = r[1]
                      , Ve = r[2]
                      , rt = r[3];
                    return i[0] = me * a + be * g + Ve * E + rt * Z,
                    i[1] = me * c + be * v + Ve * R + rt * Y,
                    i[2] = me * p + be * S + Ve * N + rt * ae,
                    i[3] = me * f + be * I + Ve * j + rt * ze,
                    i[4] = (me = r[4]) * a + (be = r[5]) * g + (Ve = r[6]) * E + (rt = r[7]) * Z,
                    i[5] = me * c + be * v + Ve * R + rt * Y,
                    i[6] = me * p + be * S + Ve * N + rt * ae,
                    i[7] = me * f + be * I + Ve * j + rt * ze,
                    i[8] = (me = r[8]) * a + (be = r[9]) * g + (Ve = r[10]) * E + (rt = r[11]) * Z,
                    i[9] = me * c + be * v + Ve * R + rt * Y,
                    i[10] = me * p + be * S + Ve * N + rt * ae,
                    i[11] = me * f + be * I + Ve * j + rt * ze,
                    i[12] = (me = r[12]) * a + (be = r[13]) * g + (Ve = r[14]) * E + (rt = r[15]) * Z,
                    i[13] = me * c + be * v + Ve * R + rt * Y,
                    i[14] = me * p + be * S + Ve * N + rt * ae,
                    i[15] = me * f + be * I + Ve * j + rt * ze,
                    i
                }
                ,
                T.P = $,
                T.Q = function(i, t) {
                    const r = {};
                    for (let a = 0; a < t.length; a++) {
                        const c = t[a];
                        c in i && (r[c] = i[c])
                    }
                    return r
                }
                ,
                T.R = na,
                T.S = ro,
                T.T = Mp,
                T.U = I_,
                T.V = P_,
                T.W = Re,
                T.X = ke,
                T.Y = dr,
                T.Z = Ma,
                T._ = o,
                T.a = F,
                T.a$ = Qe,
                T.a0 = function(i, t) {
                    var r, a, c, p;
                    if (!i)
                        return t ?? {};
                    if (!t)
                        return i;
                    const f = Object.assign({}, i);
                    if (t.removeAll && (f.removeAll = !0),
                    t.remove) {
                        const g = new Set(f.remove ? f.remove.concat(t.remove) : t.remove);
                        f.remove = Array.from(g.values())
                    }
                    if (t.add) {
                        const g = f.add ? f.add.concat(t.add) : t.add
                          , v = new Map(g.map((S => [S.id, S])));
                        f.add = Array.from(v.values())
                    }
                    if (t.update) {
                        const g = new Map((r = f.update) === null || r === void 0 ? void 0 : r.map((v => [v.id, v])));
                        for (const v of t.update) {
                            const S = (a = g.get(v.id)) !== null && a !== void 0 ? a : {
                                id: v.id
                            };
                            v.newGeometry && (S.newGeometry = v.newGeometry),
                            v.addOrUpdateProperties && (S.addOrUpdateProperties = ((c = S.addOrUpdateProperties) !== null && c !== void 0 ? c : []).concat(v.addOrUpdateProperties)),
                            v.removeProperties && (S.removeProperties = ((p = S.removeProperties) !== null && p !== void 0 ? p : []).concat(v.removeProperties)),
                            v.removeAllProperties && (S.removeAllProperties = !0),
                            g.set(v.id, S)
                        }
                        f.update = Array.from(g.values())
                    }
                    return f
                }
                ,
                T.a1 = fu,
                T.a2 = Oo,
                T.a3 = 25,
                T.a4 = Xp,
                T.a5 = i => {
                    const t = window.document.createElement("video");
                    return t.muted = !0,
                    new Promise((r => {
                        t.onloadstart = () => {
                            r(t)
                        }
                        ;
                        for (const a of i) {
                            const c = window.document.createElement("source");
                            Le(a) || (t.crossOrigin = "Anonymous"),
                            c.src = a,
                            t.appendChild(c)
                        }
                    }
                    ))
                }
                ,
                T.a6 = Tt,
                T.a7 = function() {
                    return It++
                }
                ,
                T.a8 = z,
                T.a9 = Nl,
                T.aA = function(i) {
                    let t = 1 / 0
                      , r = 1 / 0
                      , a = -1 / 0
                      , c = -1 / 0;
                    for (const p of i)
                        t = Math.min(t, p.x),
                        r = Math.min(r, p.y),
                        a = Math.max(a, p.x),
                        c = Math.max(c, p.y);
                    return [t, r, a, c]
                }
                ,
                T.aB = bn,
                T.aC = Pe,
                T.aD = function(i, t, r, a, c=!1) {
                    if (!r[0] && !r[1])
                        return [0, 0];
                    const p = c ? a === "map" ? -i.bearingInRadians : 0 : a === "viewport" ? i.bearingInRadians : 0;
                    if (p) {
                        const f = Math.sin(p)
                          , g = Math.cos(p);
                        r = [r[0] * g - r[1] * f, r[0] * f + r[1] * g]
                    }
                    return [c ? r[0] : Pe(t, r[0], i.zoom), c ? r[1] : Pe(t, r[1], i.zoom)]
                }
                ,
                T.aF = Vp,
                T.aG = Yp,
                T.aH = qp,
                T.aI = Jp,
                T.aJ = Hi,
                T.aK = cd,
                T.aL = he,
                T.aM = Wr,
                T.aN = ki,
                T.aO = tt,
                T.aP = Mr,
                T.aQ = A_,
                T.aR = Be,
                T.aS = Je,
                T.aT = function(i) {
                    var t = new Ee(3);
                    return t[0] = i[0],
                    t[1] = i[1],
                    t[2] = i[2],
                    t
                }
                ,
                T.aU = function(i, t, r) {
                    return i[0] = t[0] - r[0],
                    i[1] = t[1] - r[1],
                    i[2] = t[2] - r[2],
                    i
                }
                ,
                T.aV = function(i, t) {
                    var r = t[0]
                      , a = t[1]
                      , c = t[2]
                      , p = r * r + a * a + c * c;
                    return p > 0 && (p = 1 / Math.sqrt(p)),
                    i[0] = t[0] * p,
                    i[1] = t[1] * p,
                    i[2] = t[2] * p,
                    i
                }
                ,
                T.aW = st,
                T.aX = function(i, t) {
                    return i[0] * t[0] + i[1] * t[1] + i[2] * t[2]
                }
                ,
                T.aY = function(i, t, r) {
                    return i[0] = t[0] * r[0],
                    i[1] = t[1] * r[1],
                    i[2] = t[2] * r[2],
                    i[3] = t[3] * r[3],
                    i
                }
                ,
                T.aZ = Xe,
                T.a_ = function(i, t, r) {
                    const a = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
                    return a === 0 ? null : (-(i[0] * r[0] + i[1] * r[1] + i[2] * r[2]) - r[3]) / a
                }
                ,
                T.aa = bs,
                T.ab = Wa,
                T.ac = L_,
                T.ad = function(i) {
                    const t = {};
                    if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ( (r, a, c, p) => {
                        const f = c || p;
                        return t[a] = !f || f.toLowerCase(),
                        ""
                    }
                    )),
                    t["max-age"]) {
                        const r = parseInt(t["max-age"], 10);
                        isNaN(r) ? delete t["max-age"] : t["max-age"] = r
                    }
                    return t
                }
                ,
                T.ae = ur,
                T.af = function(i) {
                    return Math.pow(2, i)
                }
                ,
                T.ag = ft,
                T.ah = xt,
                T.ai = 85.051129,
                T.aj = M_,
                T.ak = function(i) {
                    return Math.log(i) / Math.LN2
                }
                ,
                T.al = function(i) {
                    var t = i[0]
                      , r = i[1];
                    return t * t + r * r
                }
                ,
                T.am = function(i, t) {
                    const r = [];
                    for (const a in i)
                        a in t || r.push(a);
                    return r
                }
                ,
                T.an = function(i, t) {
                    let r = 0
                      , a = 0;
                    if (i.kind === "constant")
                        a = i.layoutSize;
                    else if (i.kind !== "source") {
                        const {interpolationType: c, minZoom: p, maxZoom: f} = i
                          , g = c ? xt(In.interpolationFactor(c, t, p, f), 0, 1) : 0;
                        i.kind === "camera" ? a = Fa.number(i.minSize, i.maxSize, g) : r = g
                    }
                    return {
                        uSizeT: r,
                        uSize: a
                    }
                }
                ,
                T.ap = function(i, {uSize: t, uSizeT: r}, {lowerSize: a, upperSize: c}) {
                    return i.kind === "source" ? a / As : i.kind === "composite" ? Fa.number(a / As, c / As, r) : t
                }
                ,
                T.aq = function(i, t) {
                    var r = t[0]
                      , a = t[1]
                      , c = t[2]
                      , p = t[3]
                      , f = t[4]
                      , g = t[5]
                      , v = t[6]
                      , S = t[7]
                      , I = t[8]
                      , E = t[9]
                      , R = t[10]
                      , N = t[11]
                      , j = t[12]
                      , Z = t[13]
                      , Y = t[14]
                      , ae = t[15]
                      , ze = r * g - a * f
                      , me = r * v - c * f
                      , be = r * S - p * f
                      , Ve = a * v - c * g
                      , rt = a * S - p * g
                      , St = c * S - p * v
                      , $t = I * Z - E * j
                      , Bt = I * Y - R * j
                      , Ut = I * ae - N * j
                      , pr = E * Y - R * Z
                      , Vt = E * ae - N * Z
                      , Zt = R * ae - N * Y
                      , mt = ze * Zt - me * Vt + be * pr + Ve * Ut - rt * Bt + St * $t;
                    return mt ? (i[0] = (g * Zt - v * Vt + S * pr) * (mt = 1 / mt),
                    i[1] = (c * Vt - a * Zt - p * pr) * mt,
                    i[2] = (Z * St - Y * rt + ae * Ve) * mt,
                    i[3] = (R * rt - E * St - N * Ve) * mt,
                    i[4] = (v * Ut - f * Zt - S * Bt) * mt,
                    i[5] = (r * Zt - c * Ut + p * Bt) * mt,
                    i[6] = (Y * be - j * St - ae * me) * mt,
                    i[7] = (I * St - R * be + N * me) * mt,
                    i[8] = (f * Vt - g * Ut + S * $t) * mt,
                    i[9] = (a * Ut - r * Vt - p * $t) * mt,
                    i[10] = (j * rt - Z * be + ae * ze) * mt,
                    i[11] = (E * be - I * rt - N * ze) * mt,
                    i[12] = (g * Bt - f * pr - v * $t) * mt,
                    i[13] = (r * pr - a * Bt + c * $t) * mt,
                    i[14] = (Z * me - j * Ve - Y * ze) * mt,
                    i[15] = (I * Ve - E * me + R * ze) * mt,
                    i) : null
                }
                ,
                T.ar = te,
                T.as = function(i) {
                    return Math.hypot(i[0], i[1])
                }
                ,
                T.at = function(i) {
                    return i[0] = 0,
                    i[1] = 0,
                    i
                }
                ,
                T.au = function(i, t, r) {
                    return i[0] = t[0] * r,
                    i[1] = t[1] * r,
                    i
                }
                ,
                T.av = Up,
                T.aw = Ae,
                T.ax = function(i, t, r, a) {
                    const c = t.y - i.y
                      , p = t.x - i.x
                      , f = a.y - r.y
                      , g = a.x - r.x
                      , v = f * p - g * c;
                    if (v === 0)
                        return null;
                    const S = (g * (i.y - r.y) - f * (i.x - r.x)) / v;
                    return new $(i.x + S * p,i.y + S * c)
                }
                ,
                T.ay = B_,
                T.az = Sm,
                T.b = ar,
                T.b$ = class extends h {
                }
                ,
                T.b0 = function(i, t, r) {
                    return i[0] = t[0] * r,
                    i[1] = t[1] * r,
                    i[2] = t[2] * r,
                    i[3] = t[3] * r,
                    i
                }
                ,
                T.b1 = function(i, t) {
                    return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3]
                }
                ,
                T.b2 = E_,
                T.b3 = jl,
                T.b4 = function(i, t, r, a, c) {
                    var p, f = 1 / Math.tan(t / 2);
                    return i[0] = f / r,
                    i[1] = 0,
                    i[2] = 0,
                    i[3] = 0,
                    i[4] = 0,
                    i[5] = f,
                    i[6] = 0,
                    i[7] = 0,
                    i[8] = 0,
                    i[9] = 0,
                    i[11] = -1,
                    i[12] = 0,
                    i[13] = 0,
                    i[15] = 0,
                    c != null && c !== 1 / 0 ? (i[10] = (c + a) * (p = 1 / (a - c)),
                    i[14] = 2 * c * a * p) : (i[10] = -1,
                    i[14] = -2 * a),
                    i
                }
                ,
                T.b5 = function(i) {
                    var t = new Ee(16);
                    return t[0] = i[0],
                    t[1] = i[1],
                    t[2] = i[2],
                    t[3] = i[3],
                    t[4] = i[4],
                    t[5] = i[5],
                    t[6] = i[6],
                    t[7] = i[7],
                    t[8] = i[8],
                    t[9] = i[9],
                    t[10] = i[10],
                    t[11] = i[11],
                    t[12] = i[12],
                    t[13] = i[13],
                    t[14] = i[14],
                    t[15] = i[15],
                    t
                }
                ,
                T.b6 = function(i, t, r) {
                    var a = Math.sin(r)
                      , c = Math.cos(r)
                      , p = t[0]
                      , f = t[1]
                      , g = t[2]
                      , v = t[3]
                      , S = t[4]
                      , I = t[5]
                      , E = t[6]
                      , R = t[7];
                    return t !== i && (i[8] = t[8],
                    i[9] = t[9],
                    i[10] = t[10],
                    i[11] = t[11],
                    i[12] = t[12],
                    i[13] = t[13],
                    i[14] = t[14],
                    i[15] = t[15]),
                    i[0] = p * c + S * a,
                    i[1] = f * c + I * a,
                    i[2] = g * c + E * a,
                    i[3] = v * c + R * a,
                    i[4] = S * c - p * a,
                    i[5] = I * c - f * a,
                    i[6] = E * c - g * a,
                    i[7] = R * c - v * a,
                    i
                }
                ,
                T.b7 = function(i, t, r) {
                    var a = Math.sin(r)
                      , c = Math.cos(r)
                      , p = t[4]
                      , f = t[5]
                      , g = t[6]
                      , v = t[7]
                      , S = t[8]
                      , I = t[9]
                      , E = t[10]
                      , R = t[11];
                    return t !== i && (i[0] = t[0],
                    i[1] = t[1],
                    i[2] = t[2],
                    i[3] = t[3],
                    i[12] = t[12],
                    i[13] = t[13],
                    i[14] = t[14],
                    i[15] = t[15]),
                    i[4] = p * c + S * a,
                    i[5] = f * c + I * a,
                    i[6] = g * c + E * a,
                    i[7] = v * c + R * a,
                    i[8] = S * c - p * a,
                    i[9] = I * c - f * a,
                    i[10] = E * c - g * a,
                    i[11] = R * c - v * a,
                    i
                }
                ,
                T.b8 = function() {
                    const i = new Float32Array(16);
                    return ft(i),
                    i
                }
                ,
                T.b9 = function() {
                    const i = new Float64Array(16);
                    return ft(i),
                    i
                }
                ,
                T.bA = function(i, t) {
                    const r = Me(i, 360)
                      , a = Me(t, 360)
                      , c = a - r
                      , p = a > r ? c - 360 : c + 360;
                    return Math.abs(c) < Math.abs(p) ? c : p
                }
                ,
                T.bB = function(i) {
                    return i[0] = 0,
                    i[1] = 0,
                    i[2] = 0,
                    i
                }
                ,
                T.bC = function(i, t, r, a) {
                    const c = Math.sqrt(i * i + t * t)
                      , p = Math.sqrt(r * r + a * a);
                    i /= c,
                    t /= c,
                    r /= p,
                    a /= p;
                    const f = Math.acos(i * r + t * a);
                    return -t * r + i * a > 0 ? f : -f
                }
                ,
                T.bD = function(i, t) {
                    const r = Me(i, 2 * Math.PI)
                      , a = Me(t, 2 * Math.PI);
                    return Math.min(Math.abs(r - a), Math.abs(r - a + 2 * Math.PI), Math.abs(r - a - 2 * Math.PI))
                }
                ,
                T.bE = function() {
                    const i = {}
                      , t = xe.$version;
                    for (const r in xe.$root) {
                        const a = xe.$root[r];
                        if (a.required) {
                            let c = null;
                            c = r === "version" ? t : a.type === "array" ? [] : {},
                            c != null && (i[r] = c)
                        }
                    }
                    return i
                }
                ,
                T.bF = bl,
                T.bG = le,
                T.bH = function i(t, r) {
                    if (Array.isArray(t)) {
                        if (!Array.isArray(r) || t.length !== r.length)
                            return !1;
                        for (let a = 0; a < t.length; a++)
                            if (!i(t[a], r[a]))
                                return !1;
                        return !0
                    }
                    if (typeof t == "object" && t !== null && r !== null) {
                        if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length)
                            return !1;
                        for (const a in t)
                            if (!i(t[a], r[a]))
                                return !1;
                        return !0
                    }
                    return t === r
                }
                ,
                T.bI = function(i) {
                    i = i.slice();
                    const t = Object.create(null);
                    for (let r = 0; r < i.length; r++)
                        t[i[r].id] = i[r];
                    for (let r = 0; r < i.length; r++)
                        "ref"in i[r] && (i[r] = Pt(i[r], t[i[r].ref]));
                    return i
                }
                ,
                T.bJ = function(i) {
                    if (i.type === "custom")
                        return new sy(i);
                    switch (i.type) {
                    case "background":
                        return new iy(i);
                    case "circle":
                        return new Vv(i);
                    case "color-relief":
                        return new Wv(i);
                    case "fill":
                        return new c0(i);
                    case "fill-extrusion":
                        return new x0(i);
                    case "heatmap":
                        return new Zv(i);
                    case "hillshade":
                        return new Gv(i);
                    case "line":
                        return new I0(i);
                    case "raster":
                        return new ay(i);
                    case "symbol":
                        return new fd(i)
                    }
                }
                ,
                T.bK = wt,
                T.bL = function(i, t) {
                    if (!i)
                        return [{
                            command: "setStyle",
                            args: [t]
                        }];
                    let r = [];
                    try {
                        if (!kt(i.version, t.version))
                            return [{
                                command: "setStyle",
                                args: [t]
                            }];
                        kt(i.center, t.center) || r.push({
                            command: "setCenter",
                            args: [t.center]
                        }),
                        kt(i.state, t.state) || r.push({
                            command: "setGlobalState",
                            args: [t.state]
                        }),
                        kt(i.centerAltitude, t.centerAltitude) || r.push({
                            command: "setCenterAltitude",
                            args: [t.centerAltitude]
                        }),
                        kt(i.zoom, t.zoom) || r.push({
                            command: "setZoom",
                            args: [t.zoom]
                        }),
                        kt(i.bearing, t.bearing) || r.push({
                            command: "setBearing",
                            args: [t.bearing]
                        }),
                        kt(i.pitch, t.pitch) || r.push({
                            command: "setPitch",
                            args: [t.pitch]
                        }),
                        kt(i.roll, t.roll) || r.push({
                            command: "setRoll",
                            args: [t.roll]
                        }),
                        kt(i.sprite, t.sprite) || r.push({
                            command: "setSprite",
                            args: [t.sprite]
                        }),
                        kt(i.glyphs, t.glyphs) || r.push({
                            command: "setGlyphs",
                            args: [t.glyphs]
                        }),
                        kt(i.transition, t.transition) || r.push({
                            command: "setTransition",
                            args: [t.transition]
                        }),
                        kt(i.light, t.light) || r.push({
                            command: "setLight",
                            args: [t.light]
                        }),
                        kt(i.terrain, t.terrain) || r.push({
                            command: "setTerrain",
                            args: [t.terrain]
                        }),
                        kt(i.sky, t.sky) || r.push({
                            command: "setSky",
                            args: [t.sky]
                        }),
                        kt(i.projection, t.projection) || r.push({
                            command: "setProjection",
                            args: [t.projection]
                        });
                        const a = {}
                          , c = [];
                        (function(f, g, v, S) {
                            let I;
                            for (I in g = g || {},
                            f = f || {})
                                Object.prototype.hasOwnProperty.call(f, I) && (Object.prototype.hasOwnProperty.call(g, I) || Kr(I, v, S));
                            for (I in g)
                                Object.prototype.hasOwnProperty.call(g, I) && (Object.prototype.hasOwnProperty.call(f, I) ? kt(f[I], g[I]) || (f[I].type === "geojson" && g[I].type === "geojson" && $r(f, g, I) ? Wt(v, {
                                    command: "setGeoJSONSourceData",
                                    args: [I, g[I].data]
                                }) : Hr(I, g, v, S)) : Lr(I, g, v))
                        }
                        )(i.sources, t.sources, c, a);
                        const p = [];
                        i.layers && i.layers.forEach((f => {
                            "source"in f && a[f.source] ? r.push({
                                command: "removeLayer",
                                args: [f.id]
                            }) : p.push(f)
                        }
                        )),
                        r = r.concat(c),
                        (function(f, g, v) {
                            g = g || [];
                            const S = (f = f || []).map(gr)
                              , I = g.map(gr)
                              , E = f.reduce(ai, {})
                              , R = g.reduce(ai, {})
                              , N = S.slice()
                              , j = Object.create(null);
                            let Z, Y, ae, ze, me;
                            for (let be = 0, Ve = 0; be < S.length; be++)
                                Z = S[be],
                                Object.prototype.hasOwnProperty.call(R, Z) ? Ve++ : (Wt(v, {
                                    command: "removeLayer",
                                    args: [Z]
                                }),
                                N.splice(N.indexOf(Z, Ve), 1));
                            for (let be = 0, Ve = 0; be < I.length; be++)
                                Z = I[I.length - 1 - be],
                                N[N.length - 1 - be] !== Z && (Object.prototype.hasOwnProperty.call(E, Z) ? (Wt(v, {
                                    command: "removeLayer",
                                    args: [Z]
                                }),
                                N.splice(N.lastIndexOf(Z, N.length - Ve), 1)) : Ve++,
                                ze = N[N.length - be],
                                Wt(v, {
                                    command: "addLayer",
                                    args: [R[Z], ze]
                                }),
                                N.splice(N.length - be, 0, Z),
                                j[Z] = !0);
                            for (let be = 0; be < I.length; be++)
                                if (Z = I[be],
                                Y = E[Z],
                                ae = R[Z],
                                !j[Z] && !kt(Y, ae))
                                    if (kt(Y.source, ae.source) && kt(Y["source-layer"], ae["source-layer"]) && kt(Y.type, ae.type)) {
                                        for (me in mr(Y.layout, ae.layout, v, Z, null, "setLayoutProperty"),
                                        mr(Y.paint, ae.paint, v, Z, null, "setPaintProperty"),
                                        kt(Y.filter, ae.filter) || Wt(v, {
                                            command: "setFilter",
                                            args: [Z, ae.filter]
                                        }),
                                        kt(Y.minzoom, ae.minzoom) && kt(Y.maxzoom, ae.maxzoom) || Wt(v, {
                                            command: "setLayerZoomRange",
                                            args: [Z, ae.minzoom, ae.maxzoom]
                                        }),
                                        Y)
                                            Object.prototype.hasOwnProperty.call(Y, me) && me !== "layout" && me !== "paint" && me !== "filter" && me !== "metadata" && me !== "minzoom" && me !== "maxzoom" && (me.indexOf("paint.") === 0 ? mr(Y[me], ae[me], v, Z, me.slice(6), "setPaintProperty") : kt(Y[me], ae[me]) || Wt(v, {
                                                command: "setLayerProperty",
                                                args: [Z, me, ae[me]]
                                            }));
                                        for (me in ae)
                                            Object.prototype.hasOwnProperty.call(ae, me) && !Object.prototype.hasOwnProperty.call(Y, me) && me !== "layout" && me !== "paint" && me !== "filter" && me !== "metadata" && me !== "minzoom" && me !== "maxzoom" && (me.indexOf("paint.") === 0 ? mr(Y[me], ae[me], v, Z, me.slice(6), "setPaintProperty") : kt(Y[me], ae[me]) || Wt(v, {
                                                command: "setLayerProperty",
                                                args: [Z, me, ae[me]]
                                            }))
                                    } else
                                        Wt(v, {
                                            command: "removeLayer",
                                            args: [Z]
                                        }),
                                        ze = N[N.lastIndexOf(Z) + 1],
                                        Wt(v, {
                                            command: "addLayer",
                                            args: [ae, ze]
                                        })
                        }
                        )(p, t.layers, r)
                    } catch (a) {
                        console.warn("Unable to compute style diff:", a),
                        r = [{
                            command: "setStyle",
                            args: [t]
                        }]
                    }
                    return r
                }
                ,
                T.bM = function(i) {
                    const t = []
                      , r = i.id;
                    return r === void 0 && t.push({
                        message: `layers.${r}: missing required property "id"`
                    }),
                    i.render === void 0 && t.push({
                        message: `layers.${r}: missing required method "render"`
                    }),
                    i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({
                        message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
                    }),
                    t
                }
                ,
                T.bN = ut,
                T.bO = bt,
                T.bP = class extends Vn {
                    constructor(i, t) {
                        super(i, t),
                        this.current = 0
                    }
                    set(i) {
                        this.current !== i && (this.current = i,
                        this.gl.uniform1i(this.location, i))
                    }
                }
                ,
                T.bQ = pn,
                T.bR = class extends Vn {
                    constructor(i, t) {
                        super(i, t),
                        this.current = da
                    }
                    set(i) {
                        if (i[12] !== this.current[12] || i[0] !== this.current[0])
                            return this.current = i,
                            void this.gl.uniformMatrix4fv(this.location, !1, i);
                        for (let t = 1; t < 16; t++)
                            if (i[t] !== this.current[t]) {
                                this.current = i,
                                this.gl.uniformMatrix4fv(this.location, !1, i);
                                break
                            }
                    }
                }
                ,
                T.bS = en,
                T.bT = class extends Vn {
                    constructor(i, t) {
                        super(i, t),
                        this.current = [0, 0, 0]
                    }
                    set(i) {
                        i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i,
                        this.gl.uniform3f(this.location, i[0], i[1], i[2]))
                    }
                }
                ,
                T.bU = class extends Vn {
                    constructor(i, t) {
                        super(i, t),
                        this.current = [0, 0]
                    }
                    set(i) {
                        i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i,
                        this.gl.uniform2f(this.location, i[0], i[1]))
                    }
                }
                ,
                T.bV = Ne,
                T.bW = function(i, t) {
                    var r = Math.sin(t)
                      , a = Math.cos(t);
                    return i[0] = a,
                    i[1] = r,
                    i[2] = 0,
                    i[3] = -r,
                    i[4] = a,
                    i[5] = 0,
                    i[6] = 0,
                    i[7] = 0,
                    i[8] = 1,
                    i
                }
                ,
                T.bX = function(i, t, r) {
                    var a = t[0]
                      , c = t[1]
                      , p = t[2];
                    return i[0] = a * r[0] + c * r[3] + p * r[6],
                    i[1] = a * r[1] + c * r[4] + p * r[7],
                    i[2] = a * r[2] + c * r[5] + p * r[8],
                    i
                }
                ,
                T.bY = function(i, t, r, a, c, p, f) {
                    var g = 1 / (t - r)
                      , v = 1 / (a - c)
                      , S = 1 / (p - f);
                    return i[0] = -2 * g,
                    i[1] = 0,
                    i[2] = 0,
                    i[3] = 0,
                    i[4] = 0,
                    i[5] = -2 * v,
                    i[6] = 0,
                    i[7] = 0,
                    i[8] = 0,
                    i[9] = 0,
                    i[10] = 2 * S,
                    i[11] = 0,
                    i[12] = (t + r) * g,
                    i[13] = (c + a) * v,
                    i[14] = (f + p) * S,
                    i[15] = 1,
                    i
                }
                ,
                T.bZ = class extends Vn {
                    constructor(i, t) {
                        super(i, t),
                        this.current = new Array
                    }
                    set(i) {
                        if (i != this.current) {
                            this.current = i;
                            const t = new Float32Array(4 * i.length);
                            for (let r = 0; r < i.length; r++)
                                t[4 * r] = i[r].r,
                                t[4 * r + 1] = i[r].g,
                                t[4 * r + 2] = i[r].b,
                                t[4 * r + 3] = i[r].a;
                            this.gl.uniform4fv(this.location, t)
                        }
                    }
                }
                ,
                T.b_ = class extends Vn {
                    constructor(i, t) {
                        super(i, t),
                        this.current = new Array
                    }
                    set(i) {
                        if (i != this.current) {
                            this.current = i;
                            const t = new Float32Array(i);
                            this.gl.uniform1fv(this.location, t)
                        }
                    }
                }
                ,
                T.ba = function() {
                    return new Float64Array(16)
                }
                ,
                T.bb = function(i, t, r) {
                    const a = new Float64Array(4);
                    return Q(a, i, t - 90, r),
                    a
                }
                ,
                T.bc = function(i, t, r, a) {
                    var c, p, f, g, v, S = t[0], I = t[1], E = t[2], R = t[3], N = r[0], j = r[1], Z = r[2], Y = r[3];
                    return (p = S * N + I * j + E * Z + R * Y) < 0 && (p = -p,
                    N = -N,
                    j = -j,
                    Z = -Z,
                    Y = -Y),
                    1 - p > Oe ? (c = Math.acos(p),
                    f = Math.sin(c),
                    g = Math.sin((1 - a) * c) / f,
                    v = Math.sin(a * c) / f) : (g = 1 - a,
                    v = a),
                    i[0] = g * S + v * N,
                    i[1] = g * I + v * j,
                    i[2] = g * E + v * Z,
                    i[3] = g * R + v * Y,
                    i
                }
                ,
                T.bd = function(i) {
                    const t = new Float64Array(9);
                    var r, a, c, p, f, g, v, S, I, E, R, N, j, Z, Y, ae, ze, me;
                    E = (c = (a = i)[0]) * (v = c + c),
                    R = (p = a[1]) * v,
                    j = (f = a[2]) * v,
                    Z = f * (S = p + p),
                    ae = (g = a[3]) * v,
                    ze = g * S,
                    me = g * (I = f + f),
                    (r = t)[0] = 1 - (N = p * S) - (Y = f * I),
                    r[3] = R - me,
                    r[6] = j + ze,
                    r[1] = R + me,
                    r[4] = 1 - E - Y,
                    r[7] = Z - ae,
                    r[2] = j - ze,
                    r[5] = Z + ae,
                    r[8] = 1 - E - N;
                    const be = Mr(-Math.asin(xt(t[2], -1, 1)));
                    let Ve, rt;
                    return Math.hypot(t[5], t[8]) < .001 ? (Ve = 0,
                    rt = -Mr(Math.atan2(t[3], t[4]))) : (Ve = Mr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])),
                    rt = Mr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))),
                    {
                        roll: Ve,
                        pitch: be + 90,
                        bearing: rt
                    }
                }
                ,
                T.be = function(i, t) {
                    return i.roll == t.roll && i.pitch == t.pitch && i.bearing == t.bearing
                }
                ,
                T.bf = yr,
                T.bg = os,
                T.bh = Rl,
                T.bi = lu,
                T.bj = Dl,
                T.bk = at,
                T.bl = We,
                T.bm = hn,
                T.bn = function(i, t, r, a, c) {
                    return at(a, c, xt((i - t) / (r - t), 0, 1))
                }
                ,
                T.bo = Me,
                T.bp = function() {
                    return new Float64Array(3)
                }
                ,
                T.bq = function(i, t, r, a) {
                    return i[0] = t[0] + r[0] * a,
                    i[1] = t[1] + r[1] * a,
                    i[2] = t[2] + r[2] * a,
                    i
                }
                ,
                T.br = Q,
                T.bs = function(i, t, r) {
                    var a = r[0]
                      , c = r[1]
                      , p = r[2]
                      , f = t[0]
                      , g = t[1]
                      , v = t[2]
                      , S = c * v - p * g
                      , I = p * f - a * v
                      , E = a * g - c * f
                      , R = c * E - p * I
                      , N = p * S - a * E
                      , j = a * I - c * S
                      , Z = 2 * r[3];
                    return I *= Z,
                    E *= Z,
                    N *= 2,
                    j *= 2,
                    i[0] = f + (S *= Z) + (R *= 2),
                    i[1] = g + I + N,
                    i[2] = v + E + j,
                    i
                }
                ,
                T.bt = function(i, t, r) {
                    const a = (c = [i[0], i[1], i[2], t[0], t[1], t[2], r[0], r[1], r[2]])[0] * ((I = c[8]) * (f = c[4]) - (g = c[5]) * (S = c[7])) + c[1] * (-I * (p = c[3]) + g * (v = c[6])) + c[2] * (S * p - f * v);
                    var c, p, f, g, v, S, I;
                    if (a === 0)
                        return null;
                    const E = st([], [t[0], t[1], t[2]], [r[0], r[1], r[2]])
                      , R = st([], [r[0], r[1], r[2]], [i[0], i[1], i[2]])
                      , N = st([], [i[0], i[1], i[2]], [t[0], t[1], t[2]])
                      , j = Be([], E, -i[3]);
                    return Je(j, j, Be([], R, -t[3])),
                    Je(j, j, Be([], N, -r[3])),
                    Be(j, j, 1 / a),
                    j
                }
                ,
                T.bu = Hp,
                T.bv = function() {
                    return new Float64Array(4)
                }
                ,
                T.bw = function(i, t, r, a) {
                    var c = []
                      , p = [];
                    return c[0] = t[0] - r[0],
                    c[1] = t[1] - r[1],
                    c[2] = t[2] - r[2],
                    p[0] = c[0] * Math.cos(a) - c[1] * Math.sin(a),
                    p[1] = c[0] * Math.sin(a) + c[1] * Math.cos(a),
                    p[2] = c[2],
                    i[0] = p[0] + r[0],
                    i[1] = p[1] + r[1],
                    i[2] = p[2] + r[2],
                    i
                }
                ,
                T.bx = function(i, t, r, a) {
                    var c = []
                      , p = [];
                    return c[0] = t[0] - r[0],
                    c[1] = t[1] - r[1],
                    c[2] = t[2] - r[2],
                    p[0] = c[0],
                    p[1] = c[1] * Math.cos(a) - c[2] * Math.sin(a),
                    p[2] = c[1] * Math.sin(a) + c[2] * Math.cos(a),
                    i[0] = p[0] + r[0],
                    i[1] = p[1] + r[1],
                    i[2] = p[2] + r[2],
                    i
                }
                ,
                T.by = function(i, t, r, a) {
                    var c = []
                      , p = [];
                    return c[0] = t[0] - r[0],
                    c[1] = t[1] - r[1],
                    c[2] = t[2] - r[2],
                    p[0] = c[2] * Math.sin(a) + c[0] * Math.cos(a),
                    p[1] = c[1],
                    p[2] = c[2] * Math.cos(a) - c[0] * Math.sin(a),
                    i[0] = p[0] + r[0],
                    i[1] = p[1] + r[1],
                    i[2] = p[2] + r[2],
                    i
                }
                ,
                T.bz = function(i, t, r) {
                    var a = Math.sin(r)
                      , c = Math.cos(r)
                      , p = t[0]
                      , f = t[1]
                      , g = t[2]
                      , v = t[3]
                      , S = t[8]
                      , I = t[9]
                      , E = t[10]
                      , R = t[11];
                    return t !== i && (i[4] = t[4],
                    i[5] = t[5],
                    i[6] = t[6],
                    i[7] = t[7],
                    i[12] = t[12],
                    i[13] = t[13],
                    i[14] = t[14],
                    i[15] = t[15]),
                    i[0] = p * c - S * a,
                    i[1] = f * c - I * a,
                    i[2] = g * c - E * a,
                    i[3] = v * c - R * a,
                    i[8] = p * a + S * c,
                    i[9] = f * a + I * c,
                    i[10] = g * a + E * c,
                    i[11] = v * a + R * c,
                    i
                }
                ,
                T.c = ce,
                T.c0 = E0,
                T.c1 = class extends n {
                }
                ,
                T.c2 = Ip,
                T.c3 = function(i) {
                    return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
                }
                ,
                T.c4 = Rm,
                T.c5 = function(i, t, r) {
                    var a = t[0]
                      , c = t[1]
                      , p = t[2]
                      , f = r[3] * a + r[7] * c + r[11] * p + r[15];
                    return i[0] = (r[0] * a + r[4] * c + r[8] * p + r[12]) / (f = f || 1),
                    i[1] = (r[1] * a + r[5] * c + r[9] * p + r[13]) / f,
                    i[2] = (r[2] * a + r[6] * c + r[10] * p + r[14]) / f,
                    i
                }
                ,
                T.c6 = class extends Yc {
                }
                ,
                T.c7 = class extends P {
                }
                ,
                T.c8 = function(i, t) {
                    return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15]
                }
                ,
                T.c9 = function(i, t) {
                    var r = i[0]
                      , a = i[1]
                      , c = i[2]
                      , p = i[3]
                      , f = i[4]
                      , g = i[5]
                      , v = i[6]
                      , S = i[7]
                      , I = i[8]
                      , E = i[9]
                      , R = i[10]
                      , N = i[11]
                      , j = i[12]
                      , Z = i[13]
                      , Y = i[14]
                      , ae = i[15]
                      , ze = t[0]
                      , me = t[1]
                      , be = t[2]
                      , Ve = t[3]
                      , rt = t[4]
                      , St = t[5]
                      , $t = t[6]
                      , Bt = t[7]
                      , Ut = t[8]
                      , pr = t[9]
                      , Vt = t[10]
                      , Zt = t[11]
                      , mt = t[12]
                      , Br = t[13]
                      , Ur = t[14]
                      , xr = t[15];
                    return Math.abs(r - ze) <= Oe * Math.max(1, Math.abs(r), Math.abs(ze)) && Math.abs(a - me) <= Oe * Math.max(1, Math.abs(a), Math.abs(me)) && Math.abs(c - be) <= Oe * Math.max(1, Math.abs(c), Math.abs(be)) && Math.abs(p - Ve) <= Oe * Math.max(1, Math.abs(p), Math.abs(Ve)) && Math.abs(f - rt) <= Oe * Math.max(1, Math.abs(f), Math.abs(rt)) && Math.abs(g - St) <= Oe * Math.max(1, Math.abs(g), Math.abs(St)) && Math.abs(v - $t) <= Oe * Math.max(1, Math.abs(v), Math.abs($t)) && Math.abs(S - Bt) <= Oe * Math.max(1, Math.abs(S), Math.abs(Bt)) && Math.abs(I - Ut) <= Oe * Math.max(1, Math.abs(I), Math.abs(Ut)) && Math.abs(E - pr) <= Oe * Math.max(1, Math.abs(E), Math.abs(pr)) && Math.abs(R - Vt) <= Oe * Math.max(1, Math.abs(R), Math.abs(Vt)) && Math.abs(N - Zt) <= Oe * Math.max(1, Math.abs(N), Math.abs(Zt)) && Math.abs(j - mt) <= Oe * Math.max(1, Math.abs(j), Math.abs(mt)) && Math.abs(Z - Br) <= Oe * Math.max(1, Math.abs(Z), Math.abs(Br)) && Math.abs(Y - Ur) <= Oe * Math.max(1, Math.abs(Y), Math.abs(Ur)) && Math.abs(ae - xr) <= Oe * Math.max(1, Math.abs(ae), Math.abs(xr))
                }
                ,
                T.cA = function(i, t) {
                    F.REGISTERED_PROTOCOLS[i] = t
                }
                ,
                T.cB = function(i) {
                    delete F.REGISTERED_PROTOCOLS[i]
                }
                ,
                T.cC = function(i, t) {
                    const r = {};
                    for (let c = 0; c < i.length; c++) {
                        const p = t && t[i[c].id] || mp(i[c]);
                        t && (t[i[c].id] = p);
                        let f = r[p];
                        f || (f = r[p] = []),
                        f.push(i[c])
                    }
                    const a = [];
                    for (const c in r)
                        a.push(r[c]);
                    return a
                }
                ,
                T.cD = Kt,
                T.cE = z_,
                T.cF = D_,
                T.cG = u_,
                T.cH = function(i) {
                    i.bucket.createArrays(),
                    i.bucket.tilePixelRatio = ne / (512 * i.bucket.overscaling),
                    i.bucket.compareText = {},
                    i.bucket.iconsNeedLinear = !1;
                    const t = i.bucket.layers[0]
                      , r = t.layout
                      , a = t._unevaluatedLayout._values
                      , c = {
                        layoutIconSize: a["icon-size"].possiblyEvaluate(new Oi(i.bucket.zoom + 1), i.canonical),
                        layoutTextSize: a["text-size"].possiblyEvaluate(new Oi(i.bucket.zoom + 1), i.canonical),
                        textMaxSize: a["text-size"].possiblyEvaluate(new Oi(18))
                    };
                    if (i.bucket.textSizeData.kind === "composite") {
                        const {minZoom: S, maxZoom: I} = i.bucket.textSizeData;
                        c.compositeTextSizes = [a["text-size"].possiblyEvaluate(new Oi(S), i.canonical), a["text-size"].possiblyEvaluate(new Oi(I), i.canonical)]
                    }
                    if (i.bucket.iconSizeData.kind === "composite") {
                        const {minZoom: S, maxZoom: I} = i.bucket.iconSizeData;
                        c.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new Oi(S), i.canonical), a["icon-size"].possiblyEvaluate(new Oi(I), i.canonical)]
                    }
                    const p = r.get("text-line-height") * bn
                      , f = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point"
                      , g = r.get("text-keep-upright")
                      , v = r.get("text-size");
                    for (const S of i.bucket.features) {
                        const I = r.get("text-font").evaluate(S, {}, i.canonical).join(",")
                          , E = v.evaluate(S, {}, i.canonical)
                          , R = c.layoutTextSize.evaluate(S, {}, i.canonical)
                          , N = c.layoutIconSize.evaluate(S, {}, i.canonical)
                          , j = {
                            horizontal: {},
                            vertical: void 0
                        }
                          , Z = S.text;
                        let Y, ae = [0, 0];
                        if (Z) {
                            const be = Z.toString()
                              , Ve = r.get("text-letter-spacing").evaluate(S, {}, i.canonical) * bn
                              , rt = yp(be) ? Ve : 0
                              , St = r.get("text-anchor").evaluate(S, {}, i.canonical)
                              , $t = $_(t, S, i.canonical);
                            if (!$t) {
                                const Vt = r.get("text-radial-offset").evaluate(S, {}, i.canonical);
                                ae = Vt ? Z_(St, [Vt * bn, Kp]) : r.get("text-offset").evaluate(S, {}, i.canonical).map((Zt => Zt * bn))
                            }
                            let Bt = f ? "center" : r.get("text-justify").evaluate(S, {}, i.canonical);
                            const Ut = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(S, {}, i.canonical) * bn : 1 / 0
                              , pr = () => {
                                i.bucket.allowVerticalPlacement && wl(be) && (j.vertical = hd(Z, i.glyphMap, i.glyphPositions, i.imagePositions, I, Ut, p, St, "left", rt, ae, T.ao.vertical, !0, R, E))
                            }
                            ;
                            if (!f && $t) {
                                const Vt = new Set;
                                if (Bt === "auto")
                                    for (let mt = 0; mt < $t.values.length; mt += 2)
                                        Vt.add(Yp($t.values[mt]));
                                else
                                    Vt.add(Bt);
                                let Zt = !1;
                                for (const mt of Vt)
                                    if (!j.horizontal[mt])
                                        if (Zt)
                                            j.horizontal[mt] = j.horizontal[0];
                                        else {
                                            const Br = hd(Z, i.glyphMap, i.glyphPositions, i.imagePositions, I, Ut, p, "center", mt, rt, ae, T.ao.horizontal, !1, R, E);
                                            Br && (j.horizontal[mt] = Br,
                                            Zt = Br.positionedLines.length === 1)
                                        }
                                pr()
                            } else {
                                Bt === "auto" && (Bt = Yp(St));
                                const Vt = hd(Z, i.glyphMap, i.glyphPositions, i.imagePositions, I, Ut, p, St, Bt, rt, ae, T.ao.horizontal, !1, R, E);
                                Vt && (j.horizontal[Bt] = Vt),
                                pr(),
                                wl(be) && f && g && (j.vertical = hd(Z, i.glyphMap, i.glyphPositions, i.imagePositions, I, Ut, p, St, Bt, rt, ae, T.ao.vertical, !1, R, E))
                            }
                        }
                        let ze = !1;
                        if (S.icon && S.icon.name) {
                            const be = i.imageMap[S.icon.name];
                            be && (Y = Q0(i.imagePositions[S.icon.name], r.get("icon-offset").evaluate(S, {}, i.canonical), r.get("icon-anchor").evaluate(S, {}, i.canonical)),
                            ze = !!be.sdf,
                            i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = ze : i.bucket.sdfIcons !== ze && Lt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),
                            (be.pixelRatio !== i.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0))
                        }
                        const me = H_(j.horizontal) || j.vertical;
                        i.bucket.iconsInText = !!me && me.iconsInText,
                        (me || Y) && my(i.bucket, S, j, Y, i.imageMap, c, R, N, ae, ze, i.canonical, i.subdivisionGranularity)
                    }
                    i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers()
                }
                ,
                T.cI = Bp,
                T.cJ = Lp,
                T.cK = Rp,
                T.cL = Km,
                T.cM = Op,
                T.cN = class {
                    constructor(i) {
                        this._marks = {
                            start: [i.url, "start"].join("#"),
                            end: [i.url, "end"].join("#"),
                            measure: i.url.toString()
                        },
                        performance.mark(this._marks.start)
                    }
                    finish() {
                        performance.mark(this._marks.end);
                        let i = performance.getEntriesByName(this._marks.measure);
                        return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end),
                        i = performance.getEntriesByName(this._marks.measure),
                        performance.clearMarks(this._marks.start),
                        performance.clearMarks(this._marks.end),
                        performance.clearMeasures(this._marks.measure)),
                        i
                    }
                }
                ,
                T.cO = function(i, t, r, a, c) {
                    return o(this, void 0, void 0, (function*() {
                        if (ke())
                            try {
                                return yield dr(i, t, r, a, c)
                            } catch {}
                        return (function(p, f, g, v, S) {
                            const I = p.width
                              , E = p.height;
                            _r && Ir || (_r = new OffscreenCanvas(I,E),
                            Ir = _r.getContext("2d", {
                                willReadFrequently: !0
                            })),
                            _r.width = I,
                            _r.height = E,
                            Ir.drawImage(p, 0, 0, I, E);
                            const R = Ir.getImageData(f, g, v, S);
                            return Ir.clearRect(0, 0, I, E),
                            R.data
                        }
                        )(i, t, r, a, c)
                    }
                    ))
                }
                ,
                T.cP = Om,
                T.cQ = W,
                T.cR = Xm,
                T.cS = Bl,
                T.cT = Co,
                T.cU = function(i, t) {
                    const r = new Map;
                    if (i != null)
                        if (i.type === "Feature")
                            r.set(mu(i, t), i);
                        else
                            for (const a of i.features)
                                r.set(mu(a, t), a);
                    return r
                }
                ,
                T.cV = function(i, t) {
                    if (i == null)
                        return !0;
                    if (i.type === "Feature")
                        return mu(i, t) != null;
                    if (i.type === "FeatureCollection") {
                        const r = new Set;
                        for (const a of i.features) {
                            const c = mu(a, t);
                            if (c == null || r.has(c))
                                return !1;
                            r.add(c)
                        }
                        return !0
                    }
                    return !1
                }
                ,
                T.cW = function(i, t, r) {
                    var a, c, p, f;
                    if (t.removeAll && i.clear(),
                    t.remove)
                        for (const g of t.remove)
                            i.delete(g);
                    if (t.add)
                        for (const g of t.add) {
                            const v = mu(g, r);
                            v != null && i.set(v, g)
                        }
                    if (t.update)
                        for (const g of t.update) {
                            let v = i.get(g.id);
                            if (v == null)
                                continue;
                            const S = !g.removeAllProperties && (((a = g.removeProperties) === null || a === void 0 ? void 0 : a.length) > 0 || ((c = g.addOrUpdateProperties) === null || c === void 0 ? void 0 : c.length) > 0);
                            if ((g.newGeometry || g.removeAllProperties || S) && (v = Object.assign({}, v),
                            i.set(g.id, v),
                            S && (v.properties = Object.assign({}, v.properties))),
                            g.newGeometry && (v.geometry = g.newGeometry),
                            g.removeAllProperties)
                                v.properties = {};
                            else if (((p = g.removeProperties) === null || p === void 0 ? void 0 : p.length) > 0)
                                for (const I of g.removeProperties)
                                    Object.prototype.hasOwnProperty.call(v.properties, I) && delete v.properties[I];
                            if (((f = g.addOrUpdateProperties) === null || f === void 0 ? void 0 : f.length) > 0)
                                for (const {key: I, value: E} of g.addOrUpdateProperties)
                                    v.properties[I] = E
                        }
                }
                ,
                T.cX = Ca,
                T.ca = function(i, t) {
                    return i[0] = t[0],
                    i[1] = t[1],
                    i[2] = t[2],
                    i[3] = t[3],
                    i[4] = t[4],
                    i[5] = t[5],
                    i[6] = t[6],
                    i[7] = t[7],
                    i[8] = t[8],
                    i[9] = t[9],
                    i[10] = t[10],
                    i[11] = t[11],
                    i[12] = t[12],
                    i[13] = t[13],
                    i[14] = t[14],
                    i[15] = t[15],
                    i
                }
                ,
                T.cb = i => i.type === "symbol",
                T.cc = i => i.type === "circle",
                T.cd = i => i.type === "heatmap",
                T.ce = i => i.type === "line",
                T.cf = i => i.type === "fill",
                T.cg = i => i.type === "fill-extrusion",
                T.ch = i => i.type === "hillshade",
                T.ci = i => i.type === "color-relief",
                T.cj = i => i.type === "raster",
                T.ck = i => i.type === "background",
                T.cl = i => i.type === "custom",
                T.cm = Ct,
                T.cn = function(i, t, r) {
                    const a = _e(t.x - r.x, t.y - r.y)
                      , c = _e(i.x - r.x, i.y - r.y);
                    var p, f;
                    return Mr(Math.atan2(a[0] * c[1] - a[1] * c[0], (p = a)[0] * (f = c)[0] + p[1] * f[1]))
                }
                ,
                T.co = _t,
                T.cp = function(i, t) {
                    return kr[t] && (i instanceof MouseEvent || i instanceof WheelEvent)
                }
                ,
                T.cq = function(i, t) {
                    return Ar[t] && "touches"in i
                }
                ,
                T.cr = function(i) {
                    return Ar[i] || kr[i]
                }
                ,
                T.cs = function(i, t, r) {
                    var a = t[0]
                      , c = t[1];
                    return i[0] = r[0] * a + r[4] * c + r[12],
                    i[1] = r[1] * a + r[5] * c + r[13],
                    i
                }
                ,
                T.ct = function(i, t) {
                    const {x: r, y: a} = fu.fromLngLat(t);
                    return !(i < 0 || i > 25 || a < 0 || a >= 1 || r < 0 || r >= 1)
                }
                ,
                T.cu = function(i, t) {
                    return i[0] = t[0],
                    i[1] = 0,
                    i[2] = 0,
                    i[3] = 0,
                    i[4] = 0,
                    i[5] = t[1],
                    i[6] = 0,
                    i[7] = 0,
                    i[8] = 0,
                    i[9] = 0,
                    i[10] = t[2],
                    i[11] = 0,
                    i[12] = 0,
                    i[13] = 0,
                    i[14] = 0,
                    i[15] = 1,
                    i
                }
                ,
                T.cv = class extends Xs {
                }
                ,
                T.cw = gy,
                T.cy = function(i) {
                    return i.message === Nr
                }
                ,
                T.cz = K,
                T.d = Le,
                T.e = pt,
                T.f = i => o(void 0, void 0, void 0, (function*() {
                    if (i.byteLength === 0)
                        return createImageBitmap(new ImageData(1,1));
                    const t = new Blob([new Uint8Array(i)],{
                        type: "image/png"
                    });
                    try {
                        return createImageBitmap(t)
                    } catch (r) {
                        throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
                    }
                }
                )),
                T.g = q,
                T.h = i => new Promise(( (t, r) => {
                    const a = new Image;
                    a.onload = () => {
                        t(a),
                        URL.revokeObjectURL(a.src),
                        a.onload = null,
                        window.requestAnimationFrame(( () => {
                            a.src = Ft
                        }
                        ))
                    }
                    ,
                    a.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const c = new Blob([new Uint8Array(i)],{
                        type: "image/png"
                    });
                    a.src = i.byteLength ? URL.createObjectURL(c) : Ft
                }
                )),
                T.i = Yt,
                T.j = (i, t) => ve(pt(i, {
                    type: "json"
                }), t),
                T.k = Ye,
                T.l = ot,
                T.m = ve,
                T.n = (i, t) => ve(pt(i, {
                    type: "arrayBuffer"
                }), t),
                T.o = function(i) {
                    return new Op(i).readFields(V0, [])
                }
                ,
                T.p = c_,
                T.q = iu,
                T.r = jn,
                T.s = jr,
                T.t = ed,
                T.u = si,
                T.v = xe,
                T.w = Lt,
                T.x = _p,
                T.y = Eo,
                T.z = $s
            }
            )),
            L("worker", ["./shared"], (function(T) {
                class o {
                    constructor(F) {
                        this.keyCache = {},
                        F && this.replace(F)
                    }
                    replace(F) {
                        this._layerConfigs = {},
                        this._layers = {},
                        this.update(F, [])
                    }
                    update(F, q) {
                        for (const K of F) {
                            this._layerConfigs[K.id] = K;
                            const le = this._layers[K.id] = T.bJ(K);
                            le._featureFilter = T.aa(le.filter),
                            this.keyCache[K.id] && delete this.keyCache[K.id]
                        }
                        for (const K of q)
                            delete this.keyCache[K],
                            delete this._layerConfigs[K],
                            delete this._layers[K];
                        this.familiesBySource = {};
                        const G = T.cC(Object.values(this._layerConfigs), this.keyCache);
                        for (const K of G) {
                            const le = K.map((Ye => this._layers[Ye.id]))
                              , ve = le[0];
                            if (ve.visibility === "none")
                                continue;
                            const Le = ve.source || "";
                            let Ce = this.familiesBySource[Le];
                            Ce || (Ce = this.familiesBySource[Le] = {});
                            const Ze = ve.sourceLayer || "_geojsonTileLayer";
                            let ot = Ce[Ze];
                            ot || (ot = Ce[Ze] = []),
                            ot.push(le)
                        }
                    }
                }
                class $ {
                    constructor(F) {
                        const q = {}
                          , G = [];
                        for (const Le in F) {
                            const Ce = F[Le]
                              , Ze = q[Le] = {};
                            for (const ot in Ce) {
                                const Ye = Ce[+ot];
                                if (!Ye || Ye.bitmap.width === 0 || Ye.bitmap.height === 0)
                                    continue;
                                const Ot = {
                                    x: 0,
                                    y: 0,
                                    w: Ye.bitmap.width + 2,
                                    h: Ye.bitmap.height + 2
                                };
                                G.push(Ot),
                                Ze[ot] = {
                                    rect: Ot,
                                    metrics: Ye.metrics
                                }
                            }
                        }
                        const {w: K, h: le} = T.p(G)
                          , ve = new T.q({
                            width: K || 1,
                            height: le || 1
                        });
                        for (const Le in F) {
                            const Ce = F[Le];
                            for (const Ze in Ce) {
                                const ot = Ce[+Ze];
                                if (!ot || ot.bitmap.width === 0 || ot.bitmap.height === 0)
                                    continue;
                                const Ye = q[Le][Ze].rect;
                                T.q.copy(ot.bitmap, ve, {
                                    x: 0,
                                    y: 0
                                }, {
                                    x: Ye.x + 1,
                                    y: Ye.y + 1
                                }, ot.bitmap)
                            }
                        }
                        this.image = ve,
                        this.positions = q
                    }
                }
                T.cD("GlyphAtlas", $);
                class W {
                    constructor(F) {
                        this.tileID = new T.Z(F.tileID.overscaledZ,F.tileID.wrap,F.tileID.canonical.z,F.tileID.canonical.x,F.tileID.canonical.y),
                        this.uid = F.uid,
                        this.zoom = F.zoom,
                        this.pixelRatio = F.pixelRatio,
                        this.tileSize = F.tileSize,
                        this.source = F.source,
                        this.overscaling = this.tileID.overscaleFactor(),
                        this.showCollisionBoxes = F.showCollisionBoxes,
                        this.collectResourceTiming = !!F.collectResourceTiming,
                        this.returnDependencies = !!F.returnDependencies,
                        this.promoteId = F.promoteId,
                        this.inFlightDependencies = [],
                        this.globalState = F.globalState
                    }
                    parse(F, q, G, K, le) {
                        return T._(this, void 0, void 0, (function*() {
                            this.status = "parsing",
                            this.data = F,
                            this.collisionBoxArray = new T.a8;
                            const ve = new T.cE(Object.keys(F.layers).sort())
                              , Le = new T.cF(this.tileID,this.promoteId);
                            Le.bucketLayerIDs = [];
                            const Ce = {}
                              , Ze = {
                                featureIndex: Le,
                                iconDependencies: {},
                                patternDependencies: {},
                                glyphDependencies: {},
                                availableImages: G,
                                subdivisionGranularity: le
                            }
                              , ot = q.familiesBySource[this.source];
                            for (const mr in ot) {
                                const gr = F.layers[mr];
                                if (!gr)
                                    continue;
                                gr.version === 1 && T.w(`Vector tile source "${this.source}" layer "${mr}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                                const ai = ve.encode(mr)
                                  , Tt = [];
                                for (let Ci = 0; Ci < gr.length; Ci++) {
                                    const di = gr.feature(Ci)
                                      , Pn = Le.getId(di, mr);
                                    Tt.push({
                                        feature: di,
                                        id: Pn,
                                        index: Ci,
                                        sourceLayerIndex: ai
                                    })
                                }
                                for (const Ci of ot[mr]) {
                                    const di = Ci[0];
                                    di.source !== this.source && T.w(`layer.source = ${di.source} does not equal this.source = ${this.source}`),
                                    di.minzoom && this.zoom < Math.floor(di.minzoom) || di.maxzoom && this.zoom >= di.maxzoom || di.visibility !== "none" && (ie(Ci, this.zoom, G),
                                    (Ce[di.id] = di.createBucket({
                                        index: Le.bucketLayerIDs.length,
                                        layers: Ci,
                                        zoom: this.zoom,
                                        pixelRatio: this.pixelRatio,
                                        overscaling: this.overscaling,
                                        collisionBoxArray: this.collisionBoxArray,
                                        sourceLayerIndex: ai,
                                        sourceID: this.source,
                                        globalState: this.globalState
                                    })).populate(Tt, Ze, this.tileID.canonical),
                                    Le.bucketLayerIDs.push(Ci.map((Pn => Pn.id))))
                                }
                            }
                            const Ye = T.bN(Ze.glyphDependencies, (mr => Object.keys(mr).map(Number)));
                            this.inFlightDependencies.forEach((mr => mr == null ? void 0 : mr.abort())),
                            this.inFlightDependencies = [];
                            let Ot = Promise.resolve({});
                            if (Object.keys(Ye).length) {
                                const mr = new AbortController;
                                this.inFlightDependencies.push(mr),
                                Ot = K.sendAsync({
                                    type: "GG",
                                    data: {
                                        stacks: Ye,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "glyphs"
                                    }
                                }, mr)
                            }
                            const xe = Object.keys(Ze.iconDependencies);
                            let At = Promise.resolve({});
                            if (xe.length) {
                                const mr = new AbortController;
                                this.inFlightDependencies.push(mr),
                                At = K.sendAsync({
                                    type: "GI",
                                    data: {
                                        icons: xe,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "icons"
                                    }
                                }, mr)
                            }
                            const Pt = Object.keys(Ze.patternDependencies);
                            let kt = Promise.resolve({});
                            if (Pt.length) {
                                const mr = new AbortController;
                                this.inFlightDependencies.push(mr),
                                kt = K.sendAsync({
                                    type: "GI",
                                    data: {
                                        icons: Pt,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "patterns"
                                    }
                                }, mr)
                            }
                            const [Wt,Lr,Kr] = yield Promise.all([Ot, At, kt])
                              , Hr = new $(Wt)
                              , $r = new T.cG(Lr,Kr);
                            for (const mr in Ce) {
                                const gr = Ce[mr];
                                gr instanceof T.a9 ? (ie(gr.layers, this.zoom, G),
                                T.cH({
                                    bucket: gr,
                                    glyphMap: Wt,
                                    glyphPositions: Hr.positions,
                                    imageMap: Lr,
                                    imagePositions: $r.iconPositions,
                                    showCollisionBoxes: this.showCollisionBoxes,
                                    canonical: this.tileID.canonical,
                                    subdivisionGranularity: Ze.subdivisionGranularity
                                })) : gr.hasPattern && (gr instanceof T.cI || gr instanceof T.cJ || gr instanceof T.cK) && (ie(gr.layers, this.zoom, G),
                                gr.addFeatures(Ze, this.tileID.canonical, $r.patternPositions))
                            }
                            return this.status = "done",
                            {
                                buckets: Object.values(Ce).filter((mr => !mr.isEmpty())),
                                featureIndex: Le,
                                collisionBoxArray: this.collisionBoxArray,
                                glyphAtlasImage: Hr.image,
                                imageAtlas: $r,
                                glyphMap: this.returnDependencies ? Wt : null,
                                iconMap: this.returnDependencies ? Lr : null,
                                glyphPositions: this.returnDependencies ? Hr.positions : null
                            }
                        }
                        ))
                    }
                }
                function ie(ce, F, q) {
                    const G = new T.F(F);
                    for (const K of ce)
                        K.recalculate(G, q)
                }
                class pe {
                    constructor(F, q, G) {
                        this.actor = F,
                        this.layerIndex = q,
                        this.availableImages = G,
                        this.fetching = {},
                        this.loading = {},
                        this.loaded = {}
                    }
                    loadVectorTile(F, q) {
                        return T._(this, void 0, void 0, (function*() {
                            const G = yield T.n(F.request, q);
                            try {
                                return {
                                    vectorTile: new T.cL(new T.cM(G.data)),
                                    rawData: G.data,
                                    cacheControl: G.cacheControl,
                                    expires: G.expires
                                }
                            } catch (K) {
                                const le = new Uint8Array(G.data);
                                let ve = `Unable to parse the tile at ${F.request.url}, `;
                                throw ve += le[0] === 31 && le[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${K.message}`,
                                new Error(ve)
                            }
                        }
                        ))
                    }
                    loadTile(F) {
                        return T._(this, void 0, void 0, (function*() {
                            const q = F.uid
                              , G = !!(F && F.request && F.request.collectResourceTiming) && new T.cN(F.request)
                              , K = new W(F);
                            this.loading[q] = K;
                            const le = new AbortController;
                            K.abort = le;
                            try {
                                const ve = yield this.loadVectorTile(F, le);
                                if (delete this.loading[q],
                                !ve)
                                    return null;
                                const Le = ve.rawData
                                  , Ce = {};
                                ve.expires && (Ce.expires = ve.expires),
                                ve.cacheControl && (Ce.cacheControl = ve.cacheControl);
                                const Ze = {};
                                if (G) {
                                    const Ye = G.finish();
                                    Ye && (Ze.resourceTiming = JSON.parse(JSON.stringify(Ye)))
                                }
                                K.vectorTile = ve.vectorTile;
                                const ot = K.parse(ve.vectorTile, this.layerIndex, this.availableImages, this.actor, F.subdivisionGranularity);
                                this.loaded[q] = K,
                                this.fetching[q] = {
                                    rawTileData: Le,
                                    cacheControl: Ce,
                                    resourceTiming: Ze
                                };
                                try {
                                    const Ye = yield ot;
                                    return T.e({
                                        rawTileData: Le.slice(0)
                                    }, Ye, Ce, Ze)
                                } finally {
                                    delete this.fetching[q]
                                }
                            } catch (ve) {
                                throw delete this.loading[q],
                                K.status = "done",
                                this.loaded[q] = K,
                                ve
                            }
                        }
                        ))
                    }
                    reloadTile(F) {
                        return T._(this, void 0, void 0, (function*() {
                            const q = F.uid;
                            if (!this.loaded || !this.loaded[q])
                                throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
                            const G = this.loaded[q];
                            if (G.showCollisionBoxes = F.showCollisionBoxes,
                            G.globalState = F.globalState,
                            G.status === "parsing") {
                                const K = yield G.parse(G.vectorTile, this.layerIndex, this.availableImages, this.actor, F.subdivisionGranularity);
                                let le;
                                if (this.fetching[q]) {
                                    const {rawTileData: ve, cacheControl: Le, resourceTiming: Ce} = this.fetching[q];
                                    delete this.fetching[q],
                                    le = T.e({
                                        rawTileData: ve.slice(0)
                                    }, K, Le, Ce)
                                } else
                                    le = K;
                                return le
                            }
                            if (G.status === "done" && G.vectorTile)
                                return G.parse(G.vectorTile, this.layerIndex, this.availableImages, this.actor, F.subdivisionGranularity)
                        }
                        ))
                    }
                    abortTile(F) {
                        return T._(this, void 0, void 0, (function*() {
                            const q = this.loading
                              , G = F.uid;
                            q && q[G] && q[G].abort && (q[G].abort.abort(),
                            delete q[G])
                        }
                        ))
                    }
                    removeTile(F) {
                        return T._(this, void 0, void 0, (function*() {
                            this.loaded && this.loaded[F.uid] && delete this.loaded[F.uid]
                        }
                        ))
                    }
                }
                class ye {
                    constructor() {
                        this.loaded = {}
                    }
                    loadTile(F) {
                        return T._(this, void 0, void 0, (function*() {
                            const {uid: q, encoding: G, rawImageData: K, redFactor: le, greenFactor: ve, blueFactor: Le, baseShift: Ce} = F
                              , Ze = K.width + 2
                              , ot = K.height + 2
                              , Ye = T.b(K) ? new T.R({
                                width: Ze,
                                height: ot
                            },yield T.cO(K, -1, -1, Ze, ot)) : K
                              , Ot = new T.cP(q,Ye,G,le,ve,Le,Ce);
                            return this.loaded = this.loaded || {},
                            this.loaded[q] = Ot,
                            Ot
                        }
                        ))
                    }
                    removeTile(F) {
                        const q = this.loaded
                          , G = F.uid;
                        q && q[G] && delete q[G]
                    }
                }
                var X, Se, we = (function() {
                    if (Se)
                        return X;
                    function ce(q, G) {
                        if (q.length !== 0) {
                            F(q[0], G);
                            for (var K = 1; K < q.length; K++)
                                F(q[K], !G)
                        }
                    }
                    function F(q, G) {
                        for (var K = 0, le = 0, ve = 0, Le = q.length, Ce = Le - 1; ve < Le; Ce = ve++) {
                            var Ze = (q[ve][0] - q[Ce][0]) * (q[Ce][1] + q[ve][1])
                              , ot = K + Ze;
                            le += Math.abs(K) >= Math.abs(Ze) ? K - ot + Ze : Ze - ot + K,
                            K = ot
                        }
                        K + le >= 0 != !!G && q.reverse()
                    }
                    return Se = 1,
                    X = function q(G, K) {
                        var le, ve = G && G.type;
                        if (ve === "FeatureCollection")
                            for (le = 0; le < G.features.length; le++)
                                q(G.features[le], K);
                        else if (ve === "GeometryCollection")
                            for (le = 0; le < G.geometries.length; le++)
                                q(G.geometries[le], K);
                        else if (ve === "Feature")
                            q(G.geometry, K);
                        else if (ve === "Polygon")
                            ce(G.coordinates, K);
                        else if (ve === "MultiPolygon")
                            for (le = 0; le < G.coordinates.length; le++)
                                ce(G.coordinates[le], K);
                        return G
                    }
                }
                )(), Re = T.cQ(we);
                class ke extends T.cS {
                    constructor(F, q) {
                        super(new T.cM, 0, q, [], []),
                        this.feature = F,
                        this.type = F.type,
                        this.properties = F.tags ? F.tags : {},
                        "id"in F && (typeof F.id == "string" ? this.id = parseInt(F.id, 10) : typeof F.id != "number" || isNaN(F.id) || (this.id = F.id))
                    }
                    loadGeometry() {
                        const F = []
                          , q = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
                        for (const G of q) {
                            const K = [];
                            for (const le of G)
                                K.push(new T.P(le[0],le[1]));
                            F.push(K)
                        }
                        return F
                    }
                }
                class Oe extends T.cR {
                    constructor(F, q) {
                        super(new T.cM),
                        this.layers = {
                            _geojsonTileLayer: this
                        },
                        this.name = "_geojsonTileLayer",
                        this.version = q ? q.version : 1,
                        this.extent = q ? q.extent : 4096,
                        this.length = F.length,
                        this.features = F
                    }
                    feature(F) {
                        return new ke(this.features[F],this.extent)
                    }
                }
                function Ee(ce, F) {
                    F.writeVarintField(15, ce.version || 1),
                    F.writeStringField(1, ce.name || ""),
                    F.writeVarintField(5, ce.extent || 4096);
                    const q = {
                        keys: [],
                        values: [],
                        keycache: {},
                        valuecache: {}
                    };
                    for (let le = 0; le < ce.length; le++)
                        q.feature = ce.feature(le),
                        F.writeMessage(2, Ne, q);
                    const G = q.keys;
                    for (const le of G)
                        F.writeStringField(3, le);
                    const K = q.values;
                    for (const le of K)
                        F.writeMessage(4, Je, le)
                }
                function Ne(ce, F) {
                    if (!ce.feature)
                        return;
                    const q = ce.feature;
                    q.id !== void 0 && F.writeVarintField(1, q.id),
                    F.writeMessage(2, ft, ce),
                    F.writeVarintField(3, q.type),
                    F.writeMessage(4, ct, q)
                }
                function ft(ce, F) {
                    var q;
                    for (const G in (q = ce.feature) == null ? void 0 : q.properties) {
                        let K = ce.feature.properties[G]
                          , le = ce.keycache[G];
                        if (K === null)
                            continue;
                        le === void 0 && (ce.keys.push(G),
                        le = ce.keys.length - 1,
                        ce.keycache[G] = le),
                        F.writeVarint(le),
                        typeof K != "string" && typeof K != "boolean" && typeof K != "number" && (K = JSON.stringify(K));
                        const ve = typeof K + ":" + K;
                        let Le = ce.valuecache[ve];
                        Le === void 0 && (ce.values.push(K),
                        Le = ce.values.length - 1,
                        ce.valuecache[ve] = Le),
                        F.writeVarint(Le)
                    }
                }
                function ht(ce, F) {
                    return (F << 3) + (7 & ce)
                }
                function Xe(ce) {
                    return ce << 1 ^ ce >> 31
                }
                function ct(ce, F) {
                    const q = ce.loadGeometry()
                      , G = ce.type;
                    let K = 0
                      , le = 0;
                    for (const ve of q) {
                        let Le = 1;
                        G === 1 && (Le = ve.length),
                        F.writeVarint(ht(1, Le));
                        const Ce = G === 3 ? ve.length - 1 : ve.length;
                        for (let Ze = 0; Ze < Ce; Ze++) {
                            Ze === 1 && G !== 1 && F.writeVarint(ht(2, Ce - 1));
                            const ot = ve[Ze].x - K
                              , Ye = ve[Ze].y - le;
                            F.writeVarint(Xe(ot)),
                            F.writeVarint(Xe(Ye)),
                            K += ot,
                            le += Ye
                        }
                        ce.type === 3 && F.writeVarint(ht(7, 1))
                    }
                }
                function Je(ce, F) {
                    const q = typeof ce;
                    q === "string" ? F.writeStringField(1, ce) : q === "boolean" ? F.writeBooleanField(7, ce) : q === "number" && (ce % 1 != 0 ? F.writeDoubleField(3, ce) : ce < 0 ? F.writeSVarintField(6, ce) : F.writeVarintField(5, ce))
                }
                const Be = {
                    minZoom: 0,
                    maxZoom: 16,
                    minPoints: 2,
                    radius: 40,
                    extent: 512,
                    nodeSize: 64,
                    log: !1,
                    generateId: !1,
                    reduce: null,
                    map: ce => ce
                }
                  , st = Math.fround || (it = new Float32Array(1),
                ce => (it[0] = +ce,
                it[0]));
                var it;
                class Qe {
                    constructor(F) {
                        this.options = Object.assign(Object.create(Be), F),
                        this.trees = new Array(this.options.maxZoom + 1),
                        this.stride = this.options.reduce ? 7 : 6,
                        this.clusterProps = []
                    }
                    load(F) {
                        const {log: q, minZoom: G, maxZoom: K} = this.options;
                        q && console.time("total time");
                        const le = `prepare ${F.length} points`;
                        q && console.time(le),
                        this.points = F;
                        const ve = [];
                        for (let Ce = 0; Ce < F.length; Ce++) {
                            const Ze = F[Ce];
                            if (!Ze.geometry)
                                continue;
                            const [ot,Ye] = Ze.geometry.coordinates
                              , Ot = st(Q(ot))
                              , xe = st(te(Ye));
                            ve.push(Ot, xe, 1 / 0, Ce, -1, 1),
                            this.options.reduce && ve.push(0)
                        }
                        let Le = this.trees[K + 1] = this._createTree(ve);
                        q && console.timeEnd(le);
                        for (let Ce = K; Ce >= G; Ce--) {
                            const Ze = +Date.now();
                            Le = this.trees[Ce] = this._createTree(this._cluster(Le, Ce)),
                            q && console.log("z%d: %d clusters in %dms", Ce, Le.numItems, +Date.now() - Ze)
                        }
                        return q && console.timeEnd("total time"),
                        this
                    }
                    getClusters(F, q) {
                        let G = ((F[0] + 180) % 360 + 360) % 360 - 180;
                        const K = Math.max(-90, Math.min(90, F[1]));
                        let le = F[2] === 180 ? 180 : ((F[2] + 180) % 360 + 360) % 360 - 180;
                        const ve = Math.max(-90, Math.min(90, F[3]));
                        if (F[2] - F[0] >= 360)
                            G = -180,
                            le = 180;
                        else if (G > le) {
                            const Ye = this.getClusters([G, K, 180, ve], q)
                              , Ot = this.getClusters([-180, K, le, ve], q);
                            return Ye.concat(Ot)
                        }
                        const Le = this.trees[this._limitZoom(q)]
                          , Ce = Le.range(Q(G), te(ve), Q(le), te(K))
                          , Ze = Le.data
                          , ot = [];
                        for (const Ye of Ce) {
                            const Ot = this.stride * Ye;
                            ot.push(Ze[Ot + 5] > 1 ? Ae(Ze, Ot, this.clusterProps) : this.points[Ze[Ot + 3]])
                        }
                        return ot
                    }
                    getChildren(F) {
                        const q = this._getOriginId(F)
                          , G = this._getOriginZoom(F)
                          , K = "No cluster with the specified id."
                          , le = this.trees[G];
                        if (!le)
                            throw new Error(K);
                        const ve = le.data;
                        if (q * this.stride >= ve.length)
                            throw new Error(K);
                        const Le = this.options.radius / (this.options.extent * Math.pow(2, G - 1))
                          , Ce = le.within(ve[q * this.stride], ve[q * this.stride + 1], Le)
                          , Ze = [];
                        for (const ot of Ce) {
                            const Ye = ot * this.stride;
                            ve[Ye + 4] === F && Ze.push(ve[Ye + 5] > 1 ? Ae(ve, Ye, this.clusterProps) : this.points[ve[Ye + 3]])
                        }
                        if (Ze.length === 0)
                            throw new Error(K);
                        return Ze
                    }
                    getLeaves(F, q, G) {
                        const K = [];
                        return this._appendLeaves(K, F, q = q || 10, G = G || 0, 0),
                        K
                    }
                    getTile(F, q, G) {
                        const K = this.trees[this._limitZoom(F)]
                          , le = Math.pow(2, F)
                          , {extent: ve, radius: Le} = this.options
                          , Ce = Le / ve
                          , Ze = (G - Ce) / le
                          , ot = (G + 1 + Ce) / le
                          , Ye = {
                            features: []
                        };
                        return this._addTileFeatures(K.range((q - Ce) / le, Ze, (q + 1 + Ce) / le, ot), K.data, q, G, le, Ye),
                        q === 0 && this._addTileFeatures(K.range(1 - Ce / le, Ze, 1, ot), K.data, le, G, le, Ye),
                        q === le - 1 && this._addTileFeatures(K.range(0, Ze, Ce / le, ot), K.data, -1, G, le, Ye),
                        Ye.features.length ? Ye : null
                    }
                    getClusterExpansionZoom(F) {
                        let q = this._getOriginZoom(F) - 1;
                        for (; q <= this.options.maxZoom; ) {
                            const G = this.getChildren(F);
                            if (q++,
                            G.length !== 1)
                                break;
                            F = G[0].properties.cluster_id
                        }
                        return q
                    }
                    _appendLeaves(F, q, G, K, le) {
                        const ve = this.getChildren(q);
                        for (const Le of ve) {
                            const Ce = Le.properties;
                            if (Ce && Ce.cluster ? le + Ce.point_count <= K ? le += Ce.point_count : le = this._appendLeaves(F, Ce.cluster_id, G, K, le) : le < K ? le++ : F.push(Le),
                            F.length === G)
                                break
                        }
                        return le
                    }
                    _createTree(F) {
                        const q = new T.aI(F.length / this.stride | 0,this.options.nodeSize,Float32Array);
                        for (let G = 0; G < F.length; G += this.stride)
                            q.add(F[G], F[G + 1]);
                        return q.finish(),
                        q.data = F,
                        q
                    }
                    _addTileFeatures(F, q, G, K, le, ve) {
                        for (const Le of F) {
                            const Ce = Le * this.stride
                              , Ze = q[Ce + 5] > 1;
                            let ot, Ye, Ot;
                            if (Ze)
                                ot = vt(q, Ce, this.clusterProps),
                                Ye = q[Ce],
                                Ot = q[Ce + 1];
                            else {
                                const Pt = this.points[q[Ce + 3]];
                                ot = Pt.properties;
                                const [kt,Wt] = Pt.geometry.coordinates;
                                Ye = Q(kt),
                                Ot = te(Wt)
                            }
                            const xe = {
                                type: 1,
                                geometry: [[Math.round(this.options.extent * (Ye * le - G)), Math.round(this.options.extent * (Ot * le - K))]],
                                tags: ot
                            };
                            let At;
                            At = Ze || this.options.generateId ? q[Ce + 3] : this.points[q[Ce + 3]].id,
                            At !== void 0 && (xe.id = At),
                            ve.features.push(xe)
                        }
                    }
                    _limitZoom(F) {
                        return Math.max(this.options.minZoom, Math.min(Math.floor(+F), this.options.maxZoom + 1))
                    }
                    _cluster(F, q) {
                        const {radius: G, extent: K, reduce: le, minPoints: ve} = this.options
                          , Le = G / (K * Math.pow(2, q))
                          , Ce = F.data
                          , Ze = []
                          , ot = this.stride;
                        for (let Ye = 0; Ye < Ce.length; Ye += ot) {
                            if (Ce[Ye + 2] <= q)
                                continue;
                            Ce[Ye + 2] = q;
                            const Ot = Ce[Ye]
                              , xe = Ce[Ye + 1]
                              , At = F.within(Ce[Ye], Ce[Ye + 1], Le)
                              , Pt = Ce[Ye + 5];
                            let kt = Pt;
                            for (const Wt of At) {
                                const Lr = Wt * ot;
                                Ce[Lr + 2] > q && (kt += Ce[Lr + 5])
                            }
                            if (kt > Pt && kt >= ve) {
                                let Wt, Lr = Ot * Pt, Kr = xe * Pt, Hr = -1;
                                const $r = (Ye / ot << 5) + (q + 1) + this.points.length;
                                for (const mr of At) {
                                    const gr = mr * ot;
                                    if (Ce[gr + 2] <= q)
                                        continue;
                                    Ce[gr + 2] = q;
                                    const ai = Ce[gr + 5];
                                    Lr += Ce[gr] * ai,
                                    Kr += Ce[gr + 1] * ai,
                                    Ce[gr + 4] = $r,
                                    le && (Wt || (Wt = this._map(Ce, Ye, !0),
                                    Hr = this.clusterProps.length,
                                    this.clusterProps.push(Wt)),
                                    le(Wt, this._map(Ce, gr)))
                                }
                                Ce[Ye + 4] = $r,
                                Ze.push(Lr / kt, Kr / kt, 1 / 0, $r, -1, kt),
                                le && Ze.push(Hr)
                            } else {
                                for (let Wt = 0; Wt < ot; Wt++)
                                    Ze.push(Ce[Ye + Wt]);
                                if (kt > 1)
                                    for (const Wt of At) {
                                        const Lr = Wt * ot;
                                        if (!(Ce[Lr + 2] <= q)) {
                                            Ce[Lr + 2] = q;
                                            for (let Kr = 0; Kr < ot; Kr++)
                                                Ze.push(Ce[Lr + Kr])
                                        }
                                    }
                            }
                        }
                        return Ze
                    }
                    _getOriginId(F) {
                        return F - this.points.length >> 5
                    }
                    _getOriginZoom(F) {
                        return (F - this.points.length) % 32
                    }
                    _map(F, q, G) {
                        if (F[q + 5] > 1) {
                            const ve = this.clusterProps[F[q + 6]];
                            return G ? Object.assign({}, ve) : ve
                        }
                        const K = this.points[F[q + 3]].properties
                          , le = this.options.map(K);
                        return G && le === K ? Object.assign({}, le) : le
                    }
                }
                function Ae(ce, F, q) {
                    return {
                        type: "Feature",
                        id: ce[F + 3],
                        properties: vt(ce, F, q),
                        geometry: {
                            type: "Point",
                            coordinates: [(G = ce[F],
                            360 * (G - .5)), _e(ce[F + 1])]
                        }
                    };
                    var G
                }
                function vt(ce, F, q) {
                    const G = ce[F + 5]
                      , K = G >= 1e4 ? `${Math.round(G / 1e3)}k` : G >= 1e3 ? Math.round(G / 100) / 10 + "k" : G
                      , le = ce[F + 6]
                      , ve = le === -1 ? {} : Object.assign({}, q[le]);
                    return Object.assign(ve, {
                        cluster: !0,
                        cluster_id: ce[F + 3],
                        point_count: G,
                        point_count_abbreviated: K
                    })
                }
                function Q(ce) {
                    return ce / 360 + .5
                }
                function te(ce) {
                    const F = Math.sin(ce * Math.PI / 180)
                      , q = .5 - .25 * Math.log((1 + F) / (1 - F)) / Math.PI;
                    return q < 0 ? 0 : q > 1 ? 1 : q
                }
                function _e(ce) {
                    const F = (180 - 360 * ce) * Math.PI / 180;
                    return 360 * Math.atan(Math.exp(F)) / Math.PI - 90
                }
                function ne(ce, F, q, G) {
                    let K = G;
                    const le = F + (q - F >> 1);
                    let ve, Le = q - F;
                    const Ce = ce[F]
                      , Ze = ce[F + 1]
                      , ot = ce[q]
                      , Ye = ce[q + 1];
                    for (let Ot = F + 3; Ot < q; Ot += 3) {
                        const xe = Pe(ce[Ot], ce[Ot + 1], Ce, Ze, ot, Ye);
                        if (xe > K)
                            ve = Ot,
                            K = xe;
                        else if (xe === K) {
                            const At = Math.abs(Ot - le);
                            At < Le && (ve = Ot,
                            Le = At)
                        }
                    }
                    K > G && (ve - F > 3 && ne(ce, F, ve, G),
                    ce[ve + 2] = K,
                    q - ve > 3 && ne(ce, ve, q, G))
                }
                function Pe(ce, F, q, G, K, le) {
                    let ve = K - q
                      , Le = le - G;
                    if (ve !== 0 || Le !== 0) {
                        const Ce = ((ce - q) * ve + (F - G) * Le) / (ve * ve + Le * Le);
                        Ce > 1 ? (q = K,
                        G = le) : Ce > 0 && (q += ve * Ce,
                        G += Le * Ce)
                    }
                    return ve = ce - q,
                    Le = F - G,
                    ve * ve + Le * Le
                }
                function Me(ce, F, q, G) {
                    const K = {
                        id: ce ?? null,
                        type: F,
                        geometry: q,
                        tags: G,
                        minX: 1 / 0,
                        minY: 1 / 0,
                        maxX: -1 / 0,
                        maxY: -1 / 0
                    };
                    if (F === "Point" || F === "MultiPoint" || F === "LineString")
                        at(K, q);
                    else if (F === "Polygon")
                        at(K, q[0]);
                    else if (F === "MultiLineString")
                        for (const le of q)
                            at(K, le);
                    else if (F === "MultiPolygon")
                        for (const le of q)
                            at(K, le[0]);
                    return K
                }
                function at(ce, F) {
                    for (let q = 0; q < F.length; q += 3)
                        ce.minX = Math.min(ce.minX, F[q]),
                        ce.minY = Math.min(ce.minY, F[q + 1]),
                        ce.maxX = Math.max(ce.maxX, F[q]),
                        ce.maxY = Math.max(ce.maxY, F[q + 1])
                }
                function We(ce, F, q, G) {
                    if (!F.geometry)
                        return;
                    const K = F.geometry.coordinates;
                    if (K && K.length === 0)
                        return;
                    const le = F.geometry.type
                      , ve = Math.pow(q.tolerance / ((1 << q.maxZoom) * q.extent), 2);
                    let Le = []
                      , Ce = F.id;
                    if (q.promoteId ? Ce = F.properties[q.promoteId] : q.generateId && (Ce = G || 0),
                    le === "Point")
                        Ct(K, Le);
                    else if (le === "MultiPoint")
                        for (const Ze of K)
                            Ct(Ze, Le);
                    else if (le === "LineString")
                        _t(K, Le, ve, !1);
                    else if (le === "MultiLineString") {
                        if (q.lineMetrics) {
                            for (const Ze of K)
                                Le = [],
                                _t(Ze, Le, ve, !1),
                                ce.push(Me(Ce, "LineString", Le, F.properties));
                            return
                        }
                        xt(K, Le, ve, !1)
                    } else if (le === "Polygon")
                        xt(K, Le, ve, !0);
                    else {
                        if (le !== "MultiPolygon") {
                            if (le === "GeometryCollection") {
                                for (const Ze of F.geometry.geometries)
                                    We(ce, {
                                        id: Ce,
                                        geometry: Ze,
                                        properties: F.properties
                                    }, q, G);
                                return
                            }
                            throw new Error("Input data is not a valid GeoJSON object.")
                        }
                        for (const Ze of K) {
                            const ot = [];
                            xt(Ze, ot, ve, !0),
                            Le.push(ot)
                        }
                    }
                    ce.push(Me(Ce, le, Le, F.properties))
                }
                function Ct(ce, F) {
                    F.push(tt(ce[0]), pt(ce[1]), 0)
                }
                function _t(ce, F, q, G) {
                    let K, le, ve = 0;
                    for (let Ce = 0; Ce < ce.length; Ce++) {
                        const Ze = tt(ce[Ce][0])
                          , ot = pt(ce[Ce][1]);
                        F.push(Ze, ot, 0),
                        Ce > 0 && (ve += G ? (K * ot - Ze * le) / 2 : Math.sqrt(Math.pow(Ze - K, 2) + Math.pow(ot - le, 2))),
                        K = Ze,
                        le = ot
                    }
                    const Le = F.length - 3;
                    F[2] = 1,
                    ne(F, 0, Le, q),
                    F[Le + 2] = 1,
                    F.size = Math.abs(ve),
                    F.start = 0,
                    F.end = F.size
                }
                function xt(ce, F, q, G) {
                    for (let K = 0; K < ce.length; K++) {
                        const le = [];
                        _t(ce[K], le, q, G),
                        F.push(le)
                    }
                }
                function tt(ce) {
                    return ce / 360 + .5
                }
                function pt(ce) {
                    const F = Math.sin(ce * Math.PI / 180)
                      , q = .5 - .25 * Math.log((1 + F) / (1 - F)) / Math.PI;
                    return q < 0 ? 0 : q > 1 ? 1 : q
                }
                function It(ce, F, q, G, K, le, ve, Le) {
                    if (G /= F,
                    le >= (q /= F) && ve < G)
                        return ce;
                    if (ve < q || le >= G)
                        return null;
                    const Ce = [];
                    for (const Ze of ce) {
                        const ot = Ze.geometry;
                        let Ye = Ze.type;
                        const Ot = K === 0 ? Ze.minX : Ze.minY
                          , xe = K === 0 ? Ze.maxX : Ze.maxY;
                        if (Ot >= q && xe < G) {
                            Ce.push(Ze);
                            continue
                        }
                        if (xe < q || Ot >= G)
                            continue;
                        let At = [];
                        if (Ye === "Point" || Ye === "MultiPoint")
                            ut(ot, At, q, G, K);
                        else if (Ye === "LineString")
                            bt(ot, At, q, G, K, !1, Le.lineMetrics);
                        else if (Ye === "MultiLineString")
                            dt(ot, At, q, G, K, !1);
                        else if (Ye === "Polygon")
                            dt(ot, At, q, G, K, !0);
                        else if (Ye === "MultiPolygon")
                            for (const Pt of ot) {
                                const kt = [];
                                dt(Pt, kt, q, G, K, !0),
                                kt.length && At.push(kt)
                            }
                        if (At.length) {
                            if (Le.lineMetrics && Ye === "LineString") {
                                for (const Pt of At)
                                    Ce.push(Me(Ze.id, Ye, Pt, Ze.tags));
                                continue
                            }
                            Ye !== "LineString" && Ye !== "MultiLineString" || (At.length === 1 ? (Ye = "LineString",
                            At = At[0]) : Ye = "MultiLineString"),
                            Ye !== "Point" && Ye !== "MultiPoint" || (Ye = At.length === 3 ? "Point" : "MultiPoint"),
                            Ce.push(Me(Ze.id, Ye, At, Ze.tags))
                        }
                    }
                    return Ce.length ? Ce : null
                }
                function ut(ce, F, q, G, K) {
                    for (let le = 0; le < ce.length; le += 3) {
                        const ve = ce[le + K];
                        ve >= q && ve <= G && Lt(F, ce[le], ce[le + 1], ce[le + 2])
                    }
                }
                function bt(ce, F, q, G, K, le, ve) {
                    let Le = wt(ce);
                    const Ce = K === 0 ? Xt : Yt;
                    let Ze, ot, Ye = ce.start;
                    for (let kt = 0; kt < ce.length - 3; kt += 3) {
                        const Wt = ce[kt]
                          , Lr = ce[kt + 1]
                          , Kr = ce[kt + 2]
                          , Hr = ce[kt + 3]
                          , $r = ce[kt + 4]
                          , mr = K === 0 ? Wt : Lr
                          , gr = K === 0 ? Hr : $r;
                        let ai = !1;
                        ve && (Ze = Math.sqrt(Math.pow(Wt - Hr, 2) + Math.pow(Lr - $r, 2))),
                        mr < q ? gr > q && (ot = Ce(Le, Wt, Lr, Hr, $r, q),
                        ve && (Le.start = Ye + Ze * ot)) : mr > G ? gr < G && (ot = Ce(Le, Wt, Lr, Hr, $r, G),
                        ve && (Le.start = Ye + Ze * ot)) : Lt(Le, Wt, Lr, Kr),
                        gr < q && mr >= q && (ot = Ce(Le, Wt, Lr, Hr, $r, q),
                        ai = !0),
                        gr > G && mr <= G && (ot = Ce(Le, Wt, Lr, Hr, $r, G),
                        ai = !0),
                        !le && ai && (ve && (Le.end = Ye + Ze * ot),
                        F.push(Le),
                        Le = wt(ce)),
                        ve && (Ye += Ze)
                    }
                    let Ot = ce.length - 3;
                    const xe = ce[Ot]
                      , At = ce[Ot + 1]
                      , Pt = K === 0 ? xe : At;
                    Pt >= q && Pt <= G && Lt(Le, xe, At, ce[Ot + 2]),
                    Ot = Le.length - 3,
                    le && Ot >= 3 && (Le[Ot] !== Le[0] || Le[Ot + 1] !== Le[1]) && Lt(Le, Le[0], Le[1], Le[2]),
                    Le.length && F.push(Le)
                }
                function wt(ce) {
                    const F = [];
                    return F.size = ce.size,
                    F.start = ce.start,
                    F.end = ce.end,
                    F
                }
                function dt(ce, F, q, G, K, le) {
                    for (const ve of ce)
                        bt(ve, F, q, G, K, le, !1)
                }
                function Lt(ce, F, q, G) {
                    ce.push(F, q, G)
                }
                function Xt(ce, F, q, G, K, le) {
                    const ve = (le - F) / (G - F);
                    return Lt(ce, le, q + (K - q) * ve, 1),
                    ve
                }
                function Yt(ce, F, q, G, K, le) {
                    const ve = (le - q) / (K - q);
                    return Lt(ce, F + (G - F) * ve, le, 1),
                    ve
                }
                function nr(ce, F) {
                    const q = [];
                    for (let G = 0; G < ce.length; G++) {
                        const K = ce[G]
                          , le = K.type;
                        let ve;
                        if (le === "Point" || le === "MultiPoint" || le === "LineString")
                            ve = ar(K.geometry, F);
                        else if (le === "MultiLineString" || le === "Polygon") {
                            ve = [];
                            for (const Le of K.geometry)
                                ve.push(ar(Le, F))
                        } else if (le === "MultiPolygon") {
                            ve = [];
                            for (const Le of K.geometry) {
                                const Ce = [];
                                for (const Ze of Le)
                                    Ce.push(ar(Ze, F));
                                ve.push(Ce)
                            }
                        }
                        q.push(Me(K.id, le, ve, K.tags))
                    }
                    return q
                }
                function ar(ce, F) {
                    const q = [];
                    q.size = ce.size,
                    ce.start !== void 0 && (q.start = ce.start,
                    q.end = ce.end);
                    for (let G = 0; G < ce.length; G += 3)
                        q.push(ce[G] + F, ce[G + 1], ce[G + 2]);
                    return q
                }
                function Ft(ce, F) {
                    if (ce.transformed)
                        return ce;
                    const q = 1 << ce.z
                      , G = ce.x
                      , K = ce.y;
                    for (const le of ce.features) {
                        const ve = le.geometry
                          , Le = le.type;
                        if (le.geometry = [],
                        Le === 1)
                            for (let Ce = 0; Ce < ve.length; Ce += 2)
                                le.geometry.push(dr(ve[Ce], ve[Ce + 1], F, q, G, K));
                        else
                            for (let Ce = 0; Ce < ve.length; Ce++) {
                                const Ze = [];
                                for (let ot = 0; ot < ve[Ce].length; ot += 2)
                                    Ze.push(dr(ve[Ce][ot], ve[Ce][ot + 1], F, q, G, K));
                                le.geometry.push(Ze)
                            }
                    }
                    return ce.transformed = !0,
                    ce
                }
                function dr(ce, F, q, G, K, le) {
                    return [Math.round(q * (ce * G - K)), Math.round(q * (F * G - le))]
                }
                function _r(ce, F, q, G, K) {
                    const le = F === K.maxZoom ? 0 : K.tolerance / ((1 << F) * K.extent)
                      , ve = {
                        features: [],
                        numPoints: 0,
                        numSimplified: 0,
                        numFeatures: ce.length,
                        source: null,
                        x: q,
                        y: G,
                        z: F,
                        transformed: !1,
                        minX: 2,
                        minY: 1,
                        maxX: -1,
                        maxY: 0
                    };
                    for (const Le of ce)
                        Ir(ve, Le, le, K);
                    return ve
                }
                function Ir(ce, F, q, G) {
                    const K = F.geometry
                      , le = F.type
                      , ve = [];
                    if (ce.minX = Math.min(ce.minX, F.minX),
                    ce.minY = Math.min(ce.minY, F.minY),
                    ce.maxX = Math.max(ce.maxX, F.maxX),
                    ce.maxY = Math.max(ce.maxY, F.maxY),
                    le === "Point" || le === "MultiPoint")
                        for (let Le = 0; Le < K.length; Le += 3)
                            ve.push(K[Le], K[Le + 1]),
                            ce.numPoints++,
                            ce.numSimplified++;
                    else if (le === "LineString")
                        jr(ve, K, ce, q, !1, !1);
                    else if (le === "MultiLineString" || le === "Polygon")
                        for (let Le = 0; Le < K.length; Le++)
                            jr(ve, K[Le], ce, q, le === "Polygon", Le === 0);
                    else if (le === "MultiPolygon")
                        for (let Le = 0; Le < K.length; Le++) {
                            const Ce = K[Le];
                            for (let Ze = 0; Ze < Ce.length; Ze++)
                                jr(ve, Ce[Ze], ce, q, !0, Ze === 0)
                        }
                    if (ve.length) {
                        let Le = F.tags || null;
                        if (le === "LineString" && G.lineMetrics) {
                            Le = {};
                            for (const Ze in F.tags)
                                Le[Ze] = F.tags[Ze];
                            Le.mapbox_clip_start = K.start / K.size,
                            Le.mapbox_clip_end = K.end / K.size
                        }
                        const Ce = {
                            geometry: ve,
                            type: le === "Polygon" || le === "MultiPolygon" ? 3 : le === "LineString" || le === "MultiLineString" ? 2 : 1,
                            tags: Le
                        };
                        F.id !== null && (Ce.id = F.id),
                        ce.features.push(Ce)
                    }
                }
                function jr(ce, F, q, G, K, le) {
                    const ve = G * G;
                    if (G > 0 && F.size < (K ? ve : G))
                        return void (q.numPoints += F.length / 3);
                    const Le = [];
                    for (let Ce = 0; Ce < F.length; Ce += 3)
                        (G === 0 || F[Ce + 2] > ve) && (q.numSimplified++,
                        Le.push(F[Ce], F[Ce + 1])),
                        q.numPoints++;
                    K && (function(Ce, Ze) {
                        let ot = 0;
                        for (let Ye = 0, Ot = Ce.length, xe = Ot - 2; Ye < Ot; xe = Ye,
                        Ye += 2)
                            ot += (Ce[Ye] - Ce[xe]) * (Ce[Ye + 1] + Ce[xe + 1]);
                        if (ot > 0 === Ze)
                            for (let Ye = 0, Ot = Ce.length; Ye < Ot / 2; Ye += 2) {
                                const xe = Ce[Ye]
                                  , At = Ce[Ye + 1];
                                Ce[Ye] = Ce[Ot - 2 - Ye],
                                Ce[Ye + 1] = Ce[Ot - 1 - Ye],
                                Ce[Ot - 2 - Ye] = xe,
                                Ce[Ot - 1 - Ye] = At
                            }
                    }
                    )(Le, le),
                    ce.push(Le)
                }
                const ur = {
                    maxZoom: 14,
                    indexMaxZoom: 5,
                    indexMaxPoints: 1e5,
                    tolerance: 3,
                    extent: 4096,
                    buffer: 64,
                    lineMetrics: !1,
                    promoteId: null,
                    generateId: !1,
                    debug: 0
                };
                class Mr {
                    constructor(F, q) {
                        const G = (q = this.options = (function(le, ve) {
                            for (const Le in ve)
                                le[Le] = ve[Le];
                            return le
                        }
                        )(Object.create(ur), q)).debug;
                        if (G && console.time("preprocess data"),
                        q.maxZoom < 0 || q.maxZoom > 24)
                            throw new Error("maxZoom should be in the 0-24 range");
                        if (q.promoteId && q.generateId)
                            throw new Error("promoteId and generateId cannot be used together.");
                        let K = (function(le, ve) {
                            const Le = [];
                            if (le.type === "FeatureCollection")
                                for (let Ce = 0; Ce < le.features.length; Ce++)
                                    We(Le, le.features[Ce], ve, Ce);
                            else
                                We(Le, le.type === "Feature" ? le : {
                                    geometry: le
                                }, ve);
                            return Le
                        }
                        )(F, q);
                        this.tiles = {},
                        this.tileCoords = [],
                        G && (console.timeEnd("preprocess data"),
                        console.log("index: maxZoom: %d, maxPoints: %d", q.indexMaxZoom, q.indexMaxPoints),
                        console.time("generate tiles"),
                        this.stats = {},
                        this.total = 0),
                        K = (function(le, ve) {
                            const Le = ve.buffer / ve.extent;
                            let Ce = le;
                            const Ze = It(le, 1, -1 - Le, Le, 0, -1, 2, ve)
                              , ot = It(le, 1, 1 - Le, 2 + Le, 0, -1, 2, ve);
                            return (Ze || ot) && (Ce = It(le, 1, -Le, 1 + Le, 0, -1, 2, ve) || [],
                            Ze && (Ce = nr(Ze, 1).concat(Ce)),
                            ot && (Ce = Ce.concat(nr(ot, -1)))),
                            Ce
                        }
                        )(K, q),
                        K.length && this.splitTile(K, 0, 0, 0),
                        G && (K.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints),
                        console.timeEnd("generate tiles"),
                        console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
                    }
                    splitTile(F, q, G, K, le, ve, Le) {
                        const Ce = [F, q, G, K]
                          , Ze = this.options
                          , ot = Ze.debug;
                        for (; Ce.length; ) {
                            K = Ce.pop(),
                            G = Ce.pop(),
                            q = Ce.pop(),
                            F = Ce.pop();
                            const Ye = 1 << q
                              , Ot = Ar(q, G, K);
                            let xe = this.tiles[Ot];
                            if (!xe && (ot > 1 && console.time("creation"),
                            xe = this.tiles[Ot] = _r(F, q, G, K, Ze),
                            this.tileCoords.push({
                                z: q,
                                x: G,
                                y: K
                            }),
                            ot)) {
                                ot > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", q, G, K, xe.numFeatures, xe.numPoints, xe.numSimplified),
                                console.timeEnd("creation"));
                                const ai = `z${q}`;
                                this.stats[ai] = (this.stats[ai] || 0) + 1,
                                this.total++
                            }
                            if (xe.source = F,
                            le == null) {
                                if (q === Ze.indexMaxZoom || xe.numPoints <= Ze.indexMaxPoints)
                                    continue
                            } else {
                                if (q === Ze.maxZoom || q === le)
                                    continue;
                                if (le != null) {
                                    const ai = le - q;
                                    if (G !== ve >> ai || K !== Le >> ai)
                                        continue
                                }
                            }
                            if (xe.source = null,
                            F.length === 0)
                                continue;
                            ot > 1 && console.time("clipping");
                            const At = .5 * Ze.buffer / Ze.extent
                              , Pt = .5 - At
                              , kt = .5 + At
                              , Wt = 1 + At;
                            let Lr = null
                              , Kr = null
                              , Hr = null
                              , $r = null
                              , mr = It(F, Ye, G - At, G + kt, 0, xe.minX, xe.maxX, Ze)
                              , gr = It(F, Ye, G + Pt, G + Wt, 0, xe.minX, xe.maxX, Ze);
                            F = null,
                            mr && (Lr = It(mr, Ye, K - At, K + kt, 1, xe.minY, xe.maxY, Ze),
                            Kr = It(mr, Ye, K + Pt, K + Wt, 1, xe.minY, xe.maxY, Ze),
                            mr = null),
                            gr && (Hr = It(gr, Ye, K - At, K + kt, 1, xe.minY, xe.maxY, Ze),
                            $r = It(gr, Ye, K + Pt, K + Wt, 1, xe.minY, xe.maxY, Ze),
                            gr = null),
                            ot > 1 && console.timeEnd("clipping"),
                            Ce.push(Lr || [], q + 1, 2 * G, 2 * K),
                            Ce.push(Kr || [], q + 1, 2 * G, 2 * K + 1),
                            Ce.push(Hr || [], q + 1, 2 * G + 1, 2 * K),
                            Ce.push($r || [], q + 1, 2 * G + 1, 2 * K + 1)
                        }
                    }
                    getTile(F, q, G) {
                        F = +F,
                        q = +q,
                        G = +G;
                        const K = this.options
                          , {extent: le, debug: ve} = K;
                        if (F < 0 || F > 24)
                            return null;
                        const Le = 1 << F
                          , Ce = Ar(F, q = q + Le & Le - 1, G);
                        if (this.tiles[Ce])
                            return Ft(this.tiles[Ce], le);
                        ve > 1 && console.log("drilling down to z%d-%d-%d", F, q, G);
                        let Ze, ot = F, Ye = q, Ot = G;
                        for (; !Ze && ot > 0; )
                            ot--,
                            Ye >>= 1,
                            Ot >>= 1,
                            Ze = this.tiles[Ar(ot, Ye, Ot)];
                        return Ze && Ze.source ? (ve > 1 && (console.log("found parent tile z%d-%d-%d", ot, Ye, Ot),
                        console.time("drilling down")),
                        this.splitTile(Ze.source, ot, Ye, Ot, F, q, G),
                        ve > 1 && console.timeEnd("drilling down"),
                        this.tiles[Ce] ? Ft(this.tiles[Ce], le) : null) : null
                    }
                }
                function Ar(ce, F, q) {
                    return 32 * ((1 << ce) * q + F) + ce
                }
                class kr extends pe {
                    constructor() {
                        super(...arguments),
                        this._dataUpdateable = new Map
                    }
                    loadVectorTile(F, q) {
                        return T._(this, void 0, void 0, (function*() {
                            const G = F.tileID.canonical;
                            if (!this._geoJSONIndex)
                                throw new Error("Unable to parse the data into a cluster or geojson");
                            const K = this._geoJSONIndex.getTile(G.z, G.x, G.y);
                            if (!K)
                                return null;
                            const le = new Oe(K.features,{
                                version: 2,
                                extent: T.$
                            });
                            let ve = (function(Le) {
                                const Ce = new T.cM;
                                return (function(Ze, ot) {
                                    for (const Ye in Ze.layers)
                                        ot.writeMessage(3, Ee, Ze.layers[Ye])
                                }
                                )(Le, Ce),
                                Ce.finish()
                            }
                            )(le);
                            return ve.byteOffset === 0 && ve.byteLength === ve.buffer.byteLength || (ve = new Uint8Array(ve)),
                            {
                                vectorTile: le,
                                rawData: ve.buffer
                            }
                        }
                        ))
                    }
                    loadData(F) {
                        return T._(this, void 0, void 0, (function*() {
                            var q;
                            (q = this._pendingRequest) === null || q === void 0 || q.abort();
                            const G = !!(F && F.request && F.request.collectResourceTiming) && new T.cN(F.request);
                            this._pendingRequest = new AbortController;
                            try {
                                this._pendingData = this.loadAndProcessGeoJSON(F, this._pendingRequest);
                                const K = yield this._pendingData;
                                this._geoJSONIndex = F.cluster ? new Qe((function({superclusterOptions: ve, clusterProperties: Le}) {
                                    if (!Le || !ve)
                                        return ve;
                                    const Ce = {}
                                      , Ze = {}
                                      , ot = {
                                        accumulated: null,
                                        zoom: 0
                                    }
                                      , Ye = {
                                        properties: null
                                    }
                                      , Ot = Object.keys(Le);
                                    for (const xe of Ot) {
                                        const [At,Pt] = Le[xe]
                                          , kt = T.cT(Pt)
                                          , Wt = T.cT(typeof At == "string" ? [At, ["accumulated"], ["get", xe]] : At);
                                        Ce[xe] = kt.value,
                                        Ze[xe] = Wt.value
                                    }
                                    return ve.map = xe => {
                                        Ye.properties = xe;
                                        const At = {};
                                        for (const Pt of Ot)
                                            At[Pt] = Ce[Pt].evaluate(ot, Ye);
                                        return At
                                    }
                                    ,
                                    ve.reduce = (xe, At) => {
                                        Ye.properties = At;
                                        for (const Pt of Ot)
                                            ot.accumulated = xe[Pt],
                                            xe[Pt] = Ze[Pt].evaluate(ot, Ye)
                                    }
                                    ,
                                    ve
                                }
                                )(F)).load(K.features) : (function(ve, Le) {
                                    return new Mr(ve,Le)
                                }
                                )(K, F.geojsonVtOptions),
                                this.loaded = {};
                                const le = {
                                    data: K
                                };
                                if (G) {
                                    const ve = G.finish();
                                    ve && (le.resourceTiming = {},
                                    le.resourceTiming[F.source] = JSON.parse(JSON.stringify(ve)))
                                }
                                return le
                            } catch (K) {
                                if (delete this._pendingRequest,
                                T.cy(K))
                                    return {
                                        abandoned: !0
                                    };
                                throw K
                            }
                        }
                        ))
                    }
                    getData() {
                        return T._(this, void 0, void 0, (function*() {
                            return this._pendingData
                        }
                        ))
                    }
                    reloadTile(F) {
                        const q = this.loaded;
                        return q && q[F.uid] ? super.reloadTile(F) : this.loadTile(F)
                    }
                    loadAndProcessGeoJSON(F, q) {
                        return T._(this, void 0, void 0, (function*() {
                            let G = yield this.loadGeoJSON(F, q);
                            if (delete this._pendingRequest,
                            typeof G != "object")
                                throw new Error(`Input data given to '${F.source}' is not a valid GeoJSON object.`);
                            if (Re(G, !0),
                            F.filter) {
                                const K = T.cT(F.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if (K.result === "error")
                                    throw new Error(K.value.map((ve => `${ve.key}: ${ve.message}`)).join(", "));
                                G = {
                                    type: "FeatureCollection",
                                    features: G.features.filter((ve => K.value.evaluate({
                                        zoom: 0
                                    }, ve)))
                                }
                            }
                            return G
                        }
                        ))
                    }
                    loadGeoJSON(F, q) {
                        return T._(this, void 0, void 0, (function*() {
                            const {promoteId: G} = F;
                            if (F.request) {
                                const K = yield T.j(F.request, q);
                                return this._dataUpdateable = T.cV(K.data, G) ? T.cU(K.data, G) : void 0,
                                K.data
                            }
                            if (typeof F.data == "string")
                                try {
                                    const K = JSON.parse(F.data);
                                    return this._dataUpdateable = T.cV(K, G) ? T.cU(K, G) : void 0,
                                    K
                                } catch {
                                    throw new Error(`Input data given to '${F.source}' is not a valid GeoJSON object.`)
                                }
                            if (!F.dataDiff)
                                throw new Error(`Input data given to '${F.source}' is not a valid GeoJSON object.`);
                            if (!this._dataUpdateable)
                                throw new Error(`Cannot update existing geojson data in ${F.source}`);
                            return T.cW(this._dataUpdateable, F.dataDiff, G),
                            {
                                type: "FeatureCollection",
                                features: Array.from(this._dataUpdateable.values())
                            }
                        }
                        ))
                    }
                    removeSource(F) {
                        return T._(this, void 0, void 0, (function*() {
                            this._pendingRequest && this._pendingRequest.abort()
                        }
                        ))
                    }
                    getClusterExpansionZoom(F) {
                        return this._geoJSONIndex.getClusterExpansionZoom(F.clusterId)
                    }
                    getClusterChildren(F) {
                        return this._geoJSONIndex.getChildren(F.clusterId)
                    }
                    getClusterLeaves(F) {
                        return this._geoJSONIndex.getLeaves(F.clusterId, F.limit, F.offset)
                    }
                }
                class Nr {
                    constructor(F) {
                        this.self = F,
                        this.actor = new T.J(F),
                        this.layerIndexes = {},
                        this.availableImages = {},
                        this.workerSources = {},
                        this.demWorkerSources = {},
                        this.externalWorkerSourceTypes = {},
                        this.self.registerWorkerSource = (q, G) => {
                            if (this.externalWorkerSourceTypes[q])
                                throw new Error(`Worker source with name "${q}" already registered.`);
                            this.externalWorkerSourceTypes[q] = G
                        }
                        ,
                        this.self.addProtocol = T.cA,
                        this.self.removeProtocol = T.cB,
                        this.self.registerRTLTextPlugin = q => {
                            T.cX.setMethods(q)
                        }
                        ,
                        this.actor.registerMessageHandler("LDT", ( (q, G) => this._getDEMWorkerSource(q, G.source).loadTile(G))),
                        this.actor.registerMessageHandler("RDT", ( (q, G) => T._(this, void 0, void 0, (function*() {
                            this._getDEMWorkerSource(q, G.source).removeTile(G)
                        }
                        )))),
                        this.actor.registerMessageHandler("GCEZ", ( (q, G) => T._(this, void 0, void 0, (function*() {
                            return this._getWorkerSource(q, G.type, G.source).getClusterExpansionZoom(G)
                        }
                        )))),
                        this.actor.registerMessageHandler("GCC", ( (q, G) => T._(this, void 0, void 0, (function*() {
                            return this._getWorkerSource(q, G.type, G.source).getClusterChildren(G)
                        }
                        )))),
                        this.actor.registerMessageHandler("GCL", ( (q, G) => T._(this, void 0, void 0, (function*() {
                            return this._getWorkerSource(q, G.type, G.source).getClusterLeaves(G)
                        }
                        )))),
                        this.actor.registerMessageHandler("LD", ( (q, G) => this._getWorkerSource(q, G.type, G.source).loadData(G))),
                        this.actor.registerMessageHandler("GD", ( (q, G) => this._getWorkerSource(q, G.type, G.source).getData())),
                        this.actor.registerMessageHandler("LT", ( (q, G) => this._getWorkerSource(q, G.type, G.source).loadTile(G))),
                        this.actor.registerMessageHandler("RT", ( (q, G) => this._getWorkerSource(q, G.type, G.source).reloadTile(G))),
                        this.actor.registerMessageHandler("AT", ( (q, G) => this._getWorkerSource(q, G.type, G.source).abortTile(G))),
                        this.actor.registerMessageHandler("RMT", ( (q, G) => this._getWorkerSource(q, G.type, G.source).removeTile(G))),
                        this.actor.registerMessageHandler("RS", ( (q, G) => T._(this, void 0, void 0, (function*() {
                            if (!this.workerSources[q] || !this.workerSources[q][G.type] || !this.workerSources[q][G.type][G.source])
                                return;
                            const K = this.workerSources[q][G.type][G.source];
                            delete this.workerSources[q][G.type][G.source],
                            K.removeSource !== void 0 && K.removeSource(G)
                        }
                        )))),
                        this.actor.registerMessageHandler("RM", (q => T._(this, void 0, void 0, (function*() {
                            delete this.layerIndexes[q],
                            delete this.availableImages[q],
                            delete this.workerSources[q],
                            delete this.demWorkerSources[q]
                        }
                        )))),
                        this.actor.registerMessageHandler("SR", ( (q, G) => T._(this, void 0, void 0, (function*() {
                            this.referrer = G
                        }
                        )))),
                        this.actor.registerMessageHandler("SRPS", ( (q, G) => this._syncRTLPluginState(q, G))),
                        this.actor.registerMessageHandler("IS", ( (q, G) => T._(this, void 0, void 0, (function*() {
                            this.self.importScripts(G)
                        }
                        )))),
                        this.actor.registerMessageHandler("SI", ( (q, G) => this._setImages(q, G))),
                        this.actor.registerMessageHandler("UL", ( (q, G) => T._(this, void 0, void 0, (function*() {
                            this._getLayerIndex(q).update(G.layers, G.removedIds)
                        }
                        )))),
                        this.actor.registerMessageHandler("SL", ( (q, G) => T._(this, void 0, void 0, (function*() {
                            this._getLayerIndex(q).replace(G)
                        }
                        ))))
                    }
                    _setImages(F, q) {
                        return T._(this, void 0, void 0, (function*() {
                            this.availableImages[F] = q;
                            for (const G in this.workerSources[F]) {
                                const K = this.workerSources[F][G];
                                for (const le in K)
                                    K[le].availableImages = q
                            }
                        }
                        ))
                    }
                    _syncRTLPluginState(F, q) {
                        return T._(this, void 0, void 0, (function*() {
                            return yield T.cX.syncState(q, this.self.importScripts)
                        }
                        ))
                    }
                    _getAvailableImages(F) {
                        let q = this.availableImages[F];
                        return q || (q = []),
                        q
                    }
                    _getLayerIndex(F) {
                        let q = this.layerIndexes[F];
                        return q || (q = this.layerIndexes[F] = new o),
                        q
                    }
                    _getWorkerSource(F, q, G) {
                        if (this.workerSources[F] || (this.workerSources[F] = {}),
                        this.workerSources[F][q] || (this.workerSources[F][q] = {}),
                        !this.workerSources[F][q][G]) {
                            const K = {
                                sendAsync: (le, ve) => (le.targetMapId = F,
                                this.actor.sendAsync(le, ve))
                            };
                            switch (q) {
                            case "vector":
                                this.workerSources[F][q][G] = new pe(K,this._getLayerIndex(F),this._getAvailableImages(F));
                                break;
                            case "geojson":
                                this.workerSources[F][q][G] = new kr(K,this._getLayerIndex(F),this._getAvailableImages(F));
                                break;
                            default:
                                this.workerSources[F][q][G] = new this.externalWorkerSourceTypes[q](K,this._getLayerIndex(F),this._getAvailableImages(F))
                            }
                        }
                        return this.workerSources[F][q][G]
                    }
                    _getDEMWorkerSource(F, q) {
                        return this.demWorkerSources[F] || (this.demWorkerSources[F] = {}),
                        this.demWorkerSources[F][q] || (this.demWorkerSources[F][q] = new ye),
                        this.demWorkerSources[F][q]
                    }
                }
                return T.i(self) && (self.worker = new Nr(self)),
                Nr
            }
            )),
            L("index", ["exports", "./shared"], (function(T, o) {
                var $ = "5.6.2";
                function W() {
                    var h = new o.A(4);
                    return o.A != Float32Array && (h[1] = 0,
                    h[2] = 0),
                    h[0] = 1,
                    h[3] = 1,
                    h
                }
                let ie, pe;
                const ye = {
                    now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
                    frame(h, e, n) {
                        const s = requestAnimationFrame((d => {
                            u(),
                            e(d)
                        }
                        ))
                          , {unsubscribe: u} = o.s(h.signal, "abort", ( () => {
                            u(),
                            cancelAnimationFrame(s),
                            n(o.c())
                        }
                        ), !1)
                    },
                    frameAsync(h) {
                        return new Promise(( (e, n) => {
                            this.frame(h, e, n)
                        }
                        ))
                    },
                    getImageData(h, e=0) {
                        return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e)
                    },
                    getImageCanvasContext(h) {
                        const e = window.document.createElement("canvas")
                          , n = e.getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (!n)
                            throw new Error("failed to create canvas 2d context");
                        return e.width = h.width,
                        e.height = h.height,
                        n.drawImage(h, 0, 0, h.width, h.height),
                        n
                    },
                    resolveURL: h => (ie || (ie = document.createElement("a")),
                    ie.href = h,
                    ie.href),
                    hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
                    get prefersReducedMotion() {
                        return !!matchMedia && (pe == null && (pe = matchMedia("(prefers-reduced-motion: reduce)")),
                        pe.matches)
                    }
                };
                class X {
                    static testProp(e) {
                        if (!X.docStyle)
                            return e[0];
                        for (let n = 0; n < e.length; n++)
                            if (e[n]in X.docStyle)
                                return e[n];
                        return e[0]
                    }
                    static create(e, n, s) {
                        const u = window.document.createElement(e);
                        return n !== void 0 && (u.className = n),
                        s && s.appendChild(u),
                        u
                    }
                    static createNS(e, n) {
                        return window.document.createElementNS(e, n)
                    }
                    static disableDrag() {
                        X.docStyle && X.selectProp && (X.userSelect = X.docStyle[X.selectProp],
                        X.docStyle[X.selectProp] = "none")
                    }
                    static enableDrag() {
                        X.docStyle && X.selectProp && (X.docStyle[X.selectProp] = X.userSelect)
                    }
                    static setTransform(e, n) {
                        e.style[X.transformProp] = n
                    }
                    static addEventListener(e, n, s, u={}) {
                        e.addEventListener(n, s, "passive"in u ? u : u.capture)
                    }
                    static removeEventListener(e, n, s, u={}) {
                        e.removeEventListener(n, s, "passive"in u ? u : u.capture)
                    }
                    static suppressClickInternal(e) {
                        e.preventDefault(),
                        e.stopPropagation(),
                        window.removeEventListener("click", X.suppressClickInternal, !0)
                    }
                    static suppressClick() {
                        window.addEventListener("click", X.suppressClickInternal, !0),
                        window.setTimeout(( () => {
                            window.removeEventListener("click", X.suppressClickInternal, !0)
                        }
                        ), 0)
                    }
                    static getScale(e) {
                        const n = e.getBoundingClientRect();
                        return {
                            x: n.width / e.offsetWidth || 1,
                            y: n.height / e.offsetHeight || 1,
                            boundingClientRect: n
                        }
                    }
                    static getPoint(e, n, s) {
                        const u = n.boundingClientRect;
                        return new o.P((s.clientX - u.left) / n.x - e.clientLeft,(s.clientY - u.top) / n.y - e.clientTop)
                    }
                    static mousePos(e, n) {
                        const s = X.getScale(e);
                        return X.getPoint(e, s, n)
                    }
                    static touchPos(e, n) {
                        const s = []
                          , u = X.getScale(e);
                        for (let d = 0; d < n.length; d++)
                            s.push(X.getPoint(e, u, n[d]));
                        return s
                    }
                    static mouseButton(e) {
                        return e.button
                    }
                    static remove(e) {
                        e.parentNode && e.parentNode.removeChild(e)
                    }
                    static sanitize(e) {
                        const n = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body")
                          , s = n.querySelectorAll("script");
                        for (const u of s)
                            u.remove();
                        return X.clean(n),
                        n.innerHTML
                    }
                    static isPossiblyDangerous(e, n) {
                        const s = n.replace(/\s+/g, "").toLowerCase();
                        return !(!["src", "href", "xlink:href"].includes(e) || !s.includes("javascript:") && !s.includes("data:")) || !!e.startsWith("on") || void 0
                    }
                    static clean(e) {
                        const n = e.children;
                        for (const s of n)
                            X.removeAttributes(s),
                            X.clean(s)
                    }
                    static removeAttributes(e) {
                        for (const {name: n, value: s} of e.attributes)
                            X.isPossiblyDangerous(n, s) && e.removeAttribute(n)
                    }
                }
                X.docStyle = typeof window < "u" && window.document && window.document.documentElement.style,
                X.selectProp = X.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]),
                X.transformProp = X.testProp(["transform", "WebkitTransform"]);
                const Se = {
                    supported: !1,
                    testSupport: function(h) {
                        !ke && Re && (Oe ? Ee(h) : we = h)
                    }
                };
                let we, Re, ke = !1, Oe = !1;
                function Ee(h) {
                    const e = h.createTexture();
                    h.bindTexture(h.TEXTURE_2D, e);
                    try {
                        if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, Re),
                        h.isContextLost())
                            return;
                        Se.supported = !0
                    } catch {}
                    h.deleteTexture(e),
                    ke = !0
                }
                var Ne;
                typeof document < "u" && (Re = document.createElement("img"),
                Re.onload = () => {
                    we && Ee(we),
                    we = null,
                    Oe = !0
                }
                ,
                Re.onerror = () => {
                    ke = !0,
                    we = null
                }
                ,
                Re.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="),
                (function(h) {
                    let e, n, s, u;
                    h.resetRequestQueue = () => {
                        e = [],
                        n = 0,
                        s = 0,
                        u = {}
                    }
                    ,
                    h.addThrottleControl = w => {
                        const P = s++;
                        return u[P] = w,
                        P
                    }
                    ,
                    h.removeThrottleControl = w => {
                        delete u[w],
                        m()
                    }
                    ,
                    h.getImage = (w, P, M=!0) => new Promise(( (D, z) => {
                        Se.supported && (w.headers || (w.headers = {}),
                        w.headers.accept = "image/webp,*/*"),
                        o.e(w, {
                            type: "image"
                        }),
                        e.push({
                            abortController: P,
                            requestParameters: w,
                            supportImageRefresh: M,
                            state: "queued",
                            onError: B => {
                                z(B)
                            }
                            ,
                            onSuccess: B => {
                                D(B)
                            }
                        }),
                        m()
                    }
                    ));
                    const d = w => o._(this, void 0, void 0, (function*() {
                        w.state = "running";
                        const {requestParameters: P, supportImageRefresh: M, onError: D, onSuccess: z, abortController: B} = w
                          , U = M === !1 && !o.i(self) && !o.g(P.url) && (!P.headers || Object.keys(P.headers).reduce(( (re, se) => re && se === "accept"), !0));
                        n++;
                        const ee = U ? y(P, B) : o.m(P, B);
                        try {
                            const re = yield ee;
                            delete w.abortController,
                            w.state = "completed",
                            re.data instanceof HTMLImageElement || o.b(re.data) ? z(re) : re.data && z({
                                data: yield(J = re.data,
                                typeof createImageBitmap == "function" ? o.f(J) : o.h(J)),
                                cacheControl: re.cacheControl,
                                expires: re.expires
                            })
                        } catch (re) {
                            delete w.abortController,
                            D(re)
                        } finally {
                            n--,
                            m()
                        }
                        var J
                    }
                    ))
                      , m = () => {
                        const w = ( () => {
                            for (const P of Object.keys(u))
                                if (u[P]())
                                    return !0;
                            return !1
                        }
                        )() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
                        for (let P = n; P < w && e.length > 0; P++) {
                            const M = e.shift();
                            M.abortController.signal.aborted ? P-- : d(M)
                        }
                    }
                      , y = (w, P) => new Promise(( (M, D) => {
                        const z = new Image
                          , B = w.url
                          , U = w.credentials;
                        U && U === "include" ? z.crossOrigin = "use-credentials" : (U && U === "same-origin" || !o.d(B)) && (z.crossOrigin = "anonymous"),
                        P.signal.addEventListener("abort", ( () => {
                            z.src = "",
                            D(o.c())
                        }
                        )),
                        z.fetchPriority = "high",
                        z.onload = () => {
                            z.onerror = z.onload = null,
                            M({
                                data: z
                            })
                        }
                        ,
                        z.onerror = () => {
                            z.onerror = z.onload = null,
                            P.signal.aborted || D(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
                        }
                        ,
                        z.src = B
                    }
                    ))
                }
                )(Ne || (Ne = {})),
                Ne.resetRequestQueue();
                class ft {
                    constructor(e) {
                        this._transformRequestFn = e ?? null
                    }
                    transformRequest(e, n) {
                        return this._transformRequestFn && this._transformRequestFn(e, n) || {
                            url: e
                        }
                    }
                    setTransformRequest(e) {
                        this._transformRequestFn = e
                    }
                }
                function ht(h) {
                    const e = [];
                    if (typeof h == "string")
                        e.push({
                            id: "default",
                            url: h
                        });
                    else if (h && h.length > 0) {
                        const n = [];
                        for (const {id: s, url: u} of h) {
                            const d = `${s}${u}`;
                            n.indexOf(d) === -1 && (n.push(d),
                            e.push({
                                id: s,
                                url: u
                            }))
                        }
                    }
                    return e
                }
                function Xe(h, e, n) {
                    try {
                        const s = new URL(h);
                        return s.pathname += `${e}${n}`,
                        s.toString()
                    } catch {
                        throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
                    }
                }
                function ct(h) {
                    const {userImage: e} = h;
                    return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)),
                    !0)
                }
                class Je extends o.E {
                    constructor() {
                        super(),
                        this.images = {},
                        this.updatedImages = {},
                        this.callbackDispatchedThisFrame = {},
                        this.loaded = !1,
                        this.requestors = [],
                        this.patterns = {},
                        this.atlasImage = new o.R({
                            width: 1,
                            height: 1
                        }),
                        this.dirty = !0
                    }
                    isLoaded() {
                        return this.loaded
                    }
                    setLoaded(e) {
                        if (this.loaded !== e && (this.loaded = e,
                        e)) {
                            for (const {ids: n, promiseResolve: s} of this.requestors)
                                s(this._getImagesForIds(n));
                            this.requestors = []
                        }
                    }
                    getImage(e) {
                        const n = this.images[e];
                        if (n && !n.data && n.spriteData) {
                            const s = n.spriteData;
                            n.data = new o.R({
                                width: s.width,
                                height: s.height
                            },s.context.getImageData(s.x, s.y, s.width, s.height).data),
                            n.spriteData = null
                        }
                        return n
                    }
                    addImage(e, n) {
                        if (this.images[e])
                            throw new Error(`Image id ${e} already exist, use updateImage instead`);
                        this._validate(e, n) && (this.images[e] = n)
                    }
                    _validate(e, n) {
                        let s = !0;
                        const u = n.data || n.spriteData;
                        return this._validateStretch(n.stretchX, u && u.width) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchX" value`))),
                        s = !1),
                        this._validateStretch(n.stretchY, u && u.height) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchY" value`))),
                        s = !1),
                        this._validateContent(n.content, n) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "content" value`))),
                        s = !1),
                        s
                    }
                    _validateStretch(e, n) {
                        if (!e)
                            return !0;
                        let s = 0;
                        for (const u of e) {
                            if (u[0] < s || u[1] < u[0] || n < u[1])
                                return !1;
                            s = u[1]
                        }
                        return !0
                    }
                    _validateContent(e, n) {
                        if (!e)
                            return !0;
                        if (e.length !== 4)
                            return !1;
                        const s = n.spriteData
                          , u = s && s.width || n.data.width
                          , d = s && s.height || n.data.height;
                        return !(e[0] < 0 || u < e[0] || e[1] < 0 || d < e[1] || e[2] < 0 || u < e[2] || e[3] < 0 || d < e[3] || e[2] < e[0] || e[3] < e[1])
                    }
                    updateImage(e, n, s=!0) {
                        const u = this.getImage(e);
                        if (s && (u.data.width !== n.data.width || u.data.height !== n.data.height))
                            throw new Error(`size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${n.data.width}x${n.data.height}).`);
                        n.version = u.version + 1,
                        this.images[e] = n,
                        this.updatedImages[e] = !0
                    }
                    removeImage(e) {
                        const n = this.images[e];
                        delete this.images[e],
                        delete this.patterns[e],
                        n.userImage && n.userImage.onRemove && n.userImage.onRemove()
                    }
                    listImages() {
                        return Object.keys(this.images)
                    }
                    getImages(e) {
                        return new Promise(( (n, s) => {
                            let u = !0;
                            if (!this.isLoaded())
                                for (const d of e)
                                    this.images[d] || (u = !1);
                            this.isLoaded() || u ? n(this._getImagesForIds(e)) : this.requestors.push({
                                ids: e,
                                promiseResolve: n
                            })
                        }
                        ))
                    }
                    _getImagesForIds(e) {
                        const n = {};
                        for (const s of e) {
                            let u = this.getImage(s);
                            u || (this.fire(new o.l("styleimagemissing",{
                                id: s
                            })),
                            u = this.getImage(s)),
                            u ? n[s] = {
                                data: u.data.clone(),
                                pixelRatio: u.pixelRatio,
                                sdf: u.sdf,
                                version: u.version,
                                stretchX: u.stretchX,
                                stretchY: u.stretchY,
                                content: u.content,
                                textFitWidth: u.textFitWidth,
                                textFitHeight: u.textFitHeight,
                                hasRenderCallback: !!(u.userImage && u.userImage.render)
                            } : o.w(`Image "${s}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
                        }
                        return n
                    }
                    getPixelSize() {
                        const {width: e, height: n} = this.atlasImage;
                        return {
                            width: e,
                            height: n
                        }
                    }
                    getPattern(e) {
                        const n = this.patterns[e]
                          , s = this.getImage(e);
                        if (!s)
                            return null;
                        if (n && n.position.version === s.version)
                            return n.position;
                        if (n)
                            n.position.version = s.version;
                        else {
                            const u = {
                                w: s.data.width + 2,
                                h: s.data.height + 2,
                                x: 0,
                                y: 0
                            }
                              , d = new o.I(u,s);
                            this.patterns[e] = {
                                bin: u,
                                position: d
                            }
                        }
                        return this._updatePatternAtlas(),
                        this.patterns[e].position
                    }
                    bind(e) {
                        const n = e.gl;
                        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage),
                        this.dirty = !1) : this.atlasTexture = new o.T(e,this.atlasImage,n.RGBA),
                        this.atlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE)
                    }
                    _updatePatternAtlas() {
                        const e = [];
                        for (const d in this.patterns)
                            e.push(this.patterns[d].bin);
                        const {w: n, h: s} = o.p(e)
                          , u = this.atlasImage;
                        u.resize({
                            width: n || 1,
                            height: s || 1
                        });
                        for (const d in this.patterns) {
                            const {bin: m} = this.patterns[d]
                              , y = m.x + 1
                              , w = m.y + 1
                              , P = this.getImage(d).data
                              , M = P.width
                              , D = P.height;
                            o.R.copy(P, u, {
                                x: 0,
                                y: 0
                            }, {
                                x: y,
                                y: w
                            }, {
                                width: M,
                                height: D
                            }),
                            o.R.copy(P, u, {
                                x: 0,
                                y: D - 1
                            }, {
                                x: y,
                                y: w - 1
                            }, {
                                width: M,
                                height: 1
                            }),
                            o.R.copy(P, u, {
                                x: 0,
                                y: 0
                            }, {
                                x: y,
                                y: w + D
                            }, {
                                width: M,
                                height: 1
                            }),
                            o.R.copy(P, u, {
                                x: M - 1,
                                y: 0
                            }, {
                                x: y - 1,
                                y: w
                            }, {
                                width: 1,
                                height: D
                            }),
                            o.R.copy(P, u, {
                                x: 0,
                                y: 0
                            }, {
                                x: y + M,
                                y: w
                            }, {
                                width: 1,
                                height: D
                            })
                        }
                        this.dirty = !0
                    }
                    beginFrame() {
                        this.callbackDispatchedThisFrame = {}
                    }
                    dispatchRenderCallbacks(e) {
                        for (const n of e) {
                            if (this.callbackDispatchedThisFrame[n])
                                continue;
                            this.callbackDispatchedThisFrame[n] = !0;
                            const s = this.getImage(n);
                            s || o.w(`Image with ID: "${n}" was not found`),
                            ct(s) && this.updateImage(n, s)
                        }
                    }
                }
                const Be = 1e20;
                function st(h, e, n, s, u, d, m, y, w) {
                    for (let P = e; P < e + s; P++)
                        it(h, n * d + P, d, u, m, y, w);
                    for (let P = n; P < n + u; P++)
                        it(h, P * d + e, 1, s, m, y, w)
                }
                function it(h, e, n, s, u, d, m) {
                    d[0] = 0,
                    m[0] = -Be,
                    m[1] = Be,
                    u[0] = h[e];
                    for (let y = 1, w = 0, P = 0; y < s; y++) {
                        u[y] = h[e + y * n];
                        const M = y * y;
                        do {
                            const D = d[w];
                            P = (u[y] - u[D] + M - D * D) / (y - D) / 2
                        } while (P <= m[w] && --w > -1);
                        w++,
                        d[w] = y,
                        m[w] = P,
                        m[w + 1] = Be
                    }
                    for (let y = 0, w = 0; y < s; y++) {
                        for (; m[w + 1] < y; )
                            w++;
                        const P = d[w]
                          , M = y - P;
                        h[e + y * n] = u[P] + M * M
                    }
                }
                class Qe {
                    constructor(e, n) {
                        this.requestManager = e,
                        this.localIdeographFontFamily = n,
                        this.entries = {}
                    }
                    setURL(e) {
                        this.url = e
                    }
                    getGlyphs(e) {
                        return o._(this, void 0, void 0, (function*() {
                            const n = [];
                            for (const d in e)
                                for (const m of e[d])
                                    n.push(this._getAndCacheGlyphsPromise(d, m));
                            const s = yield Promise.all(n)
                              , u = {};
                            for (const {stack: d, id: m, glyph: y} of s)
                                u[d] || (u[d] = {}),
                                u[d][m] = y && {
                                    id: y.id,
                                    bitmap: y.bitmap.clone(),
                                    metrics: y.metrics
                                };
                            return u
                        }
                        ))
                    }
                    _getAndCacheGlyphsPromise(e, n) {
                        return o._(this, void 0, void 0, (function*() {
                            let s = this.entries[e];
                            s || (s = this.entries[e] = {
                                glyphs: {},
                                requests: {},
                                ranges: {}
                            });
                            let u = s.glyphs[n];
                            if (u !== void 0)
                                return {
                                    stack: e,
                                    id: n,
                                    glyph: u
                                };
                            if (u = this._tinySDF(s, e, n),
                            u)
                                return s.glyphs[n] = u,
                                {
                                    stack: e,
                                    id: n,
                                    glyph: u
                                };
                            const d = Math.floor(n / 256);
                            if (256 * d > 65535)
                                throw new Error("glyphs > 65535 not supported");
                            if (s.ranges[d])
                                return {
                                    stack: e,
                                    id: n,
                                    glyph: u
                                };
                            if (!this.url)
                                throw new Error("glyphsUrl is not set");
                            if (!s.requests[d]) {
                                const y = Qe.loadGlyphRange(e, d, this.url, this.requestManager);
                                s.requests[d] = y
                            }
                            const m = yield s.requests[d];
                            for (const y in m)
                                this._doesCharSupportLocalGlyph(+y) || (s.glyphs[+y] = m[+y]);
                            return s.ranges[d] = !0,
                            {
                                stack: e,
                                id: n,
                                glyph: m[n] || null
                            }
                        }
                        ))
                    }
                    _doesCharSupportLocalGlyph(e) {
                        return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}","u").test(String.fromCodePoint(e)) || o.u["CJK Unified Ideographs"](e) || o.u["Hangul Syllables"](e) || o.u.Hiragana(e) || o.u.Katakana(e) || o.u["CJK Symbols and Punctuation"](e) || o.u["Halfwidth and Fullwidth Forms"](e))
                    }
                    _tinySDF(e, n, s) {
                        const u = this.localIdeographFontFamily;
                        if (!u || !this._doesCharSupportLocalGlyph(s))
                            return;
                        let d = e.tinySDF;
                        if (!d) {
                            let y = "400";
                            /bold/i.test(n) ? y = "900" : /medium/i.test(n) ? y = "500" : /light/i.test(n) && (y = "200"),
                            d = e.tinySDF = new Qe.TinySDF({
                                fontSize: 48,
                                buffer: 6,
                                radius: 16,
                                cutoff: .25,
                                fontFamily: u,
                                fontWeight: y
                            })
                        }
                        const m = d.draw(String.fromCharCode(s));
                        return {
                            id: s,
                            bitmap: new o.q({
                                width: m.width || 60,
                                height: m.height || 60
                            },m.data),
                            metrics: {
                                width: m.glyphWidth / 2 || 24,
                                height: m.glyphHeight / 2 || 24,
                                left: m.glyphLeft / 2 + .5 || 0,
                                top: m.glyphTop / 2 - 27.5 || -8,
                                advance: m.glyphAdvance / 2 || 24,
                                isDoubleResolution: !0
                            }
                        }
                    }
                }
                Qe.loadGlyphRange = function(h, e, n, s) {
                    return o._(this, void 0, void 0, (function*() {
                        const u = 256 * e
                          , d = u + 255
                          , m = s.transformRequest(n.replace("{fontstack}", h).replace("{range}", `${u}-${d}`), "Glyphs")
                          , y = yield o.n(m, new AbortController);
                        if (!y || !y.data)
                            throw new Error(`Could not load glyph range. range: ${e}, ${u}-${d}`);
                        const w = {};
                        for (const P of o.o(y.data))
                            w[P.id] = P;
                        return w
                    }
                    ))
                }
                ,
                Qe.TinySDF = class {
                    constructor({fontSize: h=24, buffer: e=3, radius: n=8, cutoff: s=.25, fontFamily: u="sans-serif", fontWeight: d="normal", fontStyle: m="normal", lang: y=null}={}) {
                        this.buffer = e,
                        this.cutoff = s,
                        this.radius = n,
                        this.lang = y;
                        const w = this.size = h + 4 * e
                          , P = this._createCanvas(w)
                          , M = this.ctx = P.getContext("2d", {
                            willReadFrequently: !0
                        });
                        M.font = `${m} ${d} ${h}px ${u}`,
                        M.textBaseline = "alphabetic",
                        M.textAlign = "left",
                        M.fillStyle = "black",
                        this.gridOuter = new Float64Array(w * w),
                        this.gridInner = new Float64Array(w * w),
                        this.f = new Float64Array(w),
                        this.z = new Float64Array(w + 1),
                        this.v = new Uint16Array(w)
                    }
                    _createCanvas(h) {
                        const e = document.createElement("canvas");
                        return e.width = e.height = h,
                        e
                    }
                    draw(h) {
                        const {width: e, actualBoundingBoxAscent: n, actualBoundingBoxDescent: s, actualBoundingBoxLeft: u, actualBoundingBoxRight: d} = this.ctx.measureText(h)
                          , m = Math.ceil(n)
                          , y = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(d - u)))
                          , w = Math.min(this.size - this.buffer, m + Math.ceil(s))
                          , P = y + 2 * this.buffer
                          , M = w + 2 * this.buffer
                          , D = Math.max(P * M, 0)
                          , z = new Uint8ClampedArray(D)
                          , B = {
                            data: z,
                            width: P,
                            height: M,
                            glyphWidth: y,
                            glyphHeight: w,
                            glyphTop: m,
                            glyphLeft: 0,
                            glyphAdvance: e
                        };
                        if (y === 0 || w === 0)
                            return B;
                        const {ctx: U, buffer: ee, gridInner: J, gridOuter: re} = this;
                        this.lang && (U.lang = this.lang),
                        U.clearRect(ee, ee, y, w),
                        U.fillText(h, ee, ee + m);
                        const se = U.getImageData(ee, ee, y, w);
                        re.fill(Be, 0, D),
                        J.fill(0, 0, D);
                        for (let de = 0; de < w; de++)
                            for (let ue = 0; ue < y; ue++) {
                                const ge = se.data[4 * (de * y + ue) + 3] / 255;
                                if (ge === 0)
                                    continue;
                                const Te = (de + ee) * P + ue + ee;
                                if (ge === 1)
                                    re[Te] = 0,
                                    J[Te] = Be;
                                else {
                                    const he = .5 - ge;
                                    re[Te] = he > 0 ? he * he : 0,
                                    J[Te] = he < 0 ? he * he : 0
                                }
                            }
                        st(re, 0, 0, P, M, P, this.f, this.v, this.z),
                        st(J, ee, ee, y, w, P, this.f, this.v, this.z);
                        for (let de = 0; de < D; de++) {
                            const ue = Math.sqrt(re[de]) - Math.sqrt(J[de]);
                            z[de] = Math.round(255 - 255 * (ue / this.radius + this.cutoff))
                        }
                        return B
                    }
                }
                ;
                class Ae {
                    constructor() {
                        this.specification = o.v.light.position
                    }
                    possiblyEvaluate(e, n) {
                        return o.B(e.expression.evaluate(n))
                    }
                    interpolate(e, n, s) {
                        return {
                            x: o.C.number(e.x, n.x, s),
                            y: o.C.number(e.y, n.y, s),
                            z: o.C.number(e.z, n.z, s)
                        }
                    }
                }
                let vt;
                class Q extends o.E {
                    constructor(e) {
                        super(),
                        vt = vt || new o.r({
                            anchor: new o.D(o.v.light.anchor),
                            position: new Ae,
                            color: new o.D(o.v.light.color),
                            intensity: new o.D(o.v.light.intensity)
                        }),
                        this._transitionable = new o.t(vt),
                        this.setLight(e),
                        this._transitioning = this._transitionable.untransitioned()
                    }
                    getLight() {
                        return this._transitionable.serialize()
                    }
                    setLight(e, n={}) {
                        if (!this._validate(o.x, e, n))
                            for (const s in e) {
                                const u = e[s];
                                s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), u) : this._transitionable.setValue(s, u)
                            }
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e)
                    }
                    _validate(e, n, s) {
                        return (!s || s.validate !== !1) && o.y(this, e.call(o.z, {
                            value: n,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: o.v
                        }))
                    }
                }
                const te = new o.r({
                    "sky-color": new o.D(o.v.sky["sky-color"]),
                    "horizon-color": new o.D(o.v.sky["horizon-color"]),
                    "fog-color": new o.D(o.v.sky["fog-color"]),
                    "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]),
                    "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]),
                    "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]),
                    "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"])
                });
                class _e extends o.E {
                    constructor(e) {
                        super(),
                        this._transitionable = new o.t(te),
                        this.setSky(e),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.recalculate(new o.F(0))
                    }
                    setSky(e, n={}) {
                        if (!this._validate(o.G, e, n)) {
                            e || (e = {
                                "sky-color": "transparent",
                                "horizon-color": "transparent",
                                "fog-color": "transparent",
                                "fog-ground-blend": 1,
                                "atmosphere-blend": 0
                            });
                            for (const s in e) {
                                const u = e[s];
                                s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), u) : this._transitionable.setValue(s, u)
                            }
                        }
                    }
                    getSky() {
                        return this._transitionable.serialize()
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e)
                    }
                    _validate(e, n, s={}) {
                        return (s == null ? void 0 : s.validate) !== !1 && o.y(this, e.call(o.z, o.e({
                            value: n,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: o.v
                        })))
                    }
                    calculateFogBlendOpacity(e) {
                        return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
                    }
                }
                class ne {
                    constructor(e, n) {
                        this.width = e,
                        this.height = n,
                        this.nextRow = 0,
                        this.data = new Uint8Array(this.width * this.height),
                        this.dashEntry = {}
                    }
                    getDash(e, n) {
                        const s = e.join(",") + String(n);
                        return this.dashEntry[s] || (this.dashEntry[s] = this.addDash(e, n)),
                        this.dashEntry[s]
                    }
                    getDashRanges(e, n, s) {
                        const u = [];
                        let d = e.length % 2 == 1 ? -e[e.length - 1] * s : 0
                          , m = e[0] * s
                          , y = !0;
                        u.push({
                            left: d,
                            right: m,
                            isDash: y,
                            zeroLength: e[0] === 0
                        });
                        let w = e[0];
                        for (let P = 1; P < e.length; P++) {
                            y = !y;
                            const M = e[P];
                            d = w * s,
                            w += M,
                            m = w * s,
                            u.push({
                                left: d,
                                right: m,
                                isDash: y,
                                zeroLength: M === 0
                            })
                        }
                        return u
                    }
                    addRoundDash(e, n, s) {
                        const u = n / 2;
                        for (let d = -s; d <= s; d++) {
                            const m = this.width * (this.nextRow + s + d);
                            let y = 0
                              , w = e[y];
                            for (let P = 0; P < this.width; P++) {
                                P / w.right > 1 && (w = e[++y]);
                                const M = Math.abs(P - w.left)
                                  , D = Math.abs(P - w.right)
                                  , z = Math.min(M, D);
                                let B;
                                const U = d / s * (u + 1);
                                if (w.isDash) {
                                    const ee = u - Math.abs(U);
                                    B = Math.sqrt(z * z + ee * ee)
                                } else
                                    B = u - Math.sqrt(z * z + U * U);
                                this.data[m + P] = Math.max(0, Math.min(255, B + 128))
                            }
                        }
                    }
                    addRegularDash(e) {
                        for (let y = e.length - 1; y >= 0; --y) {
                            const w = e[y]
                              , P = e[y + 1];
                            w.zeroLength ? e.splice(y, 1) : P && P.isDash === w.isDash && (P.left = w.left,
                            e.splice(y, 1))
                        }
                        const n = e[0]
                          , s = e[e.length - 1];
                        n.isDash === s.isDash && (n.left = s.left - this.width,
                        s.right = n.right + this.width);
                        const u = this.width * this.nextRow;
                        let d = 0
                          , m = e[d];
                        for (let y = 0; y < this.width; y++) {
                            y / m.right > 1 && (m = e[++d]);
                            const w = Math.abs(y - m.left)
                              , P = Math.abs(y - m.right)
                              , M = Math.min(w, P);
                            this.data[u + y] = Math.max(0, Math.min(255, (m.isDash ? M : -M) + 128))
                        }
                    }
                    addDash(e, n) {
                        const s = n ? 7 : 0
                          , u = 2 * s + 1;
                        if (this.nextRow + u > this.height)
                            return o.w("LineAtlas out of space"),
                            null;
                        let d = 0;
                        for (let y = 0; y < e.length; y++)
                            d += e[y];
                        if (d !== 0) {
                            const y = this.width / d
                              , w = this.getDashRanges(e, this.width, y);
                            n ? this.addRoundDash(w, y, s) : this.addRegularDash(w)
                        }
                        const m = {
                            y: (this.nextRow + s + .5) / this.height,
                            height: 2 * s / this.height,
                            width: d
                        };
                        return this.nextRow += u,
                        this.dirty = !0,
                        m
                    }
                    bind(e) {
                        const n = e.gl;
                        this.texture ? (n.bindTexture(n.TEXTURE_2D, this.texture),
                        this.dirty && (this.dirty = !1,
                        n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, this.width, this.height, n.ALPHA, n.UNSIGNED_BYTE, this.data))) : (this.texture = n.createTexture(),
                        n.bindTexture(n.TEXTURE_2D, this.texture),
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.REPEAT),
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.REPEAT),
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR),
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR),
                        n.texImage2D(n.TEXTURE_2D, 0, n.ALPHA, this.width, this.height, 0, n.ALPHA, n.UNSIGNED_BYTE, this.data))
                    }
                }
                const Pe = "maplibre_preloaded_worker_pool";
                class Me {
                    constructor() {
                        this.active = {}
                    }
                    acquire(e) {
                        if (!this.workers)
                            for (this.workers = []; this.workers.length < Me.workerCount; )
                                this.workers.push(new Worker(o.a.WORKER_URL));
                        return this.active[e] = !0,
                        this.workers.slice()
                    }
                    release(e) {
                        delete this.active[e],
                        this.numActive() === 0 && (this.workers.forEach((n => {
                            n.terminate()
                        }
                        )),
                        this.workers = null)
                    }
                    isPreloaded() {
                        return !!this.active[Pe]
                    }
                    numActive() {
                        return Object.keys(this.active).length
                    }
                }
                const at = Math.floor(ye.hardwareConcurrency / 2);
                let We, Ct;
                function _t() {
                    return We || (We = new Me),
                    We
                }
                Me.workerCount = o.H(globalThis) ? Math.max(Math.min(at, 3), 1) : 1;
                class xt {
                    constructor(e, n) {
                        this.workerPool = e,
                        this.actors = [],
                        this.currentActor = 0,
                        this.id = n;
                        const s = this.workerPool.acquire(n);
                        for (let u = 0; u < s.length; u++) {
                            const d = new o.J(s[u],n);
                            d.name = `Worker ${u}`,
                            this.actors.push(d)
                        }
                        if (!this.actors.length)
                            throw new Error("No actors found")
                    }
                    broadcast(e, n) {
                        const s = [];
                        for (const u of this.actors)
                            s.push(u.sendAsync({
                                type: e,
                                data: n
                            }));
                        return Promise.all(s)
                    }
                    getActor() {
                        return this.currentActor = (this.currentActor + 1) % this.actors.length,
                        this.actors[this.currentActor]
                    }
                    remove(e=!0) {
                        this.actors.forEach((n => {
                            n.remove()
                        }
                        )),
                        this.actors = [],
                        e && this.workerPool.release(this.id)
                    }
                    registerMessageHandler(e, n) {
                        for (const s of this.actors)
                            s.registerMessageHandler(e, n)
                    }
                }
                function tt() {
                    return Ct || (Ct = new xt(_t(),o.K),
                    Ct.registerMessageHandler("GR", ( (h, e, n) => o.m(e, n)))),
                    Ct
                }
                function pt(h, e) {
                    const n = o.L();
                    return o.M(n, n, [1, 1, 0]),
                    o.N(n, n, [.5 * h.width, .5 * h.height, 1]),
                    h.calculatePosMatrix ? o.O(n, n, h.calculatePosMatrix(e.toUnwrapped())) : n
                }
                function It(h, e, n, s, u, d, m) {
                    var y;
                    const w = (function(z, B, U) {
                        if (z)
                            for (const ee of z) {
                                const J = B[ee];
                                if (J && J.source === U && J.type === "fill-extrusion")
                                    return !0
                            }
                        else
                            for (const ee in B) {
                                const J = B[ee];
                                if (J.source === U && J.type === "fill-extrusion")
                                    return !0
                            }
                        return !1
                    }
                    )((y = u == null ? void 0 : u.layers) !== null && y !== void 0 ? y : null, e, h.id)
                      , P = d.maxPitchScaleFactor()
                      , M = h.tilesIn(s, P, w);
                    M.sort(ut);
                    const D = [];
                    for (const z of M)
                        D.push({
                            wrappedTileID: z.tileID.wrapped().key,
                            queryResults: z.tile.queryRenderedFeatures(e, n, h._state, z.queryGeometry, z.cameraQueryGeometry, z.scale, u, d, P, pt(h.transform, z.tileID), m ? (B, U) => m(z.tileID, B, U) : void 0)
                        });
                    return (function(z, B) {
                        for (const U in z)
                            for (const ee of z[U])
                                bt(ee, B);
                        return z
                    }
                    )((function(z) {
                        const B = {}
                          , U = {};
                        for (const ee of z) {
                            const J = ee.queryResults
                              , re = ee.wrappedTileID
                              , se = U[re] = U[re] || {};
                            for (const de in J) {
                                const ue = J[de]
                                  , ge = se[de] = se[de] || {}
                                  , Te = B[de] = B[de] || [];
                                for (const he of ue)
                                    ge[he.featureIndex] || (ge[he.featureIndex] = !0,
                                    Te.push(he))
                            }
                        }
                        return B
                    }
                    )(D), h)
                }
                function ut(h, e) {
                    const n = h.tileID
                      , s = e.tileID;
                    return n.overscaledZ - s.overscaledZ || n.canonical.y - s.canonical.y || n.wrap - s.wrap || n.canonical.x - s.canonical.x
                }
                function bt(h, e) {
                    const n = h.feature
                      , s = e.getFeatureState(n.layer["source-layer"], n.id);
                    n.source = n.layer.source,
                    n.layer["source-layer"] && (n.sourceLayer = n.layer["source-layer"]),
                    n.state = s
                }
                function wt(h, e, n) {
                    return o._(this, void 0, void 0, (function*() {
                        let s = h;
                        if (h.url ? s = (yield o.j(e.transformRequest(h.url, "Source"), n)).data : yield ye.frameAsync(n),
                        !s)
                            return null;
                        const u = o.Q(o.e(s, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                        return "vector_layers"in s && s.vector_layers && (u.vectorLayerIds = s.vector_layers.map((d => d.id))),
                        u
                    }
                    ))
                }
                class dt {
                    constructor(e, n) {
                        e && (n ? this.setSouthWest(e).setNorthEast(n) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
                    }
                    setNorthEast(e) {
                        return this._ne = e instanceof o.S ? new o.S(e.lng,e.lat) : o.S.convert(e),
                        this
                    }
                    setSouthWest(e) {
                        return this._sw = e instanceof o.S ? new o.S(e.lng,e.lat) : o.S.convert(e),
                        this
                    }
                    extend(e) {
                        const n = this._sw
                          , s = this._ne;
                        let u, d;
                        if (e instanceof o.S)
                            u = e,
                            d = e;
                        else {
                            if (!(e instanceof dt))
                                return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(dt.convert(e)) : this.extend(o.S.convert(e)) : e && ("lng"in e || "lon"in e) && "lat"in e ? this.extend(o.S.convert(e)) : this;
                            if (u = e._sw,
                            d = e._ne,
                            !u || !d)
                                return this
                        }
                        return n || s ? (n.lng = Math.min(u.lng, n.lng),
                        n.lat = Math.min(u.lat, n.lat),
                        s.lng = Math.max(d.lng, s.lng),
                        s.lat = Math.max(d.lat, s.lat)) : (this._sw = new o.S(u.lng,u.lat),
                        this._ne = new o.S(d.lng,d.lat)),
                        this
                    }
                    getCenter() {
                        return new o.S((this._sw.lng + this._ne.lng) / 2,(this._sw.lat + this._ne.lat) / 2)
                    }
                    getSouthWest() {
                        return this._sw
                    }
                    getNorthEast() {
                        return this._ne
                    }
                    getNorthWest() {
                        return new o.S(this.getWest(),this.getNorth())
                    }
                    getSouthEast() {
                        return new o.S(this.getEast(),this.getSouth())
                    }
                    getWest() {
                        return this._sw.lng
                    }
                    getSouth() {
                        return this._sw.lat
                    }
                    getEast() {
                        return this._ne.lng
                    }
                    getNorth() {
                        return this._ne.lat
                    }
                    toArray() {
                        return [this._sw.toArray(), this._ne.toArray()]
                    }
                    toString() {
                        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
                    }
                    isEmpty() {
                        return !(this._sw && this._ne)
                    }
                    contains(e) {
                        const {lng: n, lat: s} = o.S.convert(e);
                        let u = this._sw.lng <= n && n <= this._ne.lng;
                        return this._sw.lng > this._ne.lng && (u = this._sw.lng >= n && n >= this._ne.lng),
                        this._sw.lat <= s && s <= this._ne.lat && u
                    }
                    static convert(e) {
                        return e instanceof dt ? e : e && new dt(e)
                    }
                    static fromLngLat(e, n=0) {
                        const s = 360 * n / 40075017
                          , u = s / Math.cos(Math.PI / 180 * e.lat);
                        return new dt(new o.S(e.lng - u,e.lat - s),new o.S(e.lng + u,e.lat + s))
                    }
                    adjustAntiMeridian() {
                        const e = new o.S(this._sw.lng,this._sw.lat)
                          , n = new o.S(this._ne.lng,this._ne.lat);
                        return new dt(e,e.lng > n.lng ? new o.S(n.lng + 360,n.lat) : n)
                    }
                }
                class Lt {
                    constructor(e, n, s) {
                        this.bounds = dt.convert(this.validateBounds(e)),
                        this.minzoom = n || 0,
                        this.maxzoom = s || 24
                    }
                    validateBounds(e) {
                        return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
                    }
                    contains(e) {
                        const n = Math.pow(2, e.z)
                          , s = Math.floor(o.V(this.bounds.getWest()) * n)
                          , u = Math.floor(o.U(this.bounds.getNorth()) * n)
                          , d = Math.ceil(o.V(this.bounds.getEast()) * n)
                          , m = Math.ceil(o.U(this.bounds.getSouth()) * n);
                        return e.x >= s && e.x < d && e.y >= u && e.y < m
                    }
                }
                class Xt extends o.E {
                    constructor(e, n, s, u) {
                        if (super(),
                        this.id = e,
                        this.dispatcher = s,
                        this.type = "vector",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this.reparseOverscaled = !0,
                        this.isTileClipped = !0,
                        this._loaded = !1,
                        o.e(this, o.Q(n, ["url", "scheme", "tileSize", "promoteId"])),
                        this._options = o.e({
                            type: "vector"
                        }, n),
                        this._collectResourceTiming = n.collectResourceTiming,
                        this.tileSize !== 512)
                            throw new Error("vector tile sources must have a tileSize of 512");
                        this.setEventedParent(u)
                    }
                    load() {
                        return o._(this, void 0, void 0, (function*() {
                            this._loaded = !1,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            })),
                            this._tileJSONRequest = new AbortController;
                            try {
                                const e = yield wt(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null,
                                this._loaded = !0,
                                this.map.style.sourceCaches[this.id].clearTiles(),
                                e && (o.e(this, e),
                                e.bounds && (this.tileBounds = new Lt(e.bounds,this.minzoom,this.maxzoom)),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "content"
                                })))
                            } catch (e) {
                                this._tileJSONRequest = null,
                                this.fire(new o.k(e))
                            }
                        }
                        ))
                    }
                    loaded() {
                        return this._loaded
                    }
                    hasTile(e) {
                        return !this.tileBounds || this.tileBounds.contains(e.canonical)
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    setSourceProperty(e) {
                        this._tileJSONRequest && this._tileJSONRequest.abort(),
                        e(),
                        this.load()
                    }
                    setTiles(e) {
                        return this.setSourceProperty(( () => {
                            this._options.tiles = e
                        }
                        )),
                        this
                    }
                    setUrl(e) {
                        return this.setSourceProperty(( () => {
                            this.url = e,
                            this._options.url = e
                        }
                        )),
                        this
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null)
                    }
                    serialize() {
                        return o.e({}, this._options)
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            const n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme)
                              , s = {
                                request: this.map._requestManager.transformRequest(n, "Tile"),
                                uid: e.uid,
                                tileID: e.tileID,
                                zoom: e.tileID.overscaledZ,
                                tileSize: this.tileSize * e.tileID.overscaleFactor(),
                                type: this.type,
                                source: this.id,
                                pixelRatio: this.map.getPixelRatio(),
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                                globalState: this.map.getGlobalState()
                            };
                            s.request.collectResourceTiming = this._collectResourceTiming;
                            let u = "RT";
                            if (e.actor && e.state !== "expired") {
                                if (e.state === "loading")
                                    return new Promise(( (d, m) => {
                                        e.reloadPromise = {
                                            resolve: d,
                                            reject: m
                                        }
                                    }
                                    ))
                            } else
                                e.actor = this.dispatcher.getActor(),
                                u = "LT";
                            e.abortController = new AbortController;
                            try {
                                const d = yield e.actor.sendAsync({
                                    type: u,
                                    data: s
                                }, e.abortController);
                                if (delete e.abortController,
                                e.aborted)
                                    return;
                                this._afterTileLoadWorkerResponse(e, d)
                            } catch (d) {
                                if (delete e.abortController,
                                e.aborted)
                                    return;
                                if (d && d.status !== 404)
                                    throw d;
                                this._afterTileLoadWorkerResponse(e, null)
                            }
                        }
                        ))
                    }
                    _afterTileLoadWorkerResponse(e, n) {
                        if (n && n.resourceTiming && (e.resourceTiming = n.resourceTiming),
                        n && this.map._refreshExpiredTiles && e.setExpiryData(n),
                        e.loadVectorData(n, this.map.painter),
                        e.reloadPromise) {
                            const s = e.reloadPromise;
                            e.reloadPromise = null,
                            this.loadTile(e).then(s.resolve).catch(s.reject)
                        }
                    }
                    abortTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            e.abortController && (e.abortController.abort(),
                            delete e.abortController),
                            e.actor && (yield e.actor.sendAsync({
                                type: "AT",
                                data: {
                                    uid: e.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            }))
                        }
                        ))
                    }
                    unloadTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            e.unloadVectorData(),
                            e.actor && (yield e.actor.sendAsync({
                                type: "RMT",
                                data: {
                                    uid: e.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            }))
                        }
                        ))
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class Yt extends o.E {
                    constructor(e, n, s, u) {
                        super(),
                        this.id = e,
                        this.dispatcher = s,
                        this.setEventedParent(u),
                        this.type = "raster",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.roundZoom = !0,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this._loaded = !1,
                        this._options = o.e({
                            type: "raster"
                        }, n),
                        o.e(this, o.Q(n, ["url", "scheme", "tileSize"]))
                    }
                    load() {
                        return o._(this, arguments, void 0, (function*(e=!1) {
                            this._loaded = !1,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            })),
                            this._tileJSONRequest = new AbortController;
                            try {
                                const n = yield wt(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null,
                                this._loaded = !0,
                                n && (o.e(this, n),
                                n.bounds && (this.tileBounds = new Lt(n.bounds,this.minzoom,this.maxzoom)),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "content",
                                    sourceDataChanged: e
                                })))
                            } catch (n) {
                                this._tileJSONRequest = null,
                                this.fire(new o.k(n))
                            }
                        }
                        ))
                    }
                    loaded() {
                        return this._loaded
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null)
                    }
                    setSourceProperty(e) {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null),
                        e(),
                        this.load(!0)
                    }
                    setTiles(e) {
                        return this.setSourceProperty(( () => {
                            this._options.tiles = e
                        }
                        )),
                        this
                    }
                    setUrl(e) {
                        return this.setSourceProperty(( () => {
                            this.url = e,
                            this._options.url = e
                        }
                        )),
                        this
                    }
                    serialize() {
                        return o.e({}, this._options)
                    }
                    hasTile(e) {
                        return !this.tileBounds || this.tileBounds.contains(e.canonical)
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            const n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                            e.abortController = new AbortController;
                            try {
                                const s = yield Ne.getImage(this.map._requestManager.transformRequest(n, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                                if (delete e.abortController,
                                e.aborted)
                                    return void (e.state = "unloaded");
                                if (s && s.data) {
                                    this.map._refreshExpiredTiles && (s.cacheControl || s.expires) && e.setExpiryData({
                                        cacheControl: s.cacheControl,
                                        expires: s.expires
                                    });
                                    const u = this.map.painter.context
                                      , d = u.gl
                                      , m = s.data;
                                    e.texture = this.map.painter.getTileTexture(m.width),
                                    e.texture ? e.texture.update(m, {
                                        useMipmap: !0
                                    }) : (e.texture = new o.T(u,m,d.RGBA,{
                                        useMipmap: !0
                                    }),
                                    e.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST)),
                                    e.state = "loaded"
                                }
                            } catch (s) {
                                if (delete e.abortController,
                                e.aborted)
                                    e.state = "unloaded";
                                else if (s)
                                    throw e.state = "errored",
                                    s
                            }
                        }
                        ))
                    }
                    abortTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            e.abortController && (e.abortController.abort(),
                            delete e.abortController)
                        }
                        ))
                    }
                    unloadTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            e.texture && this.map.painter.saveTileTexture(e.texture)
                        }
                        ))
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class nr extends Yt {
                    constructor(e, n, s, u) {
                        super(e, n, s, u),
                        this.type = "raster-dem",
                        this.maxzoom = 22,
                        this._options = o.e({
                            type: "raster-dem"
                        }, n),
                        this.encoding = n.encoding || "mapbox",
                        this.redFactor = n.redFactor,
                        this.greenFactor = n.greenFactor,
                        this.blueFactor = n.blueFactor,
                        this.baseShift = n.baseShift
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            const n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme)
                              , s = this.map._requestManager.transformRequest(n, "Tile");
                            e.neighboringTiles = this._getNeighboringTiles(e.tileID),
                            e.abortController = new AbortController;
                            try {
                                const u = yield Ne.getImage(s, e.abortController, this.map._refreshExpiredTiles);
                                if (delete e.abortController,
                                e.aborted)
                                    return void (e.state = "unloaded");
                                if (u && u.data) {
                                    const d = u.data;
                                    this.map._refreshExpiredTiles && (u.cacheControl || u.expires) && e.setExpiryData({
                                        cacheControl: u.cacheControl,
                                        expires: u.expires
                                    });
                                    const m = o.b(d) && o.W() ? d : yield this.readImageNow(d)
                                      , y = {
                                        type: this.type,
                                        uid: e.uid,
                                        source: this.id,
                                        rawImageData: m,
                                        encoding: this.encoding,
                                        redFactor: this.redFactor,
                                        greenFactor: this.greenFactor,
                                        blueFactor: this.blueFactor,
                                        baseShift: this.baseShift
                                    };
                                    if (!e.actor || e.state === "expired") {
                                        e.actor = this.dispatcher.getActor();
                                        const w = yield e.actor.sendAsync({
                                            type: "LDT",
                                            data: y
                                        });
                                        e.dem = w,
                                        e.needsHillshadePrepare = !0,
                                        e.needsTerrainPrepare = !0,
                                        e.state = "loaded"
                                    }
                                }
                            } catch (u) {
                                if (delete e.abortController,
                                e.aborted)
                                    e.state = "unloaded";
                                else if (u)
                                    throw e.state = "errored",
                                    u
                            }
                        }
                        ))
                    }
                    readImageNow(e) {
                        return o._(this, void 0, void 0, (function*() {
                            if (typeof VideoFrame < "u" && o.X()) {
                                const n = e.width + 2
                                  , s = e.height + 2;
                                try {
                                    return new o.R({
                                        width: n,
                                        height: s
                                    },yield o.Y(e, -1, -1, n, s))
                                } catch {}
                            }
                            return ye.getImageData(e, 1)
                        }
                        ))
                    }
                    _getNeighboringTiles(e) {
                        const n = e.canonical
                          , s = Math.pow(2, n.z)
                          , u = (n.x - 1 + s) % s
                          , d = n.x === 0 ? e.wrap - 1 : e.wrap
                          , m = (n.x + 1 + s) % s
                          , y = n.x + 1 === s ? e.wrap + 1 : e.wrap
                          , w = {};
                        return w[new o.Z(e.overscaledZ,d,n.z,u,n.y).key] = {
                            backfilled: !1
                        },
                        w[new o.Z(e.overscaledZ,y,n.z,m,n.y).key] = {
                            backfilled: !1
                        },
                        n.y > 0 && (w[new o.Z(e.overscaledZ,d,n.z,u,n.y - 1).key] = {
                            backfilled: !1
                        },
                        w[new o.Z(e.overscaledZ,e.wrap,n.z,n.x,n.y - 1).key] = {
                            backfilled: !1
                        },
                        w[new o.Z(e.overscaledZ,y,n.z,m,n.y - 1).key] = {
                            backfilled: !1
                        }),
                        n.y + 1 < s && (w[new o.Z(e.overscaledZ,d,n.z,u,n.y + 1).key] = {
                            backfilled: !1
                        },
                        w[new o.Z(e.overscaledZ,e.wrap,n.z,n.x,n.y + 1).key] = {
                            backfilled: !1
                        },
                        w[new o.Z(e.overscaledZ,y,n.z,m,n.y + 1).key] = {
                            backfilled: !1
                        }),
                        w
                    }
                    unloadTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            e.demTexture && this.map.painter.saveTileTexture(e.demTexture),
                            e.fbo && (e.fbo.destroy(),
                            delete e.fbo),
                            e.dem && delete e.dem,
                            delete e.neighboringTiles,
                            e.state = "unloaded",
                            e.actor && (yield e.actor.sendAsync({
                                type: "RDT",
                                data: {
                                    type: this.type,
                                    uid: e.uid,
                                    source: this.id
                                }
                            }))
                        }
                        ))
                    }
                }
                class ar extends o.E {
                    constructor(e, n, s, u) {
                        super(),
                        this.id = e,
                        this.type = "geojson",
                        this.minzoom = 0,
                        this.maxzoom = 18,
                        this.tileSize = 512,
                        this.isTileClipped = !0,
                        this.reparseOverscaled = !0,
                        this._removed = !1,
                        this._isUpdatingWorker = !1,
                        this._pendingWorkerUpdate = {
                            data: n.data
                        },
                        this.actor = s.getActor(),
                        this.setEventedParent(u),
                        this._data = n.data,
                        this._options = o.e({}, n),
                        this._collectResourceTiming = n.collectResourceTiming,
                        n.maxzoom !== void 0 && (this.maxzoom = n.maxzoom),
                        n.type && (this.type = n.type),
                        n.attribution && (this.attribution = n.attribution),
                        this.promoteId = n.promoteId,
                        n.clusterMaxZoom !== void 0 && this.maxzoom <= n.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${n.clusterMaxZoom}".`),
                        this.workerOptions = o.e({
                            source: this.id,
                            cluster: n.cluster || !1,
                            geojsonVtOptions: {
                                buffer: this._pixelsToTileUnits(n.buffer !== void 0 ? n.buffer : 128),
                                tolerance: this._pixelsToTileUnits(n.tolerance !== void 0 ? n.tolerance : .375),
                                extent: o.$,
                                maxZoom: this.maxzoom,
                                lineMetrics: n.lineMetrics || !1,
                                generateId: n.generateId || !1
                            },
                            superclusterOptions: {
                                maxZoom: this._getClusterMaxZoom(n.clusterMaxZoom),
                                minPoints: Math.max(2, n.clusterMinPoints || 2),
                                extent: o.$,
                                radius: this._pixelsToTileUnits(n.clusterRadius || 50),
                                log: !1,
                                generateId: n.generateId || !1
                            },
                            clusterProperties: n.clusterProperties,
                            filter: n.filter
                        }, n.workerOptions),
                        typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
                    }
                    _pixelsToTileUnits(e) {
                        return e * (o.$ / this.tileSize)
                    }
                    _getClusterMaxZoom(e) {
                        const n = e ? Math.round(e) : this.maxzoom - 1;
                        return Number.isInteger(e) || e === void 0 || o.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${n}"`),
                        n
                    }
                    load() {
                        return o._(this, void 0, void 0, (function*() {
                            yield this._updateWorkerData()
                        }
                        ))
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    setData(e) {
                        return this._data = e,
                        this._pendingWorkerUpdate = {
                            data: e
                        },
                        this._updateWorkerData(),
                        this
                    }
                    updateData(e) {
                        return this._pendingWorkerUpdate.diff = o.a0(this._pendingWorkerUpdate.diff, e),
                        this._updateWorkerData(),
                        this
                    }
                    getData() {
                        return o._(this, void 0, void 0, (function*() {
                            const e = o.e({
                                type: this.type
                            }, this.workerOptions);
                            return this.actor.sendAsync({
                                type: "GD",
                                data: e
                            })
                        }
                        ))
                    }
                    getCoordinatesFromGeometry(e) {
                        return e.type === "GeometryCollection" ? e.geometries.map((n => n.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0)
                    }
                    getBounds() {
                        return o._(this, void 0, void 0, (function*() {
                            const e = new dt
                              , n = yield this.getData();
                            let s;
                            switch (n.type) {
                            case "FeatureCollection":
                                s = n.features.map((u => this.getCoordinatesFromGeometry(u.geometry))).flat(1 / 0);
                                break;
                            case "Feature":
                                s = this.getCoordinatesFromGeometry(n.geometry);
                                break;
                            default:
                                s = this.getCoordinatesFromGeometry(n)
                            }
                            if (s.length == 0)
                                return e;
                            for (let u = 0; u < s.length - 1; u += 2)
                                e.extend([s[u], s[u + 1]]);
                            return e
                        }
                        ))
                    }
                    setClusterOptions(e) {
                        return this.workerOptions.cluster = e.cluster,
                        e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)),
                        e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))),
                        this._updateWorkerData(),
                        this
                    }
                    getClusterExpansionZoom(e) {
                        return this.actor.sendAsync({
                            type: "GCEZ",
                            data: {
                                type: this.type,
                                clusterId: e,
                                source: this.id
                            }
                        })
                    }
                    getClusterChildren(e) {
                        return this.actor.sendAsync({
                            type: "GCC",
                            data: {
                                type: this.type,
                                clusterId: e,
                                source: this.id
                            }
                        })
                    }
                    getClusterLeaves(e, n, s) {
                        return this.actor.sendAsync({
                            type: "GCL",
                            data: {
                                type: this.type,
                                source: this.id,
                                clusterId: e,
                                limit: n,
                                offset: s
                            }
                        })
                    }
                    _updateWorkerData() {
                        return o._(this, void 0, void 0, (function*() {
                            if (this._isUpdatingWorker)
                                return;
                            const {data: e, diff: n} = this._pendingWorkerUpdate;
                            if (!e && !n)
                                return void o.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
                            const s = o.e({
                                type: this.type
                            }, this.workerOptions);
                            e ? (typeof e == "string" ? (s.request = this.map._requestManager.transformRequest(ye.resolveURL(e), "Source"),
                            s.request.collectResourceTiming = this._collectResourceTiming) : s.data = JSON.stringify(e),
                            this._pendingWorkerUpdate.data = void 0) : n && (s.dataDiff = n,
                            this._pendingWorkerUpdate.diff = void 0),
                            this._isUpdatingWorker = !0,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            }));
                            try {
                                const u = yield this.actor.sendAsync({
                                    type: "LD",
                                    data: s
                                });
                                if (this._isUpdatingWorker = !1,
                                this._removed || u.abandoned)
                                    return void this.fire(new o.l("dataabort",{
                                        dataType: "source"
                                    }));
                                this._data = u.data;
                                let d = null;
                                u.resourceTiming && u.resourceTiming[this.id] && (d = u.resourceTiming[this.id].slice(0));
                                const m = {
                                    dataType: "source"
                                };
                                this._collectResourceTiming && d && d.length > 0 && o.e(m, {
                                    resourceTiming: d
                                }),
                                this.fire(new o.l("data",Object.assign(Object.assign({}, m), {
                                    sourceDataType: "metadata"
                                }))),
                                this.fire(new o.l("data",Object.assign(Object.assign({}, m), {
                                    sourceDataType: "content"
                                })))
                            } catch (u) {
                                if (this._isUpdatingWorker = !1,
                                this._removed)
                                    return void this.fire(new o.l("dataabort",{
                                        dataType: "source"
                                    }));
                                this.fire(new o.k(u))
                            } finally {
                                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData()
                            }
                        }
                        ))
                    }
                    loaded() {
                        return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            const n = e.actor ? "RT" : "LT";
                            e.actor = this.actor;
                            const s = {
                                type: this.type,
                                uid: e.uid,
                                tileID: e.tileID,
                                zoom: e.tileID.overscaledZ,
                                maxZoom: this.maxzoom,
                                tileSize: this.tileSize,
                                source: this.id,
                                pixelRatio: this.map.getPixelRatio(),
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                                globalState: this.map.getGlobalState()
                            };
                            e.abortController = new AbortController;
                            const u = yield this.actor.sendAsync({
                                type: n,
                                data: s
                            }, e.abortController);
                            delete e.abortController,
                            e.unloadVectorData(),
                            e.aborted || e.loadVectorData(u, this.map.painter, n === "RT")
                        }
                        ))
                    }
                    abortTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            e.abortController && (e.abortController.abort(),
                            delete e.abortController),
                            e.aborted = !0
                        }
                        ))
                    }
                    unloadTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            e.unloadVectorData(),
                            yield this.actor.sendAsync({
                                type: "RMT",
                                data: {
                                    uid: e.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            })
                        }
                        ))
                    }
                    onRemove() {
                        this._removed = !0,
                        this.actor.sendAsync({
                            type: "RS",
                            data: {
                                type: this.type,
                                source: this.id
                            }
                        })
                    }
                    serialize() {
                        return o.e({}, this._options, {
                            type: this.type,
                            data: this._data
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class Ft extends o.E {
                    constructor(e, n, s, u) {
                        super(),
                        this.flippedWindingOrder = !1,
                        this.id = e,
                        this.dispatcher = s,
                        this.coordinates = n.coordinates,
                        this.type = "image",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.tileSize = 512,
                        this.tiles = {},
                        this._loaded = !1,
                        this.setEventedParent(u),
                        this.options = n
                    }
                    load(e) {
                        return o._(this, void 0, void 0, (function*() {
                            this._loaded = !1,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            })),
                            this.url = this.options.url,
                            this._request = new AbortController;
                            try {
                                const n = yield Ne.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                                this._request = null,
                                this._loaded = !0,
                                n && n.data && (this.image = n.data,
                                e && (this.coordinates = e),
                                this._finishLoading())
                            } catch (n) {
                                this._request = null,
                                this._loaded = !0,
                                this.fire(new o.k(n))
                            }
                        }
                        ))
                    }
                    loaded() {
                        return this._loaded
                    }
                    updateImage(e) {
                        return e.url ? (this._request && (this._request.abort(),
                        this._request = null),
                        this.options.url = e.url,
                        this.load(e.coordinates).finally(( () => {
                            this.texture = null
                        }
                        )),
                        this) : this
                    }
                    _finishLoading() {
                        this.map && (this.setCoordinates(this.coordinates),
                        this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })))
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    onRemove() {
                        this._request && (this._request.abort(),
                        this._request = null)
                    }
                    setCoordinates(e) {
                        this.coordinates = e;
                        const n = e.map(o.a1.fromLngLat);
                        var s;
                        return this.tileID = (function(u) {
                            const d = o.a2.fromPoints(u)
                              , m = d.width()
                              , y = d.height()
                              , w = Math.max(m, y)
                              , P = Math.max(0, Math.floor(-Math.log(w) / Math.LN2))
                              , M = Math.pow(2, P);
                            return new o.a4(P,Math.floor((d.minX + d.maxX) / 2 * M),Math.floor((d.minY + d.maxY) / 2 * M))
                        }
                        )(n),
                        this.terrainTileRanges = this._getOverlappingTileRanges(n),
                        this.minzoom = this.maxzoom = this.tileID.z,
                        this.tileCoords = n.map((u => this.tileID.getTilePoint(u)._round())),
                        this.flippedWindingOrder = ((s = this.tileCoords)[1].x - s[0].x) * (s[2].y - s[0].y) - (s[1].y - s[0].y) * (s[2].x - s[0].x) < 0,
                        this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        })),
                        this
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || !this.image)
                            return;
                        const e = this.map.painter.context
                          , n = e.gl;
                        this.texture || (this.texture = new o.T(e,this.image,n.RGBA),
                        this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
                        let s = !1;
                        for (const u in this.tiles) {
                            const d = this.tiles[u];
                            d.state !== "loaded" && (d.state = "loaded",
                            d.texture = this.texture,
                            s = !0)
                        }
                        s && this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, (function*() {
                            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e,
                            e.buckets = {}) : e.state = "errored"
                        }
                        ))
                    }
                    serialize() {
                        return {
                            type: "image",
                            url: this.options.url,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return !1
                    }
                    _getOverlappingTileRanges(e) {
                        const {minX: n, minY: s, maxX: u, maxY: d} = o.a2.fromPoints(e)
                          , m = {};
                        for (let y = 0; y <= o.a3; y++) {
                            const w = Math.pow(2, y)
                              , P = Math.floor(n * w)
                              , M = Math.floor(s * w)
                              , D = Math.floor(u * w)
                              , z = Math.floor(d * w);
                            m[y] = {
                                minTileX: P,
                                minTileY: M,
                                maxTileX: D,
                                maxTileY: z
                            }
                        }
                        return m
                    }
                }
                class dr extends Ft {
                    constructor(e, n, s, u) {
                        super(e, n, s, u),
                        this.roundZoom = !0,
                        this.type = "video",
                        this.options = n
                    }
                    load() {
                        return o._(this, void 0, void 0, (function*() {
                            this._loaded = !1;
                            const e = this.options;
                            this.urls = [];
                            for (const n of e.urls)
                                this.urls.push(this.map._requestManager.transformRequest(n, "Source").url);
                            try {
                                const n = yield o.a5(this.urls);
                                if (this._loaded = !0,
                                !n)
                                    return;
                                this.video = n,
                                this.video.loop = !0,
                                this.video.addEventListener("playing", ( () => {
                                    this.map.triggerRepaint()
                                }
                                )),
                                this.map && this.video.play(),
                                this._finishLoading()
                            } catch (n) {
                                this.fire(new o.k(n))
                            }
                        }
                        ))
                    }
                    pause() {
                        this.video && this.video.pause()
                    }
                    play() {
                        this.video && this.video.play()
                    }
                    seek(e) {
                        if (this.video) {
                            const n = this.video.seekable;
                            e < n.start(0) || e > n.end(0) ? this.fire(new o.k(new o.a6(`sources.${this.id}`,null,`Playback for this video can be set only between the ${n.start(0)} and ${n.end(0)}-second mark.`))) : this.video.currentTime = e
                        }
                    }
                    getVideo() {
                        return this.video
                    }
                    onAdd(e) {
                        this.map || (this.map = e,
                        this.load(),
                        this.video && (this.video.play(),
                        this.setCoordinates(this.coordinates)))
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
                            return;
                        const e = this.map.painter.context
                          , n = e.gl;
                        this.texture ? this.video.paused || (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE),
                        n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(e,this.video,n.RGBA),
                        this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
                        let s = !1;
                        for (const u in this.tiles) {
                            const d = this.tiles[u];
                            d.state !== "loaded" && (d.state = "loaded",
                            d.texture = this.texture,
                            s = !0)
                        }
                        s && this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    serialize() {
                        return {
                            type: "video",
                            urls: this.urls,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this.video && !this.video.paused
                    }
                }
                class _r extends Ft {
                    constructor(e, n, s, u) {
                        super(e, n, s, u),
                        n.coordinates ? Array.isArray(n.coordinates) && n.coordinates.length === 4 && !n.coordinates.some((d => !Array.isArray(d) || d.length !== 2 || d.some((m => typeof m != "number")))) || this.fire(new o.k(new o.a6(`sources.${e}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.k(new o.a6(`sources.${e}`,null,'missing required property "coordinates"'))),
                        n.animate && typeof n.animate != "boolean" && this.fire(new o.k(new o.a6(`sources.${e}`,null,'optional "animate" property must be a boolean value'))),
                        n.canvas ? typeof n.canvas == "string" || n.canvas instanceof HTMLCanvasElement || this.fire(new o.k(new o.a6(`sources.${e}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.k(new o.a6(`sources.${e}`,null,'missing required property "canvas"'))),
                        this.options = n,
                        this.animate = n.animate === void 0 || n.animate
                    }
                    load() {
                        return o._(this, void 0, void 0, (function*() {
                            this._loaded = !0,
                            this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)),
                            this.width = this.canvas.width,
                            this.height = this.canvas.height,
                            this._hasInvalidDimensions() ? this.fire(new o.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                                this._playing = !0,
                                this.map.triggerRepaint()
                            }
                            ,
                            this.pause = function() {
                                this._playing && (this.prepare(),
                                this._playing = !1)
                            }
                            ,
                            this._finishLoading())
                        }
                        ))
                    }
                    getCanvas() {
                        return this.canvas
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load(),
                        this.canvas && this.animate && this.play()
                    }
                    onRemove() {
                        this.pause()
                    }
                    prepare() {
                        let e = !1;
                        if (this.canvas.width !== this.width && (this.width = this.canvas.width,
                        e = !0),
                        this.canvas.height !== this.height && (this.height = this.canvas.height,
                        e = !0),
                        this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
                            return;
                        const n = this.map.painter.context
                          , s = n.gl;
                        this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
                            premultiply: !0
                        }) : this.texture = new o.T(n,this.canvas,s.RGBA,{
                            premultiply: !0
                        });
                        let u = !1;
                        for (const d in this.tiles) {
                            const m = this.tiles[d];
                            m.state !== "loaded" && (m.state = "loaded",
                            m.texture = this.texture,
                            u = !0)
                        }
                        u && this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    serialize() {
                        return {
                            type: "canvas",
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this._playing
                    }
                    _hasInvalidDimensions() {
                        for (const e of [this.canvas.width, this.canvas.height])
                            if (isNaN(e) || e <= 0)
                                return !0;
                        return !1
                    }
                }
                const Ir = {}
                  , jr = h => {
                    switch (h) {
                    case "geojson":
                        return ar;
                    case "image":
                        return Ft;
                    case "raster":
                        return Yt;
                    case "raster-dem":
                        return nr;
                    case "vector":
                        return Xt;
                    case "video":
                        return dr;
                    case "canvas":
                        return _r
                    }
                    return Ir[h]
                }
                  , ur = "RTLPluginLoaded";
                class Mr extends o.E {
                    constructor() {
                        super(...arguments),
                        this.status = "unavailable",
                        this.url = null,
                        this.dispatcher = tt()
                    }
                    _syncState(e) {
                        return this.status = e,
                        this.dispatcher.broadcast("SRPS", {
                            pluginStatus: e,
                            pluginURL: this.url
                        }).catch((n => {
                            throw this.status = "error",
                            n
                        }
                        ))
                    }
                    getRTLTextPluginStatus() {
                        return this.status
                    }
                    clearRTLTextPlugin() {
                        this.status = "unavailable",
                        this.url = null
                    }
                    setRTLTextPlugin(e) {
                        return o._(this, arguments, void 0, (function*(n, s=!1) {
                            if (this.url)
                                throw new Error("setRTLTextPlugin cannot be called multiple times.");
                            if (this.url = ye.resolveURL(n),
                            !this.url)
                                throw new Error(`requested url ${n} is invalid`);
                            if (this.status === "unavailable") {
                                if (!s)
                                    return this._requestImport();
                                this.status = "deferred",
                                this._syncState(this.status)
                            } else if (this.status === "requested")
                                return this._requestImport()
                        }
                        ))
                    }
                    _requestImport() {
                        return o._(this, void 0, void 0, (function*() {
                            yield this._syncState("loading"),
                            this.status = "loaded",
                            this.fire(new o.l(ur))
                        }
                        ))
                    }
                    lazyLoad() {
                        this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
                    }
                }
                let Ar = null;
                function kr() {
                    return Ar || (Ar = new Mr),
                    Ar
                }
                class Nr {
                    constructor(e, n) {
                        this.timeAdded = 0,
                        this.fadeEndTime = 0,
                        this.tileID = e,
                        this.uid = o.a7(),
                        this.uses = 0,
                        this.tileSize = n,
                        this.buckets = {},
                        this.expirationTime = null,
                        this.queryPadding = 0,
                        this.hasSymbolBuckets = !1,
                        this.hasRTLText = !1,
                        this.dependencies = {},
                        this.rtt = [],
                        this.rttCoords = {},
                        this.expiredRequestCount = 0,
                        this.state = "loading"
                    }
                    registerFadeDuration(e) {
                        const n = e + this.timeAdded;
                        n < this.fadeEndTime || (this.fadeEndTime = n)
                    }
                    wasRequested() {
                        return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
                    }
                    clearTextures(e) {
                        this.demTexture && e.saveTileTexture(this.demTexture),
                        this.demTexture = null
                    }
                    loadVectorData(e, n, s) {
                        if (this.hasData() && this.unloadVectorData(),
                        this.state = "loaded",
                        e) {
                            e.featureIndex && (this.latestFeatureIndex = e.featureIndex,
                            e.rawTileData ? (this.latestRawTileData = e.rawTileData,
                            this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
                            this.collisionBoxArray = e.collisionBoxArray,
                            this.buckets = (function(u, d) {
                                const m = {};
                                if (!d)
                                    return m;
                                for (const y of u) {
                                    const w = y.layerIds.map((P => d.getLayer(P))).filter(Boolean);
                                    if (w.length !== 0) {
                                        y.layers = w,
                                        y.stateDependentLayerIds && (y.stateDependentLayers = y.stateDependentLayerIds.map((P => w.filter((M => M.id === P))[0])));
                                        for (const P of w)
                                            m[P.id] = y
                                    }
                                }
                                return m
                            }
                            )(e.buckets, n == null ? void 0 : n.style),
                            this.hasSymbolBuckets = !1;
                            for (const u in this.buckets) {
                                const d = this.buckets[u];
                                if (d instanceof o.a9) {
                                    if (this.hasSymbolBuckets = !0,
                                    !s)
                                        break;
                                    d.justReloaded = !0
                                }
                            }
                            if (this.hasRTLText = !1,
                            this.hasSymbolBuckets)
                                for (const u in this.buckets) {
                                    const d = this.buckets[u];
                                    if (d instanceof o.a9 && d.hasRTLText) {
                                        this.hasRTLText = !0,
                                        kr().lazyLoad();
                                        break
                                    }
                                }
                            this.queryPadding = 0;
                            for (const u in this.buckets) {
                                const d = this.buckets[u];
                                this.queryPadding = Math.max(this.queryPadding, n.style.getLayer(u).queryRadius(d))
                            }
                            e.imageAtlas && (this.imageAtlas = e.imageAtlas),
                            e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage)
                        } else
                            this.collisionBoxArray = new o.a8
                    }
                    unloadVectorData() {
                        for (const e in this.buckets)
                            this.buckets[e].destroy();
                        this.buckets = {},
                        this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                        this.imageAtlas && (this.imageAtlas = null),
                        this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                        this.latestFeatureIndex = null,
                        this.state = "unloaded"
                    }
                    getBucket(e) {
                        return this.buckets[e.id]
                    }
                    upload(e) {
                        for (const s in this.buckets) {
                            const u = this.buckets[s];
                            u.uploadPending() && u.upload(e)
                        }
                        const n = e.gl;
                        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new o.T(e,this.imageAtlas.image,n.RGBA),
                        this.imageAtlas.uploaded = !0),
                        this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(e,this.glyphAtlasImage,n.ALPHA),
                        this.glyphAtlasImage = null)
                    }
                    prepare(e) {
                        this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
                    }
                    queryRenderedFeatures(e, n, s, u, d, m, y, w, P, M, D) {
                        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                            queryGeometry: u,
                            cameraQueryGeometry: d,
                            scale: m,
                            tileSize: this.tileSize,
                            pixelPosMatrix: M,
                            transform: w,
                            params: y,
                            queryPadding: this.queryPadding * P,
                            getElevation: D
                        }, e, n, s) : {}
                    }
                    querySourceFeatures(e, n) {
                        const s = this.latestFeatureIndex;
                        if (!s || !s.rawTileData)
                            return;
                        const u = s.loadVTLayers()
                          , d = n && n.sourceLayer ? n.sourceLayer : ""
                          , m = u._geojsonTileLayer || u[d];
                        if (!m)
                            return;
                        const y = o.aa(n && n.filter)
                          , {z: w, x: P, y: M} = this.tileID.canonical
                          , D = {
                            z: w,
                            x: P,
                            y: M
                        };
                        for (let z = 0; z < m.length; z++) {
                            const B = m.feature(z);
                            if (y.needGeometry) {
                                const J = o.ab(B, !0);
                                if (!y.filter(new o.F(this.tileID.overscaledZ), J, this.tileID.canonical))
                                    continue
                            } else if (!y.filter(new o.F(this.tileID.overscaledZ), B))
                                continue;
                            const U = s.getId(B, d)
                              , ee = new o.ac(B,w,P,M,U);
                            ee.tile = D,
                            e.push(ee)
                        }
                    }
                    hasData() {
                        return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
                    }
                    patternsLoaded() {
                        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
                    }
                    setExpiryData(e) {
                        const n = this.expirationTime;
                        if (e.cacheControl) {
                            const s = o.ad(e.cacheControl);
                            s["max-age"] && (this.expirationTime = Date.now() + 1e3 * s["max-age"])
                        } else
                            e.expires && (this.expirationTime = new Date(e.expires).getTime());
                        if (this.expirationTime) {
                            const s = Date.now();
                            let u = !1;
                            if (this.expirationTime > s)
                                u = !1;
                            else if (n)
                                if (this.expirationTime < n)
                                    u = !0;
                                else {
                                    const d = this.expirationTime - n;
                                    d ? this.expirationTime = s + Math.max(d, 3e4) : u = !0
                                }
                            else
                                u = !0;
                            u ? (this.expiredRequestCount++,
                            this.state = "expired") : this.expiredRequestCount = 0
                        }
                    }
                    getExpiryTimeout() {
                        if (this.expirationTime)
                            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
                    }
                    setFeatureState(e, n) {
                        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0)
                            return;
                        const s = this.latestFeatureIndex.loadVTLayers();
                        for (const u in this.buckets) {
                            if (!n.style.hasLayer(u))
                                continue;
                            const d = this.buckets[u]
                              , m = d.layers[0].sourceLayer || "_geojsonTileLayer"
                              , y = s[m]
                              , w = e[m];
                            if (!y || !w || Object.keys(w).length === 0)
                                continue;
                            d.update(w, y, this.imageAtlas && this.imageAtlas.patternPositions || {});
                            const P = n && n.style && n.style.getLayer(u);
                            P && (this.queryPadding = Math.max(this.queryPadding, P.queryRadius(d)))
                        }
                    }
                    holdingForFade() {
                        return this.symbolFadeHoldUntil !== void 0
                    }
                    symbolFadeFinished() {
                        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < ye.now()
                    }
                    clearFadeHold() {
                        this.symbolFadeHoldUntil = void 0
                    }
                    setHoldDuration(e) {
                        this.symbolFadeHoldUntil = ye.now() + e
                    }
                    setDependencies(e, n) {
                        const s = {};
                        for (const u of n)
                            s[u] = !0;
                        this.dependencies[e] = s
                    }
                    hasDependency(e, n) {
                        for (const s of e) {
                            const u = this.dependencies[s];
                            if (u) {
                                for (const d of n)
                                    if (u[d])
                                        return !0
                            }
                        }
                        return !1
                    }
                }
                class ce {
                    constructor(e, n) {
                        this.max = e,
                        this.onRemove = n,
                        this.reset()
                    }
                    reset() {
                        for (const e in this.data)
                            for (const n of this.data[e])
                                n.timeout && clearTimeout(n.timeout),
                                this.onRemove(n.value);
                        return this.data = {},
                        this.order = [],
                        this
                    }
                    add(e, n, s) {
                        const u = e.wrapped().key;
                        this.data[u] === void 0 && (this.data[u] = []);
                        const d = {
                            value: n,
                            timeout: void 0
                        };
                        if (s !== void 0 && (d.timeout = setTimeout(( () => {
                            this.remove(e, d)
                        }
                        ), s)),
                        this.data[u].push(d),
                        this.order.push(u),
                        this.order.length > this.max) {
                            const m = this._getAndRemoveByKey(this.order[0]);
                            m && this.onRemove(m)
                        }
                        return this
                    }
                    has(e) {
                        return e.wrapped().key in this.data
                    }
                    getAndRemove(e) {
                        return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
                    }
                    _getAndRemoveByKey(e) {
                        const n = this.data[e].shift();
                        return n.timeout && clearTimeout(n.timeout),
                        this.data[e].length === 0 && delete this.data[e],
                        this.order.splice(this.order.indexOf(e), 1),
                        n.value
                    }
                    getByKey(e) {
                        const n = this.data[e];
                        return n ? n[0].value : null
                    }
                    get(e) {
                        return this.has(e) ? this.data[e.wrapped().key][0].value : null
                    }
                    remove(e, n) {
                        if (!this.has(e))
                            return this;
                        const s = e.wrapped().key
                          , u = n === void 0 ? 0 : this.data[s].indexOf(n)
                          , d = this.data[s][u];
                        return this.data[s].splice(u, 1),
                        d.timeout && clearTimeout(d.timeout),
                        this.data[s].length === 0 && delete this.data[s],
                        this.onRemove(d.value),
                        this.order.splice(this.order.indexOf(s), 1),
                        this
                    }
                    setMaxSize(e) {
                        for (this.max = e; this.order.length > this.max; ) {
                            const n = this._getAndRemoveByKey(this.order[0]);
                            n && this.onRemove(n)
                        }
                        return this
                    }
                    filter(e) {
                        const n = [];
                        for (const s in this.data)
                            for (const u of this.data[s])
                                e(u.value) || n.push(u);
                        for (const s of n)
                            this.remove(s.value.tileID, s)
                    }
                }
                class F {
                    constructor() {
                        this.state = {},
                        this.stateChanges = {},
                        this.deletedStates = {}
                    }
                    updateState(e, n, s) {
                        const u = String(n);
                        if (this.stateChanges[e] = this.stateChanges[e] || {},
                        this.stateChanges[e][u] = this.stateChanges[e][u] || {},
                        o.e(this.stateChanges[e][u], s),
                        this.deletedStates[e] === null) {
                            this.deletedStates[e] = {};
                            for (const d in this.state[e])
                                d !== u && (this.deletedStates[e][d] = null)
                        } else if (this.deletedStates[e] && this.deletedStates[e][u] === null) {
                            this.deletedStates[e][u] = {};
                            for (const d in this.state[e][u])
                                s[d] || (this.deletedStates[e][u][d] = null)
                        } else
                            for (const d in s)
                                this.deletedStates[e] && this.deletedStates[e][u] && this.deletedStates[e][u][d] === null && delete this.deletedStates[e][u][d]
                    }
                    removeFeatureState(e, n, s) {
                        if (this.deletedStates[e] === null)
                            return;
                        const u = String(n);
                        if (this.deletedStates[e] = this.deletedStates[e] || {},
                        s && n !== void 0)
                            this.deletedStates[e][u] !== null && (this.deletedStates[e][u] = this.deletedStates[e][u] || {},
                            this.deletedStates[e][u][s] = null);
                        else if (n !== void 0)
                            if (this.stateChanges[e] && this.stateChanges[e][u])
                                for (s in this.deletedStates[e][u] = {},
                                this.stateChanges[e][u])
                                    this.deletedStates[e][u][s] = null;
                            else
                                this.deletedStates[e][u] = null;
                        else
                            this.deletedStates[e] = null
                    }
                    getState(e, n) {
                        const s = String(n)
                          , u = o.e({}, (this.state[e] || {})[s], (this.stateChanges[e] || {})[s]);
                        if (this.deletedStates[e] === null)
                            return {};
                        if (this.deletedStates[e]) {
                            const d = this.deletedStates[e][n];
                            if (d === null)
                                return {};
                            for (const m in d)
                                delete u[m]
                        }
                        return u
                    }
                    initializeTileState(e, n) {
                        e.setFeatureState(this.state, n)
                    }
                    coalesceChanges(e, n) {
                        const s = {};
                        for (const u in this.stateChanges) {
                            this.state[u] = this.state[u] || {};
                            const d = {};
                            for (const m in this.stateChanges[u])
                                this.state[u][m] || (this.state[u][m] = {}),
                                o.e(this.state[u][m], this.stateChanges[u][m]),
                                d[m] = this.state[u][m];
                            s[u] = d
                        }
                        for (const u in this.deletedStates) {
                            this.state[u] = this.state[u] || {};
                            const d = {};
                            if (this.deletedStates[u] === null)
                                for (const m in this.state[u])
                                    d[m] = {},
                                    this.state[u][m] = {};
                            else
                                for (const m in this.deletedStates[u]) {
                                    if (this.deletedStates[u][m] === null)
                                        this.state[u][m] = {};
                                    else
                                        for (const y of Object.keys(this.deletedStates[u][m]))
                                            delete this.state[u][m][y];
                                    d[m] = this.state[u][m]
                                }
                            s[u] = s[u] || {},
                            o.e(s[u], d)
                        }
                        if (this.stateChanges = {},
                        this.deletedStates = {},
                        Object.keys(s).length !== 0)
                            for (const u in e)
                                e[u].setFeatureState(s, n)
                    }
                }
                const q = 89.25;
                function G(h, e) {
                    const n = o.ah(e.lat, -o.ai, o.ai);
                    return new o.P(o.V(e.lng) * h,o.U(n) * h)
                }
                function K(h, e) {
                    return new o.a1(e.x / h,e.y / h).toLngLat()
                }
                function le(h) {
                    return h.cameraToCenterDistance * Math.min(.85 * Math.tan(o.ae(90 - h.pitch)), Math.tan(o.ae(q - h.pitch)))
                }
                function ve(h, e) {
                    const n = h.canonical
                      , s = e / o.af(n.z)
                      , u = n.x + Math.pow(2, n.z) * h.wrap
                      , d = o.ag(new Float64Array(16));
                    return o.M(d, d, [u * s, n.y * s, 0]),
                    o.N(d, d, [s / o.$, s / o.$, 1]),
                    d
                }
                function Le(h, e, n, s, u) {
                    const d = o.a1.fromLngLat(h, e)
                      , m = u * o.aj(1, h.lat)
                      , y = m * Math.cos(o.ae(n))
                      , w = Math.sqrt(m * m - y * y)
                      , P = w * Math.sin(o.ae(-s))
                      , M = w * Math.cos(o.ae(-s));
                    return new o.a1(d.x + P,d.y + M,d.z + y)
                }
                function Ce(h, e, n) {
                    const s = e.intersectsFrustum(h);
                    if (!n || s === 0)
                        return s;
                    const u = e.intersectsPlane(n);
                    return u === 0 ? 0 : s === 2 && u === 2 ? 2 : 1
                }
                function Ze(h, e, n) {
                    let s = 0;
                    const u = (n - e) / 10;
                    for (let d = 0; d < 10; d++)
                        s += u * Math.pow(Math.cos(e + (d + .5) / 10 * (n - e)), h);
                    return s
                }
                function ot(h, e) {
                    return function(n, s, u, d, m) {
                        const y = 2 * ((h - 1) / o.ak(Math.cos(o.ae(q - m)) / Math.cos(o.ae(q))) - 1)
                          , w = Math.acos(u / d)
                          , P = 2 * Ze(y - 1, 0, o.ae(m / 2))
                          , M = Math.min(o.ae(q), w + o.ae(m / 2))
                          , D = Ze(y - 1, Math.min(M, w - o.ae(m / 2)), M)
                          , z = Math.atan(s / u)
                          , B = Math.hypot(s, u);
                        let U = n;
                        return U += o.ak(d / B / Math.max(.5, Math.cos(o.ae(m / 2)))),
                        U += y * o.ak(Math.cos(z)) / 2,
                        U -= o.ak(Math.max(1, D / P / e)) / 2,
                        U
                    }
                }
                const Ye = ot(9.314, 3);
                function Ot(h, e) {
                    const n = (e.roundZoom ? Math.round : Math.floor)(h.zoom + o.ak(h.tileSize / e.tileSize));
                    return Math.max(0, n)
                }
                function xe(h, e) {
                    const n = h.getCameraFrustum()
                      , s = h.getClippingPlane()
                      , u = h.screenPointToMercatorCoordinate(h.getCameraPoint())
                      , d = o.a1.fromLngLat(h.center, h.elevation);
                    u.z = d.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
                    const m = h.getCoveringTilesDetailsProvider()
                      , y = m.allowVariableZoom(h, e)
                      , w = Ot(h, e)
                      , P = e.minzoom || 0
                      , M = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom
                      , D = Math.min(Math.max(0, w), M)
                      , z = Math.pow(2, D)
                      , B = [z * u.x, z * u.y, 0]
                      , U = [z * d.x, z * d.y, 0]
                      , ee = Math.hypot(d.x - u.x, d.y - u.y)
                      , J = Math.abs(d.z - u.z)
                      , re = Math.hypot(ee, J)
                      , se = ge => ({
                        zoom: 0,
                        x: 0,
                        y: 0,
                        wrap: ge,
                        fullyVisible: !1
                    })
                      , de = []
                      , ue = [];
                    if (h.renderWorldCopies && m.allowWorldCopies())
                        for (let ge = 1; ge <= 3; ge++)
                            de.push(se(-ge)),
                            de.push(se(ge));
                    for (de.push(se(0)); de.length > 0; ) {
                        const ge = de.pop()
                          , Te = ge.x
                          , he = ge.y;
                        let De = ge.fullyVisible;
                        const He = {
                            x: Te,
                            y: he,
                            z: ge.zoom
                        }
                          , je = m.getTileBoundingVolume(He, ge.wrap, h.elevation, e);
                        if (!De) {
                            const Nt = Ce(n, je, s);
                            if (Nt === 0)
                                continue;
                            De = Nt === 2
                        }
                        const qe = m.distanceToTile2d(u.x, u.y, He, je);
                        let $e = w;
                        y && ($e = (e.calculateTileZoom || Ye)(h.zoom + o.ak(h.tileSize / e.tileSize), qe, J, re, h.fov)),
                        $e = (e.roundZoom ? Math.round : Math.floor)($e),
                        $e = Math.max(0, $e);
                        const Rt = Math.min($e, M);
                        if (ge.wrap = m.getWrap(d, He, ge.wrap),
                        ge.zoom >= Rt) {
                            if (ge.zoom < P)
                                continue;
                            const Nt = D - ge.zoom
                              , yt = B[0] - .5 - (Te << Nt)
                              , sr = B[1] - .5 - (he << Nt)
                              , Xr = e.reparseOverscaled ? Math.max(ge.zoom, $e) : ge.zoom;
                            ue.push({
                                tileID: new o.Z(ge.zoom === M ? Xr : ge.zoom,ge.wrap,ge.zoom,Te,he),
                                distanceSq: o.al([U[0] - .5 - Te, U[1] - .5 - he]),
                                tileDistanceToCamera: Math.sqrt(yt * yt + sr * sr)
                            })
                        } else
                            for (let Nt = 0; Nt < 4; Nt++)
                                de.push({
                                    zoom: ge.zoom + 1,
                                    x: (Te << 1) + Nt % 2,
                                    y: (he << 1) + (Nt >> 1),
                                    wrap: ge.wrap,
                                    fullyVisible: De
                                })
                    }
                    return ue.sort(( (ge, Te) => ge.distanceSq - Te.distanceSq)).map((ge => ge.tileID))
                }
                const At = o.a2.fromPoints([new o.P(0,0), new o.P(o.$,o.$)]);
                class Pt extends o.E {
                    constructor(e, n, s) {
                        super(),
                        this.id = e,
                        this.dispatcher = s,
                        this.on("data", (u => this._dataHandler(u))),
                        this.on("dataloading", ( () => {
                            this._sourceErrored = !1
                        }
                        )),
                        this.on("error", ( () => {
                            this._sourceErrored = this._source.loaded()
                        }
                        )),
                        this._source = ( (u, d, m, y) => {
                            const w = new (jr(d.type))(u,d,m,y);
                            if (w.id !== u)
                                throw new Error(`Expected Source id to be ${u} instead of ${w.id}`);
                            return w
                        }
                        )(e, n, s, this),
                        this._tiles = {},
                        this._cache = new ce(0,(u => this._unloadTile(u))),
                        this._timers = {},
                        this._cacheTimers = {},
                        this._maxTileCacheSize = null,
                        this._maxTileCacheZoomLevels = null,
                        this._loadedParentTiles = {},
                        this._coveredTiles = {},
                        this._state = new F,
                        this._didEmitContent = !1,
                        this._updated = !1
                    }
                    onAdd(e) {
                        this.map = e,
                        this._maxTileCacheSize = e ? e._maxTileCacheSize : null,
                        this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null,
                        this._source && this._source.onAdd && this._source.onAdd(e)
                    }
                    onRemove(e) {
                        this.clearTiles(),
                        this._source && this._source.onRemove && this._source.onRemove(e)
                    }
                    loaded() {
                        if (this._sourceErrored)
                            return !0;
                        if (!this._sourceLoaded || !this._source.loaded())
                            return !1;
                        if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain))
                            return !0;
                        if (!this._updated)
                            return !1;
                        for (const e in this._tiles) {
                            const n = this._tiles[e];
                            if (n.state !== "loaded" && n.state !== "errored")
                                return !1
                        }
                        return !0
                    }
                    getSource() {
                        return this._source
                    }
                    pause() {
                        this._paused = !0
                    }
                    resume() {
                        if (!this._paused)
                            return;
                        const e = this._shouldReloadOnResume;
                        this._paused = !1,
                        this._shouldReloadOnResume = !1,
                        e && this.reload(),
                        this.transform && this.update(this.transform, this.terrain)
                    }
                    _loadTile(e, n, s) {
                        return o._(this, void 0, void 0, (function*() {
                            try {
                                yield this._source.loadTile(e),
                                this._tileLoaded(e, n, s)
                            } catch (u) {
                                e.state = "errored",
                                u.status !== 404 ? this._source.fire(new o.k(u,{
                                    tile: e
                                })) : this.update(this.transform, this.terrain)
                            }
                        }
                        ))
                    }
                    _unloadTile(e) {
                        this._source.unloadTile && this._source.unloadTile(e)
                    }
                    _abortTile(e) {
                        this._source.abortTile && this._source.abortTile(e),
                        this._source.fire(new o.l("dataabort",{
                            tile: e,
                            coord: e.tileID,
                            dataType: "source"
                        }))
                    }
                    serialize() {
                        return this._source.serialize()
                    }
                    prepare(e) {
                        this._source.prepare && this._source.prepare(),
                        this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                        for (const n in this._tiles) {
                            const s = this._tiles[n];
                            s.upload(e),
                            s.prepare(this.map.style.imageManager)
                        }
                    }
                    getIds() {
                        return Object.values(this._tiles).map((e => e.tileID)).sort(kt).map((e => e.key))
                    }
                    getRenderableIds(e) {
                        const n = [];
                        for (const s in this._tiles)
                            this._isIdRenderable(s, e) && n.push(this._tiles[s]);
                        return e ? n.sort(( (s, u) => {
                            const d = s.tileID
                              , m = u.tileID
                              , y = new o.P(d.canonical.x,d.canonical.y)._rotate(-this.transform.bearingInRadians)
                              , w = new o.P(m.canonical.x,m.canonical.y)._rotate(-this.transform.bearingInRadians);
                            return d.overscaledZ - m.overscaledZ || w.y - y.y || w.x - y.x
                        }
                        )).map((s => s.tileID.key)) : n.map((s => s.tileID)).sort(kt).map((s => s.key))
                    }
                    hasRenderableParent(e) {
                        const n = this.findLoadedParent(e, 0);
                        return !!n && this._isIdRenderable(n.tileID.key)
                    }
                    _isIdRenderable(e, n) {
                        return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (n || !this._tiles[e].holdingForFade())
                    }
                    reload(e) {
                        if (this._paused)
                            this._shouldReloadOnResume = !0;
                        else {
                            this._cache.reset();
                            for (const n in this._tiles)
                                e ? this._reloadTile(n, "expired") : this._tiles[n].state !== "errored" && this._reloadTile(n, "reloading")
                        }
                    }
                    _reloadTile(e, n) {
                        return o._(this, void 0, void 0, (function*() {
                            const s = this._tiles[e];
                            s && (s.state !== "loading" && (s.state = n),
                            yield this._loadTile(s, e, n))
                        }
                        ))
                    }
                    _tileLoaded(e, n, s) {
                        e.timeAdded = ye.now(),
                        s === "expired" && (e.refreshedUponExpiration = !0),
                        this._setTileReloadTimer(n, e),
                        this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e),
                        this._state.initializeTileState(e, this.map ? this.map.painter : null),
                        e.aborted || this._source.fire(new o.l("data",{
                            dataType: "source",
                            tile: e,
                            coord: e.tileID
                        }))
                    }
                    _backfillDEM(e) {
                        const n = this.getRenderableIds();
                        for (let u = 0; u < n.length; u++) {
                            const d = n[u];
                            if (e.neighboringTiles && e.neighboringTiles[d]) {
                                const m = this.getTileByID(d);
                                s(e, m),
                                s(m, e)
                            }
                        }
                        function s(u, d) {
                            u.needsHillshadePrepare = !0,
                            u.needsTerrainPrepare = !0;
                            let m = d.tileID.canonical.x - u.tileID.canonical.x;
                            const y = d.tileID.canonical.y - u.tileID.canonical.y
                              , w = Math.pow(2, u.tileID.canonical.z)
                              , P = d.tileID.key;
                            m === 0 && y === 0 || Math.abs(y) > 1 || (Math.abs(m) > 1 && (Math.abs(m + w) === 1 ? m += w : Math.abs(m - w) === 1 && (m -= w)),
                            d.dem && u.dem && (u.dem.backfillBorder(d.dem, m, y),
                            u.neighboringTiles && u.neighboringTiles[P] && (u.neighboringTiles[P].backfilled = !0)))
                        }
                    }
                    getTile(e) {
                        return this.getTileByID(e.key)
                    }
                    getTileByID(e) {
                        return this._tiles[e]
                    }
                    _retainLoadedChildren(e, n, s, u) {
                        for (const d in this._tiles) {
                            let m = this._tiles[d];
                            if (u[d] || !m.hasData() || m.tileID.overscaledZ <= n || m.tileID.overscaledZ > s)
                                continue;
                            let y = m.tileID;
                            for (; m && m.tileID.overscaledZ > n + 1; ) {
                                const P = m.tileID.scaledTo(m.tileID.overscaledZ - 1);
                                m = this._tiles[P.key],
                                m && m.hasData() && (y = P)
                            }
                            let w = y;
                            for (; w.overscaledZ > n; )
                                if (w = w.scaledTo(w.overscaledZ - 1),
                                e[w.key] || e[w.canonical.key]) {
                                    u[y.key] = y;
                                    break
                                }
                        }
                    }
                    findLoadedParent(e, n) {
                        if (e.key in this._loadedParentTiles) {
                            const s = this._loadedParentTiles[e.key];
                            return s && s.tileID.overscaledZ >= n ? s : null
                        }
                        for (let s = e.overscaledZ - 1; s >= n; s--) {
                            const u = e.scaledTo(s)
                              , d = this._getLoadedTile(u);
                            if (d)
                                return d
                        }
                    }
                    findLoadedSibling(e) {
                        return this._getLoadedTile(e)
                    }
                    _getLoadedTile(e) {
                        const n = this._tiles[e.key];
                        return n && n.hasData() ? n : this._cache.getByKey(e.wrapped().key)
                    }
                    updateCacheSize(e) {
                        const n = Math.ceil(e.width / this._source.tileSize) + 1
                          , s = Math.ceil(e.height / this._source.tileSize) + 1
                          , u = Math.floor(n * s * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels))
                          , d = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, u) : u;
                        this._cache.setMaxSize(d)
                    }
                    handleWrapJump(e) {
                        const n = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
                        if (this._prevLng = e,
                        n) {
                            const s = {};
                            for (const u in this._tiles) {
                                const d = this._tiles[u];
                                d.tileID = d.tileID.unwrapTo(d.tileID.wrap + n),
                                s[d.tileID.key] = d
                            }
                            this._tiles = s;
                            for (const u in this._timers)
                                clearTimeout(this._timers[u]),
                                delete this._timers[u];
                            for (const u in this._tiles)
                                this._setTileReloadTimer(u, this._tiles[u])
                        }
                    }
                    _updateCoveredAndRetainedTiles(e, n, s, u, d, m) {
                        const y = {}
                          , w = {}
                          , P = Object.keys(e)
                          , M = ye.now();
                        for (const D of P) {
                            const z = e[D]
                              , B = this._tiles[D];
                            if (!B || B.fadeEndTime !== 0 && B.fadeEndTime <= M)
                                continue;
                            const U = this.findLoadedParent(z, n)
                              , ee = this.findLoadedSibling(z)
                              , J = U || ee || null;
                            J && (this._addTile(J.tileID),
                            y[J.tileID.key] = J.tileID),
                            w[D] = z
                        }
                        this._retainLoadedChildren(w, u, s, e);
                        for (const D in y)
                            e[D] || (this._coveredTiles[D] = !0,
                            e[D] = y[D]);
                        if (m) {
                            const D = {}
                              , z = {};
                            for (const B of d)
                                this._tiles[B.key].hasData() ? D[B.key] = B : z[B.key] = B;
                            for (const B in z) {
                                const U = z[B].children(this._source.maxzoom);
                                this._tiles[U[0].key] && this._tiles[U[1].key] && this._tiles[U[2].key] && this._tiles[U[3].key] && (D[U[0].key] = e[U[0].key] = U[0],
                                D[U[1].key] = e[U[1].key] = U[1],
                                D[U[2].key] = e[U[2].key] = U[2],
                                D[U[3].key] = e[U[3].key] = U[3],
                                delete z[B])
                            }
                            for (const B in z) {
                                const U = z[B]
                                  , ee = this.findLoadedParent(U, this._source.minzoom)
                                  , J = this.findLoadedSibling(U)
                                  , re = ee || J || null;
                                if (re) {
                                    D[re.tileID.key] = e[re.tileID.key] = re.tileID;
                                    for (const se in D)
                                        D[se].isChildOf(re.tileID) && delete D[se]
                                }
                            }
                            for (const B in this._tiles)
                                D[B] || (this._coveredTiles[B] = !0)
                        }
                    }
                    update(e, n) {
                        if (!this._sourceLoaded || this._paused)
                            return;
                        let s;
                        this.transform = e,
                        this.terrain = n,
                        this.updateCacheSize(e),
                        this.handleWrapJump(this.transform.center.lng),
                        this._coveredTiles = {},
                        this.used || this.usedForTerrain ? this._source.tileID ? s = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((M => new o.Z(M.canonical.z,M.wrap,M.canonical.z,M.canonical.x,M.canonical.y))) : (s = xe(e, {
                            tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: !this.usedForTerrain && this._source.roundZoom,
                            reparseOverscaled: this._source.reparseOverscaled,
                            terrain: n,
                            calculateTileZoom: this._source.calculateTileZoom
                        }),
                        this._source.hasTile && (s = s.filter((M => this._source.hasTile(M))))) : s = [];
                        const u = Ot(e, this._source)
                          , d = Math.max(u - Pt.maxOverzooming, this._source.minzoom)
                          , m = Math.max(u + Pt.maxUnderzooming, this._source.minzoom);
                        if (this.usedForTerrain) {
                            const M = {};
                            for (const D of s)
                                if (D.canonical.z > this._source.minzoom) {
                                    const z = D.scaledTo(D.canonical.z - 1);
                                    M[z.key] = z;
                                    const B = D.scaledTo(Math.max(this._source.minzoom, Math.min(D.canonical.z, 5)));
                                    M[B.key] = B
                                }
                            s = s.concat(Object.values(M))
                        }
                        const y = s.length === 0 && !this._updated && this._didEmitContent;
                        this._updated = !0,
                        y && this.fire(new o.l("data",{
                            sourceDataType: "idle",
                            dataType: "source",
                            sourceId: this.id
                        }));
                        const w = this._updateRetainedTiles(s, u);
                        Wt(this._source.type) && this._updateCoveredAndRetainedTiles(w, d, m, u, s, n);
                        for (const M in w)
                            this._tiles[M].clearFadeHold();
                        const P = o.am(this._tiles, w);
                        for (const M of P) {
                            const D = this._tiles[M];
                            D.hasSymbolBuckets && !D.holdingForFade() ? D.setHoldDuration(this.map._fadeDuration) : D.hasSymbolBuckets && !D.symbolFadeFinished() || this._removeTile(M)
                        }
                        this._updateLoadedParentTileCache(),
                        this._updateLoadedSiblingTileCache()
                    }
                    releaseSymbolFadeTiles() {
                        for (const e in this._tiles)
                            this._tiles[e].holdingForFade() && this._removeTile(e)
                    }
                    _updateRetainedTiles(e, n) {
                        var s;
                        const u = {}
                          , d = {}
                          , m = Math.max(n - Pt.maxOverzooming, this._source.minzoom)
                          , y = Math.max(n + Pt.maxUnderzooming, this._source.minzoom)
                          , w = {};
                        for (const P of e) {
                            const M = this._addTile(P);
                            u[P.key] = P,
                            M.hasData() || n < this._source.maxzoom && (w[P.key] = P)
                        }
                        this._retainLoadedChildren(w, n, y, u);
                        for (const P of e) {
                            let M = this._tiles[P.key];
                            if (M.hasData())
                                continue;
                            if (n + 1 > this._source.maxzoom) {
                                const z = P.children(this._source.maxzoom)[0]
                                  , B = this.getTile(z);
                                if (B && B.hasData()) {
                                    u[z.key] = z;
                                    continue
                                }
                            } else {
                                const z = P.children(this._source.maxzoom);
                                if (u[z[0].key] && u[z[1].key] && u[z[2].key] && u[z[3].key])
                                    continue
                            }
                            let D = M.wasRequested();
                            for (let z = P.overscaledZ - 1; z >= m; --z) {
                                const B = P.scaledTo(z);
                                if (d[B.key])
                                    break;
                                if (d[B.key] = !0,
                                M = this.getTile(B),
                                !M && D && (M = this._addTile(B)),
                                M) {
                                    const U = M.hasData();
                                    if ((U || !(!((s = this.map) === null || s === void 0) && s.cancelPendingTileRequestsWhileZooming) || D) && (u[B.key] = B),
                                    D = M.wasRequested(),
                                    U)
                                        break
                                }
                            }
                        }
                        return u
                    }
                    _updateLoadedParentTileCache() {
                        this._loadedParentTiles = {};
                        for (const e in this._tiles) {
                            const n = [];
                            let s, u = this._tiles[e].tileID;
                            for (; u.overscaledZ > 0; ) {
                                if (u.key in this._loadedParentTiles) {
                                    s = this._loadedParentTiles[u.key];
                                    break
                                }
                                n.push(u.key);
                                const d = u.scaledTo(u.overscaledZ - 1);
                                if (s = this._getLoadedTile(d),
                                s)
                                    break;
                                u = d
                            }
                            for (const d of n)
                                this._loadedParentTiles[d] = s
                        }
                    }
                    _updateLoadedSiblingTileCache() {
                        this._loadedSiblingTiles = {};
                        for (const e in this._tiles) {
                            const n = this._tiles[e].tileID
                              , s = this._getLoadedTile(n);
                            this._loadedSiblingTiles[n.key] = s
                        }
                    }
                    _addTile(e) {
                        let n = this._tiles[e.key];
                        if (n)
                            return n;
                        n = this._cache.getAndRemove(e),
                        n && (this._setTileReloadTimer(e.key, n),
                        n.tileID = e,
                        this._state.initializeTileState(n, this.map ? this.map.painter : null),
                        this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]),
                        delete this._cacheTimers[e.key],
                        this._setTileReloadTimer(e.key, n)));
                        const s = n;
                        return n || (n = new Nr(e,this._source.tileSize * e.overscaleFactor()),
                        this._loadTile(n, e.key, n.state)),
                        n.uses++,
                        this._tiles[e.key] = n,
                        s || this._source.fire(new o.l("dataloading",{
                            tile: n,
                            coord: n.tileID,
                            dataType: "source"
                        })),
                        n
                    }
                    _setTileReloadTimer(e, n) {
                        e in this._timers && (clearTimeout(this._timers[e]),
                        delete this._timers[e]);
                        const s = n.getExpiryTimeout();
                        s && (this._timers[e] = setTimeout(( () => {
                            this._reloadTile(e, "expired"),
                            delete this._timers[e]
                        }
                        ), s))
                    }
                    refreshTiles(e) {
                        for (const n in this._tiles)
                            (this._isIdRenderable(n) || this._tiles[n].state == "errored") && e.some((s => s.equals(this._tiles[n].tileID.canonical))) && this._reloadTile(n, "expired")
                    }
                    _removeTile(e) {
                        const n = this._tiles[e];
                        n && (n.uses--,
                        delete this._tiles[e],
                        this._timers[e] && (clearTimeout(this._timers[e]),
                        delete this._timers[e]),
                        n.uses > 0 || (n.hasData() && n.state !== "reloading" ? this._cache.add(n.tileID, n, n.getExpiryTimeout()) : (n.aborted = !0,
                        this._abortTile(n),
                        this._unloadTile(n))))
                    }
                    _dataHandler(e) {
                        const n = e.sourceDataType;
                        e.dataType === "source" && n === "metadata" && (this._sourceLoaded = !0),
                        this._sourceLoaded && !this._paused && e.dataType === "source" && n === "content" && (this.reload(e.sourceDataChanged),
                        this.transform && this.update(this.transform, this.terrain),
                        this._didEmitContent = !0)
                    }
                    clearTiles() {
                        this._shouldReloadOnResume = !1,
                        this._paused = !1;
                        for (const e in this._tiles)
                            this._removeTile(e);
                        this._cache.reset()
                    }
                    tilesIn(e, n, s) {
                        const u = []
                          , d = this.transform;
                        if (!d)
                            return u;
                        const m = d.getCoveringTilesDetailsProvider().allowWorldCopies()
                          , y = s ? d.getCameraQueryGeometry(e) : e
                          , w = B => d.screenPointToMercatorCoordinate(B, this.terrain)
                          , P = this.transformBbox(e, w, !m)
                          , M = this.transformBbox(y, w, !m)
                          , D = this.getIds()
                          , z = o.a2.fromPoints(M);
                        for (let B = 0; B < D.length; B++) {
                            const U = this._tiles[D[B]];
                            if (U.holdingForFade())
                                continue;
                            const ee = m ? [U.tileID] : [U.tileID.unwrapTo(-1), U.tileID.unwrapTo(0)]
                              , J = Math.pow(2, d.zoom - U.tileID.overscaledZ)
                              , re = n * U.queryPadding * o.$ / U.tileSize / J;
                            for (const se of ee) {
                                const de = z.map((ue => se.getTilePoint(new o.a1(ue.x,ue.y))));
                                if (de.expandBy(re),
                                de.intersects(At)) {
                                    const ue = P.map((Te => se.getTilePoint(Te)))
                                      , ge = M.map((Te => se.getTilePoint(Te)));
                                    u.push({
                                        tile: U,
                                        tileID: m ? se : se.unwrapTo(0),
                                        queryGeometry: ue,
                                        cameraQueryGeometry: ge,
                                        scale: J
                                    })
                                }
                            }
                        }
                        return u
                    }
                    transformBbox(e, n, s) {
                        let u = e.map(n);
                        if (s) {
                            const d = o.a2.fromPoints(e);
                            d.shrinkBy(.001 * Math.min(d.width(), d.height()));
                            const m = d.map(n);
                            o.a2.fromPoints(u).covers(m) || (u = u.map((y => y.x > .5 ? new o.a1(y.x - 1,y.y,y.z) : y)))
                        }
                        return u
                    }
                    getVisibleCoordinates(e) {
                        const n = this.getRenderableIds(e).map((s => this._tiles[s].tileID));
                        return this.transform && this.transform.populateCache(n),
                        n
                    }
                    hasTransition() {
                        if (this._source.hasTransition())
                            return !0;
                        if (Wt(this._source.type)) {
                            const e = ye.now();
                            for (const n in this._tiles)
                                if (this._tiles[n].fadeEndTime >= e)
                                    return !0
                        }
                        return !1
                    }
                    setFeatureState(e, n, s) {
                        this._state.updateState(e = e || "_geojsonTileLayer", n, s)
                    }
                    removeFeatureState(e, n, s) {
                        this._state.removeFeatureState(e = e || "_geojsonTileLayer", n, s)
                    }
                    getFeatureState(e, n) {
                        return this._state.getState(e = e || "_geojsonTileLayer", n)
                    }
                    setDependencies(e, n, s) {
                        const u = this._tiles[e];
                        u && u.setDependencies(n, s)
                    }
                    reloadTilesForDependencies(e, n) {
                        for (const s in this._tiles)
                            this._tiles[s].hasDependency(e, n) && this._reloadTile(s, "reloading");
                        this._cache.filter((s => !s.hasDependency(e, n)))
                    }
                }
                function kt(h, e) {
                    const n = Math.abs(2 * h.wrap) - +(h.wrap < 0)
                      , s = Math.abs(2 * e.wrap) - +(e.wrap < 0);
                    return h.overscaledZ - e.overscaledZ || s - n || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x
                }
                function Wt(h) {
                    return h === "raster" || h === "image" || h === "video"
                }
                Pt.maxOverzooming = 10,
                Pt.maxUnderzooming = 3;
                class Lr {
                    constructor(e, n) {
                        this.reset(e, n)
                    }
                    reset(e, n) {
                        this.points = e || [],
                        this._distances = [0];
                        for (let s = 1; s < this.points.length; s++)
                            this._distances[s] = this._distances[s - 1] + this.points[s].dist(this.points[s - 1]);
                        this.length = this._distances[this._distances.length - 1],
                        this.padding = Math.min(n || 0, .5 * this.length),
                        this.paddedLength = this.length - 2 * this.padding
                    }
                    lerp(e) {
                        if (this.points.length === 1)
                            return this.points[0];
                        e = o.ah(e, 0, 1);
                        let n = 1
                          , s = this._distances[n];
                        const u = e * this.paddedLength + this.padding;
                        for (; s < u && n < this._distances.length; )
                            s = this._distances[++n];
                        const d = n - 1
                          , m = this._distances[d]
                          , y = s - m
                          , w = y > 0 ? (u - m) / y : 0;
                        return this.points[d].mult(1 - w).add(this.points[n].mult(w))
                    }
                }
                function Kr(h, e) {
                    let n = !0;
                    return h === "always" || h !== "never" && e !== "never" || (n = !1),
                    n
                }
                class Hr {
                    constructor(e, n, s) {
                        const u = this.boxCells = []
                          , d = this.circleCells = [];
                        this.xCellCount = Math.ceil(e / s),
                        this.yCellCount = Math.ceil(n / s);
                        for (let m = 0; m < this.xCellCount * this.yCellCount; m++)
                            u.push([]),
                            d.push([]);
                        this.circleKeys = [],
                        this.boxKeys = [],
                        this.bboxes = [],
                        this.circles = [],
                        this.width = e,
                        this.height = n,
                        this.xScale = this.xCellCount / e,
                        this.yScale = this.yCellCount / n,
                        this.boxUid = 0,
                        this.circleUid = 0
                    }
                    keysLength() {
                        return this.boxKeys.length + this.circleKeys.length
                    }
                    insert(e, n, s, u, d) {
                        this._forEachCell(n, s, u, d, this._insertBoxCell, this.boxUid++),
                        this.boxKeys.push(e),
                        this.bboxes.push(n),
                        this.bboxes.push(s),
                        this.bboxes.push(u),
                        this.bboxes.push(d)
                    }
                    insertCircle(e, n, s, u) {
                        this._forEachCell(n - u, s - u, n + u, s + u, this._insertCircleCell, this.circleUid++),
                        this.circleKeys.push(e),
                        this.circles.push(n),
                        this.circles.push(s),
                        this.circles.push(u)
                    }
                    _insertBoxCell(e, n, s, u, d, m) {
                        this.boxCells[d].push(m)
                    }
                    _insertCircleCell(e, n, s, u, d, m) {
                        this.circleCells[d].push(m)
                    }
                    _query(e, n, s, u, d, m, y) {
                        if (s < 0 || e > this.width || u < 0 || n > this.height)
                            return [];
                        const w = [];
                        if (e <= 0 && n <= 0 && this.width <= s && this.height <= u) {
                            if (d)
                                return [{
                                    key: null,
                                    x1: e,
                                    y1: n,
                                    x2: s,
                                    y2: u
                                }];
                            for (let P = 0; P < this.boxKeys.length; P++)
                                w.push({
                                    key: this.boxKeys[P],
                                    x1: this.bboxes[4 * P],
                                    y1: this.bboxes[4 * P + 1],
                                    x2: this.bboxes[4 * P + 2],
                                    y2: this.bboxes[4 * P + 3]
                                });
                            for (let P = 0; P < this.circleKeys.length; P++) {
                                const M = this.circles[3 * P]
                                  , D = this.circles[3 * P + 1]
                                  , z = this.circles[3 * P + 2];
                                w.push({
                                    key: this.circleKeys[P],
                                    x1: M - z,
                                    y1: D - z,
                                    x2: M + z,
                                    y2: D + z
                                })
                            }
                        } else
                            this._forEachCell(e, n, s, u, this._queryCell, w, {
                                hitTest: d,
                                overlapMode: m,
                                seenUids: {
                                    box: {},
                                    circle: {}
                                }
                            }, y);
                        return w
                    }
                    query(e, n, s, u) {
                        return this._query(e, n, s, u, !1, null)
                    }
                    hitTest(e, n, s, u, d, m) {
                        return this._query(e, n, s, u, !0, d, m).length > 0
                    }
                    hitTestCircle(e, n, s, u, d) {
                        const m = e - s
                          , y = e + s
                          , w = n - s
                          , P = n + s;
                        if (y < 0 || m > this.width || P < 0 || w > this.height)
                            return !1;
                        const M = [];
                        return this._forEachCell(m, w, y, P, this._queryCellCircle, M, {
                            hitTest: !0,
                            overlapMode: u,
                            circle: {
                                x: e,
                                y: n,
                                radius: s
                            },
                            seenUids: {
                                box: {},
                                circle: {}
                            }
                        }, d),
                        M.length > 0
                    }
                    _queryCell(e, n, s, u, d, m, y, w) {
                        const {seenUids: P, hitTest: M, overlapMode: D} = y
                          , z = this.boxCells[d];
                        if (z !== null) {
                            const U = this.bboxes;
                            for (const ee of z)
                                if (!P.box[ee]) {
                                    P.box[ee] = !0;
                                    const J = 4 * ee
                                      , re = this.boxKeys[ee];
                                    if (e <= U[J + 2] && n <= U[J + 3] && s >= U[J + 0] && u >= U[J + 1] && (!w || w(re)) && (!M || !Kr(D, re.overlapMode)) && (m.push({
                                        key: re,
                                        x1: U[J],
                                        y1: U[J + 1],
                                        x2: U[J + 2],
                                        y2: U[J + 3]
                                    }),
                                    M))
                                        return !0
                                }
                        }
                        const B = this.circleCells[d];
                        if (B !== null) {
                            const U = this.circles;
                            for (const ee of B)
                                if (!P.circle[ee]) {
                                    P.circle[ee] = !0;
                                    const J = 3 * ee
                                      , re = this.circleKeys[ee];
                                    if (this._circleAndRectCollide(U[J], U[J + 1], U[J + 2], e, n, s, u) && (!w || w(re)) && (!M || !Kr(D, re.overlapMode))) {
                                        const se = U[J]
                                          , de = U[J + 1]
                                          , ue = U[J + 2];
                                        if (m.push({
                                            key: re,
                                            x1: se - ue,
                                            y1: de - ue,
                                            x2: se + ue,
                                            y2: de + ue
                                        }),
                                        M)
                                            return !0
                                    }
                                }
                        }
                        return !1
                    }
                    _queryCellCircle(e, n, s, u, d, m, y, w) {
                        const {circle: P, seenUids: M, overlapMode: D} = y
                          , z = this.boxCells[d];
                        if (z !== null) {
                            const U = this.bboxes;
                            for (const ee of z)
                                if (!M.box[ee]) {
                                    M.box[ee] = !0;
                                    const J = 4 * ee
                                      , re = this.boxKeys[ee];
                                    if (this._circleAndRectCollide(P.x, P.y, P.radius, U[J + 0], U[J + 1], U[J + 2], U[J + 3]) && (!w || w(re)) && !Kr(D, re.overlapMode))
                                        return m.push(!0),
                                        !0
                                }
                        }
                        const B = this.circleCells[d];
                        if (B !== null) {
                            const U = this.circles;
                            for (const ee of B)
                                if (!M.circle[ee]) {
                                    M.circle[ee] = !0;
                                    const J = 3 * ee
                                      , re = this.circleKeys[ee];
                                    if (this._circlesCollide(U[J], U[J + 1], U[J + 2], P.x, P.y, P.radius) && (!w || w(re)) && !Kr(D, re.overlapMode))
                                        return m.push(!0),
                                        !0
                                }
                        }
                    }
                    _forEachCell(e, n, s, u, d, m, y, w) {
                        const P = this._convertToXCellCoord(e)
                          , M = this._convertToYCellCoord(n)
                          , D = this._convertToXCellCoord(s)
                          , z = this._convertToYCellCoord(u);
                        for (let B = P; B <= D; B++)
                            for (let U = M; U <= z; U++)
                                if (d.call(this, e, n, s, u, this.xCellCount * U + B, m, y, w))
                                    return
                    }
                    _convertToXCellCoord(e) {
                        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
                    }
                    _convertToYCellCoord(e) {
                        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
                    }
                    _circlesCollide(e, n, s, u, d, m) {
                        const y = u - e
                          , w = d - n
                          , P = s + m;
                        return P * P > y * y + w * w
                    }
                    _circleAndRectCollide(e, n, s, u, d, m, y) {
                        const w = (m - u) / 2
                          , P = Math.abs(e - (u + w));
                        if (P > w + s)
                            return !1;
                        const M = (y - d) / 2
                          , D = Math.abs(n - (d + M));
                        if (D > M + s)
                            return !1;
                        if (P <= w || D <= M)
                            return !0;
                        const z = P - w
                          , B = D - M;
                        return z * z + B * B <= s * s
                    }
                }
                function $r(h, e, n) {
                    const s = o.L();
                    if (!h) {
                        const {vecSouth: D, vecEast: z} = gr(e)
                          , B = W();
                        B[0] = z[0],
                        B[1] = z[1],
                        B[2] = D[0],
                        B[3] = D[1],
                        u = B,
                        (M = (m = (d = B)[0]) * (P = d[3]) - (w = d[2]) * (y = d[1])) && (u[0] = P * (M = 1 / M),
                        u[1] = -y * M,
                        u[2] = -w * M,
                        u[3] = m * M),
                        s[0] = B[0],
                        s[1] = B[1],
                        s[4] = B[2],
                        s[5] = B[3]
                    }
                    var u, d, m, y, w, P, M;
                    return o.N(s, s, [1 / n, 1 / n, 1]),
                    s
                }
                function mr(h, e, n, s) {
                    if (h) {
                        const u = o.L();
                        if (!e) {
                            const {vecSouth: d, vecEast: m} = gr(n);
                            u[0] = m[0],
                            u[1] = m[1],
                            u[4] = d[0],
                            u[5] = d[1]
                        }
                        return o.N(u, u, [s, s, 1]),
                        u
                    }
                    return n.pixelsToClipSpaceMatrix
                }
                function gr(h) {
                    const e = Math.cos(h.rollInRadians)
                      , n = Math.sin(h.rollInRadians)
                      , s = Math.cos(h.pitchInRadians)
                      , u = Math.cos(h.bearingInRadians)
                      , d = Math.sin(h.bearingInRadians)
                      , m = o.ar();
                    m[0] = -u * s * n - d * e,
                    m[1] = -d * s * n + u * e;
                    const y = o.as(m);
                    y < 1e-9 ? o.at(m) : o.au(m, m, 1 / y);
                    const w = o.ar();
                    w[0] = u * s * e - d * n,
                    w[1] = d * s * e + u * n;
                    const P = o.as(w);
                    return P < 1e-9 ? o.at(w) : o.au(w, w, 1 / P),
                    {
                        vecEast: w,
                        vecSouth: m
                    }
                }
                function ai(h, e, n, s) {
                    let u;
                    s ? (u = [h, e, s(h, e), 1],
                    o.aw(u, u, n)) : (u = [h, e, 0, 1],
                    Li(u, u, n));
                    const d = u[3];
                    return {
                        point: new o.P(u[0] / d,u[1] / d),
                        signedDistanceFromCamera: d,
                        isOccluded: !1
                    }
                }
                function Tt(h, e) {
                    return .5 + h / e * .5
                }
                function Ci(h, e) {
                    return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
                }
                function di(h, e, n, s, u, d, m, y, w, P, M, D, z) {
                    const B = n ? h.textSizeData : h.iconSizeData
                      , U = o.an(B, e.transform.zoom)
                      , ee = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1]
                      , J = n ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
                    J.clear();
                    const re = h.lineVertexArray
                      , se = n ? h.text.placedSymbolArray : h.icon.placedSymbolArray
                      , de = e.transform.width / e.transform.height;
                    let ue = !1;
                    for (let ge = 0; ge < se.length; ge++) {
                        const Te = se.get(ge);
                        if (Te.hidden || Te.writingMode === o.ao.vertical && !ue) {
                            mi(Te.numGlyphs, J);
                            continue
                        }
                        ue = !1;
                        const he = new o.P(Te.anchorX,Te.anchorY)
                          , De = {
                            getElevation: z,
                            pitchedLabelPlaneMatrix: s,
                            lineVertexArray: re,
                            pitchWithMap: d,
                            projectionCache: {
                                projections: {},
                                offsets: {},
                                cachedAnchorPoint: void 0,
                                anyProjectionOccluded: !1
                            },
                            transform: e.transform,
                            tileAnchorPoint: he,
                            unwrappedTileID: w,
                            width: P,
                            height: M,
                            translation: D
                        }
                          , He = li(Te.anchorX, Te.anchorY, De);
                        if (!Ci(He.point, ee)) {
                            mi(Te.numGlyphs, J);
                            continue
                        }
                        const je = Tt(e.transform.cameraToCenterDistance, He.signedDistanceFromCamera)
                          , qe = o.ap(B, U, Te)
                          , $e = d ? qe * e.transform.getPitchedTextCorrection(Te.anchorX, Te.anchorY, w) / je : qe * je
                          , Rt = Ke({
                            projectionContext: De,
                            pitchedLabelPlaneMatrixInverse: u,
                            symbol: Te,
                            fontSize: $e,
                            flip: !1,
                            keepUpright: m,
                            glyphOffsetArray: h.glyphOffsetArray,
                            dynamicLayoutVertexArray: J,
                            aspectRatio: de,
                            rotateToLine: y
                        });
                        ue = Rt.useVertical,
                        (Rt.notEnoughRoom || ue || Rt.needsFlipping && Ke({
                            projectionContext: De,
                            pitchedLabelPlaneMatrixInverse: u,
                            symbol: Te,
                            fontSize: $e,
                            flip: !0,
                            keepUpright: m,
                            glyphOffsetArray: h.glyphOffsetArray,
                            dynamicLayoutVertexArray: J,
                            aspectRatio: de,
                            rotateToLine: y
                        }).notEnoughRoom) && mi(Te.numGlyphs, J)
                    }
                    n ? h.text.dynamicLayoutVertexBuffer.updateData(J) : h.icon.dynamicLayoutVertexBuffer.updateData(J)
                }
                function Pn(h, e, n, s, u, d, m, y) {
                    const w = d.glyphStartIndex + d.numGlyphs
                      , P = d.lineStartIndex
                      , M = d.lineStartIndex + d.lineLength
                      , D = e.getoffsetX(d.glyphStartIndex)
                      , z = e.getoffsetX(w - 1)
                      , B = Si(h * D, n, s, u, d.segment, P, M, y, m);
                    if (!B)
                        return null;
                    const U = Si(h * z, n, s, u, d.segment, P, M, y, m);
                    return U ? y.projectionCache.anyProjectionOccluded ? null : {
                        first: B,
                        last: U
                    } : null
                }
                function Mt(h, e, n, s) {
                    return h === o.ao.horizontal && Math.abs(n.y - e.y) > Math.abs(n.x - e.x) * s ? {
                        useVertical: !0
                    } : (h === o.ao.vertical ? e.y < n.y : e.x > n.x) ? {
                        needsFlipping: !0
                    } : null
                }
                function Ke(h) {
                    const {projectionContext: e, pitchedLabelPlaneMatrixInverse: n, symbol: s, fontSize: u, flip: d, keepUpright: m, glyphOffsetArray: y, dynamicLayoutVertexArray: w, aspectRatio: P, rotateToLine: M} = h
                      , D = u / 24
                      , z = s.lineOffsetX * D
                      , B = s.lineOffsetY * D;
                    let U;
                    if (s.numGlyphs > 1) {
                        const ee = s.glyphStartIndex + s.numGlyphs
                          , J = s.lineStartIndex
                          , re = s.lineStartIndex + s.lineLength
                          , se = Pn(D, y, z, B, d, s, M, e);
                        if (!se)
                            return {
                                notEnoughRoom: !0
                            };
                        const de = Gr(se.first.point.x, se.first.point.y, e, n)
                          , ue = Gr(se.last.point.x, se.last.point.y, e, n);
                        if (m && !d) {
                            const ge = Mt(s.writingMode, de, ue, P);
                            if (ge)
                                return ge
                        }
                        U = [se.first];
                        for (let ge = s.glyphStartIndex + 1; ge < ee - 1; ge++) {
                            const Te = Si(D * y.getoffsetX(ge), z, B, d, s.segment, J, re, e, M);
                            if (!Te)
                                return {
                                    notEnoughRoom: !0
                                };
                            U.push(Te)
                        }
                        U.push(se.last)
                    } else {
                        if (m && !d) {
                            const J = Dr(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point
                              , re = s.lineStartIndex + s.segment + 1
                              , se = new o.P(e.lineVertexArray.getx(re),e.lineVertexArray.gety(re))
                              , de = Dr(se.x, se.y, e)
                              , ue = de.signedDistanceFromCamera > 0 ? de.point : jt(e.tileAnchorPoint, se, J, 1, e)
                              , ge = Gr(J.x, J.y, e, n)
                              , Te = Gr(ue.x, ue.y, e, n)
                              , he = Mt(s.writingMode, ge, Te, P);
                            if (he)
                                return he
                        }
                        const ee = Si(D * y.getoffsetX(s.glyphStartIndex), z, B, d, s.segment, s.lineStartIndex, s.lineStartIndex + s.lineLength, e, M);
                        if (!ee || e.projectionCache.anyProjectionOccluded)
                            return {
                                notEnoughRoom: !0
                            };
                        U = [ee]
                    }
                    for (const ee of U)
                        o.av(w, ee.point, ee.angle);
                    return {}
                }
                function jt(h, e, n, s, u) {
                    const d = h.add(h.sub(e)._unit())
                      , m = Dr(d.x, d.y, u).point
                      , y = n.sub(m);
                    return n.add(y._mult(s / y.mag()))
                }
                function Gt(h, e, n) {
                    const s = e.projectionCache;
                    if (s.projections[h])
                        return s.projections[h];
                    const u = new o.P(e.lineVertexArray.getx(h),e.lineVertexArray.gety(h))
                      , d = Dr(u.x, u.y, e);
                    if (d.signedDistanceFromCamera > 0)
                        return s.projections[h] = d.point,
                        s.anyProjectionOccluded = s.anyProjectionOccluded || d.isOccluded,
                        d.point;
                    const m = h - n.direction;
                    return jt(n.distanceFromAnchor === 0 ? e.tileAnchorPoint : new o.P(e.lineVertexArray.getx(m),e.lineVertexArray.gety(m)), u, n.previousVertex, n.absOffsetX - n.distanceFromAnchor + 1, e)
                }
                function Dr(h, e, n) {
                    const s = h + n.translation[0]
                      , u = e + n.translation[1];
                    let d;
                    return n.pitchWithMap ? (d = ai(s, u, n.pitchedLabelPlaneMatrix, n.getElevation),
                    d.isOccluded = !1) : (d = n.transform.projectTileCoordinates(s, u, n.unwrappedTileID, n.getElevation),
                    d.point.x = (.5 * d.point.x + .5) * n.width,
                    d.point.y = (.5 * -d.point.y + .5) * n.height),
                    d
                }
                function Gr(h, e, n, s) {
                    if (n.pitchWithMap) {
                        const u = [h, e, 0, 1];
                        return o.aw(u, u, s),
                        n.transform.projectTileCoordinates(u[0] / u[3], u[1] / u[3], n.unwrappedTileID, n.getElevation).point
                    }
                    return {
                        x: h / n.width * 2 - 1,
                        y: 1 - e / n.height * 2
                    }
                }
                function li(h, e, n) {
                    return n.transform.projectTileCoordinates(h, e, n.unwrappedTileID, n.getElevation)
                }
                function fr(h, e, n) {
                    return h._unit()._perp()._mult(e * n)
                }
                function bi(h, e, n, s, u, d, m, y, w) {
                    if (y.projectionCache.offsets[h])
                        return y.projectionCache.offsets[h];
                    const P = n.add(e);
                    if (h + w.direction < s || h + w.direction >= u)
                        return y.projectionCache.offsets[h] = P,
                        P;
                    const M = Gt(h + w.direction, y, w)
                      , D = fr(M.sub(n), m, w.direction)
                      , z = n.add(D)
                      , B = M.add(D);
                    return y.projectionCache.offsets[h] = o.ax(d, P, z, B) || P,
                    y.projectionCache.offsets[h]
                }
                function Si(h, e, n, s, u, d, m, y, w) {
                    const P = s ? h - e : h + e;
                    let M = P > 0 ? 1 : -1
                      , D = 0;
                    s && (M *= -1,
                    D = Math.PI),
                    M < 0 && (D += Math.PI);
                    let z, B = M > 0 ? d + u : d + u + 1;
                    y.projectionCache.cachedAnchorPoint ? z = y.projectionCache.cachedAnchorPoint : (z = Dr(y.tileAnchorPoint.x, y.tileAnchorPoint.y, y).point,
                    y.projectionCache.cachedAnchorPoint = z);
                    let U, ee, J = z, re = z, se = 0, de = 0;
                    const ue = Math.abs(P)
                      , ge = [];
                    let Te;
                    for (; se + de <= ue; ) {
                        if (B += M,
                        B < d || B >= m)
                            return null;
                        se += de,
                        re = J,
                        ee = U;
                        const He = {
                            absOffsetX: ue,
                            direction: M,
                            distanceFromAnchor: se,
                            previousVertex: re
                        };
                        if (J = Gt(B, y, He),
                        n === 0)
                            ge.push(re),
                            Te = J.sub(re);
                        else {
                            let je;
                            const qe = J.sub(re);
                            je = qe.mag() === 0 ? fr(Gt(B + M, y, He).sub(J), n, M) : fr(qe, n, M),
                            ee || (ee = re.add(je)),
                            U = bi(B, je, J, d, m, ee, n, y, He),
                            ge.push(ee),
                            Te = U.sub(ee)
                        }
                        de = Te.mag()
                    }
                    const he = Te._mult((ue - se) / de)._add(ee || re)
                      , De = D + Math.atan2(J.y - re.y, J.x - re.x);
                    return ge.push(he),
                    {
                        point: he,
                        angle: w ? De : 0,
                        path: ge
                    }
                }
                const zi = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
                function mi(h, e) {
                    for (let n = 0; n < h; n++) {
                        const s = e.length;
                        e.resize(s + 4),
                        e.float32.set(zi, 3 * s)
                    }
                }
                function Li(h, e, n) {
                    const s = e[0]
                      , u = e[1];
                    return h[0] = n[0] * s + n[4] * u + n[12],
                    h[1] = n[1] * s + n[5] * u + n[13],
                    h[3] = n[3] * s + n[7] * u + n[15],
                    h
                }
                const rr = 100;
                class yi {
                    constructor(e, n=new Hr(e.width + 200,e.height + 200,25), s=new Hr(e.width + 200,e.height + 200,25)) {
                        this.transform = e,
                        this.grid = n,
                        this.ignoredGrid = s,
                        this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance,
                        this.screenRightBoundary = e.width + rr,
                        this.screenBottomBoundary = e.height + rr,
                        this.gridRightBoundary = e.width + 200,
                        this.gridBottomBoundary = e.height + 200,
                        this.perspectiveRatioCutoff = .6
                    }
                    placeCollisionBox(e, n, s, u, d, m, y, w, P, M, D, z) {
                        const B = this.projectAndGetPerspectiveRatio(e.anchorPointX + w[0], e.anchorPointY + w[1], d, M, z)
                          , U = s * B.perspectiveRatio;
                        let ee;
                        if (m || y)
                            ee = this._projectCollisionBox(e, U, u, d, m, y, w, B, M, D, z);
                        else {
                            const Te = B.x + (D ? D.x * U : 0)
                              , he = B.y + (D ? D.y * U : 0);
                            ee = {
                                allPointsOccluded: !1,
                                box: [Te + e.x1 * U, he + e.y1 * U, Te + e.x2 * U, he + e.y2 * U]
                            }
                        }
                        const [J,re,se,de] = ee.box
                          , ue = m ? ee.allPointsOccluded : B.isOccluded;
                        let ge = ue;
                        return ge || (ge = B.perspectiveRatio < this.perspectiveRatioCutoff),
                        ge || (ge = !this.isInsideGrid(J, re, se, de)),
                        ge || n !== "always" && this.grid.hitTest(J, re, se, de, n, P) ? {
                            box: [J, re, se, de],
                            placeable: !1,
                            offscreen: !1,
                            occluded: ue
                        } : {
                            box: [J, re, se, de],
                            placeable: !0,
                            offscreen: this.isOffscreen(J, re, se, de),
                            occluded: ue
                        }
                    }
                    placeCollisionCircles(e, n, s, u, d, m, y, w, P, M, D, z, B, U) {
                        const ee = []
                          , J = new o.P(n.anchorX,n.anchorY)
                          , re = this.getPerspectiveRatio(J.x, J.y, m, U)
                          , se = (P ? d * this.transform.getPitchedTextCorrection(n.anchorX, n.anchorY, m) / re : d * re) / o.aB
                          , de = {
                            getElevation: U,
                            pitchedLabelPlaneMatrix: y,
                            lineVertexArray: s,
                            pitchWithMap: P,
                            projectionCache: {
                                projections: {},
                                offsets: {},
                                cachedAnchorPoint: void 0,
                                anyProjectionOccluded: !1
                            },
                            transform: this.transform,
                            tileAnchorPoint: J,
                            unwrappedTileID: m,
                            width: this.transform.width,
                            height: this.transform.height,
                            translation: B
                        }
                          , ue = Pn(se, u, n.lineOffsetX * se, n.lineOffsetY * se, !1, n, !1, de);
                        let ge = !1
                          , Te = !1
                          , he = !0;
                        if (ue) {
                            const De = .5 * D * re + z
                              , He = new o.P(-100,-100)
                              , je = new o.P(this.screenRightBoundary,this.screenBottomBoundary)
                              , qe = new Lr
                              , $e = ue.first
                              , Rt = ue.last;
                            let Nt = [];
                            for (let Xr = $e.path.length - 1; Xr >= 1; Xr--)
                                Nt.push($e.path[Xr]);
                            for (let Xr = 1; Xr < Rt.path.length; Xr++)
                                Nt.push(Rt.path[Xr]);
                            const yt = 2.5 * De;
                            if (P) {
                                const Xr = this.projectPathToScreenSpace(Nt, de);
                                Nt = Xr.some((xi => xi.signedDistanceFromCamera <= 0)) ? [] : Xr.map((xi => xi.point))
                            }
                            let sr = [];
                            if (Nt.length > 0) {
                                const Xr = Nt[0].clone()
                                  , xi = Nt[0].clone();
                                for (let ki = 1; ki < Nt.length; ki++)
                                    Xr.x = Math.min(Xr.x, Nt[ki].x),
                                    Xr.y = Math.min(Xr.y, Nt[ki].y),
                                    xi.x = Math.max(xi.x, Nt[ki].x),
                                    xi.y = Math.max(xi.y, Nt[ki].y);
                                sr = Xr.x >= He.x && xi.x <= je.x && Xr.y >= He.y && xi.y <= je.y ? [Nt] : xi.x < He.x || Xr.x > je.x || xi.y < He.y || Xr.y > je.y ? [] : o.ay([Nt], He.x, He.y, je.x, je.y)
                            }
                            for (const Xr of sr) {
                                qe.reset(Xr, .25 * De);
                                let xi = 0;
                                xi = qe.length <= .5 * De ? 1 : Math.ceil(qe.paddedLength / yt) + 1;
                                for (let ki = 0; ki < xi; ki++) {
                                    const Pi = ki / Math.max(xi - 1, 1)
                                      , ji = qe.lerp(Pi)
                                      , Ui = ji.x + rr
                                      , Wr = ji.y + rr;
                                    ee.push(Ui, Wr, De, 0);
                                    const Ei = Ui - De
                                      , Qi = Wr - De
                                      , dn = Ui + De
                                      , xn = Wr + De;
                                    if (he = he && this.isOffscreen(Ei, Qi, dn, xn),
                                    Te = Te || this.isInsideGrid(Ei, Qi, dn, xn),
                                    e !== "always" && this.grid.hitTestCircle(Ui, Wr, De, e, M) && (ge = !0,
                                    !w))
                                        return {
                                            circles: [],
                                            offscreen: !1,
                                            collisionDetected: ge
                                        }
                                }
                            }
                        }
                        return {
                            circles: !w && ge || !Te || re < this.perspectiveRatioCutoff ? [] : ee,
                            offscreen: he,
                            collisionDetected: ge
                        }
                    }
                    projectPathToScreenSpace(e, n) {
                        const s = (function(u, d) {
                            const m = o.L();
                            return o.aq(m, d.pitchedLabelPlaneMatrix),
                            u.map((y => {
                                const w = ai(y.x, y.y, m, d.getElevation)
                                  , P = d.transform.projectTileCoordinates(w.point.x, w.point.y, d.unwrappedTileID, d.getElevation);
                                return P.point.x = (.5 * P.point.x + .5) * d.width,
                                P.point.y = (.5 * -P.point.y + .5) * d.height,
                                P
                            }
                            ))
                        }
                        )(e, n);
                        return (function(u) {
                            let d = 0
                              , m = 0
                              , y = 0
                              , w = 0;
                            for (let P = 0; P < u.length; P++)
                                u[P].isOccluded ? (y = P + 1,
                                w = 0) : (w++,
                                w > m && (m = w,
                                d = y));
                            return u.slice(d, d + m)
                        }
                        )(s)
                    }
                    queryRenderedSymbols(e) {
                        if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
                            return {};
                        const n = []
                          , s = new o.a2;
                        for (const D of e) {
                            const z = new o.P(D.x + rr,D.y + rr);
                            s.extend(z),
                            n.push(z)
                        }
                        const {minX: u, minY: d, maxX: m, maxY: y} = s
                          , w = this.grid.query(u, d, m, y).concat(this.ignoredGrid.query(u, d, m, y))
                          , P = {}
                          , M = {};
                        for (const D of w) {
                            const z = D.key;
                            if (P[z.bucketInstanceId] === void 0 && (P[z.bucketInstanceId] = {}),
                            P[z.bucketInstanceId][z.featureIndex])
                                continue;
                            const B = [new o.P(D.x1,D.y1), new o.P(D.x2,D.y1), new o.P(D.x2,D.y2), new o.P(D.x1,D.y2)];
                            o.az(n, B) && (P[z.bucketInstanceId][z.featureIndex] = !0,
                            M[z.bucketInstanceId] === void 0 && (M[z.bucketInstanceId] = []),
                            M[z.bucketInstanceId].push(z.featureIndex))
                        }
                        return M
                    }
                    insertCollisionBox(e, n, s, u, d, m) {
                        (s ? this.ignoredGrid : this.grid).insert({
                            bucketInstanceId: u,
                            featureIndex: d,
                            collisionGroupID: m,
                            overlapMode: n
                        }, e[0], e[1], e[2], e[3])
                    }
                    insertCollisionCircles(e, n, s, u, d, m) {
                        const y = s ? this.ignoredGrid : this.grid
                          , w = {
                            bucketInstanceId: u,
                            featureIndex: d,
                            collisionGroupID: m,
                            overlapMode: n
                        };
                        for (let P = 0; P < e.length; P += 4)
                            y.insertCircle(w, e[P], e[P + 1], e[P + 2])
                    }
                    projectAndGetPerspectiveRatio(e, n, s, u, d) {
                        if (d) {
                            let m;
                            u ? (m = [e, n, u(e, n), 1],
                            o.aw(m, m, d)) : (m = [e, n, 0, 1],
                            Li(m, m, d));
                            const y = m[3];
                            return {
                                x: (m[0] / y + 1) / 2 * this.transform.width + rr,
                                y: (-m[1] / y + 1) / 2 * this.transform.height + rr,
                                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / y * .5,
                                isOccluded: !1,
                                signedDistanceFromCamera: y
                            }
                        }
                        {
                            const m = this.transform.projectTileCoordinates(e, n, s, u);
                            return {
                                x: (m.point.x + 1) / 2 * this.transform.width + rr,
                                y: (1 - m.point.y) / 2 * this.transform.height + rr,
                                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / m.signedDistanceFromCamera * .5,
                                isOccluded: m.isOccluded,
                                signedDistanceFromCamera: m.signedDistanceFromCamera
                            }
                        }
                    }
                    getPerspectiveRatio(e, n, s, u) {
                        const d = this.transform.projectTileCoordinates(e, n, s, u);
                        return .5 + this.transform.cameraToCenterDistance / d.signedDistanceFromCamera * .5
                    }
                    isOffscreen(e, n, s, u) {
                        return s < rr || e >= this.screenRightBoundary || u < rr || n > this.screenBottomBoundary
                    }
                    isInsideGrid(e, n, s, u) {
                        return s >= 0 && e < this.gridRightBoundary && u >= 0 && n < this.gridBottomBoundary
                    }
                    getViewportMatrix() {
                        const e = o.ag([]);
                        return o.M(e, e, [-100, -100, 0]),
                        e
                    }
                    _projectCollisionBox(e, n, s, u, d, m, y, w, P, M, D) {
                        let z = 1
                          , B = 0
                          , U = 0
                          , ee = 1;
                        const J = e.anchorPointX + y[0]
                          , re = e.anchorPointY + y[1];
                        if (m && !d) {
                            const Nt = this.projectAndGetPerspectiveRatio(J + 1, re, u, P, D)
                              , yt = Nt.x - w.x
                              , sr = Math.atan((Nt.y - w.y) / yt) + (yt < 0 ? Math.PI : 0)
                              , Xr = Math.sin(sr)
                              , xi = Math.cos(sr);
                            z = xi,
                            B = Xr,
                            U = -Xr,
                            ee = xi
                        } else if (!m && d) {
                            const Nt = gr(this.transform);
                            z = Nt.vecEast[0],
                            B = Nt.vecEast[1],
                            U = Nt.vecSouth[0],
                            ee = Nt.vecSouth[1]
                        }
                        let se = w.x
                          , de = w.y
                          , ue = n;
                        d && (se = J,
                        de = re,
                        ue = Math.pow(2, -(this.transform.zoom - s.overscaledZ)),
                        ue *= this.transform.getPitchedTextCorrection(J, re, u),
                        M || (ue *= o.ah(.5 + w.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))),
                        M && (se += z * M.x * ue + U * M.y * ue,
                        de += B * M.x * ue + ee * M.y * ue);
                        const ge = e.x1 * ue
                          , Te = e.x2 * ue
                          , he = (ge + Te) / 2
                          , De = e.y1 * ue
                          , He = e.y2 * ue
                          , je = (De + He) / 2
                          , qe = [{
                            offsetX: ge,
                            offsetY: De
                        }, {
                            offsetX: he,
                            offsetY: De
                        }, {
                            offsetX: Te,
                            offsetY: De
                        }, {
                            offsetX: Te,
                            offsetY: je
                        }, {
                            offsetX: Te,
                            offsetY: He
                        }, {
                            offsetX: he,
                            offsetY: He
                        }, {
                            offsetX: ge,
                            offsetY: He
                        }, {
                            offsetX: ge,
                            offsetY: je
                        }];
                        let $e = [];
                        for (const {offsetX: Nt, offsetY: yt} of qe)
                            $e.push(new o.P(se + z * Nt + U * yt,de + B * Nt + ee * yt));
                        let Rt = !1;
                        if (d) {
                            const Nt = $e.map((yt => this.projectAndGetPerspectiveRatio(yt.x, yt.y, u, P, D)));
                            Rt = Nt.some((yt => !yt.isOccluded)),
                            $e = Nt.map((yt => new o.P(yt.x,yt.y)))
                        } else
                            Rt = !0;
                        return {
                            box: o.aA($e),
                            allPointsOccluded: !Rt
                        }
                    }
                }
                class Qr {
                    constructor(e, n, s, u) {
                        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? n : -n))) : u && s ? 1 : 0,
                        this.placed = s
                    }
                    isHidden() {
                        return this.opacity === 0 && !this.placed
                    }
                }
                class Yr {
                    constructor(e, n, s, u, d) {
                        this.text = new Qr(e ? e.text : null,n,s,d),
                        this.icon = new Qr(e ? e.icon : null,n,u,d)
                    }
                    isHidden() {
                        return this.text.isHidden() && this.icon.isHidden()
                    }
                }
                class la {
                    constructor(e, n, s) {
                        this.text = e,
                        this.icon = n,
                        this.skipFade = s
                    }
                }
                class sn {
                    constructor(e, n, s, u, d) {
                        this.bucketInstanceId = e,
                        this.featureIndex = n,
                        this.sourceLayerIndex = s,
                        this.bucketIndex = u,
                        this.tileID = d
                    }
                }
                class ta {
                    constructor(e) {
                        this.crossSourceCollisions = e,
                        this.maxGroupID = 0,
                        this.collisionGroups = {}
                    }
                    get(e) {
                        if (this.crossSourceCollisions)
                            return {
                                ID: 0,
                                predicate: null
                            };
                        if (!this.collisionGroups[e]) {
                            const n = ++this.maxGroupID;
                            this.collisionGroups[e] = {
                                ID: n,
                                predicate: s => s.collisionGroupID === n
                            }
                        }
                        return this.collisionGroups[e]
                    }
                }
                function Fi(h, e, n, s, u) {
                    const {horizontalAlign: d, verticalAlign: m} = o.aH(h);
                    return new o.P(-(d - .5) * e + s[0] * u,-(m - .5) * n + s[1] * u)
                }
                class Xi {
                    constructor(e, n, s, u, d) {
                        this.transform = e.clone(),
                        this.terrain = n,
                        this.collisionIndex = new yi(this.transform),
                        this.placements = {},
                        this.opacities = {},
                        this.variableOffsets = {},
                        this.stale = !1,
                        this.commitTime = 0,
                        this.fadeDuration = s,
                        this.retainedQueryData = {},
                        this.collisionGroups = new ta(u),
                        this.collisionCircleArrays = {},
                        this.collisionBoxArrays = new Map,
                        this.prevPlacement = d,
                        d && (d.prevPlacement = void 0),
                        this.placedOrientations = {}
                    }
                    _getTerrainElevationFunc(e) {
                        const n = this.terrain;
                        return n ? (s, u) => n.getElevation(e, s, u) : null
                    }
                    getBucketParts(e, n, s, u) {
                        const d = s.getBucket(n)
                          , m = s.latestFeatureIndex;
                        if (!d || !m || n.id !== d.layerIds[0])
                            return;
                        const y = s.collisionBoxArray
                          , w = d.layers[0].layout
                          , P = d.layers[0].paint
                          , M = Math.pow(2, this.transform.zoom - s.tileID.overscaledZ)
                          , D = s.tileSize / o.$
                          , z = s.tileID.toUnwrapped()
                          , B = w.get("text-rotation-alignment") === "map"
                          , U = o.aC(s, 1, this.transform.zoom)
                          , ee = o.aD(this.collisionIndex.transform, s, P.get("text-translate"), P.get("text-translate-anchor"))
                          , J = o.aD(this.collisionIndex.transform, s, P.get("icon-translate"), P.get("icon-translate-anchor"))
                          , re = $r(B, this.transform, U);
                        this.retainedQueryData[d.bucketInstanceId] = new sn(d.bucketInstanceId,m,d.sourceLayerIndex,d.index,s.tileID);
                        const se = {
                            bucket: d,
                            layout: w,
                            translationText: ee,
                            translationIcon: J,
                            unwrappedTileID: z,
                            pitchedLabelPlaneMatrix: re,
                            scale: M,
                            textPixelRatio: D,
                            holdingForFade: s.holdingForFade(),
                            collisionBoxArray: y,
                            partiallyEvaluatedTextSize: o.an(d.textSizeData, this.transform.zoom),
                            collisionGroup: this.collisionGroups.get(d.sourceID)
                        };
                        if (u)
                            for (const de of d.sortKeyRanges) {
                                const {sortKey: ue, symbolInstanceStart: ge, symbolInstanceEnd: Te} = de;
                                e.push({
                                    sortKey: ue,
                                    symbolInstanceStart: ge,
                                    symbolInstanceEnd: Te,
                                    parameters: se
                                })
                            }
                        else
                            e.push({
                                symbolInstanceStart: 0,
                                symbolInstanceEnd: d.symbolInstances.length,
                                parameters: se
                            })
                    }
                    attemptAnchorPlacement(e, n, s, u, d, m, y, w, P, M, D, z, B, U, ee, J, re, se, de, ue) {
                        const ge = o.aE[e.textAnchor]
                          , Te = [e.textOffset0, e.textOffset1]
                          , he = Fi(ge, s, u, Te, d)
                          , De = this.collisionIndex.placeCollisionBox(n, z, w, P, M, y, m, J, D.predicate, de, he, ue);
                        if ((!se || this.collisionIndex.placeCollisionBox(se, z, w, P, M, y, m, re, D.predicate, de, he, ue).placeable) && De.placeable) {
                            let He;
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[B.crossTileID] && this.prevPlacement.placements[B.crossTileID] && this.prevPlacement.placements[B.crossTileID].text && (He = this.prevPlacement.variableOffsets[B.crossTileID].anchor),
                            B.crossTileID === 0)
                                throw new Error("symbolInstance.crossTileID can't be 0");
                            return this.variableOffsets[B.crossTileID] = {
                                textOffset: Te,
                                width: s,
                                height: u,
                                anchor: ge,
                                textBoxScale: d,
                                prevAnchor: He
                            },
                            this.markUsedJustification(U, ge, B, ee),
                            U.allowVerticalPlacement && (this.markUsedOrientation(U, ee, B),
                            this.placedOrientations[B.crossTileID] = ee),
                            {
                                shift: he,
                                placedGlyphBoxes: De
                            }
                        }
                    }
                    placeLayerBucketPart(e, n, s) {
                        const {bucket: u, layout: d, translationText: m, translationIcon: y, unwrappedTileID: w, pitchedLabelPlaneMatrix: P, textPixelRatio: M, holdingForFade: D, collisionBoxArray: z, partiallyEvaluatedTextSize: B, collisionGroup: U} = e.parameters
                          , ee = d.get("text-optional")
                          , J = d.get("icon-optional")
                          , re = o.aF(d, "text-overlap", "text-allow-overlap")
                          , se = re === "always"
                          , de = o.aF(d, "icon-overlap", "icon-allow-overlap")
                          , ue = de === "always"
                          , ge = d.get("text-rotation-alignment") === "map"
                          , Te = d.get("text-pitch-alignment") === "map"
                          , he = d.get("icon-text-fit") !== "none"
                          , De = d.get("symbol-z-order") === "viewport-y"
                          , He = se && (ue || !u.hasIconData() || J)
                          , je = ue && (se || !u.hasTextData() || ee);
                        !u.collisionArrays && z && u.deserializeCollisionBoxes(z);
                        const qe = this.retainedQueryData[u.bucketInstanceId].tileID
                          , $e = this._getTerrainElevationFunc(qe)
                          , Rt = this.transform.getFastPathSimpleProjectionMatrix(qe)
                          , Nt = (yt, sr, Xr) => {
                            var xi, ki;
                            if (n[yt.crossTileID])
                                return;
                            if (D)
                                return void (this.placements[yt.crossTileID] = new la(!1,!1,!1));
                            let Pi = !1
                              , ji = !1
                              , Ui = !0
                              , Wr = null
                              , Ei = {
                                box: null,
                                placeable: !1,
                                offscreen: null,
                                occluded: !1
                            }
                              , Qi = {
                                placeable: !1
                            }
                              , dn = null
                              , xn = null
                              , qn = null
                              , Sa = 0
                              , as = 0
                              , ss = 0;
                            sr.textFeatureIndex ? Sa = sr.textFeatureIndex : yt.useRuntimeCollisionCircles && (Sa = yt.featureIndex),
                            sr.verticalTextFeatureIndex && (as = sr.verticalTextFeatureIndex);
                            const Ys = sr.textBox;
                            if (Ys) {
                                const Kn = en => {
                                    let pn = o.ao.horizontal;
                                    if (u.allowVerticalPlacement && !en && this.prevPlacement) {
                                        const da = this.prevPlacement.placedOrientations[yt.crossTileID];
                                        da && (this.placedOrientations[yt.crossTileID] = da,
                                        pn = da,
                                        this.markUsedOrientation(u, pn, yt))
                                    }
                                    return pn
                                }
                                  , Pa = (en, pn) => {
                                    if (u.allowVerticalPlacement && yt.numVerticalGlyphVertices > 0 && sr.verticalTextBox) {
                                        for (const da of u.writingModes)
                                            if (da === o.ao.vertical ? (Ei = pn(),
                                            Qi = Ei) : Ei = en(),
                                            Ei && Ei.placeable)
                                                break
                                    } else
                                        Ei = en()
                                }
                                  , Vn = yt.textAnchorOffsetStartIndex
                                  , os = yt.textAnchorOffsetEndIndex;
                                if (os === Vn) {
                                    const en = (pn, da) => {
                                        const tn = this.collisionIndex.placeCollisionBox(pn, re, M, qe, w, Te, ge, m, U.predicate, $e, void 0, Rt);
                                        return tn && tn.placeable && (this.markUsedOrientation(u, da, yt),
                                        this.placedOrientations[yt.crossTileID] = da),
                                        tn
                                    }
                                    ;
                                    Pa(( () => en(Ys, o.ao.horizontal)), ( () => {
                                        const pn = sr.verticalTextBox;
                                        return u.allowVerticalPlacement && yt.numVerticalGlyphVertices > 0 && pn ? en(pn, o.ao.vertical) : {
                                            box: null,
                                            offscreen: null
                                        }
                                    }
                                    )),
                                    Kn(Ei && Ei.placeable)
                                } else {
                                    let en = o.aE[(ki = (xi = this.prevPlacement) === null || xi === void 0 ? void 0 : xi.variableOffsets[yt.crossTileID]) === null || ki === void 0 ? void 0 : ki.anchor];
                                    const pn = (tn, Ro, Qs) => {
                                        const Ha = tn.x2 - tn.x1
                                          , Ia = tn.y2 - tn.y1
                                          , ls = yt.textBoxScale
                                          , id = he && de === "never" ? Ro : null;
                                        let ia = null
                                          , nd = re === "never" ? 1 : 2
                                          , tu = "never";
                                        en && nd++;
                                        for (let kl = 0; kl < nd; kl++) {
                                            for (let El = Vn; El < os; El++) {
                                                const cs = u.textAnchorOffsets.get(El);
                                                if (en && cs.textAnchor !== en)
                                                    continue;
                                                const Wa = this.attemptAnchorPlacement(cs, tn, Ha, Ia, ls, ge, Te, M, qe, w, U, tu, yt, u, Qs, m, y, id, $e);
                                                if (Wa && (ia = Wa.placedGlyphBoxes,
                                                ia && ia.placeable))
                                                    return Pi = !0,
                                                    Wr = Wa.shift,
                                                    ia
                                            }
                                            en ? en = null : tu = re
                                        }
                                        return s && !ia && (ia = {
                                            box: this.collisionIndex.placeCollisionBox(Ys, "always", M, qe, w, Te, ge, m, U.predicate, $e, void 0, Rt).box,
                                            offscreen: !1,
                                            placeable: !1,
                                            occluded: !1
                                        }),
                                        ia
                                    }
                                    ;
                                    Pa(( () => pn(Ys, sr.iconBox, o.ao.horizontal)), ( () => {
                                        const tn = sr.verticalTextBox;
                                        return u.allowVerticalPlacement && (!Ei || !Ei.placeable) && yt.numVerticalGlyphVertices > 0 && tn ? pn(tn, sr.verticalIconBox, o.ao.vertical) : {
                                            box: null,
                                            occluded: !0,
                                            offscreen: null
                                        }
                                    }
                                    )),
                                    Ei && (Pi = Ei.placeable,
                                    Ui = Ei.offscreen);
                                    const da = Kn(Ei && Ei.placeable);
                                    if (!Pi && this.prevPlacement) {
                                        const tn = this.prevPlacement.variableOffsets[yt.crossTileID];
                                        tn && (this.variableOffsets[yt.crossTileID] = tn,
                                        this.markUsedJustification(u, tn.anchor, yt, da))
                                    }
                                }
                            }
                            if (dn = Ei,
                            Pi = dn && dn.placeable,
                            Ui = dn && dn.offscreen,
                            yt.useRuntimeCollisionCircles) {
                                const Kn = u.text.placedSymbolArray.get(yt.centerJustifiedTextSymbolIndex)
                                  , Pa = o.ap(u.textSizeData, B, Kn)
                                  , Vn = d.get("text-padding");
                                xn = this.collisionIndex.placeCollisionCircles(re, Kn, u.lineVertexArray, u.glyphOffsetArray, Pa, w, P, s, Te, U.predicate, yt.collisionCircleDiameter, Vn, m, $e),
                                xn.circles.length && xn.collisionDetected && !s && o.w("Collisions detected, but collision boxes are not shown"),
                                Pi = se || xn.circles.length > 0 && !xn.collisionDetected,
                                Ui = Ui && xn.offscreen
                            }
                            if (sr.iconFeatureIndex && (ss = sr.iconFeatureIndex),
                            sr.iconBox) {
                                const Kn = Pa => this.collisionIndex.placeCollisionBox(Pa, de, M, qe, w, Te, ge, y, U.predicate, $e, he && Wr ? Wr : void 0, Rt);
                                Qi && Qi.placeable && sr.verticalIconBox ? (qn = Kn(sr.verticalIconBox),
                                ji = qn.placeable) : (qn = Kn(sr.iconBox),
                                ji = qn.placeable),
                                Ui = Ui && qn.offscreen
                            }
                            const Js = ee || yt.numHorizontalGlyphVertices === 0 && yt.numVerticalGlyphVertices === 0
                              , Is = J || yt.numIconVertices === 0;
                            Js || Is ? Is ? Js || (ji = ji && Pi) : Pi = ji && Pi : ji = Pi = ji && Pi;
                            const Ms = ji && qn.placeable;
                            if (Pi && dn.placeable && this.collisionIndex.insertCollisionBox(dn.box, re, d.get("text-ignore-placement"), u.bucketInstanceId, Qi && Qi.placeable && as ? as : Sa, U.ID),
                            Ms && this.collisionIndex.insertCollisionBox(qn.box, de, d.get("icon-ignore-placement"), u.bucketInstanceId, ss, U.ID),
                            xn && Pi && this.collisionIndex.insertCollisionCircles(xn.circles, re, d.get("text-ignore-placement"), u.bucketInstanceId, Sa, U.ID),
                            s && this.storeCollisionData(u.bucketInstanceId, Xr, sr, dn, qn, xn),
                            yt.crossTileID === 0)
                                throw new Error("symbolInstance.crossTileID can't be 0");
                            if (u.bucketInstanceId === 0)
                                throw new Error("bucket.bucketInstanceId can't be 0");
                            this.placements[yt.crossTileID] = new la((Pi || He) && !(dn != null && dn.occluded),(ji || je) && !(qn != null && qn.occluded),Ui || u.justReloaded),
                            n[yt.crossTileID] = !0
                        }
                        ;
                        if (De) {
                            if (e.symbolInstanceStart !== 0)
                                throw new Error("bucket.bucketInstanceId should be 0");
                            const yt = u.getSortedSymbolIndexes(-this.transform.bearingInRadians);
                            for (let sr = yt.length - 1; sr >= 0; --sr) {
                                const Xr = yt[sr];
                                Nt(u.symbolInstances.get(Xr), u.collisionArrays[Xr], Xr)
                            }
                        } else
                            for (let yt = e.symbolInstanceStart; yt < e.symbolInstanceEnd; yt++)
                                Nt(u.symbolInstances.get(yt), u.collisionArrays[yt], yt);
                        u.justReloaded = !1
                    }
                    storeCollisionData(e, n, s, u, d, m) {
                        if (s.textBox || s.iconBox) {
                            let y, w;
                            this.collisionBoxArrays.has(e) ? y = this.collisionBoxArrays.get(e) : (y = new Map,
                            this.collisionBoxArrays.set(e, y)),
                            y.has(n) ? w = y.get(n) : (w = {
                                text: null,
                                icon: null
                            },
                            y.set(n, w)),
                            s.textBox && (w.text = u.box),
                            s.iconBox && (w.icon = d.box)
                        }
                        if (m) {
                            let y = this.collisionCircleArrays[e];
                            y === void 0 && (y = this.collisionCircleArrays[e] = []);
                            for (let w = 0; w < m.circles.length; w += 4)
                                y.push(m.circles[w + 0] - rr),
                                y.push(m.circles[w + 1] - rr),
                                y.push(m.circles[w + 2]),
                                y.push(m.collisionDetected ? 1 : 0)
                        }
                    }
                    markUsedJustification(e, n, s, u) {
                        let d;
                        d = u === o.ao.vertical ? s.verticalPlacedTextSymbolIndex : {
                            left: s.leftJustifiedTextSymbolIndex,
                            center: s.centerJustifiedTextSymbolIndex,
                            right: s.rightJustifiedTextSymbolIndex
                        }[o.aG(n)];
                        const m = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex, s.verticalPlacedTextSymbolIndex];
                        for (const y of m)
                            y >= 0 && (e.text.placedSymbolArray.get(y).crossTileID = d >= 0 && y !== d ? 0 : s.crossTileID)
                    }
                    markUsedOrientation(e, n, s) {
                        const u = n === o.ao.horizontal || n === o.ao.horizontalOnly ? n : 0
                          , d = n === o.ao.vertical ? n : 0
                          , m = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex];
                        for (const y of m)
                            e.text.placedSymbolArray.get(y).placedOrientation = u;
                        s.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(s.verticalPlacedTextSymbolIndex).placedOrientation = d)
                    }
                    commit(e) {
                        this.commitTime = e,
                        this.zoomAtLastRecencyCheck = this.transform.zoom;
                        const n = this.prevPlacement;
                        let s = !1;
                        this.prevZoomAdjustment = n ? n.zoomAdjustment(this.transform.zoom) : 0;
                        const u = n ? n.symbolFadeChange(e) : 1
                          , d = n ? n.opacities : {}
                          , m = n ? n.variableOffsets : {}
                          , y = n ? n.placedOrientations : {};
                        for (const w in this.placements) {
                            const P = this.placements[w]
                              , M = d[w];
                            M ? (this.opacities[w] = new Yr(M,u,P.text,P.icon),
                            s = s || P.text !== M.text.placed || P.icon !== M.icon.placed) : (this.opacities[w] = new Yr(null,u,P.text,P.icon,P.skipFade),
                            s = s || P.text || P.icon)
                        }
                        for (const w in d) {
                            const P = d[w];
                            if (!this.opacities[w]) {
                                const M = new Yr(P,u,!1,!1);
                                M.isHidden() || (this.opacities[w] = M,
                                s = s || P.text.placed || P.icon.placed)
                            }
                        }
                        for (const w in m)
                            this.variableOffsets[w] || !this.opacities[w] || this.opacities[w].isHidden() || (this.variableOffsets[w] = m[w]);
                        for (const w in y)
                            this.placedOrientations[w] || !this.opacities[w] || this.opacities[w].isHidden() || (this.placedOrientations[w] = y[w]);
                        if (n && n.lastPlacementChangeTime === void 0)
                            throw new Error("Last placement time for previous placement is not defined");
                        s ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = n ? n.lastPlacementChangeTime : e)
                    }
                    updateLayerOpacities(e, n) {
                        const s = {};
                        for (const u of n) {
                            const d = u.getBucket(e);
                            d && u.latestFeatureIndex && e.id === d.layerIds[0] && this.updateBucketOpacities(d, u.tileID, s, u.collisionBoxArray)
                        }
                    }
                    updateBucketOpacities(e, n, s, u) {
                        e.hasTextData() && (e.text.opacityVertexArray.clear(),
                        e.text.hasVisibleVertices = !1),
                        e.hasIconData() && (e.icon.opacityVertexArray.clear(),
                        e.icon.hasVisibleVertices = !1),
                        e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(),
                        e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
                        const d = e.layers[0]
                          , m = d.layout
                          , y = new Yr(null,0,!1,!1,!0)
                          , w = m.get("text-allow-overlap")
                          , P = m.get("icon-allow-overlap")
                          , M = d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset")
                          , D = m.get("text-rotation-alignment") === "map"
                          , z = m.get("text-pitch-alignment") === "map"
                          , B = m.get("icon-text-fit") !== "none"
                          , U = new Yr(null,0,w && (P || !e.hasIconData() || m.get("icon-optional")),P && (w || !e.hasTextData() || m.get("text-optional")),!0);
                        !e.collisionArrays && u && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(u);
                        const ee = (re, se, de) => {
                            for (let ue = 0; ue < se / 4; ue++)
                                re.opacityVertexArray.emplaceBack(de);
                            re.hasVisibleVertices = re.hasVisibleVertices || de !== Mi
                        }
                          , J = this.collisionBoxArrays.get(e.bucketInstanceId);
                        for (let re = 0; re < e.symbolInstances.length; re++) {
                            const se = e.symbolInstances.get(re)
                              , {numHorizontalGlyphVertices: de, numVerticalGlyphVertices: ue, crossTileID: ge} = se;
                            let Te = this.opacities[ge];
                            s[ge] ? Te = y : Te || (Te = U,
                            this.opacities[ge] = Te),
                            s[ge] = !0;
                            const he = se.numIconVertices > 0
                              , De = this.placedOrientations[se.crossTileID]
                              , He = De === o.ao.vertical
                              , je = De === o.ao.horizontal || De === o.ao.horizontalOnly;
                            if (de > 0 || ue > 0) {
                                const $e = $i(Te.text);
                                ee(e.text, de, He ? Mi : $e),
                                ee(e.text, ue, je ? Mi : $e);
                                const Rt = Te.text.isHidden();
                                [se.rightJustifiedTextSymbolIndex, se.centerJustifiedTextSymbolIndex, se.leftJustifiedTextSymbolIndex].forEach((sr => {
                                    sr >= 0 && (e.text.placedSymbolArray.get(sr).hidden = Rt || He ? 1 : 0)
                                }
                                )),
                                se.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(se.verticalPlacedTextSymbolIndex).hidden = Rt || je ? 1 : 0);
                                const Nt = this.variableOffsets[se.crossTileID];
                                Nt && this.markUsedJustification(e, Nt.anchor, se, De);
                                const yt = this.placedOrientations[se.crossTileID];
                                yt && (this.markUsedJustification(e, "left", se, yt),
                                this.markUsedOrientation(e, yt, se))
                            }
                            if (he) {
                                const $e = $i(Te.icon)
                                  , Rt = !(B && se.verticalPlacedIconSymbolIndex && He);
                                se.placedIconSymbolIndex >= 0 && (ee(e.icon, se.numIconVertices, Rt ? $e : Mi),
                                e.icon.placedSymbolArray.get(se.placedIconSymbolIndex).hidden = Te.icon.isHidden()),
                                se.verticalPlacedIconSymbolIndex >= 0 && (ee(e.icon, se.numVerticalIconVertices, Rt ? Mi : $e),
                                e.icon.placedSymbolArray.get(se.verticalPlacedIconSymbolIndex).hidden = Te.icon.isHidden())
                            }
                            const qe = J && J.has(re) ? J.get(re) : {
                                text: null,
                                icon: null
                            };
                            if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                                const $e = e.collisionArrays[re];
                                if ($e) {
                                    let Rt = new o.P(0,0);
                                    if ($e.textBox || $e.verticalTextBox) {
                                        let Nt = !0;
                                        if (M) {
                                            const yt = this.variableOffsets[ge];
                                            yt ? (Rt = Fi(yt.anchor, yt.width, yt.height, yt.textOffset, yt.textBoxScale),
                                            D && Rt._rotate(z ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Nt = !1
                                        }
                                        if ($e.textBox || $e.verticalTextBox) {
                                            let yt;
                                            $e.textBox && (yt = He),
                                            $e.verticalTextBox && (yt = je),
                                            Gn(e.textCollisionBox.collisionVertexArray, Te.text.placed, !Nt || yt, qe.text, Rt.x, Rt.y)
                                        }
                                    }
                                    if ($e.iconBox || $e.verticalIconBox) {
                                        const Nt = !!(!je && $e.verticalIconBox);
                                        let yt;
                                        $e.iconBox && (yt = Nt),
                                        $e.verticalIconBox && (yt = !Nt),
                                        Gn(e.iconCollisionBox.collisionVertexArray, Te.icon.placed, yt, qe.icon, B ? Rt.x : 0, B ? Rt.y : 0)
                                    }
                                }
                            }
                        }
                        if (e.sortFeatures(-this.transform.bearingInRadians),
                        this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder),
                        e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray),
                        e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray),
                        e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray),
                        e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray),
                        e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4)
                            throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
                        if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4)
                            throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
                        e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId],
                        delete this.collisionCircleArrays[e.bucketInstanceId])
                    }
                    symbolFadeChange(e) {
                        return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                    }
                    zoomAdjustment(e) {
                        return Math.max(0, (this.transform.zoom - e) / 1.5)
                    }
                    hasTransitions(e) {
                        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
                    }
                    stillRecent(e, n) {
                        const s = this.zoomAtLastRecencyCheck === n ? 1 - this.zoomAdjustment(n) : 1;
                        return this.zoomAtLastRecencyCheck = n,
                        this.commitTime + this.fadeDuration * s > e
                    }
                    setStale() {
                        this.stale = !0
                    }
                }
                function Gn(h, e, n, s, u, d) {
                    s && s.length !== 0 || (s = [0, 0, 0, 0]);
                    const m = s[0] - rr
                      , y = s[1] - rr
                      , w = s[2] - rr
                      , P = s[3] - rr;
                    h.emplaceBack(e ? 1 : 0, n ? 1 : 0, u || 0, d || 0, m, y),
                    h.emplaceBack(e ? 1 : 0, n ? 1 : 0, u || 0, d || 0, w, y),
                    h.emplaceBack(e ? 1 : 0, n ? 1 : 0, u || 0, d || 0, w, P),
                    h.emplaceBack(e ? 1 : 0, n ? 1 : 0, u || 0, d || 0, m, P)
                }
                const Hn = Math.pow(2, 25)
                  , Ln = Math.pow(2, 24)
                  , gt = Math.pow(2, 17)
                  , qt = Math.pow(2, 16)
                  , vr = Math.pow(2, 9)
                  , _i = Math.pow(2, 8)
                  , Di = Math.pow(2, 1);
                function $i(h) {
                    if (h.opacity === 0 && !h.placed)
                        return 0;
                    if (h.opacity === 1 && h.placed)
                        return 4294967295;
                    const e = h.placed ? 1 : 0
                      , n = Math.floor(127 * h.opacity);
                    return n * Hn + e * Ln + n * gt + e * qt + n * vr + e * _i + n * Di + e
                }
                const Mi = 0;
                class Cr {
                    constructor(e) {
                        this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(),
                        this._currentTileIndex = 0,
                        this._currentPartIndex = 0,
                        this._seenCrossTileIDs = {},
                        this._bucketParts = []
                    }
                    continuePlacement(e, n, s, u, d) {
                        const m = this._bucketParts;
                        for (; this._currentTileIndex < e.length; )
                            if (n.getBucketParts(m, u, e[this._currentTileIndex], this._sortAcrossTiles),
                            this._currentTileIndex++,
                            d())
                                return !0;
                        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1,
                        m.sort(( (y, w) => y.sortKey - w.sortKey))); this._currentPartIndex < m.length; )
                            if (n.placeLayerBucketPart(m[this._currentPartIndex], this._seenCrossTileIDs, s),
                            this._currentPartIndex++,
                            d())
                                return !0;
                        return !1
                    }
                }
                class gn {
                    constructor(e, n, s, u, d, m, y, w) {
                        this.placement = new Xi(e,n,m,y,w),
                        this._currentPlacementIndex = s.length - 1,
                        this._forceFullPlacement = u,
                        this._showCollisionBoxes = d,
                        this._done = !1
                    }
                    isDone() {
                        return this._done
                    }
                    continuePlacement(e, n, s) {
                        const u = ye.now()
                          , d = () => !this._forceFullPlacement && ye.now() - u > 2;
                        for (; this._currentPlacementIndex >= 0; ) {
                            const m = n[e[this._currentPlacementIndex]]
                              , y = this.placement.collisionIndex.transform.zoom;
                            if (m.type === "symbol" && (!m.minzoom || m.minzoom <= y) && (!m.maxzoom || m.maxzoom > y)) {
                                if (this._inProgressLayer || (this._inProgressLayer = new Cr(m)),
                                this._inProgressLayer.continuePlacement(s[m.source], this.placement, this._showCollisionBoxes, m, d))
                                    return;
                                delete this._inProgressLayer
                            }
                            this._currentPlacementIndex--
                        }
                        this._done = !0
                    }
                    commit(e) {
                        return this.placement.commit(e),
                        this.placement
                    }
                }
                const tr = 512 / o.$ / 2;
                class Ht {
                    constructor(e, n, s) {
                        this.tileID = e,
                        this.bucketInstanceId = s,
                        this._symbolsByKey = {};
                        const u = new Map;
                        for (let d = 0; d < n.length; d++) {
                            const m = n.get(d)
                              , y = m.key
                              , w = u.get(y);
                            w ? w.push(m) : u.set(y, [m])
                        }
                        for (const [d,m] of u) {
                            const y = {
                                positions: m.map((w => ({
                                    x: Math.floor(w.anchorX * tr),
                                    y: Math.floor(w.anchorY * tr)
                                }))),
                                crossTileIDs: m.map((w => w.crossTileID))
                            };
                            if (y.positions.length > 128) {
                                const w = new o.aI(y.positions.length,16,Uint16Array);
                                for (const {x: P, y: M} of y.positions)
                                    w.add(P, M);
                                w.finish(),
                                delete y.positions,
                                y.index = w
                            }
                            this._symbolsByKey[d] = y
                        }
                    }
                    getScaledCoordinates(e, n) {
                        const {x: s, y: u, z: d} = this.tileID.canonical
                          , {x: m, y, z: w} = n.canonical
                          , P = tr / Math.pow(2, w - d)
                          , M = (y * o.$ + e.anchorY) * P
                          , D = u * o.$ * tr;
                        return {
                            x: Math.floor((m * o.$ + e.anchorX) * P - s * o.$ * tr),
                            y: Math.floor(M - D)
                        }
                    }
                    findMatches(e, n, s) {
                        const u = this.tileID.canonical.z < n.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - n.canonical.z);
                        for (let d = 0; d < e.length; d++) {
                            const m = e.get(d);
                            if (m.crossTileID)
                                continue;
                            const y = this._symbolsByKey[m.key];
                            if (!y)
                                continue;
                            const w = this.getScaledCoordinates(m, n);
                            if (y.index) {
                                const P = y.index.range(w.x - u, w.y - u, w.x + u, w.y + u).sort();
                                for (const M of P) {
                                    const D = y.crossTileIDs[M];
                                    if (!s[D]) {
                                        s[D] = !0,
                                        m.crossTileID = D;
                                        break
                                    }
                                }
                            } else if (y.positions)
                                for (let P = 0; P < y.positions.length; P++) {
                                    const M = y.positions[P]
                                      , D = y.crossTileIDs[P];
                                    if (Math.abs(M.x - w.x) <= u && Math.abs(M.y - w.y) <= u && !s[D]) {
                                        s[D] = !0,
                                        m.crossTileID = D;
                                        break
                                    }
                                }
                        }
                    }
                    getCrossTileIDsLists() {
                        return Object.values(this._symbolsByKey).map(( ({crossTileIDs: e}) => e))
                    }
                }
                class ei {
                    constructor() {
                        this.maxCrossTileID = 0
                    }
                    generate() {
                        return ++this.maxCrossTileID
                    }
                }
                class ri {
                    constructor() {
                        this.indexes = {},
                        this.usedCrossTileIDs = {},
                        this.lng = 0
                    }
                    handleWrapJump(e) {
                        const n = Math.round((e - this.lng) / 360);
                        if (n !== 0)
                            for (const s in this.indexes) {
                                const u = this.indexes[s]
                                  , d = {};
                                for (const m in u) {
                                    const y = u[m];
                                    y.tileID = y.tileID.unwrapTo(y.tileID.wrap + n),
                                    d[y.tileID.key] = y
                                }
                                this.indexes[s] = d
                            }
                        this.lng = e
                    }
                    addBucket(e, n, s) {
                        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                            if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === n.bucketInstanceId)
                                return !1;
                            this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
                        }
                        for (let d = 0; d < n.symbolInstances.length; d++)
                            n.symbolInstances.get(d).crossTileID = 0;
                        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
                        const u = this.usedCrossTileIDs[e.overscaledZ];
                        for (const d in this.indexes) {
                            const m = this.indexes[d];
                            if (Number(d) > e.overscaledZ)
                                for (const y in m) {
                                    const w = m[y];
                                    w.tileID.isChildOf(e) && w.findMatches(n.symbolInstances, e, u)
                                }
                            else {
                                const y = m[e.scaledTo(Number(d)).key];
                                y && y.findMatches(n.symbolInstances, e, u)
                            }
                        }
                        for (let d = 0; d < n.symbolInstances.length; d++) {
                            const m = n.symbolInstances.get(d);
                            m.crossTileID || (m.crossTileID = s.generate(),
                            u[m.crossTileID] = !0)
                        }
                        return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}),
                        this.indexes[e.overscaledZ][e.key] = new Ht(e,n.symbolInstances,n.bucketInstanceId),
                        !0
                    }
                    removeBucketCrossTileIDs(e, n) {
                        for (const s of n.getCrossTileIDsLists())
                            for (const u of s)
                                delete this.usedCrossTileIDs[e][u]
                    }
                    removeStaleBuckets(e) {
                        let n = !1;
                        for (const s in this.indexes) {
                            const u = this.indexes[s];
                            for (const d in u)
                                e[u[d].bucketInstanceId] || (this.removeBucketCrossTileIDs(s, u[d]),
                                delete u[d],
                                n = !0)
                        }
                        return n
                    }
                }
                class gi {
                    constructor() {
                        this.layerIndexes = {},
                        this.crossTileIDs = new ei,
                        this.maxBucketInstanceId = 0,
                        this.bucketsInCurrentPlacement = {}
                    }
                    addLayer(e, n, s) {
                        let u = this.layerIndexes[e.id];
                        u === void 0 && (u = this.layerIndexes[e.id] = new ri);
                        let d = !1;
                        const m = {};
                        u.handleWrapJump(s);
                        for (const y of n) {
                            const w = y.getBucket(e);
                            w && e.id === w.layerIds[0] && (w.bucketInstanceId || (w.bucketInstanceId = ++this.maxBucketInstanceId),
                            u.addBucket(y.tileID, w, this.crossTileIDs) && (d = !0),
                            m[w.bucketInstanceId] = !0)
                        }
                        return u.removeStaleBuckets(m) && (d = !0),
                        d
                    }
                    pruneUnusedLayers(e) {
                        const n = {};
                        e.forEach((s => {
                            n[s] = !0
                        }
                        ));
                        for (const s in this.layerIndexes)
                            n[s] || delete this.layerIndexes[s]
                    }
                }
                var ci = "void main() {fragColor=vec4(1.0);}";
                const pi = {
                    prelude: Er(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
                    projectionMercator: Er("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
                    projectionGlobe: Er("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
                    background: Er(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
                    backgroundPattern: Er(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
                    circle: Er(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
                    clippingMask: Er(ci, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
                    heatmap: Er(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
                    heatmapTexture: Er(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
                    collisionBox: Er("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
                    collisionCircle: Er("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
                    colorRelief: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
                    debug: Er("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
                    depth: Er(ci, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
                    fill: Er(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
                    fillOutline: Er(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
                    fillOutlinePattern: Er(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
                    fillPattern: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
                    fillExtrusion: Er(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
                    fillExtrusionPattern: Er(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
                    hillshadePrepare: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                    hillshade: Er(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
                    line: Er(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                    lineGradient: Er(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                    linePattern: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
                    lineSDF: Er(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
                    raster: Er(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
                    symbolIcon: Er(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
                    symbolSDF: Er(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
                    symbolTextAndIcon: Er(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
                    terrain: Er("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
                    terrainDepth: Er("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
                    terrainCoords: Er("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
                    projectionErrorMeasurement: Er("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
                    atmosphere: Er(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
                    sky: Er("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
                };
                function Er(h, e) {
                    const n = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g
                      , s = e.match(/in ([\w]+) ([\w]+)/g)
                      , u = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g)
                      , d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g)
                      , m = d ? d.concat(u) : u
                      , y = {};
                    return {
                        fragmentSource: h = h.replace(n, ( (w, P, M, D, z) => (y[z] = !0,
                        P === "define" ? `
#ifndef HAS_UNIFORM_u_${z}
in ${M} ${D} ${z};
#else
uniform ${M} ${D} u_${z};
#endif
` : `
#ifdef HAS_UNIFORM_u_${z}
    ${M} ${D} ${z} = u_${z};
#endif
`))),
                        vertexSource: e = e.replace(n, ( (w, P, M, D, z) => {
                            const B = D === "float" ? "vec2" : "vec4"
                              , U = z.match(/color/) ? "color" : B;
                            return y[z] ? P === "define" ? `
#ifndef HAS_UNIFORM_u_${z}
uniform lowp float u_${z}_t;
in ${M} ${B} a_${z};
out ${M} ${D} ${z};
#else
uniform ${M} ${D} u_${z};
#endif
` : U === "vec4" ? `
#ifndef HAS_UNIFORM_u_${z}
    ${z} = a_${z};
#else
    ${M} ${D} ${z} = u_${z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${z}
    ${z} = unpack_mix_${U}(a_${z}, u_${z}_t);
#else
    ${M} ${D} ${z} = u_${z};
#endif
` : P === "define" ? `
#ifndef HAS_UNIFORM_u_${z}
uniform lowp float u_${z}_t;
in ${M} ${B} a_${z};
#else
uniform ${M} ${D} u_${z};
#endif
` : U === "vec4" ? `
#ifndef HAS_UNIFORM_u_${z}
    ${M} ${D} ${z} = a_${z};
#else
    ${M} ${D} ${z} = u_${z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${z}
    ${M} ${D} ${z} = unpack_mix_${U}(a_${z}, u_${z}_t);
#else
    ${M} ${D} ${z} = u_${z};
#endif
`
                        }
                        )),
                        staticAttributes: s,
                        staticUniforms: m
                    }
                }
                class Ri {
                    constructor(e, n, s) {
                        this.vertexBuffer = e,
                        this.indexBuffer = n,
                        this.segments = s
                    }
                    destroy() {
                        this.vertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.vertexBuffer = null,
                        this.indexBuffer = null,
                        this.segments = null
                    }
                }
                var ui = o.aJ([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }]);
                const Jr = "#define PROJECTION_MERCATOR"
                  , ti = "mercator";
                class yr {
                    constructor() {
                        this._cachedMesh = null
                    }
                    get name() {
                        return "mercator"
                    }
                    get useSubdivision() {
                        return !1
                    }
                    get shaderVariantName() {
                        return ti
                    }
                    get shaderDefine() {
                        return Jr
                    }
                    get shaderPreludeCode() {
                        return pi.projectionMercator
                    }
                    get vertexShaderPreludeCode() {
                        return pi.projectionMercator.vertexSource
                    }
                    get subdivisionGranularity() {
                        return o.aK.noSubdivision
                    }
                    get useGlobeControls() {
                        return !1
                    }
                    get transitionState() {
                        return 0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return 0
                    }
                    destroy() {}
                    updateGPUdependent(e) {}
                    getMeshFromTileID(e, n, s, u, d) {
                        if (this._cachedMesh)
                            return this._cachedMesh;
                        const m = new o.aL;
                        m.emplaceBack(0, 0),
                        m.emplaceBack(o.$, 0),
                        m.emplaceBack(0, o.$),
                        m.emplaceBack(o.$, o.$);
                        const y = e.createVertexBuffer(m, ui.members)
                          , w = o.aM.simpleSegment(0, 0, 4, 2)
                          , P = new o.aN;
                        P.emplaceBack(1, 0, 2),
                        P.emplaceBack(1, 2, 3);
                        const M = e.createIndexBuffer(P);
                        return this._cachedMesh = new Ri(y,M,w),
                        this._cachedMesh
                    }
                    recalculate() {}
                    hasTransition() {
                        return !1
                    }
                    setErrorQueryLatitudeDegrees(e) {}
                }
                class on {
                    constructor(e=0, n=0, s=0, u=0) {
                        if (isNaN(e) || e < 0 || isNaN(n) || n < 0 || isNaN(s) || s < 0 || isNaN(u) || u < 0)
                            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                        this.top = e,
                        this.bottom = n,
                        this.left = s,
                        this.right = u
                    }
                    interpolate(e, n, s) {
                        return n.top != null && e.top != null && (this.top = o.C.number(e.top, n.top, s)),
                        n.bottom != null && e.bottom != null && (this.bottom = o.C.number(e.bottom, n.bottom, s)),
                        n.left != null && e.left != null && (this.left = o.C.number(e.left, n.left, s)),
                        n.right != null && e.right != null && (this.right = o.C.number(e.right, n.right, s)),
                        this
                    }
                    getCenter(e, n) {
                        const s = o.ah((this.left + e - this.right) / 2, 0, e)
                          , u = o.ah((this.top + n - this.bottom) / 2, 0, n);
                        return new o.P(s,u)
                    }
                    equals(e) {
                        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
                    }
                    clone() {
                        return new on(this.top,this.bottom,this.left,this.right)
                    }
                    toJSON() {
                        return {
                            top: this.top,
                            bottom: this.bottom,
                            left: this.left,
                            right: this.right
                        }
                    }
                }
                function vn(h, e) {
                    if (!h.renderWorldCopies || h.lngRange)
                        return;
                    const n = e.lng - h.center.lng;
                    e.lng += n > 180 ? -360 : n < -180 ? 360 : 0
                }
                function _a(h) {
                    return Math.max(0, Math.floor(h))
                }
                class ln {
                    constructor(e, n, s, u, d, m) {
                        this._callbacks = e,
                        this._tileSize = 512,
                        this._renderWorldCopies = m === void 0 || !!m,
                        this._minZoom = n || 0,
                        this._maxZoom = s || 22,
                        this._minPitch = u ?? 0,
                        this._maxPitch = d ?? 60,
                        this.setMaxBounds(),
                        this._width = 0,
                        this._height = 0,
                        this._center = new o.S(0,0),
                        this._elevation = 0,
                        this._zoom = 0,
                        this._tileZoom = _a(this._zoom),
                        this._scale = o.af(this._zoom),
                        this._bearingInRadians = 0,
                        this._fovInRadians = .6435011087932844,
                        this._pitchInRadians = 0,
                        this._rollInRadians = 0,
                        this._unmodified = !0,
                        this._edgeInsets = new on,
                        this._minElevationForCurrentTile = 0,
                        this._autoCalculateNearFarZ = !0
                    }
                    apply(e, n, s) {
                        this._latRange = e.latRange,
                        this._lngRange = e.lngRange,
                        this._width = e.width,
                        this._height = e.height,
                        this._center = e.center,
                        this._elevation = e.elevation,
                        this._minElevationForCurrentTile = e.minElevationForCurrentTile,
                        this._zoom = e.zoom,
                        this._tileZoom = _a(this._zoom),
                        this._scale = o.af(this._zoom),
                        this._bearingInRadians = e.bearingInRadians,
                        this._fovInRadians = e.fovInRadians,
                        this._pitchInRadians = e.pitchInRadians,
                        this._rollInRadians = e.rollInRadians,
                        this._unmodified = e.unmodified,
                        this._edgeInsets = new on(e.padding.top,e.padding.bottom,e.padding.left,e.padding.right),
                        this._minZoom = e.minZoom,
                        this._maxZoom = e.maxZoom,
                        this._minPitch = e.minPitch,
                        this._maxPitch = e.maxPitch,
                        this._renderWorldCopies = e.renderWorldCopies,
                        this._cameraToCenterDistance = e.cameraToCenterDistance,
                        this._nearZ = e.nearZ,
                        this._farZ = e.farZ,
                        this._autoCalculateNearFarZ = !s && e.autoCalculateNearFarZ,
                        n && this._constrain(),
                        this._calcMatrices()
                    }
                    get pixelsToClipSpaceMatrix() {
                        return this._pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._clipSpaceToPixelsMatrix
                    }
                    get minElevationForCurrentTile() {
                        return this._minElevationForCurrentTile
                    }
                    setMinElevationForCurrentTile(e) {
                        this._minElevationForCurrentTile = e
                    }
                    get tileSize() {
                        return this._tileSize
                    }
                    get tileZoom() {
                        return this._tileZoom
                    }
                    get scale() {
                        return this._scale
                    }
                    get width() {
                        return this._width
                    }
                    get height() {
                        return this._height
                    }
                    get bearingInRadians() {
                        return this._bearingInRadians
                    }
                    get lngRange() {
                        return this._lngRange
                    }
                    get latRange() {
                        return this._latRange
                    }
                    get pixelsToGLUnits() {
                        return this._pixelsToGLUnits
                    }
                    get minZoom() {
                        return this._minZoom
                    }
                    setMinZoom(e) {
                        this._minZoom !== e && (this._minZoom = e,
                        this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
                    }
                    get maxZoom() {
                        return this._maxZoom
                    }
                    setMaxZoom(e) {
                        this._maxZoom !== e && (this._maxZoom = e,
                        this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
                    }
                    get minPitch() {
                        return this._minPitch
                    }
                    setMinPitch(e) {
                        this._minPitch !== e && (this._minPitch = e,
                        this.setPitch(Math.max(this.pitch, e)))
                    }
                    get maxPitch() {
                        return this._maxPitch
                    }
                    setMaxPitch(e) {
                        this._maxPitch !== e && (this._maxPitch = e,
                        this.setPitch(Math.min(this.pitch, e)))
                    }
                    get renderWorldCopies() {
                        return this._renderWorldCopies
                    }
                    setRenderWorldCopies(e) {
                        e === void 0 ? e = !0 : e === null && (e = !1),
                        this._renderWorldCopies = e
                    }
                    get worldSize() {
                        return this._tileSize * this._scale
                    }
                    get centerOffset() {
                        return this.centerPoint._sub(this.size._div(2))
                    }
                    get size() {
                        return new o.P(this._width,this._height)
                    }
                    get bearing() {
                        return this._bearingInRadians / Math.PI * 180
                    }
                    setBearing(e) {
                        const n = o.aO(e, -180, 180) * Math.PI / 180;
                        var s, u, d, m, y, w, P, M, D;
                        this._bearingInRadians !== n && (this._unmodified = !1,
                        this._bearingInRadians = n,
                        this._calcMatrices(),
                        this._rotationMatrix = W(),
                        s = this._rotationMatrix,
                        d = -this._bearingInRadians,
                        m = (u = this._rotationMatrix)[0],
                        y = u[1],
                        w = u[2],
                        P = u[3],
                        M = Math.sin(d),
                        D = Math.cos(d),
                        s[0] = m * D + w * M,
                        s[1] = y * D + P * M,
                        s[2] = m * -M + w * D,
                        s[3] = y * -M + P * D)
                    }
                    get rotationMatrix() {
                        return this._rotationMatrix
                    }
                    get pitchInRadians() {
                        return this._pitchInRadians
                    }
                    get pitch() {
                        return this._pitchInRadians / Math.PI * 180
                    }
                    setPitch(e) {
                        const n = o.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
                        this._pitchInRadians !== n && (this._unmodified = !1,
                        this._pitchInRadians = n,
                        this._calcMatrices())
                    }
                    get rollInRadians() {
                        return this._rollInRadians
                    }
                    get roll() {
                        return this._rollInRadians / Math.PI * 180
                    }
                    setRoll(e) {
                        const n = e / 180 * Math.PI;
                        this._rollInRadians !== n && (this._unmodified = !1,
                        this._rollInRadians = n,
                        this._calcMatrices())
                    }
                    get fovInRadians() {
                        return this._fovInRadians
                    }
                    get fov() {
                        return o.aP(this._fovInRadians)
                    }
                    setFov(e) {
                        e = o.ah(e, .1, 150),
                        this.fov !== e && (this._unmodified = !1,
                        this._fovInRadians = o.ae(e),
                        this._calcMatrices())
                    }
                    get zoom() {
                        return this._zoom
                    }
                    setZoom(e) {
                        const n = this.getConstrained(this._center, e).zoom;
                        this._zoom !== n && (this._unmodified = !1,
                        this._zoom = n,
                        this._tileZoom = Math.max(0, Math.floor(n)),
                        this._scale = o.af(n),
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get center() {
                        return this._center
                    }
                    setCenter(e) {
                        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1,
                        this._center = e,
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get elevation() {
                        return this._elevation
                    }
                    setElevation(e) {
                        e !== this._elevation && (this._elevation = e,
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get padding() {
                        return this._edgeInsets.toJSON()
                    }
                    setPadding(e) {
                        this._edgeInsets.equals(e) || (this._unmodified = !1,
                        this._edgeInsets.interpolate(this._edgeInsets, e, 1),
                        this._calcMatrices())
                    }
                    get centerPoint() {
                        return this._edgeInsets.getCenter(this._width, this._height)
                    }
                    get pixelsPerMeter() {
                        return this._pixelPerMeter
                    }
                    get unmodified() {
                        return this._unmodified
                    }
                    get cameraToCenterDistance() {
                        return this._cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._nearZ
                    }
                    get farZ() {
                        return this._farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._autoCalculateNearFarZ
                    }
                    overrideNearFarZ(e, n) {
                        this._autoCalculateNearFarZ = !1,
                        this._nearZ = e,
                        this._farZ = n,
                        this._calcMatrices()
                    }
                    clearNearFarZOverride() {
                        this._autoCalculateNearFarZ = !0,
                        this._calcMatrices()
                    }
                    isPaddingEqual(e) {
                        return this._edgeInsets.equals(e)
                    }
                    interpolatePadding(e, n, s) {
                        this._unmodified = !1,
                        this._edgeInsets.interpolate(e, n, s),
                        this._constrain(),
                        this._calcMatrices()
                    }
                    resize(e, n, s=!0) {
                        this._width = e,
                        this._height = n,
                        s && this._constrain(),
                        this._calcMatrices()
                    }
                    getMaxBounds() {
                        return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new dt([this._lngRange[0], this._latRange[0]],[this._lngRange[1], this._latRange[1]]) : null
                    }
                    setMaxBounds(e) {
                        e ? (this._lngRange = [e.getWest(), e.getEast()],
                        this._latRange = [e.getSouth(), e.getNorth()],
                        this._constrain()) : (this._lngRange = null,
                        this._latRange = [-o.ai, o.ai])
                    }
                    getConstrained(e, n) {
                        return this._callbacks.getConstrained(e, n)
                    }
                    getCameraQueryGeometry(e, n) {
                        if (n.length === 1)
                            return [n[0], e];
                        {
                            const {minX: s, minY: u, maxX: d, maxY: m} = o.a2.fromPoints(n).extend(e);
                            return [new o.P(s,u), new o.P(d,u), new o.P(d,m), new o.P(s,m), new o.P(s,u)]
                        }
                    }
                    _constrain() {
                        if (!this.center || !this._width || !this._height || this._constraining)
                            return;
                        this._constraining = !0;
                        const e = this._unmodified
                          , {center: n, zoom: s} = this.getConstrained(this.center, this.zoom);
                        this.setCenter(n),
                        this.setZoom(s),
                        this._unmodified = e,
                        this._constraining = !1
                    }
                    _calcMatrices() {
                        if (this._width && this._height) {
                            this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
                            let e = o.ag(new Float64Array(16));
                            o.N(e, e, [this._width / 2, -this._height / 2, 1]),
                            o.M(e, e, [1, -1, 0]),
                            this._clipSpaceToPixelsMatrix = e,
                            e = o.ag(new Float64Array(16)),
                            o.N(e, e, [1, -1, 1]),
                            o.M(e, e, [-1, -1, 0]),
                            o.N(e, e, [2 / this._width, 2 / this._height, 1]),
                            this._pixelsToClipSpaceMatrix = e,
                            this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
                        }
                        this._callbacks.calcMatrices()
                    }
                    calculateCenterFromCameraLngLatAlt(e, n, s, u) {
                        const d = s !== void 0 ? s : this.bearing
                          , m = u = u !== void 0 ? u : this.pitch
                          , y = o.a1.fromLngLat(e, n)
                          , w = -Math.cos(o.ae(m))
                          , P = Math.sin(o.ae(m))
                          , M = P * Math.sin(o.ae(d))
                          , D = -P * Math.cos(o.ae(d));
                        let z = this.elevation;
                        const B = n - z;
                        let U;
                        w * B >= 0 || Math.abs(w) < .1 ? (U = 1e4,
                        z = n + U * w) : U = -B / w;
                        let ee, J, re = o.aQ(1, y.y), se = 0;
                        do {
                            if (se += 1,
                            se > 10)
                                break;
                            J = U / re,
                            ee = new o.a1(y.x + M * J,y.y + D * J),
                            re = 1 / ee.meterInMercatorCoordinateUnits()
                        } while (Math.abs(U - J * re) > 1e-12);
                        return {
                            center: ee.toLngLat(),
                            elevation: z,
                            zoom: o.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / J / this.tileSize)
                        }
                    }
                    recalculateZoomAndCenter(e) {
                        if (this.elevation - e == 0)
                            return;
                        const n = o.aj(1, this.center.lat) * this.worldSize
                          , s = this.cameraToCenterDistance / n
                          , u = o.a1.fromLngLat(this.center, this.elevation)
                          , d = Le(this.center, this.elevation, this.pitch, this.bearing, s);
                        this._elevation = e;
                        const m = this.calculateCenterFromCameraLngLatAlt(d.toLngLat(), o.aQ(d.z, u.y), this.bearing, this.pitch);
                        this._elevation = m.elevation,
                        this._center = m.center,
                        this.setZoom(m.zoom)
                    }
                    getCameraPoint() {
                        const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
                        return this.centerPoint.add(new o.P(e * Math.sin(this.rollInRadians),e * Math.cos(this.rollInRadians)))
                    }
                    getCameraAltitude() {
                        return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
                    }
                    getCameraLngLat() {
                        const e = o.aj(1, this.center.lat) * this.worldSize;
                        return Le(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
                    }
                    getMercatorTileCoordinates(e) {
                        if (!e)
                            return [0, 0, 1, 1];
                        const n = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
                        return [e.canonical.x / n, e.canonical.y / n, 1 / n / o.$, 1 / n / o.$]
                    }
                }
                class Ki {
                    constructor(e, n) {
                        this.min = e,
                        this.max = n,
                        this.center = o.aR([], o.aS([], this.min, this.max), .5)
                    }
                    quadrant(e) {
                        const n = [e % 2 == 0, e < 2]
                          , s = o.aT(this.min)
                          , u = o.aT(this.max);
                        for (let d = 0; d < n.length; d++)
                            s[d] = n[d] ? this.min[d] : this.center[d],
                            u[d] = n[d] ? this.center[d] : this.max[d];
                        return u[2] = this.max[2],
                        new Ki(s,u)
                    }
                    distanceX(e) {
                        return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
                    }
                    distanceY(e) {
                        return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
                    }
                    intersectsFrustum(e) {
                        let n = !0;
                        for (let s = 0; s < e.planes.length; s++) {
                            const u = this.intersectsPlane(e.planes[s]);
                            if (u === 0)
                                return 0;
                            u === 1 && (n = !1)
                        }
                        return n ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
                    }
                    intersectsPlane(e) {
                        let n = e[3]
                          , s = e[3];
                        for (let u = 0; u < 3; u++)
                            e[u] > 0 ? (n += e[u] * this.min[u],
                            s += e[u] * this.max[u]) : (s += e[u] * this.min[u],
                            n += e[u] * this.max[u]);
                        return n >= 0 ? 2 : s < 0 ? 0 : 1
                    }
                }
                class cn {
                    distanceToTile2d(e, n, s, u) {
                        const d = u.distanceX([e, n])
                          , m = u.distanceY([e, n]);
                        return Math.hypot(d, m)
                    }
                    getWrap(e, n, s) {
                        return s
                    }
                    getTileBoundingVolume(e, n, s, u) {
                        var d, m;
                        let y = 0
                          , w = 0;
                        if (u != null && u.terrain) {
                            const M = new o.Z(e.z,n,e.z,e.x,e.y)
                              , D = u.terrain.getMinMaxElevation(M);
                            y = (d = D.minElevation) !== null && d !== void 0 ? d : Math.min(0, s),
                            w = (m = D.maxElevation) !== null && m !== void 0 ? m : Math.max(0, s)
                        }
                        const P = 1 << e.z;
                        return new Ki([n + e.x / P, e.y / P, y],[n + (e.x + 1) / P, (e.y + 1) / P, w])
                    }
                    allowVariableZoom(e, n) {
                        const s = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height
                          , u = o.ah(78.5 - s / 2, 0, 60);
                        return !!n.terrain || e.pitch > u
                    }
                    allowWorldCopies() {
                        return !0
                    }
                    prepareNextFrame() {}
                }
                class Ni {
                    constructor(e, n, s) {
                        this.points = e,
                        this.planes = n,
                        this.aabb = s
                    }
                    static fromInvProjectionMatrix(e, n=1, s=0, u, d) {
                        const m = d ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]]
                          , y = Math.pow(2, s)
                          , w = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((z => (function(B, U, ee, J) {
                            const re = o.aw([], B, U)
                              , se = 1 / re[3] / ee * J;
                            return o.aY(re, re, [se, se, 1 / re[3], se])
                        }
                        )(z, e, n, y)));
                        u && (function(z, B, U, ee) {
                            const J = ee ? 4 : 0
                              , re = ee ? 0 : 4;
                            let se = 0;
                            const de = []
                              , ue = [];
                            for (let he = 0; he < 4; he++) {
                                const De = o.aU([], z[he + re], z[he + J])
                                  , He = o.aZ(De);
                                o.aR(De, De, 1 / He),
                                de.push(He),
                                ue.push(De)
                            }
                            for (let he = 0; he < 4; he++) {
                                const De = o.a_(z[he + J], ue[he], U);
                                se = De !== null && De >= 0 ? Math.max(se, De) : Math.max(se, de[he])
                            }
                            const ge = (function(he, De) {
                                const He = o.aU([], he[De[0]], he[De[1]])
                                  , je = o.aU([], he[De[2]], he[De[1]])
                                  , qe = [0, 0, 0, 0];
                                return o.aV(qe, o.aW([], He, je)),
                                qe[3] = -o.aX(qe, he[De[0]]),
                                qe
                            }
                            )(z, B)
                              , Te = (function(he, De) {
                                const He = o.a$(he)
                                  , je = o.b0([], he, 1 / He)
                                  , qe = o.aU([], De, o.aR([], je, o.aX(De, je)))
                                  , $e = o.a$(qe);
                                if ($e > 0) {
                                    const Rt = Math.sqrt(1 - je[3] * je[3])
                                      , Nt = o.aR([], je, -je[3])
                                      , yt = o.aS([], Nt, o.aR([], qe, Rt / $e));
                                    return o.b1(De, yt)
                                }
                                return null
                            }
                            )(U, ge);
                            if (Te !== null) {
                                const he = Te / o.aX(ue[0], ge);
                                se = Math.min(se, he)
                            }
                            for (let he = 0; he < 4; he++) {
                                const De = Math.min(se, de[he]);
                                z[he + re] = [z[he + J][0] + ue[he][0] * De, z[he + J][1] + ue[he][1] * De, z[he + J][2] + ue[he][2] * De, 1]
                            }
                        }
                        )(w, m[0], u, d);
                        const P = m.map((z => {
                            const B = o.aU([], w[z[0]], w[z[1]])
                              , U = o.aU([], w[z[2]], w[z[1]])
                              , ee = o.aV([], o.aW([], B, U))
                              , J = -o.aX(ee, w[z[1]]);
                            return ee.concat(J)
                        }
                        ))
                          , M = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
                          , D = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
                        for (const z of w)
                            for (let B = 0; B < 3; B++)
                                M[B] = Math.min(M[B], z[B]),
                                D[B] = Math.max(D[B], z[B]);
                        return new Ni(w,P,new Ki(M,D))
                    }
                }
                class wi {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e)
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e)
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e)
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e)
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e)
                    }
                    setBearing(e) {
                        this._helper.setBearing(e)
                    }
                    setPitch(e) {
                        this._helper.setPitch(e)
                    }
                    setRoll(e) {
                        this._helper.setRoll(e)
                    }
                    setFov(e) {
                        this._helper.setFov(e)
                    }
                    setZoom(e) {
                        this._helper.setZoom(e)
                    }
                    setCenter(e) {
                        this._helper.setCenter(e)
                    }
                    setElevation(e) {
                        this._helper.setElevation(e)
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e)
                    }
                    setPadding(e) {
                        this._helper.setPadding(e)
                    }
                    interpolatePadding(e, n, s) {
                        return this._helper.interpolatePadding(e, n, s)
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e)
                    }
                    resize(e, n, s=!0) {
                        this._helper.resize(e, n, s)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e)
                    }
                    overrideNearFarZ(e, n) {
                        this._helper.overrideNearFarZ(e, n)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    setTransitionState(e, n) {}
                    constructor(e, n, s, u, d) {
                        this._posMatrixCache = new Map,
                        this._alignedPosMatrixCache = new Map,
                        this._fogMatrixCacheF32 = new Map,
                        this._helper = new ln({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (m, y) => this.getConstrained(m, y)
                        },e,n,s,u,d),
                        this._coveringTilesDetailsProvider = new cn
                    }
                    clone() {
                        const e = new wi;
                        return e.apply(this),
                        e
                    }
                    apply(e, n, s) {
                        this._helper.apply(e, n, s)
                    }
                    get cameraPosition() {
                        return this._cameraPosition
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this._viewProjMatrix
                    }
                    get inverseProjectionMatrix() {
                        return this._invProjMatrix
                    }
                    get mercatorMatrix() {
                        return this._mercatorMatrix
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        const n = [new o.b2(0,e)];
                        if (this._helper._renderWorldCopies) {
                            const s = this.screenPointToMercatorCoordinate(new o.P(0,0))
                              , u = this.screenPointToMercatorCoordinate(new o.P(this._helper._width,0))
                              , d = this.screenPointToMercatorCoordinate(new o.P(this._helper._width,this._helper._height))
                              , m = this.screenPointToMercatorCoordinate(new o.P(0,this._helper._height))
                              , y = Math.floor(Math.min(s.x, u.x, d.x, m.x))
                              , w = Math.floor(Math.max(s.x, u.x, d.x, m.x))
                              , P = 1;
                            for (let M = y - P; M <= w + P; M++)
                                M !== 0 && n.push(new o.b2(M,e))
                        }
                        return n
                    }
                    getCameraFrustum() {
                        return Ni.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
                    }
                    getClippingPlane() {
                        return null
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider
                    }
                    recalculateZoomAndCenter(e) {
                        const n = this.screenPointToLocation(this.centerPoint, e)
                          , s = e ? e.getElevationForLngLatZoom(n, this._helper._tileZoom) : 0;
                        this._helper.recalculateZoomAndCenter(s)
                    }
                    setLocationAtPoint(e, n) {
                        const s = o.aj(this.elevation, this.center.lat)
                          , u = this.screenPointToMercatorCoordinateAtZ(n, s)
                          , d = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, s)
                          , m = o.a1.fromLngLat(e)
                          , y = new o.a1(m.x - (u.x - d.x),m.y - (u.y - d.y));
                        this.setCenter(y == null ? void 0 : y.toLngLat()),
                        this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
                    }
                    locationToScreenPoint(e, n) {
                        return n ? this.coordinatePoint(o.a1.fromLngLat(e), n.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.a1.fromLngLat(e))
                    }
                    screenPointToLocation(e, n) {
                        var s;
                        return (s = this.screenPointToMercatorCoordinate(e, n)) === null || s === void 0 ? void 0 : s.toLngLat()
                    }
                    screenPointToMercatorCoordinate(e, n) {
                        if (n) {
                            const s = n.pointCoordinate(e);
                            if (s != null)
                                return s
                        }
                        return this.screenPointToMercatorCoordinateAtZ(e)
                    }
                    screenPointToMercatorCoordinateAtZ(e, n) {
                        const s = n || 0
                          , u = [e.x, e.y, 0, 1]
                          , d = [e.x, e.y, 1, 1];
                        o.aw(u, u, this._pixelMatrixInverse),
                        o.aw(d, d, this._pixelMatrixInverse);
                        const m = u[3]
                          , y = d[3]
                          , w = u[1] / m
                          , P = d[1] / y
                          , M = u[2] / m
                          , D = d[2] / y
                          , z = M === D ? 0 : (s - M) / (D - M);
                        return new o.a1(o.C.number(u[0] / m, d[0] / y, z) / this.worldSize,o.C.number(w, P, z) / this.worldSize,s)
                    }
                    coordinatePoint(e, n=0, s=this._pixelMatrix) {
                        const u = [e.x * this.worldSize, e.y * this.worldSize, n, 1];
                        return o.aw(u, u, s),
                        new o.P(u[0] / u[3],u[1] / u[3])
                    }
                    getBounds() {
                        const e = Math.max(0, this._helper._height / 2 - le(this));
                        return new dt().extend(this.screenPointToLocation(new o.P(0,e))).extend(this.screenPointToLocation(new o.P(this._helper._width,e))).extend(this.screenPointToLocation(new o.P(this._helper._width,this._helper._height))).extend(this.screenPointToLocation(new o.P(0,this._helper._height)))
                    }
                    isPointOnMapSurface(e, n) {
                        return n ? n.pointCoordinate(e) != null : e.y > this.height / 2 - le(this)
                    }
                    calculatePosMatrix(e, n=!1, s) {
                        var u;
                        const d = (u = e.key) !== null && u !== void 0 ? u : o.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y)
                          , m = n ? this._alignedPosMatrixCache : this._posMatrixCache;
                        if (m.has(d)) {
                            const P = m.get(d);
                            return s ? P.f32 : P.f64
                        }
                        const y = ve(e, this.worldSize);
                        o.O(y, n ? this._alignedProjMatrix : this._viewProjMatrix, y);
                        const w = {
                            f64: y,
                            f32: new Float32Array(y)
                        };
                        return m.set(d, w),
                        s ? w.f32 : w.f64
                    }
                    calculateFogMatrix(e) {
                        const n = e.key
                          , s = this._fogMatrixCacheF32;
                        if (s.has(n))
                            return s.get(n);
                        const u = ve(e, this.worldSize);
                        return o.O(u, this._fogMatrix, u),
                        s.set(n, new Float32Array(u)),
                        s.get(n)
                    }
                    getConstrained(e, n) {
                        n = o.ah(+n, this.minZoom, this.maxZoom);
                        const s = {
                            center: new o.S(e.lng,e.lat),
                            zoom: n
                        };
                        let u = this._helper._lngRange;
                        if (!this._helper._renderWorldCopies && u === null) {
                            const de = 179.9999999999;
                            u = [-de, de]
                        }
                        const d = this.tileSize * o.af(s.zoom);
                        let m = 0
                          , y = d
                          , w = 0
                          , P = d
                          , M = 0
                          , D = 0;
                        const {x: z, y: B} = this.size;
                        if (this._helper._latRange) {
                            const de = this._helper._latRange;
                            m = o.U(de[1]) * d,
                            y = o.U(de[0]) * d,
                            y - m < B && (M = B / (y - m))
                        }
                        u && (w = o.aO(o.V(u[0]) * d, 0, d),
                        P = o.aO(o.V(u[1]) * d, 0, d),
                        P < w && (P += d),
                        P - w < z && (D = z / (P - w)));
                        const {x: U, y: ee} = G(d, e);
                        let J, re;
                        const se = Math.max(D || 0, M || 0);
                        if (se) {
                            const de = new o.P(D ? (P + w) / 2 : U,M ? (y + m) / 2 : ee);
                            return s.center = K(d, de).wrap(),
                            s.zoom += o.ak(se),
                            s
                        }
                        if (this._helper._latRange) {
                            const de = B / 2;
                            ee - de < m && (re = m + de),
                            ee + de > y && (re = y - de)
                        }
                        if (u) {
                            const de = (w + P) / 2;
                            let ue = U;
                            this._helper._renderWorldCopies && (ue = o.aO(U, de - d / 2, de + d / 2));
                            const ge = z / 2;
                            ue - ge < w && (J = w + ge),
                            ue + ge > P && (J = P - ge)
                        }
                        if (J !== void 0 || re !== void 0) {
                            const de = new o.P(J ?? U,re ?? ee);
                            s.center = K(d, de).wrap()
                        }
                        return s
                    }
                    calculateCenterFromCameraLngLatAlt(e, n, s, u) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, n, s, u)
                    }
                    _calculateNearFarZIfNeeded(e, n, s) {
                        if (!this._helper.autoCalculateNearFarZ)
                            return;
                        const u = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100)
                          , d = e - u * this._helper._pixelPerMeter / Math.cos(n)
                          , m = u < 0 ? d : e
                          , y = Math.PI / 2 + this.pitchInRadians
                          , w = o.ae(this.fov) * (Math.abs(Math.cos(o.ae(this.roll))) * this.height + Math.abs(Math.sin(o.ae(this.roll))) * this.width) / this.height * (.5 + s.y / this.height)
                          , P = Math.sin(w) * m / Math.sin(o.ah(Math.PI - y - w, .01, Math.PI - .01))
                          , M = le(this)
                          , D = Math.atan(M / this._helper.cameraToCenterDistance)
                          , z = o.ae(.75)
                          , B = D > z ? 2 * D * (.5 + s.y / (2 * M)) : z
                          , U = Math.sin(B) * m / Math.sin(o.ah(Math.PI - y - B, .01, Math.PI - .01))
                          , ee = Math.min(P, U);
                        this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - n) * ee + m),
                        this._helper._nearZ = this._helper._height / 50
                    }
                    _calcMatrices() {
                        if (!this._helper._height)
                            return;
                        const e = this.centerOffset
                          , n = G(this.worldSize, this.center)
                          , s = n.x
                          , u = n.y;
                        this._helper._pixelPerMeter = o.aj(1, this.center.lat) * this.worldSize;
                        const d = o.ae(Math.min(this.pitch, q))
                          , m = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(d));
                        let y;
                        this._calculateNearFarZIfNeeded(m, d, e),
                        y = new Float64Array(16),
                        o.b4(y, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ),
                        this._invProjMatrix = new Float64Array(16),
                        o.aq(this._invProjMatrix, y),
                        y[8] = 2 * -e.x / this._helper._width,
                        y[9] = 2 * e.y / this._helper._height,
                        this._projectionMatrix = o.b5(y),
                        o.N(y, y, [1, -1, 1]),
                        o.M(y, y, [0, 0, -this._helper.cameraToCenterDistance]),
                        o.b6(y, y, -this.rollInRadians),
                        o.b7(y, y, this.pitchInRadians),
                        o.b6(y, y, -this.bearingInRadians),
                        o.M(y, y, [-s, -u, 0]),
                        this._mercatorMatrix = o.N([], y, [this.worldSize, this.worldSize, this.worldSize]),
                        o.N(y, y, [1, 1, this._helper._pixelPerMeter]),
                        this._pixelMatrix = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, y),
                        o.M(y, y, [0, 0, -this.elevation]),
                        this._viewProjMatrix = y,
                        this._invViewProjMatrix = o.aq([], y);
                        const w = [0, 0, -1, 1];
                        o.aw(w, w, this._invViewProjMatrix),
                        this._cameraPosition = [w[0] / w[3], w[1] / w[3], w[2] / w[3]],
                        this._fogMatrix = new Float64Array(16),
                        o.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, m, this._helper._farZ),
                        this._fogMatrix[8] = 2 * -e.x / this.width,
                        this._fogMatrix[9] = 2 * e.y / this.height,
                        o.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]),
                        o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]),
                        o.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians),
                        o.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians),
                        o.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians),
                        o.M(this._fogMatrix, this._fogMatrix, [-s, -u, 0]),
                        o.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]),
                        o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]),
                        this._pixelMatrix3D = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, y);
                        const P = this._helper._width % 2 / 2
                          , M = this._helper._height % 2 / 2
                          , D = Math.cos(this.bearingInRadians)
                          , z = Math.sin(-this.bearingInRadians)
                          , B = s - Math.round(s) + D * P + z * M
                          , U = u - Math.round(u) + D * M + z * P
                          , ee = new Float64Array(y);
                        if (o.M(ee, ee, [B > .5 ? B - 1 : B, U > .5 ? U - 1 : U, 0]),
                        this._alignedProjMatrix = ee,
                        y = o.aq(new Float64Array(16), this._pixelMatrix),
                        !y)
                            throw new Error("failed to invert matrix");
                        this._pixelMatrixInverse = y,
                        this._clearMatrixCaches()
                    }
                    _clearMatrixCaches() {
                        this._posMatrixCache.clear(),
                        this._alignedPosMatrixCache.clear(),
                        this._fogMatrixCacheF32.clear()
                    }
                    maxPitchScaleFactor() {
                        if (!this._pixelMatrixInverse)
                            return 1;
                        const e = this.screenPointToMercatorCoordinate(new o.P(0,0))
                          , n = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
                        return o.aw(n, n, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        const e = o.aj(1, this.center.lat) * this.worldSize;
                        return Le(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
                    }
                    lngLatToCameraDepth(e, n) {
                        const s = o.a1.fromLngLat(e)
                          , u = [s.x * this.worldSize, s.y * this.worldSize, n, 1];
                        return o.aw(u, u, this._viewProjMatrix),
                        u[2] / u[3]
                    }
                    getProjectionData(e) {
                        const {overscaledTileID: n, aligned: s, applyTerrainMatrix: u} = e
                          , d = this._helper.getMercatorTileCoordinates(n)
                          , m = n ? this.calculatePosMatrix(n, s, !0) : null;
                        let y;
                        return y = n && n.terrainRttPosMatrix32f && u ? n.terrainRttPosMatrix32f : m || o.b8(),
                        {
                            mainMatrix: y,
                            tileMercatorCoords: d,
                            clippingPlane: [0, 0, 0, 0],
                            projectionTransition: 0,
                            fallbackMatrix: y
                        }
                    }
                    isLocationOccluded(e) {
                        return !1
                    }
                    getPixelScale() {
                        return 1
                    }
                    getCircleRadiusCorrection() {
                        return 1
                    }
                    getPitchedTextCorrection(e, n, s) {
                        return 1
                    }
                    transformLightDirection(e) {
                        return o.aT(e)
                    }
                    getRayDirectionFromPixel(e) {
                        throw new Error("Not implemented.")
                    }
                    projectTileCoordinates(e, n, s, u) {
                        const d = this.calculatePosMatrix(s);
                        let m;
                        u ? (m = [e, n, u(e, n), 1],
                        o.aw(m, m, d)) : (m = [e, n, 0, 1],
                        Li(m, m, d));
                        const y = m[3];
                        return {
                            point: new o.P(m[0] / y,m[1] / y),
                            signedDistanceFromCamera: y,
                            isOccluded: !1
                        }
                    }
                    populateCache(e) {
                        for (const n of e)
                            this.calculatePosMatrix(n)
                    }
                    getMatrixForModel(e, n) {
                        const s = o.a1.fromLngLat(e, n)
                          , u = s.meterInMercatorCoordinateUnits()
                          , d = o.b9();
                        return o.M(d, d, [s.x, s.y, s.z]),
                        o.b6(d, d, Math.PI),
                        o.b7(d, d, Math.PI / 2),
                        o.N(d, d, [-u, u, u]),
                        d
                    }
                    getProjectionDataForCustomLayer(e=!0) {
                        const n = new o.Z(0,0,0,0,0)
                          , s = this.getProjectionData({
                            overscaledTileID: n,
                            applyGlobeMatrix: e
                        })
                          , u = ve(n, this.worldSize);
                        o.O(u, this._viewProjMatrix, u),
                        s.tileMercatorCoords = [0, 0, 1, 1];
                        const d = [o.$, o.$, this.worldSize / this._helper.pixelsPerMeter]
                          , m = o.ba();
                        return o.N(m, u, d),
                        s.fallbackMatrix = m,
                        s.mainMatrix = m,
                        s
                    }
                    getFastPathSimpleProjectionMatrix(e) {
                        return this.calculatePosMatrix(e)
                    }
                }
                function Ko() {
                    o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
                }
                function un(h) {
                    if (h.useSlerp)
                        if (h.k < 1) {
                            const e = o.bb(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing)
                              , n = o.bb(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing)
                              , s = new Float64Array(4);
                            o.bc(s, e, n, h.k);
                            const u = o.bd(s);
                            h.tr.setRoll(u.roll),
                            h.tr.setPitch(u.pitch),
                            h.tr.setBearing(u.bearing)
                        } else
                            h.tr.setRoll(h.endEulerAngles.roll),
                            h.tr.setPitch(h.endEulerAngles.pitch),
                            h.tr.setBearing(h.endEulerAngles.bearing);
                    else
                        h.tr.setRoll(o.C.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)),
                        h.tr.setPitch(o.C.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)),
                        h.tr.setBearing(o.C.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k))
                }
                function Nn(h, e, n, s, u) {
                    const d = u.padding
                      , m = G(u.worldSize, n.getNorthWest())
                      , y = G(u.worldSize, n.getNorthEast())
                      , w = G(u.worldSize, n.getSouthEast())
                      , P = G(u.worldSize, n.getSouthWest())
                      , M = o.ae(-s)
                      , D = m.rotate(M)
                      , z = y.rotate(M)
                      , B = w.rotate(M)
                      , U = P.rotate(M)
                      , ee = new o.P(Math.max(D.x, z.x, U.x, B.x),Math.max(D.y, z.y, U.y, B.y))
                      , J = new o.P(Math.min(D.x, z.x, U.x, B.x),Math.min(D.y, z.y, U.y, B.y))
                      , re = ee.sub(J)
                      , se = (u.width - (d.left + d.right + e.left + e.right)) / re.x
                      , de = (u.height - (d.top + d.bottom + e.top + e.bottom)) / re.y;
                    if (de < 0 || se < 0)
                        return void Ko();
                    const ue = Math.min(o.ak(u.scale * Math.min(se, de)), h.maxZoom)
                      , ge = o.P.convert(h.offset)
                      , Te = new o.P((e.left - e.right) / 2,(e.top - e.bottom) / 2).rotate(o.ae(s))
                      , he = ge.add(Te).mult(u.scale / o.af(ue));
                    return {
                        center: K(u.worldSize, m.add(w).div(2).sub(he)),
                        zoom: ue,
                        bearing: s
                    }
                }
                class hn {
                    get useGlobeControls() {
                        return !1
                    }
                    handlePanInertia(e, n) {
                        return {
                            easingOffset: e,
                            easingCenter: n.center
                        }
                    }
                    handleMapControlsRollPitchBearingZoom(e, n) {
                        e.bearingDelta && n.setBearing(n.bearing + e.bearingDelta),
                        e.pitchDelta && n.setPitch(n.pitch + e.pitchDelta),
                        e.rollDelta && n.setRoll(n.roll + e.rollDelta),
                        e.zoomDelta && n.setZoom(n.zoom + e.zoomDelta)
                    }
                    handleMapControlsPan(e, n, s) {
                        e.around.distSqr(n.centerPoint) < .01 || n.setLocationAtPoint(s, e.around)
                    }
                    cameraForBoxAndBearing(e, n, s, u, d) {
                        return Nn(e, n, s, u, d)
                    }
                    handleJumpToCenterZoom(e, n) {
                        e.zoom !== (n.zoom !== void 0 ? +n.zoom : e.zoom) && e.setZoom(+n.zoom),
                        n.center !== void 0 && e.setCenter(o.S.convert(n.center))
                    }
                    handleEaseTo(e, n) {
                        const s = e.zoom
                          , u = e.padding
                          , d = {
                            roll: e.roll,
                            pitch: e.pitch,
                            bearing: e.bearing
                        }
                          , m = {
                            roll: n.roll === void 0 ? e.roll : n.roll,
                            pitch: n.pitch === void 0 ? e.pitch : n.pitch,
                            bearing: n.bearing === void 0 ? e.bearing : n.bearing
                        }
                          , y = n.zoom !== void 0
                          , w = !e.isPaddingEqual(n.padding);
                        let P = !1;
                        const M = y ? +n.zoom : e.zoom;
                        let D = e.centerPoint.add(n.offsetAsPoint);
                        const z = e.screenPointToLocation(D)
                          , {center: B, zoom: U} = e.getConstrained(o.S.convert(n.center || z), M ?? s);
                        vn(e, B);
                        const ee = G(e.worldSize, z)
                          , J = G(e.worldSize, B).sub(ee)
                          , re = o.af(U - s);
                        return P = U !== s,
                        {
                            easeFunc: se => {
                                if (P && e.setZoom(o.C.number(s, U, se)),
                                o.be(d, m) || un({
                                    startEulerAngles: d,
                                    endEulerAngles: m,
                                    tr: e,
                                    k: se,
                                    useSlerp: d.roll != m.roll
                                }),
                                w && (e.interpolatePadding(u, n.padding, se),
                                D = e.centerPoint.add(n.offsetAsPoint)),
                                n.around)
                                    e.setLocationAtPoint(n.around, n.aroundPoint);
                                else {
                                    const de = o.af(e.zoom - s)
                                      , ue = U > s ? Math.min(2, re) : Math.max(.5, re)
                                      , ge = Math.pow(ue, 1 - se)
                                      , Te = K(e.worldSize, ee.add(J.mult(se * ge)).mult(de));
                                    e.setLocationAtPoint(e.renderWorldCopies ? Te.wrap() : Te, D)
                                }
                            }
                            ,
                            isZooming: P,
                            elevationCenter: B
                        }
                    }
                    handleFlyTo(e, n) {
                        const s = n.zoom !== void 0
                          , u = e.zoom
                          , d = e.getConstrained(o.S.convert(n.center || n.locationAtOffset), s ? +n.zoom : u)
                          , m = d.center
                          , y = d.zoom;
                        vn(e, m);
                        const w = G(e.worldSize, n.locationAtOffset)
                          , P = G(e.worldSize, m).sub(w)
                          , M = P.mag()
                          , D = o.af(y - u);
                        let z;
                        if (n.minZoom !== void 0) {
                            const B = Math.min(+n.minZoom, u, y)
                              , U = e.getConstrained(m, B).zoom;
                            z = o.af(U - u)
                        }
                        return {
                            easeFunc: (B, U, ee, J) => {
                                e.setZoom(B === 1 ? y : u + o.ak(U));
                                const re = B === 1 ? m : K(e.worldSize, w.add(P.mult(ee)).mult(U));
                                e.setLocationAtPoint(e.renderWorldCopies ? re.wrap() : re, J)
                            }
                            ,
                            scaleOfZoom: D,
                            targetCenter: m,
                            scaleOfMinZoom: z,
                            pixelPathLength: M
                        }
                    }
                }
                class Ti {
                    constructor(e, n, s) {
                        this.blendFunction = e,
                        this.blendColor = n,
                        this.mask = s
                    }
                }
                Ti.Replace = [1, 0],
                Ti.disabled = new Ti(Ti.Replace,o.bf.transparent,[!1, !1, !1, !1]),
                Ti.unblended = new Ti(Ti.Replace,o.bf.transparent,[!0, !0, !0, !0]),
                Ti.alphaBlended = new Ti([1, 771],o.bf.transparent,[!0, !0, !0, !0]);
                const Za = 2305;
                class wr {
                    constructor(e, n, s) {
                        this.enable = e,
                        this.mode = n,
                        this.frontFace = s
                    }
                }
                wr.disabled = new wr(!1,1029,Za),
                wr.backCCW = new wr(!0,1029,Za),
                wr.frontCCW = new wr(!0,1028,Za);
                class Vr {
                    constructor(e, n, s) {
                        this.func = e,
                        this.mask = n,
                        this.range = s
                    }
                }
                Vr.ReadOnly = !1,
                Vr.ReadWrite = !0,
                Vr.disabled = new Vr(519,Vr.ReadOnly,[0, 1]);
                const ga = 7680;
                class hi {
                    constructor(e, n, s, u, d, m) {
                        this.test = e,
                        this.ref = n,
                        this.mask = s,
                        this.fail = u,
                        this.depthFail = d,
                        this.pass = m
                    }
                }
                hi.disabled = new hi({
                    func: 519,
                    mask: 0
                },0,0,ga,ga,ga);
                const ra = new WeakMap;
                function Ra(h) {
                    var e;
                    if (ra.has(h))
                        return ra.get(h);
                    {
                        const n = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
                        return ra.set(h, n),
                        n
                    }
                }
                class Ba {
                    get awaitingQuery() {
                        return !!this._readbackQueue
                    }
                    constructor(e) {
                        this._readbackWaitFrames = 4,
                        this._measureWaitFrames = 6,
                        this._texWidth = 1,
                        this._texHeight = 1,
                        this._measuredError = 0,
                        this._updateCount = 0,
                        this._lastReadbackFrame = -1e3,
                        this._readbackQueue = null,
                        this._cachedRenderContext = e;
                        const n = e.context
                          , s = n.gl;
                        this._texFormat = s.RGBA,
                        this._texType = s.UNSIGNED_BYTE;
                        const u = new o.aL;
                        u.emplaceBack(-1, -1),
                        u.emplaceBack(2, -1),
                        u.emplaceBack(-1, 2);
                        const d = new o.aN;
                        d.emplaceBack(0, 1, 2),
                        this._fullscreenTriangle = new Ri(n.createVertexBuffer(u, ui.members),n.createIndexBuffer(d),o.aM.simpleSegment(0, 0, u.length, d.length)),
                        this._resultBuffer = new Uint8Array(4),
                        n.activeTexture.set(s.TEXTURE1);
                        const m = s.createTexture();
                        s.bindTexture(s.TEXTURE_2D, m),
                        s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
                        s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
                        s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST),
                        s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST),
                        s.texImage2D(s.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null),
                        this._fbo = n.createFramebuffer(this._texWidth, this._texHeight, !1, !1),
                        this._fbo.colorAttachment.set(m),
                        Ra(s) && (this._pbo = s.createBuffer(),
                        s.bindBuffer(s.PIXEL_PACK_BUFFER, this._pbo),
                        s.bufferData(s.PIXEL_PACK_BUFFER, 4, s.STREAM_READ),
                        s.bindBuffer(s.PIXEL_PACK_BUFFER, null))
                    }
                    destroy() {
                        const e = this._cachedRenderContext.context.gl;
                        this._fullscreenTriangle.destroy(),
                        this._fbo.destroy(),
                        e.deleteBuffer(this._pbo),
                        this._fullscreenTriangle = null,
                        this._fbo = null,
                        this._pbo = null,
                        this._resultBuffer = null
                    }
                    updateErrorLoop(e, n) {
                        const s = this._updateCount;
                        return this._readbackQueue ? s >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : s >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, n),
                        this._updateCount++,
                        this._measuredError
                    }
                    _bindFramebuffer() {
                        const e = this._cachedRenderContext.context
                          , n = e.gl;
                        e.activeTexture.set(n.TEXTURE1),
                        n.bindTexture(n.TEXTURE_2D, this._fbo.colorAttachment.get()),
                        e.bindFramebuffer.set(this._fbo.framebuffer)
                    }
                    _renderErrorTexture(e, n) {
                        const s = this._cachedRenderContext.context
                          , u = s.gl;
                        if (this._bindFramebuffer(),
                        s.viewport.set([0, 0, this._texWidth, this._texHeight]),
                        s.clear({
                            color: o.bf.transparent
                        }),
                        this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(s, u.TRIANGLES, Vr.disabled, hi.disabled, Ti.unblended, wr.disabled, ( (d, m) => ({
                            u_input: d,
                            u_output_expected: m
                        }))(e, n), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments),
                        this._pbo && Ra(u)) {
                            u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo),
                            u.readBuffer(u.COLOR_ATTACHMENT0),
                            u.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0),
                            u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
                            const d = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
                            u.flush(),
                            this._readbackQueue = {
                                frameNumberIssued: this._updateCount,
                                sync: d
                            }
                        } else
                            this._readbackQueue = {
                                frameNumberIssued: this._updateCount,
                                sync: null
                            }
                    }
                    _tryReadback() {
                        const e = this._cachedRenderContext.context.gl;
                        if (this._pbo && this._readbackQueue && Ra(e)) {
                            const n = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
                            if (n === e.WAIT_FAILED)
                                return o.w("WebGL2 clientWaitSync failed."),
                                this._readbackQueue = null,
                                void (this._lastReadbackFrame = this._updateCount);
                            if (n === e.TIMEOUT_EXPIRED)
                                return;
                            e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo),
                            e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4),
                            e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
                        } else
                            this._bindFramebuffer(),
                            e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
                        this._readbackQueue = null,
                        this._measuredError = Ba._parseRGBA8float(this._resultBuffer),
                        this._lastReadbackFrame = this._updateCount
                    }
                    static _parseRGBA8float(e) {
                        let n = 0;
                        return n += e[0] / 256,
                        n += e[1] / 65536,
                        n += e[2] / 16777216,
                        e[3] < 127 && (n = -n),
                        n / 128
                    }
                }
                const Yo = o.$ / 128;
                function mc(h, e) {
                    const n = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1
                      , s = n + (h.generateBorders ? 2 : 0)
                      , u = n + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0)
                      , d = s + 1
                      , m = u + 1
                      , y = h.generateBorders ? -1 : 0
                      , w = h.generateBorders || h.extendToNorthPole ? -1 : 0
                      , P = n + (h.generateBorders ? 1 : 0)
                      , M = n + (h.generateBorders || h.extendToSouthPole ? 1 : 0)
                      , D = d * m
                      , z = s * u * 6
                      , B = d * m > 65536;
                    if (B && e === "16bit")
                        throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
                    const U = B || e === "32bit"
                      , ee = new Int16Array(2 * D);
                    let J = 0;
                    for (let de = w; de <= M; de++)
                        for (let ue = y; ue <= P; ue++) {
                            let ge = ue / n * o.$;
                            ue === -1 && (ge = -Yo),
                            ue === n + 1 && (ge = o.$ + Yo);
                            let Te = de / n * o.$;
                            de === -1 && (Te = h.extendToNorthPole ? o.bh : -Yo),
                            de === n + 1 && (Te = h.extendToSouthPole ? o.bi : o.$ + Yo),
                            ee[J++] = ge,
                            ee[J++] = Te
                        }
                    const re = U ? new Uint32Array(z) : new Uint16Array(z);
                    let se = 0;
                    for (let de = 0; de < u; de++)
                        for (let ue = 0; ue < s; ue++) {
                            const ge = ue + 1 + de * d
                              , Te = ue + (de + 1) * d
                              , he = ue + 1 + (de + 1) * d;
                            re[se++] = ue + de * d,
                            re[se++] = Te,
                            re[se++] = ge,
                            re[se++] = ge,
                            re[se++] = Te,
                            re[se++] = he
                        }
                    return {
                        vertices: ee.buffer.slice(0),
                        indices: re.buffer.slice(0),
                        uses32bitIndices: U
                    }
                }
                const Rs = new o.aK({
                    fill: new o.bj(128,2),
                    line: new o.bj(512,0),
                    tile: new o.bj(128,32),
                    stencil: new o.bj(128,1),
                    circle: 3
                });
                class co {
                    constructor() {
                        this._tileMeshCache = {},
                        this._errorCorrectionUsable = 0,
                        this._errorMeasurementLastValue = 0,
                        this._errorCorrectionPreviousValue = 0,
                        this._errorMeasurementLastChangeTime = -1e3
                    }
                    get name() {
                        return "vertical-perspective"
                    }
                    get transitionState() {
                        return 1
                    }
                    get useSubdivision() {
                        return !0
                    }
                    get shaderVariantName() {
                        return "globe"
                    }
                    get shaderDefine() {
                        return "#define GLOBE"
                    }
                    get shaderPreludeCode() {
                        return pi.projectionGlobe
                    }
                    get vertexShaderPreludeCode() {
                        return pi.projectionMercator.vertexSource
                    }
                    get subdivisionGranularity() {
                        return Rs
                    }
                    get useGlobeControls() {
                        return !0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._errorCorrectionUsable
                    }
                    destroy() {
                        this._errorMeasurement && this._errorMeasurement.destroy()
                    }
                    updateGPUdependent(e) {
                        this._errorMeasurement || (this._errorMeasurement = new Ba(e));
                        const n = o.U(this._errorQueryLatitudeDegrees)
                          , s = 2 * Math.atan(Math.exp(Math.PI - n * Math.PI * 2)) - .5 * Math.PI
                          , u = this._errorMeasurement.updateErrorLoop(n, s)
                          , d = ye.now();
                        u !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable,
                        this._errorMeasurementLastValue = u,
                        this._errorMeasurementLastChangeTime = d);
                        const m = Math.min(Math.max((d - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
                        this._errorCorrectionUsable = o.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bl(m))
                    }
                    _getMeshKey(e) {
                        return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`
                    }
                    getMeshFromTileID(e, n, s, u, d) {
                        const m = (d === "stencil" ? Rs.stencil : Rs.tile).getGranularityForZoomLevel(n.z);
                        return this._getMesh(e, {
                            granularity: m,
                            generateBorders: s,
                            extendToNorthPole: n.y === 0 && u,
                            extendToSouthPole: n.y === (1 << n.z) - 1 && u
                        })
                    }
                    _getMesh(e, n) {
                        const s = this._getMeshKey(n);
                        if (s in this._tileMeshCache)
                            return this._tileMeshCache[s];
                        const u = (function(d, m) {
                            const y = mc(m, "16bit")
                              , w = o.aL.deserialize({
                                arrayBuffer: y.vertices,
                                length: y.vertices.byteLength / 2 / 2
                            })
                              , P = o.aN.deserialize({
                                arrayBuffer: y.indices,
                                length: y.indices.byteLength / 2 / 3
                            });
                            return new Ri(d.createVertexBuffer(w, ui.members),d.createIndexBuffer(P),o.aM.simpleSegment(0, 0, w.length, P.length))
                        }
                        )(e, n);
                        return this._tileMeshCache[s] = u,
                        u
                    }
                    recalculate(e) {}
                    hasTransition() {
                        const e = ye.now();
                        let n = !1;
                        return n = n || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7,
                        n = n || this._errorMeasurement && this._errorMeasurement.awaitingQuery,
                        n
                    }
                    setErrorQueryLatitudeDegrees(e) {
                        this._errorQueryLatitudeDegrees = e
                    }
                }
                const Jo = new o.r({
                    type: new o.D(o.v.projection.type)
                });
                class Qo extends o.E {
                    constructor(e) {
                        super(),
                        this._transitionable = new o.t(Jo),
                        this.setProjection(e),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.recalculate(new o.F(0)),
                        this._mercatorProjection = new yr,
                        this._verticalPerspectiveProjection = new co
                    }
                    get transitionState() {
                        const e = this.properties.get("type");
                        if (typeof e == "string" && e === "mercator")
                            return 0;
                        if (typeof e == "string" && e === "vertical-perspective")
                            return 1;
                        if (e instanceof o.bm) {
                            if (e.from === "vertical-perspective" && e.to === "mercator")
                                return 1 - e.transition;
                            if (e.from === "mercator" && e.to === "vertical-perspective")
                                return e.transition
                        }
                        return 1
                    }
                    get useGlobeRendering() {
                        return this.transitionState > 0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
                    }
                    get currentProjection() {
                        return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
                    }
                    get name() {
                        return "globe"
                    }
                    get useSubdivision() {
                        return this.currentProjection.useSubdivision
                    }
                    get shaderVariantName() {
                        return this.currentProjection.shaderVariantName
                    }
                    get shaderDefine() {
                        return this.currentProjection.shaderDefine
                    }
                    get shaderPreludeCode() {
                        return this.currentProjection.shaderPreludeCode
                    }
                    get vertexShaderPreludeCode() {
                        return this.currentProjection.vertexShaderPreludeCode
                    }
                    get subdivisionGranularity() {
                        return this.currentProjection.subdivisionGranularity
                    }
                    get useGlobeControls() {
                        return this.transitionState > 0
                    }
                    destroy() {
                        this._mercatorProjection.destroy(),
                        this._verticalPerspectiveProjection.destroy()
                    }
                    updateGPUdependent(e) {
                        this._mercatorProjection.updateGPUdependent(e),
                        this._verticalPerspectiveProjection.updateGPUdependent(e)
                    }
                    getMeshFromTileID(e, n, s, u, d) {
                        return this.currentProjection.getMeshFromTileID(e, n, s, u, d)
                    }
                    setProjection(e) {
                        this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e)
                    }
                    setErrorQueryLatitudeDegrees(e) {
                        this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e),
                        this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
                    }
                }
                function el(h) {
                    const e = Bs(h.worldSize, h.center.lat);
                    return 2 * Math.PI * e
                }
                function va(h, e, n, s, u) {
                    const d = 1 / (1 << u)
                      , m = e / o.$ * d + s * d
                      , y = o.bo((h / o.$ * d + n * d) * Math.PI * 2 + Math.PI, 2 * Math.PI)
                      , w = 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI
                      , P = Math.cos(w)
                      , M = new Float64Array(3);
                    return M[0] = Math.sin(y) * P,
                    M[1] = Math.sin(w),
                    M[2] = Math.cos(y) * P,
                    M
                }
                function yn(h) {
                    return (function(e, n) {
                        const s = Math.cos(n)
                          , u = new Float64Array(3);
                        return u[0] = Math.sin(e) * s,
                        u[1] = Math.sin(n),
                        u[2] = Math.cos(e) * s,
                        u
                    }
                    )(h.lng * Math.PI / 180, h.lat * Math.PI / 180)
                }
                function Bs(h, e) {
                    return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
                }
                function uo(h) {
                    const e = Math.asin(h[1]) / Math.PI * 180
                      , n = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
                    if (n > 1e-6) {
                        const s = h[0] / n
                          , u = Math.acos(h[2] / n)
                          , d = (s > 0 ? u : -u) / Math.PI * 180;
                        return new o.S(o.aO(d, -180, 180),e)
                    }
                    return new o.S(0,e)
                }
                function fs(h) {
                    return Math.cos(h * Math.PI / 180)
                }
                function Gi(h, e) {
                    const n = fs(h)
                      , s = fs(e);
                    return o.ak(s / n)
                }
                function _h(h, e) {
                    const n = h.rotate(e.bearingInRadians)
                      , s = e.zoom + Gi(e.center.lat, 0)
                      , u = o.bk(1 / fs(e.center.lat), 1 / fs(Math.min(Math.abs(e.center.lat), 60)), o.bn(s, 7, 3, 0, 1))
                      , d = 360 / el({
                        worldSize: e.worldSize,
                        center: {
                            lat: e.center.lat
                        }
                    });
                    return new o.S(e.center.lng - n.x * d * u,o.ah(e.center.lat + n.y * d, -o.ai, o.ai))
                }
                function ho(h) {
                    const e = .5 * h
                      , n = Math.sin(e)
                      , s = Math.cos(e);
                    return Math.log(n + s) - Math.log(s - n)
                }
                function _c(h, e, n, s) {
                    const u = h.lat + n * s;
                    if (Math.abs(n) > 1) {
                        const d = (Math.sign(h.lat + n) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180
                          , m = Math.abs(h.lat + n) * Math.PI / 180
                          , y = ho(d + s * (m - d))
                          , w = ho(d)
                          , P = ho(m);
                        return new o.S(h.lng + e * ((y - w) / (P - w)),u)
                    }
                    return new o.S(h.lng + e * s,u)
                }
                class Yd {
                    constructor(e) {
                        this._cachePrevious = new Map,
                        this._cache = new Map,
                        this._hadAnyChanges = !1,
                        this._boundingVolumeFactory = e
                    }
                    swapBuffers() {
                        if (!this._hadAnyChanges)
                            return;
                        const e = this._cachePrevious;
                        this._cachePrevious = this._cache,
                        this._cache = e,
                        this._cache.clear(),
                        this._hadAnyChanges = !1
                    }
                    getTileBoundingVolume(e, n, s, u) {
                        const d = `${e.z}_${e.x}_${e.y}_${u != null && u.terrain ? "t" : ""}`
                          , m = this._cache.get(d);
                        if (m)
                            return m;
                        const y = this._cachePrevious.get(d);
                        if (y)
                            return this._cache.set(d, y),
                            y;
                        const w = this._boundingVolumeFactory(e, n, s, u);
                        return this._cache.set(d, w),
                        this._hadAnyChanges = !0,
                        w
                    }
                }
                class Fs {
                    constructor(e, n, s, u) {
                        this.min = s,
                        this.max = u,
                        this.points = e,
                        this.planes = n
                    }
                    static fromAabb(e, n) {
                        const s = [];
                        for (let u = 0; u < 8; u++)
                            s.push([1 & ~u ? e[0] : n[0], (u >> 1 & 1) == 1 ? n[1] : e[1], (u >> 2 & 1) == 1 ? n[2] : e[2]]);
                        return new Fs(s,[[-1, 0, 0, n[0]], [1, 0, 0, -e[0]], [0, -1, 0, n[1]], [0, 1, 0, -e[1]], [0, 0, -1, n[2]], [0, 0, 1, -e[2]]],e,n)
                    }
                    static fromCenterSizeAngles(e, n, s) {
                        const u = o.br([], s[0], s[1], s[2])
                          , d = o.bs([], [n[0], 0, 0], u)
                          , m = o.bs([], [0, n[1], 0], u)
                          , y = o.bs([], [0, 0, n[2]], u)
                          , w = [...e]
                          , P = [...e];
                        for (let D = 0; D < 8; D++)
                            for (let z = 0; z < 3; z++) {
                                const B = e[z] + d[z] * (1 & ~D ? -1 : 1) + m[z] * ((D >> 1 & 1) == 1 ? 1 : -1) + y[z] * ((D >> 2 & 1) == 1 ? 1 : -1);
                                w[z] = Math.min(w[z], B),
                                P[z] = Math.max(P[z], B)
                            }
                        const M = [];
                        for (let D = 0; D < 8; D++) {
                            const z = [...e];
                            o.aS(z, z, o.aR([], d, 1 & ~D ? -1 : 1)),
                            o.aS(z, z, o.aR([], m, (D >> 1 & 1) == 1 ? 1 : -1)),
                            o.aS(z, z, o.aR([], y, (D >> 2 & 1) == 1 ? 1 : -1)),
                            M.push(z)
                        }
                        return new Fs(M,[[...d, -o.aX(d, M[0])], [...m, -o.aX(m, M[0])], [...y, -o.aX(y, M[0])], [-d[0], -d[1], -d[2], -o.aX(d, M[7])], [-m[0], -m[1], -m[2], -o.aX(m, M[7])], [-y[0], -y[1], -y[2], -o.aX(y, M[7])]],w,P)
                    }
                    intersectsFrustum(e) {
                        let n = !0;
                        const s = this.points.length
                          , u = this.planes.length
                          , d = e.planes.length
                          , m = e.points.length;
                        for (let y = 0; y < d; y++) {
                            const w = e.planes[y];
                            let P = 0;
                            for (let M = 0; M < s; M++) {
                                const D = this.points[M];
                                w[0] * D[0] + w[1] * D[1] + w[2] * D[2] + w[3] >= 0 && P++
                            }
                            if (P === 0)
                                return 0;
                            P < s && (n = !1)
                        }
                        if (n)
                            return 2;
                        for (let y = 0; y < u; y++) {
                            const w = this.planes[y];
                            let P = 0;
                            for (let M = 0; M < m; M++) {
                                const D = e.points[M];
                                w[0] * D[0] + w[1] * D[1] + w[2] * D[2] + w[3] >= 0 && P++
                            }
                            if (P === 0)
                                return 0
                        }
                        return 1
                    }
                    intersectsPlane(e) {
                        const n = this.points.length;
                        let s = 0;
                        for (let u = 0; u < n; u++) {
                            const d = this.points[u];
                            e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && s++
                        }
                        return s === n ? 2 : s === 0 ? 0 : 1
                    }
                }
                function In(h, e, n) {
                    const s = h - e;
                    return s < 0 ? -s : Math.max(0, s - n)
                }
                function po(h, e, n, s, u) {
                    const d = h - n;
                    let m;
                    return m = d < 0 ? Math.min(-d, 1 + d - u) : d > 1 ? Math.min(Math.max(d - u, 0), 1 - d) : 0,
                    Math.max(m, In(e, s, u))
                }
                class Fa {
                    constructor() {
                        this._boundingVolumeCache = new Yd(this._computeTileBoundingVolume)
                    }
                    prepareNextFrame() {
                        this._boundingVolumeCache.swapBuffers()
                    }
                    distanceToTile2d(e, n, s, u) {
                        const d = 1 << s.z
                          , m = 1 / d
                          , y = s.x / d
                          , w = s.y / d;
                        let P = 2;
                        return P = Math.min(P, po(e, n, y, w, m)),
                        P = Math.min(P, po(e, n, y + .5, -w - m, m)),
                        P = Math.min(P, po(e, n, y + .5, 2 - w - m, m)),
                        P
                    }
                    getWrap(e, n, s) {
                        const u = 1 << n.z
                          , d = 1 / u
                          , m = n.x / u
                          , y = In(e.x, m, d)
                          , w = In(e.x, m - 1, d)
                          , P = In(e.x, m + 1, d)
                          , M = Math.min(y, w, P);
                        return M === P ? 1 : M === w ? -1 : 0
                    }
                    allowVariableZoom(e, n) {
                        return Ot(e, n) > 4
                    }
                    allowWorldCopies() {
                        return !1
                    }
                    getTileBoundingVolume(e, n, s, u) {
                        return this._boundingVolumeCache.getTileBoundingVolume(e, n, s, u)
                    }
                    _computeTileBoundingVolume(e, n, s, u) {
                        var d, m;
                        let y = 0
                          , w = 0;
                        if (u != null && u.terrain) {
                            const P = new o.Z(e.z,n,e.z,e.x,e.y)
                              , M = u.terrain.getMinMaxElevation(P);
                            y = (d = M.minElevation) !== null && d !== void 0 ? d : Math.min(0, s),
                            w = (m = M.maxElevation) !== null && m !== void 0 ? m : Math.max(0, s)
                        }
                        if (y /= o.bu,
                        w /= o.bu,
                        y += 1,
                        w += 1,
                        e.z <= 0)
                            return Fs.fromAabb([-w, -w, -w], [w, w, w]);
                        if (e.z === 1)
                            return Fs.fromAabb([e.x === 0 ? -w : 0, e.y === 0 ? 0 : -w, -w], [e.x === 0 ? 0 : w, e.y === 0 ? w : 0, w]);
                        {
                            const P = [va(0, 0, e.x, e.y, e.z), va(o.$, 0, e.x, e.y, e.z), va(o.$, o.$, e.x, e.y, e.z), va(0, o.$, e.x, e.y, e.z)]
                              , M = [];
                            for (const qe of P)
                                M.push(o.aR([], qe, w));
                            if (w !== y)
                                for (const qe of P)
                                    M.push(o.aR([], qe, y));
                            e.y === 0 && M.push([0, 1, 0]),
                            e.y === (1 << e.z) - 1 && M.push([0, -1, 0]);
                            const D = [1, 1, 1]
                              , z = [-1, -1, -1];
                            for (const qe of M)
                                for (let $e = 0; $e < 3; $e++)
                                    D[$e] = Math.min(D[$e], qe[$e]),
                                    z[$e] = Math.max(z[$e], qe[$e]);
                            const B = va(o.$ / 2, o.$ / 2, e.x, e.y, e.z)
                              , U = o.aW([], [0, 1, 0], B);
                            o.aV(U, U);
                            const ee = o.aW([], B, U);
                            o.aV(ee, ee);
                            const J = o.aW([], P[2], P[1]);
                            o.aV(J, J);
                            const re = o.aW([], P[0], P[3]);
                            o.aV(re, re),
                            M.push(o.aR([], B, w)),
                            e.y >= (1 << e.z) / 2 && M.push(o.aR([], va(o.$ / 2, 0, e.x, e.y, e.z), w)),
                            e.y < (1 << e.z) / 2 && M.push(o.aR([], va(o.$ / 2, o.$, e.x, e.y, e.z), w));
                            const se = fo(B, M)
                              , de = fo(ee, M)
                              , ue = [-B[0], -B[1], -B[2], se.max]
                              , ge = [B[0], B[1], B[2], -se.min]
                              , Te = [-ee[0], -ee[1], -ee[2], de.max]
                              , he = [ee[0], ee[1], ee[2], -de.min]
                              , De = [...J, 0]
                              , He = [...re, 0]
                              , je = [];
                            return e.y === 0 ? je.push(o.bt(He, De, ue), o.bt(He, De, ge)) : je.push(o.bt(Te, De, ue), o.bt(Te, De, ge), o.bt(Te, He, ue), o.bt(Te, He, ge)),
                            e.y === (1 << e.z) - 1 ? je.push(o.bt(He, De, ue), o.bt(He, De, ge)) : je.push(o.bt(he, De, ue), o.bt(he, De, ge), o.bt(he, He, ue), o.bt(he, He, ge)),
                            new Fs(je,[ue, ge, Te, he, De, He],D,z)
                        }
                    }
                }
                function fo(h, e) {
                    let n = 1 / 0
                      , s = -1 / 0;
                    for (const u of e) {
                        const d = o.aX(h, u);
                        n = Math.min(n, d),
                        s = Math.max(s, d)
                    }
                    return {
                        min: n,
                        max: s
                    }
                }
                class mo {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e)
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e)
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e)
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e)
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e)
                    }
                    setBearing(e) {
                        this._helper.setBearing(e)
                    }
                    setPitch(e) {
                        this._helper.setPitch(e)
                    }
                    setRoll(e) {
                        this._helper.setRoll(e)
                    }
                    setFov(e) {
                        this._helper.setFov(e)
                    }
                    setZoom(e) {
                        this._helper.setZoom(e)
                    }
                    setCenter(e) {
                        this._helper.setCenter(e)
                    }
                    setElevation(e) {
                        this._helper.setElevation(e)
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e)
                    }
                    setPadding(e) {
                        this._helper.setPadding(e)
                    }
                    interpolatePadding(e, n, s) {
                        return this._helper.interpolatePadding(e, n, s)
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e)
                    }
                    resize(e, n) {
                        this._helper.resize(e, n)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e)
                    }
                    overrideNearFarZ(e, n) {
                        this._helper.overrideNearFarZ(e, n)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    setTransitionState(e) {}
                    constructor() {
                        this._cachedClippingPlane = o.bv(),
                        this._projectionMatrix = o.b9(),
                        this._globeViewProjMatrix32f = o.b8(),
                        this._globeViewProjMatrixNoCorrection = o.b9(),
                        this._globeViewProjMatrixNoCorrectionInverted = o.b9(),
                        this._globeProjMatrixInverted = o.b9(),
                        this._cameraPosition = o.bp(),
                        this._globeLatitudeErrorCorrectionRadians = 0,
                        this._helper = new ln({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (e, n) => this.getConstrained(e, n)
                        }),
                        this._coveringTilesDetailsProvider = new Fa
                    }
                    clone() {
                        const e = new mo;
                        return e.apply(this),
                        e
                    }
                    apply(e, n) {
                        this._globeLatitudeErrorCorrectionRadians = n || 0,
                        this._helper.apply(e)
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this._globeViewProjMatrixNoCorrection
                    }
                    get inverseProjectionMatrix() {
                        return this._globeProjMatrixInverted
                    }
                    get cameraPosition() {
                        const e = o.bp();
                        return e[0] = this._cameraPosition[0],
                        e[1] = this._cameraPosition[1],
                        e[2] = this._cameraPosition[2],
                        e
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    getProjectionData(e) {
                        const {overscaledTileID: n, applyGlobeMatrix: s} = e
                          , u = this._helper.getMercatorTileCoordinates(n);
                        return {
                            mainMatrix: this._globeViewProjMatrix32f,
                            tileMercatorCoords: u,
                            clippingPlane: this._cachedClippingPlane,
                            projectionTransition: s ? 1 : 0,
                            fallbackMatrix: this._globeViewProjMatrix32f
                        }
                    }
                    _computeClippingPlane(e) {
                        const n = this.pitchInRadians
                          , s = this.cameraToCenterDistance / e
                          , u = Math.sin(n) * s
                          , d = Math.cos(n) * s + 1
                          , m = 1 / Math.sqrt(u * u + d * d) * 1;
                        let y = -u
                          , w = d;
                        const P = Math.sqrt(y * y + w * w);
                        y /= P,
                        w /= P;
                        const M = [0, y, w];
                        o.bw(M, M, [0, 0, 0], -this.bearingInRadians),
                        o.bx(M, M, [0, 0, 0], -1 * this.center.lat * Math.PI / 180),
                        o.by(M, M, [0, 0, 0], this.center.lng * Math.PI / 180);
                        const D = 1 / o.aZ(M);
                        return o.aR(M, M, D),
                        [...M, -m * D]
                    }
                    isLocationOccluded(e) {
                        return !this.isSurfacePointVisible(yn(e))
                    }
                    transformLightDirection(e) {
                        const n = this._helper._center.lng * Math.PI / 180
                          , s = this._helper._center.lat * Math.PI / 180
                          , u = Math.cos(s)
                          , d = [Math.sin(n) * u, Math.sin(s), Math.cos(n) * u]
                          , m = [d[2], 0, -d[0]]
                          , y = [0, 0, 0];
                        o.aW(y, m, d),
                        o.aV(m, m),
                        o.aV(y, y);
                        const w = [0, 0, 0];
                        return o.aV(w, [m[0] * e[0] + y[0] * e[1] + d[0] * e[2], m[1] * e[0] + y[1] * e[1] + d[1] * e[2], m[2] * e[0] + y[2] * e[1] + d[2] * e[2]]),
                        w
                    }
                    getPixelScale() {
                        return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
                    }
                    getCircleRadiusCorrection() {
                        return Math.cos(this._helper._center.lat * Math.PI / 180)
                    }
                    getPitchedTextCorrection(e, n, s) {
                        const u = (function(y, w, P) {
                            const M = 1 / (1 << P.z);
                            return new o.a1(y / o.$ * M + P.x * M,w / o.$ * M + P.y * M)
                        }
                        )(e, n, s.canonical)
                          , d = (m = u.y,
                        [o.bo(u.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI]);
                        var m;
                        return this.getCircleRadiusCorrection() / Math.cos(d[1])
                    }
                    projectTileCoordinates(e, n, s, u) {
                        const d = s.canonical
                          , m = va(e, n, d.x, d.y, d.z)
                          , y = 1 + (u ? u(e, n) : 0) / o.bu
                          , w = [m[0] * y, m[1] * y, m[2] * y, 1];
                        o.aw(w, w, this._globeViewProjMatrixNoCorrection);
                        const P = this._cachedClippingPlane
                          , M = P[0] * m[0] + P[1] * m[1] + P[2] * m[2] + P[3] < 0;
                        return {
                            point: new o.P(w[0] / w[3],w[1] / w[3]),
                            signedDistanceFromCamera: w[3],
                            isOccluded: M
                        }
                    }
                    _calcMatrices() {
                        if (!this._helper._width || !this._helper._height)
                            return;
                        const e = Bs(this.worldSize, this.center.lat)
                          , n = o.ba()
                          , s = o.ba();
                        this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5,
                        this._helper._farZ = this.cameraToCenterDistance + 2 * e),
                        o.b4(n, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
                        const u = this.centerOffset;
                        n[8] = 2 * -u.x / this._helper._width,
                        n[9] = 2 * u.y / this._helper._height,
                        this._projectionMatrix = o.b5(n),
                        this._globeProjMatrixInverted = o.ba(),
                        o.aq(this._globeProjMatrixInverted, n),
                        o.M(n, n, [0, 0, -this.cameraToCenterDistance]),
                        o.b6(n, n, this.rollInRadians),
                        o.b7(n, n, -this.pitchInRadians),
                        o.b6(n, n, this.bearingInRadians),
                        o.M(n, n, [0, 0, -e]);
                        const d = o.bp();
                        d[0] = e,
                        d[1] = e,
                        d[2] = e,
                        o.b7(s, n, this.center.lat * Math.PI / 180),
                        o.bz(s, s, -this.center.lng * Math.PI / 180),
                        o.N(s, s, d),
                        this._globeViewProjMatrixNoCorrection = s,
                        o.b7(n, n, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians),
                        o.bz(n, n, -this.center.lng * Math.PI / 180),
                        o.N(n, n, d),
                        this._globeViewProjMatrix32f = new Float32Array(n),
                        this._globeViewProjMatrixNoCorrectionInverted = o.ba(),
                        o.aq(this._globeViewProjMatrixNoCorrectionInverted, s);
                        const m = o.bp();
                        this._cameraPosition = o.bp(),
                        this._cameraPosition[2] = this.cameraToCenterDistance / e,
                        o.bw(this._cameraPosition, this._cameraPosition, m, -this.rollInRadians),
                        o.bx(this._cameraPosition, this._cameraPosition, m, this.pitchInRadians),
                        o.bw(this._cameraPosition, this._cameraPosition, m, -this.bearingInRadians),
                        o.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]),
                        o.bx(this._cameraPosition, this._cameraPosition, m, -this.center.lat * Math.PI / 180),
                        o.by(this._cameraPosition, this._cameraPosition, m, this.center.lng * Math.PI / 180),
                        this._cachedClippingPlane = this._computeClippingPlane(e);
                        const y = o.b5(this._globeViewProjMatrixNoCorrectionInverted);
                        o.N(y, y, [1, 1, -1]),
                        this._cachedFrustum = Ni.fromInvProjectionMatrix(y, 1, 0, this._cachedClippingPlane, !0)
                    }
                    calculateFogMatrix(e) {
                        o.w("calculateFogMatrix is not supported on globe projection.");
                        const n = o.ba();
                        return o.ag(n),
                        n
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        return [new o.b2(0,e)]
                    }
                    getCameraFrustum() {
                        return this._cachedFrustum
                    }
                    getClippingPlane() {
                        return this._cachedClippingPlane
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider
                    }
                    recalculateZoomAndCenter(e) {
                        e && o.w("terrain is not fully supported on vertical perspective projection."),
                        this._helper.recalculateZoomAndCenter(0)
                    }
                    maxPitchScaleFactor() {
                        return 1
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat()
                    }
                    lngLatToCameraDepth(e, n) {
                        if (!this._globeViewProjMatrixNoCorrection)
                            return 1;
                        const s = yn(e);
                        o.aR(s, s, 1 + n / o.bu);
                        const u = o.bv();
                        return o.aw(u, [s[0], s[1], s[2], 1], this._globeViewProjMatrixNoCorrection),
                        u[2] / u[3]
                    }
                    populateCache(e) {}
                    getBounds() {
                        const e = .5 * this.width
                          , n = .5 * this.height
                          , s = [new o.P(0,0), new o.P(e,0), new o.P(this.width,0), new o.P(this.width,n), new o.P(this.width,this.height), new o.P(e,this.height), new o.P(0,this.height), new o.P(0,n)]
                          , u = [];
                        for (const D of s)
                            u.push(this.unprojectScreenPoint(D));
                        let d = 0
                          , m = 0
                          , y = 0
                          , w = 0;
                        const P = this.center;
                        for (const D of u) {
                            const z = o.bA(P.lng, D.lng)
                              , B = o.bA(P.lat, D.lat);
                            z < m && (m = z),
                            z > d && (d = z),
                            B < w && (w = B),
                            B > y && (y = B)
                        }
                        const M = [P.lng + m, P.lat + w, P.lng + d, P.lat + y];
                        return this.isSurfacePointOnScreen([0, 1, 0]) && (M[3] = 90,
                        M[0] = -180,
                        M[2] = 180),
                        this.isSurfacePointOnScreen([0, -1, 0]) && (M[1] = -90,
                        M[0] = -180,
                        M[2] = 180),
                        new dt(M)
                    }
                    getConstrained(e, n) {
                        const s = o.ah(e.lat, -o.ai, o.ai)
                          , u = o.ah(+n, this.minZoom + Gi(0, s), this.maxZoom);
                        return {
                            center: new o.S(e.lng,s),
                            zoom: u
                        }
                    }
                    calculateCenterFromCameraLngLatAlt(e, n, s, u) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, n, s, u)
                    }
                    setLocationAtPoint(e, n) {
                        const s = yn(this.unprojectScreenPoint(n))
                          , u = yn(e)
                          , d = o.bp();
                        o.bB(d);
                        const m = o.bp();
                        o.by(m, s, d, -this.center.lng * Math.PI / 180),
                        o.bx(m, m, d, this.center.lat * Math.PI / 180);
                        const y = u[0] * u[0] + u[2] * u[2]
                          , w = m[0] * m[0];
                        if (y < w)
                            return;
                        const P = Math.sqrt(y - w)
                          , M = -P
                          , D = o.bC(u[0], u[2], m[0], P)
                          , z = o.bC(u[0], u[2], m[0], M)
                          , B = o.bp();
                        o.by(B, u, d, -D);
                        const U = o.bC(B[1], B[2], m[1], m[2])
                          , ee = o.bp();
                        o.by(ee, u, d, -z);
                        const J = o.bC(ee[1], ee[2], m[1], m[2])
                          , re = .5 * Math.PI
                          , se = U >= -re && U <= re
                          , de = J >= -re && J <= re;
                        let ue, ge;
                        if (se && de) {
                            const He = this.center.lng * Math.PI / 180
                              , je = this.center.lat * Math.PI / 180;
                            o.bD(D, He) + o.bD(U, je) < o.bD(z, He) + o.bD(J, je) ? (ue = D,
                            ge = U) : (ue = z,
                            ge = J)
                        } else if (se)
                            ue = D,
                            ge = U;
                        else {
                            if (!de)
                                return;
                            ue = z,
                            ge = J
                        }
                        const Te = ue / Math.PI * 180
                          , he = ge / Math.PI * 180
                          , De = this.center.lat;
                        this.setCenter(new o.S(Te,o.ah(he, -90, 90))),
                        this.setZoom(this.zoom + Gi(De, this.center.lat))
                    }
                    locationToScreenPoint(e, n) {
                        const s = yn(e);
                        if (n) {
                            const u = n.getElevationForLngLatZoom(e, this._helper._tileZoom);
                            o.aR(s, s, 1 + u / o.bu)
                        }
                        return this._projectSurfacePointToScreen(s)
                    }
                    _projectSurfacePointToScreen(e) {
                        const n = o.bv();
                        return o.aw(n, [...e, 1], this._globeViewProjMatrixNoCorrection),
                        n[0] /= n[3],
                        n[1] /= n[3],
                        new o.P((.5 * n[0] + .5) * this.width,(.5 * -n[1] + .5) * this.height)
                    }
                    screenPointToMercatorCoordinate(e, n) {
                        if (n) {
                            const s = n.pointCoordinate(e);
                            if (s)
                                return s
                        }
                        return o.a1.fromLngLat(this.unprojectScreenPoint(e))
                    }
                    screenPointToLocation(e, n) {
                        var s;
                        return (s = this.screenPointToMercatorCoordinate(e, n)) === null || s === void 0 ? void 0 : s.toLngLat()
                    }
                    isPointOnMapSurface(e, n) {
                        const s = this._cameraPosition
                          , u = this.getRayDirectionFromPixel(e);
                        return !!this.rayPlanetIntersection(s, u)
                    }
                    getRayDirectionFromPixel(e) {
                        const n = o.bv();
                        n[0] = e.x / this.width * 2 - 1,
                        n[1] = -1 * (e.y / this.height * 2 - 1),
                        n[2] = 1,
                        n[3] = 1,
                        o.aw(n, n, this._globeViewProjMatrixNoCorrectionInverted),
                        n[0] /= n[3],
                        n[1] /= n[3],
                        n[2] /= n[3];
                        const s = o.bp();
                        s[0] = n[0] - this._cameraPosition[0],
                        s[1] = n[1] - this._cameraPosition[1],
                        s[2] = n[2] - this._cameraPosition[2];
                        const u = o.bp();
                        return o.aV(u, s),
                        u
                    }
                    isSurfacePointVisible(e) {
                        const n = this._cachedClippingPlane;
                        return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] + n[3] >= 0
                    }
                    isSurfacePointOnScreen(e) {
                        if (!this.isSurfacePointVisible(e))
                            return !1;
                        const n = o.bv();
                        return o.aw(n, [...e, 1], this._globeViewProjMatrixNoCorrection),
                        n[0] /= n[3],
                        n[1] /= n[3],
                        n[2] /= n[3],
                        n[0] > -1 && n[0] < 1 && n[1] > -1 && n[1] < 1 && n[2] > -1 && n[2] < 1
                    }
                    rayPlanetIntersection(e, n) {
                        const s = o.aX(e, n)
                          , u = o.bp()
                          , d = o.bp();
                        o.aR(d, n, s),
                        o.aU(u, e, d);
                        const m = 1 - o.aX(u, u);
                        if (m < 0)
                            return null;
                        const y = o.aX(e, e) - 1
                          , w = -s + (s < 0 ? 1 : -1) * Math.sqrt(m)
                          , P = y / w
                          , M = w;
                        return {
                            tMin: Math.min(P, M),
                            tMax: Math.max(P, M)
                        }
                    }
                    unprojectScreenPoint(e) {
                        const n = this._cameraPosition
                          , s = this.getRayDirectionFromPixel(e)
                          , u = this.rayPlanetIntersection(n, s);
                        if (u) {
                            const M = o.bp();
                            o.aS(M, n, [s[0] * u.tMin, s[1] * u.tMin, s[2] * u.tMin]);
                            const D = o.bp();
                            return o.aV(D, M),
                            uo(D)
                        }
                        const d = this._cachedClippingPlane
                          , m = d[0] * s[0] + d[1] * s[1] + d[2] * s[2]
                          , y = -o.b1(d, n) / m
                          , w = o.bp();
                        if (y > 0)
                            o.aS(w, n, [s[0] * y, s[1] * y, s[2] * y]);
                        else {
                            const M = o.bp();
                            o.aS(M, n, [2 * s[0], 2 * s[1], 2 * s[2]]);
                            const D = o.b1(this._cachedClippingPlane, M);
                            o.aU(w, M, [this._cachedClippingPlane[0] * D, this._cachedClippingPlane[1] * D, this._cachedClippingPlane[2] * D])
                        }
                        const P = (function(M) {
                            const D = o.bp();
                            return D[0] = M[0] * -M[3],
                            D[1] = M[1] * -M[3],
                            D[2] = M[2] * -M[3],
                            {
                                center: D,
                                radius: Math.sqrt(1 - M[3] * M[3])
                            }
                        }
                        )(d);
                        return uo((function(M, D, z) {
                            const B = o.bp();
                            o.aU(B, z, M);
                            const U = o.bp();
                            return o.bq(U, M, B, D / o.a$(B)),
                            U
                        }
                        )(P.center, P.radius, w))
                    }
                    getMatrixForModel(e, n) {
                        const s = o.S.convert(e)
                          , u = 1 / o.bu
                          , d = o.b9();
                        return o.bz(d, d, s.lng / 180 * Math.PI),
                        o.b7(d, d, -s.lat / 180 * Math.PI),
                        o.M(d, d, [0, 0, 1 + n / o.bu]),
                        o.b7(d, d, .5 * Math.PI),
                        o.N(d, d, [u, u, u]),
                        d
                    }
                    getProjectionDataForCustomLayer(e=!0) {
                        const n = this.getProjectionData({
                            overscaledTileID: new o.Z(0,0,0,0,0),
                            applyGlobeMatrix: e
                        });
                        return n.tileMercatorCoords = [0, 0, 1, 1],
                        n
                    }
                    getFastPathSimpleProjectionMatrix(e) {}
                }
                class _o {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e)
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e)
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e)
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e)
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e)
                    }
                    setBearing(e) {
                        this._helper.setBearing(e)
                    }
                    setPitch(e) {
                        this._helper.setPitch(e)
                    }
                    setRoll(e) {
                        this._helper.setRoll(e)
                    }
                    setFov(e) {
                        this._helper.setFov(e)
                    }
                    setZoom(e) {
                        this._helper.setZoom(e)
                    }
                    setCenter(e) {
                        this._helper.setCenter(e)
                    }
                    setElevation(e) {
                        this._helper.setElevation(e)
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e)
                    }
                    setPadding(e) {
                        this._helper.setPadding(e)
                    }
                    interpolatePadding(e, n, s) {
                        return this._helper.interpolatePadding(e, n, s)
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e)
                    }
                    resize(e, n, s=!0) {
                        this._helper.resize(e, n, s)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e)
                    }
                    overrideNearFarZ(e, n) {
                        this._helper.overrideNearFarZ(e, n)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    get isGlobeRendering() {
                        return this._globeness > 0
                    }
                    setTransitionState(e, n) {
                        this._globeness = e,
                        this._globeLatitudeErrorCorrectionRadians = n,
                        this._calcMatrices(),
                        this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(),
                        this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
                    }
                    get currentTransform() {
                        return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
                    }
                    constructor() {
                        this._globeLatitudeErrorCorrectionRadians = 0,
                        this._globeness = 1,
                        this._helper = new ln({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (e, n) => this.getConstrained(e, n)
                        }),
                        this._globeness = 1,
                        this._mercatorTransform = new wi,
                        this._verticalPerspectiveTransform = new mo
                    }
                    clone() {
                        const e = new _o;
                        return e._globeness = this._globeness,
                        e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians,
                        e.apply(this),
                        e
                    }
                    apply(e) {
                        this._helper.apply(e),
                        this._mercatorTransform.apply(this),
                        this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
                    }
                    get projectionMatrix() {
                        return this.currentTransform.projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this.currentTransform.modelViewProjectionMatrix
                    }
                    get inverseProjectionMatrix() {
                        return this.currentTransform.inverseProjectionMatrix
                    }
                    get cameraPosition() {
                        return this.currentTransform.cameraPosition
                    }
                    getProjectionData(e) {
                        const n = this._mercatorTransform.getProjectionData(e)
                          , s = this._verticalPerspectiveTransform.getProjectionData(e);
                        return {
                            mainMatrix: this.isGlobeRendering ? s.mainMatrix : n.mainMatrix,
                            clippingPlane: s.clippingPlane,
                            tileMercatorCoords: s.tileMercatorCoords,
                            projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
                            fallbackMatrix: n.fallbackMatrix
                        }
                    }
                    isLocationOccluded(e) {
                        return this.currentTransform.isLocationOccluded(e)
                    }
                    transformLightDirection(e) {
                        return this.currentTransform.transformLightDirection(e)
                    }
                    getPixelScale() {
                        return o.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
                    }
                    getCircleRadiusCorrection() {
                        return o.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
                    }
                    getPitchedTextCorrection(e, n, s) {
                        const u = this._mercatorTransform.getPitchedTextCorrection(e, n, s)
                          , d = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, n, s);
                        return o.bk(u, d, this._globeness)
                    }
                    projectTileCoordinates(e, n, s, u) {
                        return this.currentTransform.projectTileCoordinates(e, n, s, u)
                    }
                    _calcMatrices() {
                        this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians),
                        this._helper._nearZ = this._verticalPerspectiveTransform.nearZ,
                        this._helper._farZ = this._verticalPerspectiveTransform.farZ,
                        this._mercatorTransform.apply(this, !0, this.isGlobeRendering),
                        this._helper._nearZ = this._mercatorTransform.nearZ,
                        this._helper._farZ = this._mercatorTransform.farZ)
                    }
                    calculateFogMatrix(e) {
                        return this.currentTransform.calculateFogMatrix(e)
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        return this.currentTransform.getVisibleUnwrappedCoordinates(e)
                    }
                    getCameraFrustum() {
                        return this.currentTransform.getCameraFrustum()
                    }
                    getClippingPlane() {
                        return this.currentTransform.getClippingPlane()
                    }
                    getCoveringTilesDetailsProvider() {
                        return this.currentTransform.getCoveringTilesDetailsProvider()
                    }
                    recalculateZoomAndCenter(e) {
                        this._mercatorTransform.recalculateZoomAndCenter(e),
                        this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
                    }
                    maxPitchScaleFactor() {
                        return this._mercatorTransform.maxPitchScaleFactor()
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat()
                    }
                    lngLatToCameraDepth(e, n) {
                        return this.currentTransform.lngLatToCameraDepth(e, n)
                    }
                    populateCache(e) {
                        this._mercatorTransform.populateCache(e),
                        this._verticalPerspectiveTransform.populateCache(e)
                    }
                    getBounds() {
                        return this.currentTransform.getBounds()
                    }
                    getConstrained(e, n) {
                        return this.currentTransform.getConstrained(e, n)
                    }
                    calculateCenterFromCameraLngLatAlt(e, n, s, u) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, n, s, u)
                    }
                    setLocationAtPoint(e, n) {
                        if (!this.isGlobeRendering)
                            return this._mercatorTransform.setLocationAtPoint(e, n),
                            void this.apply(this._mercatorTransform);
                        this._verticalPerspectiveTransform.setLocationAtPoint(e, n),
                        this.apply(this._verticalPerspectiveTransform)
                    }
                    locationToScreenPoint(e, n) {
                        return this.currentTransform.locationToScreenPoint(e, n)
                    }
                    screenPointToMercatorCoordinate(e, n) {
                        return this.currentTransform.screenPointToMercatorCoordinate(e, n)
                    }
                    screenPointToLocation(e, n) {
                        return this.currentTransform.screenPointToLocation(e, n)
                    }
                    isPointOnMapSurface(e, n) {
                        return this.currentTransform.isPointOnMapSurface(e, n)
                    }
                    getRayDirectionFromPixel(e) {
                        return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
                    }
                    getMatrixForModel(e, n) {
                        return this.currentTransform.getMatrixForModel(e, n)
                    }
                    getProjectionDataForCustomLayer(e=!0) {
                        const n = this._mercatorTransform.getProjectionDataForCustomLayer(e);
                        if (!this.isGlobeRendering)
                            return n;
                        const s = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
                        return s.fallbackMatrix = n.mainMatrix,
                        s
                    }
                    getFastPathSimpleProjectionMatrix(e) {
                        return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
                    }
                }
                class Dn {
                    get useGlobeControls() {
                        return !0
                    }
                    handlePanInertia(e, n) {
                        const s = _h(e, n);
                        return Math.abs(s.lng - n.center.lng) > 180 && (s.lng = n.center.lng + 179.5 * Math.sign(s.lng - n.center.lng)),
                        {
                            easingCenter: s,
                            easingOffset: new o.P(0,0)
                        }
                    }
                    handleMapControlsRollPitchBearingZoom(e, n) {
                        const s = e.around
                          , u = n.screenPointToLocation(s);
                        e.bearingDelta && n.setBearing(n.bearing + e.bearingDelta),
                        e.pitchDelta && n.setPitch(n.pitch + e.pitchDelta),
                        e.rollDelta && n.setRoll(n.roll + e.rollDelta);
                        const d = n.zoom;
                        e.zoomDelta && n.setZoom(n.zoom + e.zoomDelta);
                        const m = n.zoom - d;
                        if (m === 0)
                            return;
                        const y = o.bA(n.center.lng, u.lng)
                          , w = y / (Math.abs(y / 180) + 1)
                          , P = o.bA(n.center.lat, u.lat)
                          , M = n.getRayDirectionFromPixel(s)
                          , D = n.cameraPosition
                          , z = -1 * o.aX(D, M)
                          , B = o.bp();
                        o.aS(B, D, [M[0] * z, M[1] * z, M[2] * z]);
                        const U = o.aZ(B) - 1
                          , ee = Math.exp(.5 * -Math.max(U - .3, 0))
                          , J = Bs(n.worldSize, n.center.lat) / Math.min(n.width, n.height)
                          , re = o.bn(J, .9, .5, 1, .25)
                          , se = (1 - o.af(-m)) * Math.min(ee, re)
                          , de = n.center.lat
                          , ue = n.zoom
                          , ge = new o.S(n.center.lng + w * se,o.ah(n.center.lat + P * se, -o.ai, o.ai));
                        n.setLocationAtPoint(u, s);
                        const Te = n.center
                          , he = o.bn(Math.abs(y), 45, 85, 0, 1)
                          , De = o.bn(J, .75, .35, 0, 1)
                          , He = Math.pow(Math.max(he, De), .25)
                          , je = o.bA(Te.lng, ge.lng)
                          , qe = o.bA(Te.lat, ge.lat);
                        n.setCenter(new o.S(Te.lng + je * He,Te.lat + qe * He).wrap()),
                        n.setZoom(ue + Gi(de, n.center.lat))
                    }
                    handleMapControlsPan(e, n, s) {
                        if (!e.panDelta)
                            return;
                        const u = n.center.lat
                          , d = n.zoom;
                        n.setCenter(_h(e.panDelta, n).wrap()),
                        n.setZoom(d + Gi(u, n.center.lat))
                    }
                    cameraForBoxAndBearing(e, n, s, u, d) {
                        const m = Nn(e, n, s, u, d)
                          , y = n.left / d.width * 2 - 1
                          , w = (d.width - n.right) / d.width * 2 - 1
                          , P = n.top / d.height * -2 + 1
                          , M = (d.height - n.bottom) / d.height * -2 + 1
                          , D = o.bA(s.getWest(), s.getEast()) < 0
                          , z = D ? s.getEast() : s.getWest()
                          , B = D ? s.getWest() : s.getEast()
                          , U = Math.max(s.getNorth(), s.getSouth())
                          , ee = Math.min(s.getNorth(), s.getSouth())
                          , J = z + .5 * o.bA(z, B)
                          , re = U + .5 * o.bA(U, ee)
                          , se = d.clone();
                        se.setCenter(m.center),
                        se.setBearing(m.bearing),
                        se.setPitch(0),
                        se.setRoll(0),
                        se.setZoom(m.zoom);
                        const de = se.modelViewProjectionMatrix
                          , ue = [yn(s.getNorthWest()), yn(s.getNorthEast()), yn(s.getSouthWest()), yn(s.getSouthEast()), yn(new o.S(B,re)), yn(new o.S(z,re)), yn(new o.S(J,U)), yn(new o.S(J,ee))]
                          , ge = yn(m.center);
                        let Te = Number.POSITIVE_INFINITY;
                        for (const he of ue)
                            y < 0 && (Te = Dn.getLesserNonNegativeNonNull(Te, Dn.solveVectorScale(he, ge, de, "x", y))),
                            w > 0 && (Te = Dn.getLesserNonNegativeNonNull(Te, Dn.solveVectorScale(he, ge, de, "x", w))),
                            P > 0 && (Te = Dn.getLesserNonNegativeNonNull(Te, Dn.solveVectorScale(he, ge, de, "y", P))),
                            M < 0 && (Te = Dn.getLesserNonNegativeNonNull(Te, Dn.solveVectorScale(he, ge, de, "y", M)));
                        if (Number.isFinite(Te) && Te !== 0)
                            return m.zoom = se.zoom + o.ak(Te),
                            m;
                        Ko()
                    }
                    handleJumpToCenterZoom(e, n) {
                        const s = e.center.lat
                          , u = e.getConstrained(n.center ? o.S.convert(n.center) : e.center, e.zoom).center;
                        e.setCenter(u.wrap());
                        const d = n.zoom !== void 0 ? +n.zoom : e.zoom + Gi(s, u.lat);
                        e.zoom !== d && e.setZoom(d)
                    }
                    handleEaseTo(e, n) {
                        const s = e.zoom
                          , u = e.center
                          , d = e.padding
                          , m = {
                            roll: e.roll,
                            pitch: e.pitch,
                            bearing: e.bearing
                        }
                          , y = {
                            roll: n.roll === void 0 ? e.roll : n.roll,
                            pitch: n.pitch === void 0 ? e.pitch : n.pitch,
                            bearing: n.bearing === void 0 ? e.bearing : n.bearing
                        }
                          , w = n.zoom !== void 0
                          , P = !e.isPaddingEqual(n.padding);
                        let M = !1;
                        const D = n.center ? o.S.convert(n.center) : u
                          , z = e.getConstrained(D, s).center;
                        vn(e, z);
                        const B = e.clone();
                        B.setCenter(z),
                        B.setZoom(w ? +n.zoom : s + Gi(u.lat, D.lat)),
                        B.setBearing(n.bearing);
                        const U = new o.P(o.ah(e.centerPoint.x + n.offsetAsPoint.x, 0, e.width),o.ah(e.centerPoint.y + n.offsetAsPoint.y, 0, e.height));
                        B.setLocationAtPoint(z, U);
                        const ee = (n.offset && n.offsetAsPoint.mag()) > 0 ? B.center : z
                          , J = w ? +n.zoom : s + Gi(u.lat, ee.lat)
                          , re = s + Gi(u.lat, 0)
                          , se = J + Gi(ee.lat, 0)
                          , de = o.bA(u.lng, ee.lng)
                          , ue = o.bA(u.lat, ee.lat)
                          , ge = o.af(se - re);
                        return M = J !== s,
                        {
                            easeFunc: Te => {
                                if (o.be(m, y) || un({
                                    startEulerAngles: m,
                                    endEulerAngles: y,
                                    tr: e,
                                    k: Te,
                                    useSlerp: m.roll != y.roll
                                }),
                                P && e.interpolatePadding(d, n.padding, Te),
                                n.around)
                                    o.w("Easing around a point is not supported under globe projection."),
                                    e.setLocationAtPoint(n.around, n.aroundPoint);
                                else {
                                    const he = se > re ? Math.min(2, ge) : Math.max(.5, ge)
                                      , De = Math.pow(he, 1 - Te)
                                      , He = _c(u, de, ue, Te * De);
                                    e.setCenter(He.wrap())
                                }
                                if (M) {
                                    const he = o.C.number(re, se, Te) + Gi(0, e.center.lat);
                                    e.setZoom(he)
                                }
                            }
                            ,
                            isZooming: M,
                            elevationCenter: ee
                        }
                    }
                    handleFlyTo(e, n) {
                        const s = n.zoom !== void 0
                          , u = e.center
                          , d = e.zoom
                          , m = e.padding
                          , y = !e.isPaddingEqual(n.padding)
                          , w = e.getConstrained(o.S.convert(n.center || n.locationAtOffset), d).center
                          , P = s ? +n.zoom : e.zoom + Gi(e.center.lat, w.lat)
                          , M = e.clone();
                        M.setCenter(w),
                        M.setZoom(P),
                        M.setBearing(n.bearing);
                        const D = new o.P(o.ah(e.centerPoint.x + n.offsetAsPoint.x, 0, e.width),o.ah(e.centerPoint.y + n.offsetAsPoint.y, 0, e.height));
                        M.setLocationAtPoint(w, D);
                        const z = M.center;
                        vn(e, z);
                        const B = (function(ue, ge, Te) {
                            const he = yn(ge)
                              , De = yn(Te)
                              , He = o.aX(he, De)
                              , je = Math.acos(He)
                              , qe = el(ue);
                            return je / (2 * Math.PI) * qe
                        }
                        )(e, u, z)
                          , U = d + Gi(u.lat, 0)
                          , ee = P + Gi(z.lat, 0)
                          , J = o.af(ee - U);
                        let re;
                        if (typeof n.minZoom == "number") {
                            const ue = +n.minZoom + Gi(z.lat, 0)
                              , ge = Math.min(ue, U, ee) + Gi(0, z.lat)
                              , Te = e.getConstrained(z, ge).zoom + Gi(z.lat, 0);
                            re = o.af(Te - U)
                        }
                        const se = o.bA(u.lng, z.lng)
                          , de = o.bA(u.lat, z.lat);
                        return {
                            easeFunc: (ue, ge, Te, he) => {
                                const De = _c(u, se, de, Te);
                                y && e.interpolatePadding(m, n.padding, ue);
                                const He = ue === 1 ? z : De;
                                e.setCenter(He.wrap());
                                const je = U + o.ak(ge);
                                e.setZoom(ue === 1 ? P : je + Gi(0, He.lat))
                            }
                            ,
                            scaleOfZoom: J,
                            targetCenter: z,
                            scaleOfMinZoom: re,
                            pixelPathLength: B
                        }
                    }
                    static solveVectorScale(e, n, s, u, d) {
                        const m = u === "x" ? [s[0], s[4], s[8], s[12]] : [s[1], s[5], s[9], s[13]]
                          , y = [s[3], s[7], s[11], s[15]]
                          , w = e[0] * m[0] + e[1] * m[1] + e[2] * m[2]
                          , P = e[0] * y[0] + e[1] * y[1] + e[2] * y[2]
                          , M = n[0] * m[0] + n[1] * m[1] + n[2] * m[2]
                          , D = n[0] * y[0] + n[1] * y[1] + n[2] * y[2];
                        return M + d * P === w + d * D || y[3] * (w - M) + m[3] * (D - P) + w * D == M * P ? null : (M + m[3] - d * D - d * y[3]) / (M - w - d * D + d * P)
                    }
                    static getLesserNonNegativeNonNull(e, n) {
                        return n !== null && n >= 0 && n < e ? n : e
                    }
                }
                class gh {
                    constructor(e) {
                        this._globe = e,
                        this._mercatorCameraHelper = new hn,
                        this._verticalPerspectiveCameraHelper = new Dn
                    }
                    get useGlobeControls() {
                        return this._globe.useGlobeRendering
                    }
                    get currentHelper() {
                        return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
                    }
                    handlePanInertia(e, n) {
                        return this.currentHelper.handlePanInertia(e, n)
                    }
                    handleMapControlsRollPitchBearingZoom(e, n) {
                        return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, n)
                    }
                    handleMapControlsPan(e, n, s) {
                        this.currentHelper.handleMapControlsPan(e, n, s)
                    }
                    cameraForBoxAndBearing(e, n, s, u, d) {
                        return this.currentHelper.cameraForBoxAndBearing(e, n, s, u, d)
                    }
                    handleJumpToCenterZoom(e, n) {
                        this.currentHelper.handleJumpToCenterZoom(e, n)
                    }
                    handleEaseTo(e, n) {
                        return this.currentHelper.handleEaseTo(e, n)
                    }
                    handleFlyTo(e, n) {
                        return this.currentHelper.handleFlyTo(e, n)
                    }
                }
                const tl = (h, e) => o.y(h, e && e.filter((n => n.identifier !== "source.canvas")))
                  , Jd = o.bE();
                class gc extends o.E {
                    constructor(e, n={}) {
                        super(),
                        this._rtlPluginLoaded = () => {
                            for (const s in this.sourceCaches) {
                                const u = this.sourceCaches[s].getSource().type;
                                u !== "vector" && u !== "geojson" || this.sourceCaches[s].reload()
                            }
                        }
                        ,
                        this.map = e,
                        this.dispatcher = new xt(_t(),e._getMapId()),
                        this.dispatcher.registerMessageHandler("GG", ( (s, u) => this.getGlyphs(s, u))),
                        this.dispatcher.registerMessageHandler("GI", ( (s, u) => this.getImages(s, u))),
                        this.imageManager = new Je,
                        this.imageManager.setEventedParent(this),
                        this.glyphManager = new Qe(e._requestManager,n.localIdeographFontFamily),
                        this.lineAtlas = new ne(256,512),
                        this.crossTileSymbolIndex = new gi,
                        this._spritesImagesIds = {},
                        this._layers = {},
                        this._order = [],
                        this.sourceCaches = {},
                        this.zoomHistory = new o.bF,
                        this._loaded = !1,
                        this._availableImages = [],
                        this._globalState = {},
                        this._resetUpdates(),
                        this.dispatcher.broadcast("SR", o.bG()),
                        kr().on(ur, this._rtlPluginLoaded),
                        this.on("data", (s => {
                            if (s.dataType !== "source" || s.sourceDataType !== "metadata")
                                return;
                            const u = this.sourceCaches[s.sourceId];
                            if (!u)
                                return;
                            const d = u.getSource();
                            if (d && d.vectorLayerIds)
                                for (const m in this._layers) {
                                    const y = this._layers[m];
                                    y.source === d.id && this._validateLayer(y)
                                }
                        }
                        ))
                    }
                    setGlobalStateProperty(e, n) {
                        var s, u, d;
                        this._checkLoaded();
                        const m = n === null ? (d = (u = (s = this.stylesheet.state) === null || s === void 0 ? void 0 : s[e]) === null || u === void 0 ? void 0 : u.default) !== null && d !== void 0 ? d : null : n;
                        if (o.bH(m, this._globalState[e]))
                            return this;
                        this._globalState[e] = m;
                        const y = this._findGlobalStateAffectedSources([e]);
                        for (const w in this.sourceCaches)
                            y.has(w) && (this._reloadSource(w),
                            this._changed = !0)
                    }
                    getGlobalState() {
                        return this._globalState
                    }
                    setGlobalState(e) {
                        this._checkLoaded();
                        const n = [];
                        for (const u in e)
                            !o.bH(this._globalState[u], e[u].default) && (n.push(u),
                            this._globalState[u] = e[u].default);
                        const s = this._findGlobalStateAffectedSources(n);
                        for (const u in this.sourceCaches)
                            s.has(u) && (this._reloadSource(u),
                            this._changed = !0)
                    }
                    _findGlobalStateAffectedSources(e) {
                        if (e.length === 0)
                            return new Set;
                        const n = new Set;
                        for (const s in this._layers) {
                            const u = this._layers[s]
                              , d = u.getLayoutAffectingGlobalStateRefs();
                            for (const m of e)
                                d.has(m) && n.add(u.source)
                        }
                        return n
                    }
                    loadURL(e, n={}, s) {
                        this.fire(new o.l("dataloading",{
                            dataType: "style"
                        })),
                        n.validate = typeof n.validate != "boolean" || n.validate;
                        const u = this.map._requestManager.transformRequest(e, "Style");
                        this._loadStyleRequest = new AbortController;
                        const d = this._loadStyleRequest;
                        o.j(u, this._loadStyleRequest).then((m => {
                            this._loadStyleRequest = null,
                            this._load(m.data, n, s)
                        }
                        )).catch((m => {
                            this._loadStyleRequest = null,
                            m && !d.signal.aborted && this.fire(new o.k(m))
                        }
                        ))
                    }
                    loadJSON(e, n={}, s) {
                        this.fire(new o.l("dataloading",{
                            dataType: "style"
                        })),
                        this._frameRequest = new AbortController,
                        ye.frameAsync(this._frameRequest).then(( () => {
                            this._frameRequest = null,
                            n.validate = n.validate !== !1,
                            this._load(e, n, s)
                        }
                        )).catch(( () => {}
                        ))
                    }
                    loadEmpty() {
                        this.fire(new o.l("dataloading",{
                            dataType: "style"
                        })),
                        this._load(Jd, {
                            validate: !1
                        })
                    }
                    _load(e, n, s) {
                        var u, d, m;
                        const y = n.transformStyle ? n.transformStyle(s, e) : e;
                        if (!n.validate || !tl(this, o.z(y))) {
                            this._loaded = !0,
                            this.stylesheet = y;
                            for (const w in y.sources)
                                this.addSource(w, y.sources[w], {
                                    validate: !1
                                });
                            y.sprite ? this._loadSprite(y.sprite) : this.imageManager.setLoaded(!0),
                            this.glyphManager.setURL(y.glyphs),
                            this._createLayers(),
                            this.light = new Q(this.stylesheet.light),
                            this._setProjectionInternal(((u = this.stylesheet.projection) === null || u === void 0 ? void 0 : u.type) || "mercator"),
                            this.sky = new _e(this.stylesheet.sky),
                            this.map.setTerrain((d = this.stylesheet.terrain) !== null && d !== void 0 ? d : null),
                            this.setGlobalState((m = this.stylesheet.state) !== null && m !== void 0 ? m : null),
                            this.fire(new o.l("data",{
                                dataType: "style"
                            })),
                            this.fire(new o.l("style.load"))
                        }
                    }
                    _createLayers() {
                        const e = o.bI(this.stylesheet.layers);
                        this.dispatcher.broadcast("SL", e),
                        this._order = e.map((n => n.id)),
                        this._layers = {},
                        this._serializedLayers = null;
                        for (const n of e) {
                            const s = o.bJ(n);
                            s.setEventedParent(this, {
                                layer: {
                                    id: n.id
                                }
                            }),
                            this._layers[n.id] = s
                        }
                    }
                    _loadSprite(e, n=!1, s=void 0) {
                        let u;
                        this.imageManager.setLoaded(!1),
                        this._spriteRequest = new AbortController,
                        (function(d, m, y, w) {
                            return o._(this, void 0, void 0, (function*() {
                                const P = ht(d)
                                  , M = y > 1 ? "@2x" : ""
                                  , D = {}
                                  , z = {};
                                for (const {id: B, url: U} of P) {
                                    const ee = m.transformRequest(Xe(U, M, ".json"), "SpriteJSON");
                                    D[B] = o.j(ee, w);
                                    const J = m.transformRequest(Xe(U, M, ".png"), "SpriteImage");
                                    z[B] = Ne.getImage(J, w)
                                }
                                return yield Promise.all([...Object.values(D), ...Object.values(z)]),
                                (function(B, U) {
                                    return o._(this, void 0, void 0, (function*() {
                                        const ee = {};
                                        for (const J in B) {
                                            ee[J] = {};
                                            const re = ye.getImageCanvasContext((yield U[J]).data)
                                              , se = (yield B[J]).data;
                                            for (const de in se) {
                                                const {width: ue, height: ge, x: Te, y: he, sdf: De, pixelRatio: He, stretchX: je, stretchY: qe, content: $e, textFitWidth: Rt, textFitHeight: Nt} = se[de];
                                                ee[J][de] = {
                                                    data: null,
                                                    pixelRatio: He,
                                                    sdf: De,
                                                    stretchX: je,
                                                    stretchY: qe,
                                                    content: $e,
                                                    textFitWidth: Rt,
                                                    textFitHeight: Nt,
                                                    spriteData: {
                                                        width: ue,
                                                        height: ge,
                                                        x: Te,
                                                        y: he,
                                                        context: re
                                                    }
                                                }
                                            }
                                        }
                                        return ee
                                    }
                                    ))
                                }
                                )(D, z)
                            }
                            ))
                        }
                        )(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((d => {
                            if (this._spriteRequest = null,
                            d)
                                for (const m in d) {
                                    this._spritesImagesIds[m] = [];
                                    const y = this._spritesImagesIds[m] ? this._spritesImagesIds[m].filter((w => !(w in d))) : [];
                                    for (const w of y)
                                        this.imageManager.removeImage(w),
                                        this._changedImages[w] = !0;
                                    for (const w in d[m]) {
                                        const P = m === "default" ? w : `${m}:${w}`;
                                        this._spritesImagesIds[m].push(P),
                                        P in this.imageManager.images ? this.imageManager.updateImage(P, d[m][w], !1) : this.imageManager.addImage(P, d[m][w]),
                                        n && (this._changedImages[P] = !0)
                                    }
                                }
                        }
                        )).catch((d => {
                            this._spriteRequest = null,
                            u = d,
                            this.fire(new o.k(u))
                        }
                        )).finally(( () => {
                            this.imageManager.setLoaded(!0),
                            this._availableImages = this.imageManager.listImages(),
                            n && (this._changed = !0),
                            this.dispatcher.broadcast("SI", this._availableImages),
                            this.fire(new o.l("data",{
                                dataType: "style"
                            })),
                            s && s(u)
                        }
                        ))
                    }
                    _unloadSprite() {
                        for (const e of Object.values(this._spritesImagesIds).flat())
                            this.imageManager.removeImage(e),
                            this._changedImages[e] = !0;
                        this._spritesImagesIds = {},
                        this._availableImages = this.imageManager.listImages(),
                        this._changed = !0,
                        this.dispatcher.broadcast("SI", this._availableImages),
                        this.fire(new o.l("data",{
                            dataType: "style"
                        }))
                    }
                    _validateLayer(e) {
                        const n = this.sourceCaches[e.source];
                        if (!n)
                            return;
                        const s = e.sourceLayer;
                        if (!s)
                            return;
                        const u = n.getSource();
                        (u.type === "geojson" || u.vectorLayerIds && u.vectorLayerIds.indexOf(s) === -1) && this.fire(new o.k(new Error(`Source layer "${s}" does not exist on source "${u.id}" as specified by style layer "${e.id}".`)))
                    }
                    loaded() {
                        if (!this._loaded || Object.keys(this._updatedSources).length)
                            return !1;
                        for (const e in this.sourceCaches)
                            if (!this.sourceCaches[e].loaded())
                                return !1;
                        return !!this.imageManager.isLoaded()
                    }
                    _serializeByIds(e, n=!1) {
                        const s = this._serializedAllLayers();
                        if (!e || e.length === 0)
                            return Object.values(n ? o.bK(s) : s);
                        const u = [];
                        for (const d of e)
                            if (s[d]) {
                                const m = n ? o.bK(s[d]) : s[d];
                                u.push(m)
                            }
                        return u
                    }
                    _serializedAllLayers() {
                        let e = this._serializedLayers;
                        if (e)
                            return e;
                        e = this._serializedLayers = {};
                        const n = Object.keys(this._layers);
                        for (const s of n) {
                            const u = this._layers[s];
                            u.type !== "custom" && (e[s] = u.serialize())
                        }
                        return e
                    }
                    hasTransitions() {
                        var e, n, s;
                        if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((n = this.sky) === null || n === void 0) && n.hasTransition() || !((s = this.projection) === null || s === void 0) && s.hasTransition())
                            return !0;
                        for (const u in this.sourceCaches)
                            if (this.sourceCaches[u].hasTransition())
                                return !0;
                        for (const u in this._layers)
                            if (this._layers[u].hasTransition())
                                return !0;
                        return !1
                    }
                    _checkLoaded() {
                        if (!this._loaded)
                            throw new Error("Style is not done loading.")
                    }
                    update(e) {
                        if (!this._loaded)
                            return;
                        const n = this._changed;
                        if (n) {
                            const u = Object.keys(this._updatedLayers)
                              , d = Object.keys(this._removedLayers);
                            (u.length || d.length) && this._updateWorkerLayers(u, d);
                            for (const m in this._updatedSources) {
                                const y = this._updatedSources[m];
                                if (y === "reload")
                                    this._reloadSource(m);
                                else {
                                    if (y !== "clear")
                                        throw new Error(`Invalid action ${y}`);
                                    this._clearSource(m)
                                }
                            }
                            this._updateTilesForChangedImages(),
                            this._updateTilesForChangedGlyphs();
                            for (const m in this._updatedPaintProps)
                                this._layers[m].updateTransitions(e);
                            this.light.updateTransitions(e),
                            this.sky.updateTransitions(e),
                            this._resetUpdates()
                        }
                        const s = {};
                        for (const u in this.sourceCaches) {
                            const d = this.sourceCaches[u];
                            s[u] = d.used,
                            d.used = !1
                        }
                        for (const u of this._order) {
                            const d = this._layers[u];
                            d.recalculate(e, this._availableImages),
                            !d.isHidden(e.zoom) && d.source && (this.sourceCaches[d.source].used = !0)
                        }
                        for (const u in s) {
                            const d = this.sourceCaches[u];
                            !!s[u] != !!d.used && d.fire(new o.l("data",{
                                sourceDataType: "visibility",
                                dataType: "source",
                                sourceId: u
                            }))
                        }
                        this.light.recalculate(e),
                        this.sky.recalculate(e),
                        this.projection.recalculate(e),
                        this.z = e.zoom,
                        n && this.fire(new o.l("data",{
                            dataType: "style"
                        }))
                    }
                    _updateTilesForChangedImages() {
                        const e = Object.keys(this._changedImages);
                        if (e.length) {
                            for (const n in this.sourceCaches)
                                this.sourceCaches[n].reloadTilesForDependencies(["icons", "patterns"], e);
                            this._changedImages = {}
                        }
                    }
                    _updateTilesForChangedGlyphs() {
                        if (this._glyphsDidChange) {
                            for (const e in this.sourceCaches)
                                this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
                            this._glyphsDidChange = !1
                        }
                    }
                    _updateWorkerLayers(e, n) {
                        this.dispatcher.broadcast("UL", {
                            layers: this._serializeByIds(e, !1),
                            removedIds: n
                        })
                    }
                    _resetUpdates() {
                        this._changed = !1,
                        this._updatedLayers = {},
                        this._removedLayers = {},
                        this._updatedSources = {},
                        this._updatedPaintProps = {},
                        this._changedImages = {},
                        this._glyphsDidChange = !1
                    }
                    setState(e, n={}) {
                        var s;
                        this._checkLoaded();
                        const u = this.serialize();
                        if (e = n.transformStyle ? n.transformStyle(u, e) : e,
                        ((s = n.validate) === null || s === void 0 || s) && tl(this, o.z(e)))
                            return !1;
                        (e = o.bK(e)).layers = o.bI(e.layers);
                        const d = o.bL(u, e)
                          , m = this._getOperationsToPerform(d);
                        if (m.unimplemented.length > 0)
                            throw new Error(`Unimplemented: ${m.unimplemented.join(", ")}.`);
                        if (m.operations.length === 0)
                            return !1;
                        for (const y of m.operations)
                            y();
                        return this.stylesheet = e,
                        this._serializedLayers = null,
                        !0
                    }
                    _getOperationsToPerform(e) {
                        const n = []
                          , s = [];
                        for (const u of e)
                            switch (u.command) {
                            case "setCenter":
                            case "setZoom":
                            case "setBearing":
                            case "setPitch":
                            case "setRoll":
                                continue;
                            case "addLayer":
                                n.push(( () => this.addLayer.apply(this, u.args)));
                                break;
                            case "removeLayer":
                                n.push(( () => this.removeLayer.apply(this, u.args)));
                                break;
                            case "setPaintProperty":
                                n.push(( () => this.setPaintProperty.apply(this, u.args)));
                                break;
                            case "setLayoutProperty":
                                n.push(( () => this.setLayoutProperty.apply(this, u.args)));
                                break;
                            case "setFilter":
                                n.push(( () => this.setFilter.apply(this, u.args)));
                                break;
                            case "addSource":
                                n.push(( () => this.addSource.apply(this, u.args)));
                                break;
                            case "removeSource":
                                n.push(( () => this.removeSource.apply(this, u.args)));
                                break;
                            case "setLayerZoomRange":
                                n.push(( () => this.setLayerZoomRange.apply(this, u.args)));
                                break;
                            case "setLight":
                                n.push(( () => this.setLight.apply(this, u.args)));
                                break;
                            case "setGeoJSONSourceData":
                                n.push(( () => this.setGeoJSONSourceData.apply(this, u.args)));
                                break;
                            case "setGlyphs":
                                n.push(( () => this.setGlyphs.apply(this, u.args)));
                                break;
                            case "setSprite":
                                n.push(( () => this.setSprite.apply(this, u.args)));
                                break;
                            case "setTerrain":
                                n.push(( () => this.map.setTerrain.apply(this, u.args)));
                                break;
                            case "setSky":
                                n.push(( () => this.setSky.apply(this, u.args)));
                                break;
                            case "setProjection":
                                this.setProjection.apply(this, u.args);
                                break;
                            case "setGlobalState":
                                n.push(( () => this.setGlobalState.apply(this, u.args)));
                                break;
                            case "setTransition":
                                n.push(( () => {}
                                ));
                                break;
                            default:
                                s.push(u.command)
                            }
                        return {
                            operations: n,
                            unimplemented: s
                        }
                    }
                    addImage(e, n) {
                        if (this.getImage(e))
                            return this.fire(new o.k(new Error(`An image named "${e}" already exists.`)));
                        this.imageManager.addImage(e, n),
                        this._afterImageUpdated(e)
                    }
                    updateImage(e, n) {
                        this.imageManager.updateImage(e, n)
                    }
                    getImage(e) {
                        return this.imageManager.getImage(e)
                    }
                    removeImage(e) {
                        if (!this.getImage(e))
                            return this.fire(new o.k(new Error(`An image named "${e}" does not exist.`)));
                        this.imageManager.removeImage(e),
                        this._afterImageUpdated(e)
                    }
                    _afterImageUpdated(e) {
                        this._availableImages = this.imageManager.listImages(),
                        this._changedImages[e] = !0,
                        this._changed = !0,
                        this.dispatcher.broadcast("SI", this._availableImages),
                        this.fire(new o.l("data",{
                            dataType: "style"
                        }))
                    }
                    listImages() {
                        return this._checkLoaded(),
                        this.imageManager.listImages()
                    }
                    addSource(e, n, s={}) {
                        if (this._checkLoaded(),
                        this.sourceCaches[e] !== void 0)
                            throw new Error(`Source "${e}" already exists.`);
                        if (!n.type)
                            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n).join(", ")}.`);
                        if (["vector", "raster", "geojson", "video", "image"].indexOf(n.type) >= 0 && this._validate(o.z.source, `sources.${e}`, n, null, s))
                            return;
                        this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0);
                        const u = this.sourceCaches[e] = new Pt(e,n,this.dispatcher);
                        u.style = this,
                        u.setEventedParent(this, ( () => ({
                            isSourceLoaded: u.loaded(),
                            source: u.serialize(),
                            sourceId: e
                        }))),
                        u.onAdd(this.map),
                        this._changed = !0
                    }
                    removeSource(e) {
                        if (this._checkLoaded(),
                        this.sourceCaches[e] === void 0)
                            throw new Error("There is no source with this ID");
                        for (const s in this._layers)
                            if (this._layers[s].source === e)
                                return this.fire(new o.k(new Error(`Source "${e}" cannot be removed while layer "${s}" is using it.`)));
                        const n = this.sourceCaches[e];
                        delete this.sourceCaches[e],
                        delete this._updatedSources[e],
                        n.fire(new o.l("data",{
                            sourceDataType: "metadata",
                            dataType: "source",
                            sourceId: e
                        })),
                        n.setEventedParent(null),
                        n.onRemove(this.map),
                        this._changed = !0
                    }
                    setGeoJSONSourceData(e, n) {
                        if (this._checkLoaded(),
                        this.sourceCaches[e] === void 0)
                            throw new Error(`There is no source with this ID=${e}`);
                        const s = this.sourceCaches[e].getSource();
                        if (s.type !== "geojson")
                            throw new Error(`geojsonSource.type is ${s.type}, which is !== 'geojson`);
                        s.setData(n),
                        this._changed = !0
                    }
                    getSource(e) {
                        return this.sourceCaches[e] && this.sourceCaches[e].getSource()
                    }
                    addLayer(e, n, s={}) {
                        this._checkLoaded();
                        const u = e.id;
                        if (this.getLayer(u))
                            return void this.fire(new o.k(new Error(`Layer "${u}" already exists on this map.`)));
                        let d;
                        if (e.type === "custom") {
                            if (tl(this, o.bM(e)))
                                return;
                            d = o.bJ(e)
                        } else {
                            if ("source"in e && typeof e.source == "object" && (this.addSource(u, e.source),
                            e = o.bK(e),
                            e = o.e(e, {
                                source: u
                            })),
                            this._validate(o.z.layer, `layers.${u}`, e, {
                                arrayIndex: -1
                            }, s))
                                return;
                            d = o.bJ(e),
                            this._validateLayer(d),
                            d.setEventedParent(this, {
                                layer: {
                                    id: u
                                }
                            })
                        }
                        const m = n ? this._order.indexOf(n) : this._order.length;
                        if (n && m === -1)
                            this.fire(new o.k(new Error(`Cannot add layer "${u}" before non-existing layer "${n}".`)));
                        else {
                            if (this._order.splice(m, 0, u),
                            this._layerOrderChanged = !0,
                            this._layers[u] = d,
                            this._removedLayers[u] && d.source && d.type !== "custom") {
                                const y = this._removedLayers[u];
                                delete this._removedLayers[u],
                                y.type !== d.type ? this._updatedSources[d.source] = "clear" : (this._updatedSources[d.source] = "reload",
                                this.sourceCaches[d.source].pause())
                            }
                            this._updateLayer(d),
                            d.onAdd && d.onAdd(this.map)
                        }
                    }
                    moveLayer(e, n) {
                        if (this._checkLoaded(),
                        this._changed = !0,
                        !this._layers[e])
                            return void this.fire(new o.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
                        if (e === n)
                            return;
                        const s = this._order.indexOf(e);
                        this._order.splice(s, 1);
                        const u = n ? this._order.indexOf(n) : this._order.length;
                        n && u === -1 ? this.fire(new o.k(new Error(`Cannot move layer "${e}" before non-existing layer "${n}".`))) : (this._order.splice(u, 0, e),
                        this._layerOrderChanged = !0)
                    }
                    removeLayer(e) {
                        this._checkLoaded();
                        const n = this._layers[e];
                        if (!n)
                            return void this.fire(new o.k(new Error(`Cannot remove non-existing layer "${e}".`)));
                        n.setEventedParent(null);
                        const s = this._order.indexOf(e);
                        this._order.splice(s, 1),
                        this._layerOrderChanged = !0,
                        this._changed = !0,
                        this._removedLayers[e] = n,
                        delete this._layers[e],
                        this._serializedLayers && delete this._serializedLayers[e],
                        delete this._updatedLayers[e],
                        delete this._updatedPaintProps[e],
                        n.onRemove && n.onRemove(this.map)
                    }
                    getLayer(e) {
                        return this._layers[e]
                    }
                    getLayersOrder() {
                        return [...this._order]
                    }
                    hasLayer(e) {
                        return e in this._layers
                    }
                    setLayerZoomRange(e, n, s) {
                        this._checkLoaded();
                        const u = this.getLayer(e);
                        u ? u.minzoom === n && u.maxzoom === s || (n != null && (u.minzoom = n),
                        s != null && (u.maxzoom = s),
                        this._updateLayer(u)) : this.fire(new o.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
                    }
                    setFilter(e, n, s={}) {
                        this._checkLoaded();
                        const u = this.getLayer(e);
                        if (u) {
                            if (!o.bH(u.filter, n))
                                return n == null ? (u.setFilter(void 0),
                                void this._updateLayer(u)) : void (this._validate(o.z.filter, `layers.${u.id}.filter`, n, null, s) || (u.setFilter(o.bK(n)),
                                this._updateLayer(u)))
                        } else
                            this.fire(new o.k(new Error(`Cannot filter non-existing layer "${e}".`)))
                    }
                    getFilter(e) {
                        return o.bK(this.getLayer(e).filter)
                    }
                    setLayoutProperty(e, n, s, u={}) {
                        this._checkLoaded();
                        const d = this.getLayer(e);
                        d ? o.bH(d.getLayoutProperty(n), s) || (d.setLayoutProperty(n, s, u),
                        this._updateLayer(d)) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
                    }
                    getLayoutProperty(e, n) {
                        const s = this.getLayer(e);
                        if (s)
                            return s.getLayoutProperty(n);
                        this.fire(new o.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
                    }
                    setPaintProperty(e, n, s, u={}) {
                        this._checkLoaded();
                        const d = this.getLayer(e);
                        d ? o.bH(d.getPaintProperty(n), s) || (d.setPaintProperty(n, s, u) && this._updateLayer(d),
                        this._changed = !0,
                        this._updatedPaintProps[e] = !0,
                        this._serializedLayers = null) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
                    }
                    getPaintProperty(e, n) {
                        return this.getLayer(e).getPaintProperty(n)
                    }
                    setFeatureState(e, n) {
                        this._checkLoaded();
                        const s = e.source
                          , u = e.sourceLayer
                          , d = this.sourceCaches[s];
                        if (d === void 0)
                            return void this.fire(new o.k(new Error(`The source '${s}' does not exist in the map's style.`)));
                        const m = d.getSource().type;
                        m === "geojson" && u ? this.fire(new o.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : m !== "vector" || u ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))),
                        d.setFeatureState(u, e.id, n)) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    }
                    removeFeatureState(e, n) {
                        this._checkLoaded();
                        const s = e.source
                          , u = this.sourceCaches[s];
                        if (u === void 0)
                            return void this.fire(new o.k(new Error(`The source '${s}' does not exist in the map's style.`)));
                        const d = u.getSource().type
                          , m = d === "vector" ? e.sourceLayer : void 0;
                        d !== "vector" || m ? n && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new o.k(new Error("A feature id is required to remove its specific state property."))) : u.removeFeatureState(m, e.id, n) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    }
                    getFeatureState(e) {
                        this._checkLoaded();
                        const n = e.source
                          , s = e.sourceLayer
                          , u = this.sourceCaches[n];
                        if (u !== void 0)
                            return u.getSource().type !== "vector" || s ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))),
                            u.getFeatureState(s, e.id)) : void this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
                        this.fire(new o.k(new Error(`The source '${n}' does not exist in the map's style.`)))
                    }
                    getTransition() {
                        return o.e({
                            duration: 300,
                            delay: 0
                        }, this.stylesheet && this.stylesheet.transition)
                    }
                    serialize() {
                        if (!this._loaded)
                            return;
                        const e = o.bN(this.sourceCaches, (d => d.serialize()))
                          , n = this._serializeByIds(this._order, !0)
                          , s = this.map.getTerrain() || void 0
                          , u = this.stylesheet;
                        return o.bO({
                            version: u.version,
                            name: u.name,
                            metadata: u.metadata,
                            light: u.light,
                            sky: u.sky,
                            center: u.center,
                            zoom: u.zoom,
                            bearing: u.bearing,
                            pitch: u.pitch,
                            sprite: u.sprite,
                            glyphs: u.glyphs,
                            transition: u.transition,
                            projection: u.projection,
                            sources: e,
                            layers: n,
                            terrain: s
                        }, (d => d !== void 0))
                    }
                    _updateLayer(e) {
                        this._updatedLayers[e.id] = !0,
                        e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload",
                        this.sourceCaches[e.source].pause()),
                        this._serializedLayers = null,
                        this._changed = !0
                    }
                    _flattenAndSortRenderedFeatures(e) {
                        const n = m => this._layers[m].type === "fill-extrusion"
                          , s = {}
                          , u = [];
                        for (let m = this._order.length - 1; m >= 0; m--) {
                            const y = this._order[m];
                            if (n(y)) {
                                s[y] = m;
                                for (const w of e) {
                                    const P = w[y];
                                    if (P)
                                        for (const M of P)
                                            u.push(M)
                                }
                            }
                        }
                        u.sort(( (m, y) => y.intersectionZ - m.intersectionZ));
                        const d = [];
                        for (let m = this._order.length - 1; m >= 0; m--) {
                            const y = this._order[m];
                            if (n(y))
                                for (let w = u.length - 1; w >= 0; w--) {
                                    const P = u[w].feature;
                                    if (s[P.layer.id] < m)
                                        break;
                                    d.push(P),
                                    u.pop()
                                }
                            else
                                for (const w of e) {
                                    const P = w[y];
                                    if (P)
                                        for (const M of P)
                                            d.push(M.feature)
                                }
                        }
                        return d
                    }
                    queryRenderedFeatures(e, n, s) {
                        n && n.filter && this._validate(o.z.filter, "queryRenderedFeatures.filter", n.filter, null, n);
                        const u = {};
                        if (n && n.layers) {
                            if (!(Array.isArray(n.layers) || n.layers instanceof Set))
                                return this.fire(new o.k(new Error("parameters.layers must be an Array or a Set of strings"))),
                                [];
                            for (const P of n.layers) {
                                const M = this._layers[P];
                                if (!M)
                                    return this.fire(new o.k(new Error(`The layer '${P}' does not exist in the map's style and cannot be queried for features.`))),
                                    [];
                                u[M.source] = !0
                            }
                        }
                        const d = [];
                        n.availableImages = this._availableImages;
                        const m = this._serializedAllLayers()
                          , y = n.layers instanceof Set ? n.layers : Array.isArray(n.layers) ? new Set(n.layers) : null
                          , w = Object.assign(Object.assign({}, n), {
                            layers: y
                        });
                        for (const P in this.sourceCaches)
                            n.layers && !u[P] || d.push(It(this.sourceCaches[P], this._layers, m, e, w, s, this.map.terrain ? (M, D, z) => this.map.terrain.getElevation(M, D, z) : void 0));
                        return this.placement && d.push((function(P, M, D, z, B, U, ee) {
                            const J = {}
                              , re = U.queryRenderedSymbols(z)
                              , se = [];
                            for (const de of Object.keys(re).map(Number))
                                se.push(ee[de]);
                            se.sort(ut);
                            for (const de of se) {
                                const ue = de.featureIndex.lookupSymbolFeatures(re[de.bucketInstanceId], M, de.bucketIndex, de.sourceLayerIndex, B.filter, B.layers, B.availableImages, P);
                                for (const ge in ue) {
                                    const Te = J[ge] = J[ge] || []
                                      , he = ue[ge];
                                    he.sort(( (De, He) => {
                                        const je = de.featureSortOrder;
                                        if (je) {
                                            const qe = je.indexOf(De.featureIndex);
                                            return je.indexOf(He.featureIndex) - qe
                                        }
                                        return He.featureIndex - De.featureIndex
                                    }
                                    ));
                                    for (const De of he)
                                        Te.push(De)
                                }
                            }
                            return (function(de, ue, ge) {
                                for (const Te in de)
                                    for (const he of de[Te])
                                        bt(he, ge[ue[Te].source]);
                                return de
                            }
                            )(J, P, D)
                        }
                        )(this._layers, m, this.sourceCaches, e, w, this.placement.collisionIndex, this.placement.retainedQueryData)),
                        this._flattenAndSortRenderedFeatures(d)
                    }
                    querySourceFeatures(e, n) {
                        n && n.filter && this._validate(o.z.filter, "querySourceFeatures.filter", n.filter, null, n);
                        const s = this.sourceCaches[e];
                        return s ? (function(u, d) {
                            const m = u.getRenderableIds().map((P => u.getTileByID(P)))
                              , y = []
                              , w = {};
                            for (let P = 0; P < m.length; P++) {
                                const M = m[P]
                                  , D = M.tileID.canonical.key;
                                w[D] || (w[D] = !0,
                                M.querySourceFeatures(y, d))
                            }
                            return y
                        }
                        )(s, n) : []
                    }
                    getLight() {
                        return this.light.getLight()
                    }
                    setLight(e, n={}) {
                        this._checkLoaded();
                        const s = this.light.getLight();
                        let u = !1;
                        for (const m in e)
                            if (!o.bH(e[m], s[m])) {
                                u = !0;
                                break
                            }
                        if (!u)
                            return;
                        const d = {
                            now: ye.now(),
                            transition: o.e({
                                duration: 300,
                                delay: 0
                            }, this.stylesheet.transition)
                        };
                        this.light.setLight(e, n),
                        this.light.updateTransitions(d)
                    }
                    getProjection() {
                        var e;
                        return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
                    }
                    setProjection(e) {
                        if (this._checkLoaded(),
                        this.projection) {
                            if (this.projection.name === e.type)
                                return;
                            this.projection.destroy(),
                            delete this.projection
                        }
                        this.stylesheet.projection = e,
                        this._setProjectionInternal(e.type)
                    }
                    getSky() {
                        var e;
                        return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
                    }
                    setSky(e, n={}) {
                        this._checkLoaded();
                        const s = this.getSky();
                        let u = !1;
                        if (!e && !s)
                            return;
                        if (e && !s)
                            u = !0;
                        else if (!e && s)
                            u = !0;
                        else
                            for (const m in e)
                                if (!o.bH(e[m], s[m])) {
                                    u = !0;
                                    break
                                }
                        if (!u)
                            return;
                        const d = {
                            now: ye.now(),
                            transition: o.e({
                                duration: 300,
                                delay: 0
                            }, this.stylesheet.transition)
                        };
                        this.stylesheet.sky = e,
                        this.sky.setSky(e, n),
                        this.sky.updateTransitions(d)
                    }
                    _setProjectionInternal(e) {
                        const n = (function(s) {
                            if (Array.isArray(s)) {
                                const u = new Qo({
                                    type: s
                                });
                                return {
                                    projection: u,
                                    transform: new _o,
                                    cameraHelper: new gh(u)
                                }
                            }
                            switch (s) {
                            case "mercator":
                                return {
                                    projection: new yr,
                                    transform: new wi,
                                    cameraHelper: new hn
                                };
                            case "globe":
                                {
                                    const u = new Qo({
                                        type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"]
                                    });
                                    return {
                                        projection: u,
                                        transform: new _o,
                                        cameraHelper: new gh(u)
                                    }
                                }
                            case "vertical-perspective":
                                return {
                                    projection: new co,
                                    transform: new mo,
                                    cameraHelper: new Dn
                                };
                            default:
                                return o.w(`Unknown projection name: ${s}. Falling back to mercator projection.`),
                                {
                                    projection: new yr,
                                    transform: new wi,
                                    cameraHelper: new hn
                                }
                            }
                        }
                        )(e);
                        this.projection = n.projection,
                        this.map.migrateProjection(n.transform, n.cameraHelper);
                        for (const s in this.sourceCaches)
                            this.sourceCaches[s].reload()
                    }
                    _validate(e, n, s, u, d={}) {
                        return (!d || d.validate !== !1) && tl(this, e.call(o.z, o.e({
                            key: n,
                            style: this.serialize(),
                            value: s,
                            styleSpec: o.v
                        }, u)))
                    }
                    _remove(e=!0) {
                        this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._loadStyleRequest && (this._loadStyleRequest.abort(),
                        this._loadStyleRequest = null),
                        this._spriteRequest && (this._spriteRequest.abort(),
                        this._spriteRequest = null),
                        kr().off(ur, this._rtlPluginLoaded);
                        for (const n in this._layers)
                            this._layers[n].setEventedParent(null);
                        for (const n in this.sourceCaches) {
                            const s = this.sourceCaches[n];
                            s.setEventedParent(null),
                            s.onRemove(this.map)
                        }
                        this.imageManager.setEventedParent(null),
                        this.setEventedParent(null),
                        e && this.dispatcher.broadcast("RM", void 0),
                        this.dispatcher.remove(e)
                    }
                    _clearSource(e) {
                        this.sourceCaches[e].clearTiles()
                    }
                    _reloadSource(e) {
                        this.sourceCaches[e].resume(),
                        this.sourceCaches[e].reload()
                    }
                    _updateSources(e) {
                        for (const n in this.sourceCaches)
                            this.sourceCaches[n].update(e, this.map.terrain)
                    }
                    _generateCollisionBoxes() {
                        for (const e in this.sourceCaches)
                            this._reloadSource(e)
                    }
                    _updatePlacement(e, n, s, u, d=!1) {
                        let m = !1
                          , y = !1;
                        const w = {};
                        for (const P of this._order) {
                            const M = this._layers[P];
                            if (M.type !== "symbol")
                                continue;
                            if (!w[M.source]) {
                                const z = this.sourceCaches[M.source];
                                w[M.source] = z.getRenderableIds(!0).map((B => z.getTileByID(B))).sort(( (B, U) => U.tileID.overscaledZ - B.tileID.overscaledZ || (B.tileID.isLessThan(U.tileID) ? -1 : 1)))
                            }
                            const D = this.crossTileSymbolIndex.addLayer(M, w[M.source], e.center.lng);
                            m = m || D
                        }
                        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                        ((d = d || this._layerOrderChanged || s === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(ye.now(), e.zoom)) && (this.pauseablePlacement = new gn(e,this.map.terrain,this._order,d,n,s,u,this.placement),
                        this._layerOrderChanged = !1),
                        this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, w),
                        this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(ye.now()),
                        y = !0),
                        m && this.pauseablePlacement.placement.setStale()),
                        y || m)
                            for (const P of this._order) {
                                const M = this._layers[P];
                                M.type === "symbol" && this.placement.updateLayerOpacities(M, w[M.source])
                            }
                        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(ye.now())
                    }
                    _releaseSymbolFadeTiles() {
                        for (const e in this.sourceCaches)
                            this.sourceCaches[e].releaseSymbolFadeTiles()
                    }
                    getImages(e, n) {
                        return o._(this, void 0, void 0, (function*() {
                            const s = yield this.imageManager.getImages(n.icons);
                            this._updateTilesForChangedImages();
                            const u = this.sourceCaches[n.source];
                            return u && u.setDependencies(n.tileID.key, n.type, n.icons),
                            s
                        }
                        ))
                    }
                    getGlyphs(e, n) {
                        return o._(this, void 0, void 0, (function*() {
                            const s = yield this.glyphManager.getGlyphs(n.stacks)
                              , u = this.sourceCaches[n.source];
                            return u && u.setDependencies(n.tileID.key, n.type, [""]),
                            s
                        }
                        ))
                    }
                    getGlyphsUrl() {
                        return this.stylesheet.glyphs || null
                    }
                    setGlyphs(e, n={}) {
                        this._checkLoaded(),
                        e && this._validate(o.z.glyphs, "glyphs", e, null, n) || (this._glyphsDidChange = !0,
                        this.stylesheet.glyphs = e,
                        this.glyphManager.entries = {},
                        this.glyphManager.setURL(e))
                    }
                    addSprite(e, n, s={}, u) {
                        this._checkLoaded();
                        const d = [{
                            id: e,
                            url: n
                        }]
                          , m = [...ht(this.stylesheet.sprite), ...d];
                        this._validate(o.z.sprite, "sprite", m, null, s) || (this.stylesheet.sprite = m,
                        this._loadSprite(d, !0, u))
                    }
                    removeSprite(e) {
                        this._checkLoaded();
                        const n = ht(this.stylesheet.sprite);
                        if (n.find((s => s.id === e))) {
                            if (this._spritesImagesIds[e])
                                for (const s of this._spritesImagesIds[e])
                                    this.imageManager.removeImage(s),
                                    this._changedImages[s] = !0;
                            n.splice(n.findIndex((s => s.id === e)), 1),
                            this.stylesheet.sprite = n.length > 0 ? n : void 0,
                            delete this._spritesImagesIds[e],
                            this._availableImages = this.imageManager.listImages(),
                            this._changed = !0,
                            this.dispatcher.broadcast("SI", this._availableImages),
                            this.fire(new o.l("data",{
                                dataType: "style"
                            }))
                        } else
                            this.fire(new o.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
                    }
                    getSprite() {
                        return ht(this.stylesheet.sprite)
                    }
                    setSprite(e, n={}, s) {
                        this._checkLoaded(),
                        e && this._validate(o.z.sprite, "sprite", e, null, n) || (this.stylesheet.sprite = e,
                        e ? this._loadSprite(e, !0, s) : (this._unloadSprite(),
                        s && s(null)))
                    }
                }
                var Qd = o.aJ([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }, {
                    name: "a_texture_pos",
                    type: "Int16",
                    components: 2
                }]);
                class ep {
                    constructor() {
                        this.boundProgram = null,
                        this.boundLayoutVertexBuffer = null,
                        this.boundPaintVertexBuffers = [],
                        this.boundIndexBuffer = null,
                        this.boundVertexOffset = null,
                        this.boundDynamicVertexBuffer = null,
                        this.vao = null
                    }
                    bind(e, n, s, u, d, m, y, w, P) {
                        this.context = e;
                        let M = this.boundPaintVertexBuffers.length !== u.length;
                        for (let D = 0; !M && D < u.length; D++)
                            this.boundPaintVertexBuffers[D] !== u[D] && (M = !0);
                        !this.vao || this.boundProgram !== n || this.boundLayoutVertexBuffer !== s || M || this.boundIndexBuffer !== d || this.boundVertexOffset !== m || this.boundDynamicVertexBuffer !== y || this.boundDynamicVertexBuffer2 !== w || this.boundDynamicVertexBuffer3 !== P ? this.freshBind(n, s, u, d, m, y, w, P) : (e.bindVertexArray.set(this.vao),
                        y && y.bind(),
                        d && d.dynamicDraw && d.bind(),
                        w && w.bind(),
                        P && P.bind())
                    }
                    freshBind(e, n, s, u, d, m, y, w) {
                        const P = e.numAttributes
                          , M = this.context
                          , D = M.gl;
                        this.vao && this.destroy(),
                        this.vao = M.createVertexArray(),
                        M.bindVertexArray.set(this.vao),
                        this.boundProgram = e,
                        this.boundLayoutVertexBuffer = n,
                        this.boundPaintVertexBuffers = s,
                        this.boundIndexBuffer = u,
                        this.boundVertexOffset = d,
                        this.boundDynamicVertexBuffer = m,
                        this.boundDynamicVertexBuffer2 = y,
                        this.boundDynamicVertexBuffer3 = w,
                        n.enableAttributes(D, e);
                        for (const z of s)
                            z.enableAttributes(D, e);
                        m && m.enableAttributes(D, e),
                        y && y.enableAttributes(D, e),
                        w && w.enableAttributes(D, e),
                        n.bind(),
                        n.setVertexAttribPointers(D, e, d);
                        for (const z of s)
                            z.bind(),
                            z.setVertexAttribPointers(D, e, d);
                        m && (m.bind(),
                        m.setVertexAttribPointers(D, e, d)),
                        u && u.bind(),
                        y && (y.bind(),
                        y.setVertexAttribPointers(D, e, d)),
                        w && (w.bind(),
                        w.setVertexAttribPointers(D, e, d)),
                        M.currentNumAttributes = P
                    }
                    destroy() {
                        this.vao && (this.context.deleteVertexArray(this.vao),
                        this.vao = null)
                    }
                }
                const rl = (h, e, n, s, u) => ({
                    u_texture: 0,
                    u_ele_delta: h,
                    u_fog_matrix: e,
                    u_fog_color: n ? n.properties.get("fog-color") : o.bf.white,
                    u_fog_ground_blend: n ? n.properties.get("fog-ground-blend") : 1,
                    u_fog_ground_blend_opacity: u ? 0 : n ? n.calculateFogBlendOpacity(s) : 0,
                    u_horizon_color: n ? n.properties.get("horizon-color") : o.bf.white,
                    u_horizon_fog_blend: n ? n.properties.get("horizon-fog-blend") : 1,
                    u_is_globe_mode: u ? 1 : 0
                })
                  , vc = {
                    mainMatrix: "u_projection_matrix",
                    tileMercatorCoords: "u_projection_tile_mercator_coords",
                    clippingPlane: "u_projection_clipping_plane",
                    projectionTransition: "u_projection_transition",
                    fallbackMatrix: "u_projection_fallback_matrix"
                };
                function ms(h) {
                    const e = [];
                    for (let n = 0; n < h.length; n++) {
                        if (h[n] === null)
                            continue;
                        const s = h[n].split(" ");
                        e.push(s.pop())
                    }
                    return e
                }
                class yc {
                    constructor(e, n, s, u, d, m, y, w, P=[]) {
                        const M = e.gl;
                        this.program = M.createProgram();
                        const D = ms(n.staticAttributes)
                          , z = s ? s.getBinderAttributes() : []
                          , B = D.concat(z)
                          , U = pi.prelude.staticUniforms ? ms(pi.prelude.staticUniforms) : []
                          , ee = y.staticUniforms ? ms(y.staticUniforms) : []
                          , J = n.staticUniforms ? ms(n.staticUniforms) : []
                          , re = s ? s.getBinderUniforms() : []
                          , se = U.concat(ee).concat(J).concat(re)
                          , de = [];
                        for (const je of se)
                            de.indexOf(je) < 0 && de.push(je);
                        const ue = s ? s.defines() : [];
                        Ra(M) && ue.unshift("#version 300 es"),
                        d && ue.push("#define OVERDRAW_INSPECTOR;"),
                        m && ue.push("#define TERRAIN3D;"),
                        w && ue.push(w),
                        P && ue.push(...P);
                        let ge = ue.concat(pi.prelude.fragmentSource, y.fragmentSource, n.fragmentSource).join(`
`)
                          , Te = ue.concat(pi.prelude.vertexSource, y.vertexSource, n.vertexSource).join(`
`);
                        Ra(M) || (ge = (function(je) {
                            return je.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
                        }
                        )(ge),
                        Te = (function(je) {
                            return je.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
                        }
                        )(Te));
                        const he = M.createShader(M.FRAGMENT_SHADER);
                        if (M.isContextLost())
                            return void (this.failedToCreate = !0);
                        if (M.shaderSource(he, ge),
                        M.compileShader(he),
                        !M.getShaderParameter(he, M.COMPILE_STATUS))
                            throw new Error(`Could not compile fragment shader: ${M.getShaderInfoLog(he)}`);
                        M.attachShader(this.program, he);
                        const De = M.createShader(M.VERTEX_SHADER);
                        if (M.isContextLost())
                            return void (this.failedToCreate = !0);
                        if (M.shaderSource(De, Te),
                        M.compileShader(De),
                        !M.getShaderParameter(De, M.COMPILE_STATUS))
                            throw new Error(`Could not compile vertex shader: ${M.getShaderInfoLog(De)}`);
                        M.attachShader(this.program, De),
                        this.attributes = {};
                        const He = {};
                        this.numAttributes = B.length;
                        for (let je = 0; je < this.numAttributes; je++)
                            B[je] && (M.bindAttribLocation(this.program, je, B[je]),
                            this.attributes[B[je]] = je);
                        if (M.linkProgram(this.program),
                        !M.getProgramParameter(this.program, M.LINK_STATUS))
                            throw new Error(`Program failed to link: ${M.getProgramInfoLog(this.program)}`);
                        M.deleteShader(De),
                        M.deleteShader(he);
                        for (let je = 0; je < de.length; je++) {
                            const qe = de[je];
                            if (qe && !He[qe]) {
                                const $e = M.getUniformLocation(this.program, qe);
                                $e && (He[qe] = $e)
                            }
                        }
                        this.fixedUniforms = u(e, He),
                        this.terrainUniforms = ( (je, qe) => ({
                            u_depth: new o.bP(je,qe.u_depth),
                            u_terrain: new o.bP(je,qe.u_terrain),
                            u_terrain_dim: new o.bg(je,qe.u_terrain_dim),
                            u_terrain_matrix: new o.bR(je,qe.u_terrain_matrix),
                            u_terrain_unpack: new o.bS(je,qe.u_terrain_unpack),
                            u_terrain_exaggeration: new o.bg(je,qe.u_terrain_exaggeration)
                        }))(e, He),
                        this.projectionUniforms = ( (je, qe) => ({
                            u_projection_matrix: new o.bR(je,qe.u_projection_matrix),
                            u_projection_tile_mercator_coords: new o.bS(je,qe.u_projection_tile_mercator_coords),
                            u_projection_clipping_plane: new o.bS(je,qe.u_projection_clipping_plane),
                            u_projection_transition: new o.bg(je,qe.u_projection_transition),
                            u_projection_fallback_matrix: new o.bR(je,qe.u_projection_fallback_matrix)
                        }))(e, He),
                        this.binderUniforms = s ? s.getUniforms(e, He) : []
                    }
                    draw(e, n, s, u, d, m, y, w, P, M, D, z, B, U, ee, J, re, se, de) {
                        const ue = e.gl;
                        if (this.failedToCreate)
                            return;
                        if (e.program.set(this.program),
                        e.setDepthMode(s),
                        e.setStencilMode(u),
                        e.setColorMode(d),
                        e.setCullFace(m),
                        w) {
                            e.activeTexture.set(ue.TEXTURE2),
                            ue.bindTexture(ue.TEXTURE_2D, w.depthTexture),
                            e.activeTexture.set(ue.TEXTURE3),
                            ue.bindTexture(ue.TEXTURE_2D, w.texture);
                            for (const Te in this.terrainUniforms)
                                this.terrainUniforms[Te].set(w[Te])
                        }
                        if (P)
                            for (const Te in P)
                                this.projectionUniforms[vc[Te]].set(P[Te]);
                        if (y)
                            for (const Te in this.fixedUniforms)
                                this.fixedUniforms[Te].set(y[Te]);
                        J && J.setUniforms(e, this.binderUniforms, U, {
                            zoom: ee
                        });
                        let ge = 0;
                        switch (n) {
                        case ue.LINES:
                            ge = 2;
                            break;
                        case ue.TRIANGLES:
                            ge = 3;
                            break;
                        case ue.LINE_STRIP:
                            ge = 1
                        }
                        for (const Te of B.get()) {
                            const he = Te.vaos || (Te.vaos = {});
                            (he[M] || (he[M] = new ep)).bind(e, this, D, J ? J.getPaintVertexBuffers() : [], z, Te.vertexOffset, re, se, de),
                            ue.drawElements(n, Te.primitiveLength * ge, ue.UNSIGNED_SHORT, Te.primitiveOffset * ge * 2)
                        }
                    }
                }
                function il(h, e, n) {
                    const s = 1 / o.aC(n, 1, e.transform.tileZoom)
                      , u = Math.pow(2, n.tileID.overscaledZ)
                      , d = n.tileSize * Math.pow(2, e.transform.tileZoom) / u
                      , m = d * (n.tileID.canonical.x + n.tileID.wrap * u)
                      , y = d * n.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_texsize: n.imageAtlasTexture.size,
                        u_scale: [s, h.fromScale, h.toScale],
                        u_fade: h.t,
                        u_pixel_coord_upper: [m >> 16, y >> 16],
                        u_pixel_coord_lower: [65535 & m, 65535 & y]
                    }
                }
                const ya = (h, e, n, s) => {
                    const u = h.style.light
                      , d = u.properties.get("position")
                      , m = [d.x, d.y, d.z]
                      , y = o.bV();
                    u.properties.get("anchor") === "viewport" && o.bW(y, h.transform.bearingInRadians),
                    o.bX(m, m, y);
                    const w = h.transform.transformLightDirection(m)
                      , P = u.properties.get("color");
                    return {
                        u_lightpos: m,
                        u_lightpos_globe: w,
                        u_lightintensity: u.properties.get("intensity"),
                        u_lightcolor: [P.r, P.g, P.b],
                        u_vertical_gradient: +e,
                        u_opacity: n,
                        u_fill_translate: s
                    }
                }
                  , tp = (h, e, n, s, u, d, m) => o.e(ya(h, e, n, s), il(d, h, m), {
                    u_height_factor: -Math.pow(2, u.overscaledZ) / m.tileSize / 8
                })
                  , nl = (h, e, n, s) => o.e(il(e, h, n), {
                    u_fill_translate: s
                })
                  , go = (h, e) => ({
                    u_world: h,
                    u_fill_translate: e
                })
                  , vo = (h, e, n, s, u) => o.e(nl(h, e, n, u), {
                    u_world: s
                })
                  , rp = (h, e, n, s, u) => {
                    const d = h.transform;
                    let m, y, w = 0;
                    if (n.paint.get("circle-pitch-alignment") === "map") {
                        const P = o.aC(e, 1, d.zoom);
                        m = !0,
                        y = [P, P],
                        w = P / (o.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * u
                    } else
                        m = !1,
                        y = d.pixelsToGLUnits;
                    return {
                        u_camera_to_center_distance: d.cameraToCenterDistance,
                        u_scale_with_map: +(n.paint.get("circle-pitch-scale") === "map"),
                        u_pitch_with_map: +m,
                        u_device_pixel_ratio: h.pixelRatio,
                        u_extrude_scale: y,
                        u_globe_extrude_scale: w,
                        u_translate: s
                    }
                }
                  , al = h => ({
                    u_pixel_extrude_scale: [1 / h.width, 1 / h.height]
                })
                  , ip = h => ({
                    u_viewport_size: [h.width, h.height]
                })
                  , _s = (h, e=1) => ({
                    u_color: h,
                    u_overlay: 0,
                    u_overlay_scale: e
                })
                  , vh = (h, e, n, s) => {
                    const u = o.aC(h, 1, e) / (o.$ * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * s;
                    return {
                        u_extrude_scale: o.aC(h, 1, e),
                        u_intensity: n,
                        u_globe_extrude_scale: u
                    }
                }
                  , xc = (h, e, n, s) => {
                    const u = o.L();
                    o.bY(u, 0, h.width, h.height, 0, 0, 1);
                    const d = h.context.gl;
                    return {
                        u_matrix: u,
                        u_world: [d.drawingBufferWidth, d.drawingBufferHeight],
                        u_image: n,
                        u_color_ramp: s,
                        u_opacity: e.paint.get("heatmap-opacity")
                    }
                }
                  , np = (h, e, n) => {
                    const s = n.paint.get("hillshade-accent-color");
                    let u;
                    switch (n.paint.get("hillshade-method")) {
                    case "basic":
                        u = 4;
                        break;
                    case "combined":
                        u = 1;
                        break;
                    case "igor":
                        u = 2;
                        break;
                    case "multidirectional":
                        u = 3;
                        break;
                    default:
                        u = 0
                    }
                    const d = n.getIlluminationProperties();
                    for (let m = 0; m < d.directionRadians.length; m++)
                        n.paint.get("hillshade-illumination-anchor") === "viewport" && (d.directionRadians[m] += h.transform.bearingInRadians);
                    return {
                        u_image: 0,
                        u_latrange: bc(0, e.tileID),
                        u_exaggeration: n.paint.get("hillshade-exaggeration"),
                        u_altitudes: d.altitudeRadians,
                        u_azimuths: d.directionRadians,
                        u_accent: s,
                        u_method: u,
                        u_highlights: d.highlightColor,
                        u_shadows: d.shadowColor
                    }
                }
                  , yh = (h, e) => {
                    const n = e.stride
                      , s = o.L();
                    return o.bY(s, 0, o.$, -o.$, 0, 0, 1),
                    o.M(s, s, [0, -o.$, 0]),
                    {
                        u_matrix: s,
                        u_image: 1,
                        u_dimension: [n, n],
                        u_zoom: h.overscaledZ,
                        u_unpack: e.getUnpackVector()
                    }
                }
                ;
                function bc(h, e) {
                    const n = Math.pow(2, e.canonical.z)
                      , s = e.canonical.y;
                    return [new o.a1(0,s / n).toLngLat().lat, new o.a1(0,(s + 1) / n).toLngLat().lat]
                }
                const xh = (h, e, n=0) => ({
                    u_image: 0,
                    u_unpack: e.getUnpackVector(),
                    u_dimension: [e.stride, e.stride],
                    u_elevation_stops: 1,
                    u_color_stops: 4,
                    u_color_ramp_size: n,
                    u_opacity: h.paint.get("color-relief-opacity")
                })
                  , sl = (h, e, n, s) => {
                    const u = h.transform;
                    return {
                        u_translation: Tc(h, e, n),
                        u_ratio: s / o.aC(e, 1, u.zoom),
                        u_device_pixel_ratio: h.pixelRatio,
                        u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]]
                    }
                }
                  , bh = (h, e, n, s, u) => o.e(sl(h, e, n, s), {
                    u_image: 0,
                    u_image_height: u
                })
                  , wh = (h, e, n, s, u) => {
                    const d = h.transform
                      , m = wc(e, d);
                    return {
                        u_translation: Tc(h, e, n),
                        u_texsize: e.imageAtlasTexture.size,
                        u_ratio: s / o.aC(e, 1, d.zoom),
                        u_device_pixel_ratio: h.pixelRatio,
                        u_image: 0,
                        u_scale: [m, u.fromScale, u.toScale],
                        u_fade: u.t,
                        u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]]
                    }
                }
                  , gs = (h, e, n, s, u, d) => {
                    const m = h.lineAtlas
                      , y = wc(e, h.transform)
                      , w = n.layout.get("line-cap") === "round"
                      , P = m.getDash(u.from, w)
                      , M = m.getDash(u.to, w)
                      , D = P.width * d.fromScale
                      , z = M.width * d.toScale;
                    return o.e(sl(h, e, n, s), {
                        u_patternscale_a: [y / D, -P.height / 2],
                        u_patternscale_b: [y / z, -M.height / 2],
                        u_sdfgamma: m.width / (256 * Math.min(D, z) * h.pixelRatio) / 2,
                        u_image: 0,
                        u_tex_y_a: P.y,
                        u_tex_y_b: M.y,
                        u_mix: d.t
                    })
                }
                ;
                function wc(h, e) {
                    return 1 / o.aC(h, 1, e.tileZoom)
                }
                function Tc(h, e, n) {
                    return o.aD(h.transform, e, n.paint.get("line-translate"), n.paint.get("line-translate-anchor"))
                }
                const yo = (h, e, n, s, u) => {
                    return {
                        u_tl_parent: h,
                        u_scale_parent: e,
                        u_buffer_scale: 1,
                        u_fade_t: n.mix,
                        u_opacity: n.opacity * s.paint.get("raster-opacity"),
                        u_image0: 0,
                        u_image1: 1,
                        u_brightness_low: s.paint.get("raster-brightness-min"),
                        u_brightness_high: s.paint.get("raster-brightness-max"),
                        u_saturation_factor: (m = s.paint.get("raster-saturation"),
                        m > 0 ? 1 - 1 / (1.001 - m) : -m),
                        u_contrast_factor: (d = s.paint.get("raster-contrast"),
                        d > 0 ? 1 / (1 - d) : 1 + d),
                        u_spin_weights: ap(s.paint.get("raster-hue-rotate")),
                        u_coords_top: [u[0].x, u[0].y, u[1].x, u[1].y],
                        u_coords_bottom: [u[3].x, u[3].y, u[2].x, u[2].y]
                    };
                    var d, m
                }
                ;
                function ap(h) {
                    h *= Math.PI / 180;
                    const e = Math.sin(h)
                      , n = Math.cos(h);
                    return [(2 * n + 1) / 3, (-Math.sqrt(3) * e - n + 1) / 3, (Math.sqrt(3) * e - n + 1) / 3]
                }
                const xo = (h, e, n, s, u, d, m, y, w, P, M, D, z) => {
                    const B = m.transform;
                    return {
                        u_is_size_zoom_constant: +(h === "constant" || h === "source"),
                        u_is_size_feature_constant: +(h === "constant" || h === "camera"),
                        u_size_t: e ? e.uSizeT : 0,
                        u_size: e ? e.uSize : 0,
                        u_camera_to_center_distance: B.cameraToCenterDistance,
                        u_pitch: B.pitch / 360 * 2 * Math.PI,
                        u_rotate_symbol: +n,
                        u_aspect_ratio: B.width / B.height,
                        u_fade_change: m.options.fadeDuration ? m.symbolFadeChange : 1,
                        u_label_plane_matrix: y,
                        u_coord_matrix: w,
                        u_is_text: +M,
                        u_pitch_with_map: +s,
                        u_is_along_line: u,
                        u_is_variable_anchor: d,
                        u_texsize: D,
                        u_texture: 0,
                        u_translation: P,
                        u_pitched_scale: z
                    }
                }
                  , Th = (h, e, n, s, u, d, m, y, w, P, M, D, z, B) => {
                    const U = m.transform;
                    return o.e(xo(h, e, n, s, u, d, m, y, w, P, M, D, B), {
                        u_gamma_scale: s ? Math.cos(U.pitch * Math.PI / 180) * U.cameraToCenterDistance : 1,
                        u_device_pixel_ratio: m.pixelRatio,
                        u_is_halo: 1
                    })
                }
                  , sp = (h, e, n, s, u, d, m, y, w, P, M, D, z) => o.e(Th(h, e, n, s, u, d, m, y, w, P, !0, M, 0, z), {
                    u_texsize_icon: D,
                    u_texture_icon: 1
                })
                  , Ch = (h, e) => ({
                    u_opacity: h,
                    u_color: e
                })
                  , Sh = (h, e, n, s, u) => o.e((function(d, m, y, w) {
                    const P = y.imageManager.getPattern(d.from.toString())
                      , M = y.imageManager.getPattern(d.to.toString())
                      , {width: D, height: z} = y.imageManager.getPixelSize()
                      , B = Math.pow(2, w.tileID.overscaledZ)
                      , U = w.tileSize * Math.pow(2, y.transform.tileZoom) / B
                      , ee = U * (w.tileID.canonical.x + w.tileID.wrap * B)
                      , J = U * w.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_pattern_tl_a: P.tl,
                        u_pattern_br_a: P.br,
                        u_pattern_tl_b: M.tl,
                        u_pattern_br_b: M.br,
                        u_texsize: [D, z],
                        u_mix: m.t,
                        u_pattern_size_a: P.displaySize,
                        u_pattern_size_b: M.displaySize,
                        u_scale_a: m.fromScale,
                        u_scale_b: m.toScale,
                        u_tile_units_to_pixels: 1 / o.aC(w, 1, y.transform.tileZoom),
                        u_pixel_coord_upper: [ee >> 16, J >> 16],
                        u_pixel_coord_lower: [65535 & ee, 65535 & J]
                    }
                }
                )(n, u, e, s), {
                    u_opacity: h
                })
                  , Cc = (h, e) => {}
                  , Sc = {
                    fillExtrusion: (h, e) => ({
                        u_lightpos: new o.bT(h,e.u_lightpos),
                        u_lightpos_globe: new o.bT(h,e.u_lightpos_globe),
                        u_lightintensity: new o.bg(h,e.u_lightintensity),
                        u_lightcolor: new o.bT(h,e.u_lightcolor),
                        u_vertical_gradient: new o.bg(h,e.u_vertical_gradient),
                        u_opacity: new o.bg(h,e.u_opacity),
                        u_fill_translate: new o.bU(h,e.u_fill_translate)
                    }),
                    fillExtrusionPattern: (h, e) => ({
                        u_lightpos: new o.bT(h,e.u_lightpos),
                        u_lightpos_globe: new o.bT(h,e.u_lightpos_globe),
                        u_lightintensity: new o.bg(h,e.u_lightintensity),
                        u_lightcolor: new o.bT(h,e.u_lightcolor),
                        u_vertical_gradient: new o.bg(h,e.u_vertical_gradient),
                        u_height_factor: new o.bg(h,e.u_height_factor),
                        u_opacity: new o.bg(h,e.u_opacity),
                        u_fill_translate: new o.bU(h,e.u_fill_translate),
                        u_image: new o.bP(h,e.u_image),
                        u_texsize: new o.bU(h,e.u_texsize),
                        u_pixel_coord_upper: new o.bU(h,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bU(h,e.u_pixel_coord_lower),
                        u_scale: new o.bT(h,e.u_scale),
                        u_fade: new o.bg(h,e.u_fade)
                    }),
                    fill: (h, e) => ({
                        u_fill_translate: new o.bU(h,e.u_fill_translate)
                    }),
                    fillPattern: (h, e) => ({
                        u_image: new o.bP(h,e.u_image),
                        u_texsize: new o.bU(h,e.u_texsize),
                        u_pixel_coord_upper: new o.bU(h,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bU(h,e.u_pixel_coord_lower),
                        u_scale: new o.bT(h,e.u_scale),
                        u_fade: new o.bg(h,e.u_fade),
                        u_fill_translate: new o.bU(h,e.u_fill_translate)
                    }),
                    fillOutline: (h, e) => ({
                        u_world: new o.bU(h,e.u_world),
                        u_fill_translate: new o.bU(h,e.u_fill_translate)
                    }),
                    fillOutlinePattern: (h, e) => ({
                        u_world: new o.bU(h,e.u_world),
                        u_image: new o.bP(h,e.u_image),
                        u_texsize: new o.bU(h,e.u_texsize),
                        u_pixel_coord_upper: new o.bU(h,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bU(h,e.u_pixel_coord_lower),
                        u_scale: new o.bT(h,e.u_scale),
                        u_fade: new o.bg(h,e.u_fade),
                        u_fill_translate: new o.bU(h,e.u_fill_translate)
                    }),
                    circle: (h, e) => ({
                        u_camera_to_center_distance: new o.bg(h,e.u_camera_to_center_distance),
                        u_scale_with_map: new o.bP(h,e.u_scale_with_map),
                        u_pitch_with_map: new o.bP(h,e.u_pitch_with_map),
                        u_extrude_scale: new o.bU(h,e.u_extrude_scale),
                        u_device_pixel_ratio: new o.bg(h,e.u_device_pixel_ratio),
                        u_globe_extrude_scale: new o.bg(h,e.u_globe_extrude_scale),
                        u_translate: new o.bU(h,e.u_translate)
                    }),
                    collisionBox: (h, e) => ({
                        u_pixel_extrude_scale: new o.bU(h,e.u_pixel_extrude_scale)
                    }),
                    collisionCircle: (h, e) => ({
                        u_viewport_size: new o.bU(h,e.u_viewport_size)
                    }),
                    debug: (h, e) => ({
                        u_color: new o.bQ(h,e.u_color),
                        u_overlay: new o.bP(h,e.u_overlay),
                        u_overlay_scale: new o.bg(h,e.u_overlay_scale)
                    }),
                    depth: Cc,
                    clippingMask: Cc,
                    heatmap: (h, e) => ({
                        u_extrude_scale: new o.bg(h,e.u_extrude_scale),
                        u_intensity: new o.bg(h,e.u_intensity),
                        u_globe_extrude_scale: new o.bg(h,e.u_globe_extrude_scale)
                    }),
                    heatmapTexture: (h, e) => ({
                        u_matrix: new o.bR(h,e.u_matrix),
                        u_world: new o.bU(h,e.u_world),
                        u_image: new o.bP(h,e.u_image),
                        u_color_ramp: new o.bP(h,e.u_color_ramp),
                        u_opacity: new o.bg(h,e.u_opacity)
                    }),
                    hillshade: (h, e) => ({
                        u_image: new o.bP(h,e.u_image),
                        u_latrange: new o.bU(h,e.u_latrange),
                        u_exaggeration: new o.bg(h,e.u_exaggeration),
                        u_altitudes: new o.b_(h,e.u_altitudes),
                        u_azimuths: new o.b_(h,e.u_azimuths),
                        u_accent: new o.bQ(h,e.u_accent),
                        u_method: new o.bP(h,e.u_method),
                        u_shadows: new o.bZ(h,e.u_shadows),
                        u_highlights: new o.bZ(h,e.u_highlights)
                    }),
                    hillshadePrepare: (h, e) => ({
                        u_matrix: new o.bR(h,e.u_matrix),
                        u_image: new o.bP(h,e.u_image),
                        u_dimension: new o.bU(h,e.u_dimension),
                        u_zoom: new o.bg(h,e.u_zoom),
                        u_unpack: new o.bS(h,e.u_unpack)
                    }),
                    colorRelief: (h, e) => ({
                        u_image: new o.bP(h,e.u_image),
                        u_unpack: new o.bS(h,e.u_unpack),
                        u_dimension: new o.bU(h,e.u_dimension),
                        u_elevation_stops: new o.bP(h,e.u_elevation_stops),
                        u_color_stops: new o.bP(h,e.u_color_stops),
                        u_color_ramp_size: new o.bP(h,e.u_color_ramp_size),
                        u_opacity: new o.bg(h,e.u_opacity)
                    }),
                    line: (h, e) => ({
                        u_translation: new o.bU(h,e.u_translation),
                        u_ratio: new o.bg(h,e.u_ratio),
                        u_device_pixel_ratio: new o.bg(h,e.u_device_pixel_ratio),
                        u_units_to_pixels: new o.bU(h,e.u_units_to_pixels)
                    }),
                    lineGradient: (h, e) => ({
                        u_translation: new o.bU(h,e.u_translation),
                        u_ratio: new o.bg(h,e.u_ratio),
                        u_device_pixel_ratio: new o.bg(h,e.u_device_pixel_ratio),
                        u_units_to_pixels: new o.bU(h,e.u_units_to_pixels),
                        u_image: new o.bP(h,e.u_image),
                        u_image_height: new o.bg(h,e.u_image_height)
                    }),
                    linePattern: (h, e) => ({
                        u_translation: new o.bU(h,e.u_translation),
                        u_texsize: new o.bU(h,e.u_texsize),
                        u_ratio: new o.bg(h,e.u_ratio),
                        u_device_pixel_ratio: new o.bg(h,e.u_device_pixel_ratio),
                        u_image: new o.bP(h,e.u_image),
                        u_units_to_pixels: new o.bU(h,e.u_units_to_pixels),
                        u_scale: new o.bT(h,e.u_scale),
                        u_fade: new o.bg(h,e.u_fade)
                    }),
                    lineSDF: (h, e) => ({
                        u_translation: new o.bU(h,e.u_translation),
                        u_ratio: new o.bg(h,e.u_ratio),
                        u_device_pixel_ratio: new o.bg(h,e.u_device_pixel_ratio),
                        u_units_to_pixels: new o.bU(h,e.u_units_to_pixels),
                        u_patternscale_a: new o.bU(h,e.u_patternscale_a),
                        u_patternscale_b: new o.bU(h,e.u_patternscale_b),
                        u_sdfgamma: new o.bg(h,e.u_sdfgamma),
                        u_image: new o.bP(h,e.u_image),
                        u_tex_y_a: new o.bg(h,e.u_tex_y_a),
                        u_tex_y_b: new o.bg(h,e.u_tex_y_b),
                        u_mix: new o.bg(h,e.u_mix)
                    }),
                    raster: (h, e) => ({
                        u_tl_parent: new o.bU(h,e.u_tl_parent),
                        u_scale_parent: new o.bg(h,e.u_scale_parent),
                        u_buffer_scale: new o.bg(h,e.u_buffer_scale),
                        u_fade_t: new o.bg(h,e.u_fade_t),
                        u_opacity: new o.bg(h,e.u_opacity),
                        u_image0: new o.bP(h,e.u_image0),
                        u_image1: new o.bP(h,e.u_image1),
                        u_brightness_low: new o.bg(h,e.u_brightness_low),
                        u_brightness_high: new o.bg(h,e.u_brightness_high),
                        u_saturation_factor: new o.bg(h,e.u_saturation_factor),
                        u_contrast_factor: new o.bg(h,e.u_contrast_factor),
                        u_spin_weights: new o.bT(h,e.u_spin_weights),
                        u_coords_top: new o.bS(h,e.u_coords_top),
                        u_coords_bottom: new o.bS(h,e.u_coords_bottom)
                    }),
                    symbolIcon: (h, e) => ({
                        u_is_size_zoom_constant: new o.bP(h,e.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new o.bP(h,e.u_is_size_feature_constant),
                        u_size_t: new o.bg(h,e.u_size_t),
                        u_size: new o.bg(h,e.u_size),
                        u_camera_to_center_distance: new o.bg(h,e.u_camera_to_center_distance),
                        u_pitch: new o.bg(h,e.u_pitch),
                        u_rotate_symbol: new o.bP(h,e.u_rotate_symbol),
                        u_aspect_ratio: new o.bg(h,e.u_aspect_ratio),
                        u_fade_change: new o.bg(h,e.u_fade_change),
                        u_label_plane_matrix: new o.bR(h,e.u_label_plane_matrix),
                        u_coord_matrix: new o.bR(h,e.u_coord_matrix),
                        u_is_text: new o.bP(h,e.u_is_text),
                        u_pitch_with_map: new o.bP(h,e.u_pitch_with_map),
                        u_is_along_line: new o.bP(h,e.u_is_along_line),
                        u_is_variable_anchor: new o.bP(h,e.u_is_variable_anchor),
                        u_texsize: new o.bU(h,e.u_texsize),
                        u_texture: new o.bP(h,e.u_texture),
                        u_translation: new o.bU(h,e.u_translation),
                        u_pitched_scale: new o.bg(h,e.u_pitched_scale)
                    }),
                    symbolSDF: (h, e) => ({
                        u_is_size_zoom_constant: new o.bP(h,e.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new o.bP(h,e.u_is_size_feature_constant),
                        u_size_t: new o.bg(h,e.u_size_t),
                        u_size: new o.bg(h,e.u_size),
                        u_camera_to_center_distance: new o.bg(h,e.u_camera_to_center_distance),
                        u_pitch: new o.bg(h,e.u_pitch),
                        u_rotate_symbol: new o.bP(h,e.u_rotate_symbol),
                        u_aspect_ratio: new o.bg(h,e.u_aspect_ratio),
                        u_fade_change: new o.bg(h,e.u_fade_change),
                        u_label_plane_matrix: new o.bR(h,e.u_label_plane_matrix),
                        u_coord_matrix: new o.bR(h,e.u_coord_matrix),
                        u_is_text: new o.bP(h,e.u_is_text),
                        u_pitch_with_map: new o.bP(h,e.u_pitch_with_map),
                        u_is_along_line: new o.bP(h,e.u_is_along_line),
                        u_is_variable_anchor: new o.bP(h,e.u_is_variable_anchor),
                        u_texsize: new o.bU(h,e.u_texsize),
                        u_texture: new o.bP(h,e.u_texture),
                        u_gamma_scale: new o.bg(h,e.u_gamma_scale),
                        u_device_pixel_ratio: new o.bg(h,e.u_device_pixel_ratio),
                        u_is_halo: new o.bP(h,e.u_is_halo),
                        u_translation: new o.bU(h,e.u_translation),
                        u_pitched_scale: new o.bg(h,e.u_pitched_scale)
                    }),
                    symbolTextAndIcon: (h, e) => ({
                        u_is_size_zoom_constant: new o.bP(h,e.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new o.bP(h,e.u_is_size_feature_constant),
                        u_size_t: new o.bg(h,e.u_size_t),
                        u_size: new o.bg(h,e.u_size),
                        u_camera_to_center_distance: new o.bg(h,e.u_camera_to_center_distance),
                        u_pitch: new o.bg(h,e.u_pitch),
                        u_rotate_symbol: new o.bP(h,e.u_rotate_symbol),
                        u_aspect_ratio: new o.bg(h,e.u_aspect_ratio),
                        u_fade_change: new o.bg(h,e.u_fade_change),
                        u_label_plane_matrix: new o.bR(h,e.u_label_plane_matrix),
                        u_coord_matrix: new o.bR(h,e.u_coord_matrix),
                        u_is_text: new o.bP(h,e.u_is_text),
                        u_pitch_with_map: new o.bP(h,e.u_pitch_with_map),
                        u_is_along_line: new o.bP(h,e.u_is_along_line),
                        u_is_variable_anchor: new o.bP(h,e.u_is_variable_anchor),
                        u_texsize: new o.bU(h,e.u_texsize),
                        u_texsize_icon: new o.bU(h,e.u_texsize_icon),
                        u_texture: new o.bP(h,e.u_texture),
                        u_texture_icon: new o.bP(h,e.u_texture_icon),
                        u_gamma_scale: new o.bg(h,e.u_gamma_scale),
                        u_device_pixel_ratio: new o.bg(h,e.u_device_pixel_ratio),
                        u_is_halo: new o.bP(h,e.u_is_halo),
                        u_translation: new o.bU(h,e.u_translation),
                        u_pitched_scale: new o.bg(h,e.u_pitched_scale)
                    }),
                    background: (h, e) => ({
                        u_opacity: new o.bg(h,e.u_opacity),
                        u_color: new o.bQ(h,e.u_color)
                    }),
                    backgroundPattern: (h, e) => ({
                        u_opacity: new o.bg(h,e.u_opacity),
                        u_image: new o.bP(h,e.u_image),
                        u_pattern_tl_a: new o.bU(h,e.u_pattern_tl_a),
                        u_pattern_br_a: new o.bU(h,e.u_pattern_br_a),
                        u_pattern_tl_b: new o.bU(h,e.u_pattern_tl_b),
                        u_pattern_br_b: new o.bU(h,e.u_pattern_br_b),
                        u_texsize: new o.bU(h,e.u_texsize),
                        u_mix: new o.bg(h,e.u_mix),
                        u_pattern_size_a: new o.bU(h,e.u_pattern_size_a),
                        u_pattern_size_b: new o.bU(h,e.u_pattern_size_b),
                        u_scale_a: new o.bg(h,e.u_scale_a),
                        u_scale_b: new o.bg(h,e.u_scale_b),
                        u_pixel_coord_upper: new o.bU(h,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bU(h,e.u_pixel_coord_lower),
                        u_tile_units_to_pixels: new o.bg(h,e.u_tile_units_to_pixels)
                    }),
                    terrain: (h, e) => ({
                        u_texture: new o.bP(h,e.u_texture),
                        u_ele_delta: new o.bg(h,e.u_ele_delta),
                        u_fog_matrix: new o.bR(h,e.u_fog_matrix),
                        u_fog_color: new o.bQ(h,e.u_fog_color),
                        u_fog_ground_blend: new o.bg(h,e.u_fog_ground_blend),
                        u_fog_ground_blend_opacity: new o.bg(h,e.u_fog_ground_blend_opacity),
                        u_horizon_color: new o.bQ(h,e.u_horizon_color),
                        u_horizon_fog_blend: new o.bg(h,e.u_horizon_fog_blend),
                        u_is_globe_mode: new o.bg(h,e.u_is_globe_mode)
                    }),
                    terrainDepth: (h, e) => ({
                        u_ele_delta: new o.bg(h,e.u_ele_delta)
                    }),
                    terrainCoords: (h, e) => ({
                        u_texture: new o.bP(h,e.u_texture),
                        u_terrain_coords_id: new o.bg(h,e.u_terrain_coords_id),
                        u_ele_delta: new o.bg(h,e.u_ele_delta)
                    }),
                    projectionErrorMeasurement: (h, e) => ({
                        u_input: new o.bg(h,e.u_input),
                        u_output_expected: new o.bg(h,e.u_output_expected)
                    }),
                    atmosphere: (h, e) => ({
                        u_sun_pos: new o.bT(h,e.u_sun_pos),
                        u_atmosphere_blend: new o.bg(h,e.u_atmosphere_blend),
                        u_globe_position: new o.bT(h,e.u_globe_position),
                        u_globe_radius: new o.bg(h,e.u_globe_radius),
                        u_inv_proj_matrix: new o.bR(h,e.u_inv_proj_matrix)
                    }),
                    sky: (h, e) => ({
                        u_sky_color: new o.bQ(h,e.u_sky_color),
                        u_horizon_color: new o.bQ(h,e.u_horizon_color),
                        u_horizon: new o.bU(h,e.u_horizon),
                        u_horizon_normal: new o.bU(h,e.u_horizon_normal),
                        u_sky_horizon_blend: new o.bg(h,e.u_sky_horizon_blend),
                        u_sky_blend: new o.bg(h,e.u_sky_blend)
                    })
                };
                class Ph {
                    constructor(e, n, s) {
                        this.context = e;
                        const u = e.gl;
                        this.buffer = u.createBuffer(),
                        this.dynamicDraw = !!s,
                        this.context.unbindVAO(),
                        e.bindElementBuffer.set(this.buffer),
                        u.bufferData(u.ELEMENT_ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW),
                        this.dynamicDraw || delete n.arrayBuffer
                    }
                    bind() {
                        this.context.bindElementBuffer.set(this.buffer)
                    }
                    updateData(e) {
                        const n = this.context.gl;
                        if (!this.dynamicDraw)
                            throw new Error("Attempted to update data while not in dynamic mode.");
                        this.context.unbindVAO(),
                        this.bind(),
                        n.bufferSubData(n.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                const ol = {
                    Int8: "BYTE",
                    Uint8: "UNSIGNED_BYTE",
                    Int16: "SHORT",
                    Uint16: "UNSIGNED_SHORT",
                    Int32: "INT",
                    Uint32: "UNSIGNED_INT",
                    Float32: "FLOAT"
                };
                class $a {
                    constructor(e, n, s, u) {
                        this.length = n.length,
                        this.attributes = s,
                        this.itemSize = n.bytesPerElement,
                        this.dynamicDraw = u,
                        this.context = e;
                        const d = e.gl;
                        this.buffer = d.createBuffer(),
                        e.bindVertexBuffer.set(this.buffer),
                        d.bufferData(d.ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW),
                        this.dynamicDraw || delete n.arrayBuffer
                    }
                    bind() {
                        this.context.bindVertexBuffer.set(this.buffer)
                    }
                    updateData(e) {
                        if (e.length !== this.length)
                            throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
                        const n = this.context.gl;
                        this.bind(),
                        n.bufferSubData(n.ARRAY_BUFFER, 0, e.arrayBuffer)
                    }
                    enableAttributes(e, n) {
                        for (let s = 0; s < this.attributes.length; s++) {
                            const u = n.attributes[this.attributes[s].name];
                            u !== void 0 && e.enableVertexAttribArray(u)
                        }
                    }
                    setVertexAttribPointers(e, n, s) {
                        for (let u = 0; u < this.attributes.length; u++) {
                            const d = this.attributes[u]
                              , m = n.attributes[d.name];
                            m !== void 0 && e.vertexAttribPointer(m, d.components, e[ol[d.type]], !1, this.itemSize, d.offset + this.itemSize * (s || 0))
                        }
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                class vi {
                    constructor(e) {
                        this.gl = e.gl,
                        this.default = this.getDefault(),
                        this.current = this.default,
                        this.dirty = !1
                    }
                    get() {
                        return this.current
                    }
                    set(e) {}
                    getDefault() {
                        return this.default
                    }
                    setDefault() {
                        this.set(this.default)
                    }
                }
                class Pc extends vi {
                    getDefault() {
                        return o.bf.transparent
                    }
                    set(e) {
                        const n = this.current;
                        (e.r !== n.r || e.g !== n.g || e.b !== n.b || e.a !== n.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Ic extends vi {
                    getDefault() {
                        return 1
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.clearDepth(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Ih extends vi {
                    getDefault() {
                        return 0
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.clearStencil(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Mc extends vi {
                    getDefault() {
                        return [!0, !0, !0, !0]
                    }
                    set(e) {
                        const n = this.current;
                        (e[0] !== n[0] || e[1] !== n[1] || e[2] !== n[2] || e[3] !== n[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class vs extends vi {
                    getDefault() {
                        return !0
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.depthMask(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Ac extends vi {
                    getDefault() {
                        return 255
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.stencilMask(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class op extends vi {
                    getDefault() {
                        return {
                            func: this.gl.ALWAYS,
                            ref: 0,
                            mask: 255
                        }
                    }
                    set(e) {
                        const n = this.current;
                        (e.func !== n.func || e.ref !== n.ref || e.mask !== n.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class lp extends vi {
                    getDefault() {
                        const e = this.gl;
                        return [e.KEEP, e.KEEP, e.KEEP]
                    }
                    set(e) {
                        const n = this.current;
                        (e[0] !== n[0] || e[1] !== n[1] || e[2] !== n[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class cp extends vi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        e ? n.enable(n.STENCIL_TEST) : n.disable(n.STENCIL_TEST),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class up extends vi {
                    getDefault() {
                        return [0, 1]
                    }
                    set(e) {
                        const n = this.current;
                        (e[0] !== n[0] || e[1] !== n[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Mh extends vi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        e ? n.enable(n.DEPTH_TEST) : n.disable(n.DEPTH_TEST),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class hp extends vi {
                    getDefault() {
                        return this.gl.LESS
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.depthFunc(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Ah extends vi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        e ? n.enable(n.BLEND) : n.disable(n.BLEND),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class ll extends vi {
                    getDefault() {
                        const e = this.gl;
                        return [e.ONE, e.ZERO]
                    }
                    set(e) {
                        const n = this.current;
                        (e[0] !== n[0] || e[1] !== n[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class cl extends vi {
                    getDefault() {
                        return o.bf.transparent
                    }
                    set(e) {
                        const n = this.current;
                        (e.r !== n.r || e.g !== n.g || e.b !== n.b || e.a !== n.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class ul extends vi {
                    getDefault() {
                        return this.gl.FUNC_ADD
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.blendEquation(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class kc extends vi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        e ? n.enable(n.CULL_FACE) : n.disable(n.CULL_FACE),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class ys extends vi {
                    getDefault() {
                        return this.gl.BACK
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.cullFace(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class bo extends vi {
                    getDefault() {
                        return this.gl.CCW
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.frontFace(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Os extends vi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.useProgram(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class ca extends vi {
                    getDefault() {
                        return this.gl.TEXTURE0
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.activeTexture(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class kh extends vi {
                    getDefault() {
                        const e = this.gl;
                        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
                    }
                    set(e) {
                        const n = this.current;
                        (e[0] !== n[0] || e[1] !== n[1] || e[2] !== n[2] || e[3] !== n[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Eh extends vi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        n.bindFramebuffer(n.FRAMEBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Ec extends vi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        n.bindRenderbuffer(n.RENDERBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class xs extends vi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        n.bindTexture(n.TEXTURE_2D, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class hl extends vi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        n.bindBuffer(n.ARRAY_BUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class dl extends vi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        const n = this.gl;
                        n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class wo extends vi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        var n;
                        if (e === this.current && !this.dirty)
                            return;
                        const s = this.gl;
                        Ra(s) ? s.bindVertexArray(e) : (n = s.getExtension("OES_vertex_array_object")) === null || n === void 0 || n.bindVertexArrayOES(e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class pl extends vi {
                    getDefault() {
                        return 4
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        n.pixelStorei(n.UNPACK_ALIGNMENT, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class zh extends vi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Ns extends vi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const n = this.gl;
                        n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class rs extends vi {
                    constructor(e, n) {
                        super(e),
                        this.context = e,
                        this.parent = n
                    }
                    getDefault() {
                        return null
                    }
                }
                class Lh extends rs {
                    setDirty() {
                        this.dirty = !0
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const n = this.gl;
                        n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e, 0),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class zc extends rs {
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const n = this.gl;
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class ii extends rs {
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const n = this.gl;
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                const To = "Framebuffer is not complete";
                class dp {
                    constructor(e, n, s, u, d) {
                        this.context = e,
                        this.width = n,
                        this.height = s;
                        const m = e.gl
                          , y = this.framebuffer = m.createFramebuffer();
                        if (this.colorAttachment = new Lh(e,y),
                        u)
                            this.depthAttachment = d ? new ii(e,y) : new zc(e,y);
                        else if (d)
                            throw new Error("Stencil cannot be set without depth");
                        if (m.checkFramebufferStatus(m.FRAMEBUFFER) !== m.FRAMEBUFFER_COMPLETE)
                            throw new Error(To)
                    }
                    destroy() {
                        const e = this.context.gl
                          , n = this.colorAttachment.get();
                        if (n && e.deleteTexture(n),
                        this.depthAttachment) {
                            const s = this.depthAttachment.get();
                            s && e.deleteRenderbuffer(s)
                        }
                        e.deleteFramebuffer(this.framebuffer)
                    }
                }
                class Dh {
                    constructor(e) {
                        var n, s;
                        if (this.gl = e,
                        this.clearColor = new Pc(this),
                        this.clearDepth = new Ic(this),
                        this.clearStencil = new Ih(this),
                        this.colorMask = new Mc(this),
                        this.depthMask = new vs(this),
                        this.stencilMask = new Ac(this),
                        this.stencilFunc = new op(this),
                        this.stencilOp = new lp(this),
                        this.stencilTest = new cp(this),
                        this.depthRange = new up(this),
                        this.depthTest = new Mh(this),
                        this.depthFunc = new hp(this),
                        this.blend = new Ah(this),
                        this.blendFunc = new ll(this),
                        this.blendColor = new cl(this),
                        this.blendEquation = new ul(this),
                        this.cullFace = new kc(this),
                        this.cullFaceSide = new ys(this),
                        this.frontFace = new bo(this),
                        this.program = new Os(this),
                        this.activeTexture = new ca(this),
                        this.viewport = new kh(this),
                        this.bindFramebuffer = new Eh(this),
                        this.bindRenderbuffer = new Ec(this),
                        this.bindTexture = new xs(this),
                        this.bindVertexBuffer = new hl(this),
                        this.bindElementBuffer = new dl(this),
                        this.bindVertexArray = new wo(this),
                        this.pixelStoreUnpack = new pl(this),
                        this.pixelStoreUnpackPremultiplyAlpha = new zh(this),
                        this.pixelStoreUnpackFlipY = new Ns(this),
                        this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                        this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),
                        this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE),
                        Ra(e)) {
                            this.HALF_FLOAT = e.HALF_FLOAT;
                            const u = e.getExtension("EXT_color_buffer_half_float");
                            this.RGBA16F = (n = e.RGBA16F) !== null && n !== void 0 ? n : u == null ? void 0 : u.RGBA16F_EXT,
                            this.RGB16F = (s = e.RGB16F) !== null && s !== void 0 ? s : u == null ? void 0 : u.RGB16F_EXT,
                            e.getExtension("EXT_color_buffer_float")
                        } else {
                            e.getExtension("EXT_color_buffer_half_float"),
                            e.getExtension("OES_texture_half_float_linear");
                            const u = e.getExtension("OES_texture_half_float");
                            this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES
                        }
                    }
                    setDefault() {
                        this.unbindVAO(),
                        this.clearColor.setDefault(),
                        this.clearDepth.setDefault(),
                        this.clearStencil.setDefault(),
                        this.colorMask.setDefault(),
                        this.depthMask.setDefault(),
                        this.stencilMask.setDefault(),
                        this.stencilFunc.setDefault(),
                        this.stencilOp.setDefault(),
                        this.stencilTest.setDefault(),
                        this.depthRange.setDefault(),
                        this.depthTest.setDefault(),
                        this.depthFunc.setDefault(),
                        this.blend.setDefault(),
                        this.blendFunc.setDefault(),
                        this.blendColor.setDefault(),
                        this.blendEquation.setDefault(),
                        this.cullFace.setDefault(),
                        this.cullFaceSide.setDefault(),
                        this.frontFace.setDefault(),
                        this.program.setDefault(),
                        this.activeTexture.setDefault(),
                        this.bindFramebuffer.setDefault(),
                        this.pixelStoreUnpack.setDefault(),
                        this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.pixelStoreUnpackFlipY.setDefault()
                    }
                    setDirty() {
                        this.clearColor.dirty = !0,
                        this.clearDepth.dirty = !0,
                        this.clearStencil.dirty = !0,
                        this.colorMask.dirty = !0,
                        this.depthMask.dirty = !0,
                        this.stencilMask.dirty = !0,
                        this.stencilFunc.dirty = !0,
                        this.stencilOp.dirty = !0,
                        this.stencilTest.dirty = !0,
                        this.depthRange.dirty = !0,
                        this.depthTest.dirty = !0,
                        this.depthFunc.dirty = !0,
                        this.blend.dirty = !0,
                        this.blendFunc.dirty = !0,
                        this.blendColor.dirty = !0,
                        this.blendEquation.dirty = !0,
                        this.cullFace.dirty = !0,
                        this.cullFaceSide.dirty = !0,
                        this.frontFace.dirty = !0,
                        this.program.dirty = !0,
                        this.activeTexture.dirty = !0,
                        this.viewport.dirty = !0,
                        this.bindFramebuffer.dirty = !0,
                        this.bindRenderbuffer.dirty = !0,
                        this.bindTexture.dirty = !0,
                        this.bindVertexBuffer.dirty = !0,
                        this.bindElementBuffer.dirty = !0,
                        this.bindVertexArray.dirty = !0,
                        this.pixelStoreUnpack.dirty = !0,
                        this.pixelStoreUnpackPremultiplyAlpha.dirty = !0,
                        this.pixelStoreUnpackFlipY.dirty = !0
                    }
                    createIndexBuffer(e, n) {
                        return new Ph(this,e,n)
                    }
                    createVertexBuffer(e, n, s) {
                        return new $a(this,e,n,s)
                    }
                    createRenderbuffer(e, n, s) {
                        const u = this.gl
                          , d = u.createRenderbuffer();
                        return this.bindRenderbuffer.set(d),
                        u.renderbufferStorage(u.RENDERBUFFER, e, n, s),
                        this.bindRenderbuffer.set(null),
                        d
                    }
                    createFramebuffer(e, n, s, u) {
                        return new dp(this,e,n,s,u)
                    }
                    clear({color: e, depth: n, stencil: s}) {
                        const u = this.gl;
                        let d = 0;
                        e && (d |= u.COLOR_BUFFER_BIT,
                        this.clearColor.set(e),
                        this.colorMask.set([!0, !0, !0, !0])),
                        n !== void 0 && (d |= u.DEPTH_BUFFER_BIT,
                        this.depthRange.set([0, 1]),
                        this.clearDepth.set(n),
                        this.depthMask.set(!0)),
                        s !== void 0 && (d |= u.STENCIL_BUFFER_BIT,
                        this.clearStencil.set(s),
                        this.stencilMask.set(255)),
                        u.clear(d)
                    }
                    setCullFace(e) {
                        e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0),
                        this.cullFaceSide.set(e.mode),
                        this.frontFace.set(e.frontFace))
                    }
                    setDepthMode(e) {
                        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0),
                        this.depthFunc.set(e.func),
                        this.depthMask.set(e.mask),
                        this.depthRange.set(e.range)) : this.depthTest.set(!1)
                    }
                    setStencilMode(e) {
                        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0),
                        this.stencilMask.set(e.mask),
                        this.stencilOp.set([e.fail, e.depthFail, e.pass]),
                        this.stencilFunc.set({
                            func: e.test.func,
                            ref: e.ref,
                            mask: e.test.mask
                        })) : this.stencilTest.set(!1)
                    }
                    setColorMode(e) {
                        o.bH(e.blendFunction, Ti.Replace) ? this.blend.set(!1) : (this.blend.set(!0),
                        this.blendFunc.set(e.blendFunction),
                        this.blendColor.set(e.blendColor)),
                        this.colorMask.set(e.mask)
                    }
                    createVertexArray() {
                        var e;
                        return Ra(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
                    }
                    deleteVertexArray(e) {
                        var n;
                        return Ra(this.gl) ? this.gl.deleteVertexArray(e) : (n = this.gl.getExtension("OES_vertex_array_object")) === null || n === void 0 ? void 0 : n.deleteVertexArrayOES(e)
                    }
                    unbindVAO() {
                        this.bindVertexArray.set(null)
                    }
                }
                let is;
                function Rh(h, e, n, s, u) {
                    const d = h.context
                      , m = h.transform
                      , y = d.gl
                      , w = h.useProgram("collisionBox")
                      , P = [];
                    let M = 0
                      , D = 0;
                    for (let re = 0; re < s.length; re++) {
                        const se = s[re]
                          , de = e.getTile(se).getBucket(n);
                        if (!de)
                            continue;
                        const ue = u ? de.textCollisionBox : de.iconCollisionBox
                          , ge = de.collisionCircleArray;
                        ge.length > 0 && (P.push({
                            circleArray: ge,
                            circleOffset: D,
                            coord: se
                        }),
                        M += ge.length / 4,
                        D = M),
                        ue && w.draw(d, y.LINES, Vr.disabled, hi.disabled, h.colorModeForRenderPass(), wr.disabled, al(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(se), m.getProjectionData({
                            overscaledTileID: se,
                            applyGlobeMatrix: !0,
                            applyTerrainMatrix: !0
                        }), n.id, ue.layoutVertexBuffer, ue.indexBuffer, ue.segments, null, h.transform.zoom, null, null, ue.collisionVertexBuffer)
                    }
                    if (!u || !P.length)
                        return;
                    const z = h.useProgram("collisionCircle")
                      , B = new o.b$;
                    B.resize(4 * M),
                    B._trim();
                    let U = 0;
                    for (const re of P)
                        for (let se = 0; se < re.circleArray.length / 4; se++) {
                            const de = 4 * se
                              , ue = re.circleArray[de + 0]
                              , ge = re.circleArray[de + 1]
                              , Te = re.circleArray[de + 2]
                              , he = re.circleArray[de + 3];
                            B.emplace(U++, ue, ge, Te, he, 0),
                            B.emplace(U++, ue, ge, Te, he, 1),
                            B.emplace(U++, ue, ge, Te, he, 2),
                            B.emplace(U++, ue, ge, Te, he, 3)
                        }
                    (!is || is.length < 2 * M) && (is = (function(re) {
                        const se = 2 * re
                          , de = new o.c1;
                        de.resize(se),
                        de._trim();
                        for (let ue = 0; ue < se; ue++) {
                            const ge = 6 * ue;
                            de.uint16[ge + 0] = 4 * ue + 0,
                            de.uint16[ge + 1] = 4 * ue + 1,
                            de.uint16[ge + 2] = 4 * ue + 2,
                            de.uint16[ge + 3] = 4 * ue + 2,
                            de.uint16[ge + 4] = 4 * ue + 3,
                            de.uint16[ge + 5] = 4 * ue + 0
                        }
                        return de
                    }
                    )(M));
                    const ee = d.createIndexBuffer(is, !0)
                      , J = d.createVertexBuffer(B, o.c0.members, !0);
                    for (const re of P) {
                        const se = ip(h.transform);
                        z.draw(d, y.TRIANGLES, Vr.disabled, hi.disabled, h.colorModeForRenderPass(), wr.disabled, se, h.style.map.terrain && h.style.map.terrain.getTerrainData(re.coord), null, n.id, J, ee, o.aM.simpleSegment(0, 2 * re.circleOffset, re.circleArray.length, re.circleArray.length / 2), null, h.transform.zoom, null, null, null)
                    }
                    J.destroy(),
                    ee.destroy()
                }
                const pp = o.ag(new Float32Array(16));
                function Bh(h, e, n, s, u, d) {
                    const {horizontalAlign: m, verticalAlign: y} = o.aH(h);
                    return new o.P((-(m - .5) * e / u + s[0]) * d,(-(y - .5) * n / u + s[1]) * d)
                }
                function fp(h, e, n, s, u, d) {
                    const m = e.tileAnchorPoint.add(new o.P(e.translation[0],e.translation[1]));
                    if (e.pitchWithMap) {
                        let y = s.mult(d);
                        n || (y = y.rotate(-u));
                        const w = m.add(y);
                        return ai(w.x, w.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
                    }
                    if (n) {
                        const y = Dr(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h)
                          , w = Math.atan(y.y / y.x) + (y.x < 0 ? Math.PI : 0);
                        return h.add(s.rotate(w))
                    }
                    return h.add(s)
                }
                function Lc(h, e, n, s, u, d, m, y, w, P, M, D) {
                    const z = h.text.placedSymbolArray
                      , B = h.text.dynamicLayoutVertexArray
                      , U = h.icon.dynamicLayoutVertexArray
                      , ee = {};
                    B.clear();
                    for (let J = 0; J < z.length; J++) {
                        const re = z.get(J)
                          , se = re.hidden || !re.crossTileID || h.allowVerticalPlacement && !re.placedOrientation ? null : s[re.crossTileID];
                        if (se) {
                            const de = new o.P(re.anchorX,re.anchorY)
                              , ue = {
                                getElevation: D,
                                width: u.width,
                                height: u.height,
                                pitchedLabelPlaneMatrix: d,
                                pitchWithMap: n,
                                transform: u,
                                tileAnchorPoint: de,
                                translation: P,
                                unwrappedTileID: M
                            }
                              , ge = n ? li(de.x, de.y, ue) : Dr(de.x, de.y, ue)
                              , Te = Tt(u.cameraToCenterDistance, ge.signedDistanceFromCamera);
                            let he = o.ap(h.textSizeData, y, re) * Te / o.aB;
                            n && (he *= h.tilePixelRatio / m);
                            const {width: De, height: He, anchor: je, textOffset: qe, textBoxScale: $e} = se
                              , Rt = Bh(je, De, He, qe, $e, he)
                              , Nt = u.getPitchedTextCorrection(de.x + P[0], de.y + P[1], M)
                              , yt = fp(ge.point, ue, e, Rt, -u.bearingInRadians, Nt)
                              , sr = h.allowVerticalPlacement && re.placedOrientation === o.ao.vertical ? Math.PI / 2 : 0;
                            for (let Xr = 0; Xr < re.numGlyphs; Xr++)
                                o.av(B, yt, sr);
                            w && re.associatedIconIndex >= 0 && (ee[re.associatedIconIndex] = {
                                shiftedAnchor: yt,
                                angle: sr
                            })
                        } else
                            mi(re.numGlyphs, B)
                    }
                    if (w) {
                        U.clear();
                        const J = h.icon.placedSymbolArray;
                        for (let re = 0; re < J.length; re++) {
                            const se = J.get(re);
                            if (se.hidden)
                                mi(se.numGlyphs, U);
                            else {
                                const de = ee[re];
                                if (de)
                                    for (let ue = 0; ue < se.numGlyphs; ue++)
                                        o.av(U, de.shiftedAnchor, de.angle);
                                else
                                    mi(se.numGlyphs, U)
                            }
                        }
                        h.icon.dynamicLayoutVertexBuffer.updateData(U)
                    }
                    h.text.dynamicLayoutVertexBuffer.updateData(B)
                }
                function fl(h, e, n) {
                    return n.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon"
                }
                function Co(h, e, n, s, u, d, m, y, w, P, M, D, z) {
                    const B = h.context
                      , U = B.gl
                      , ee = h.transform
                      , J = y === "map"
                      , re = w === "map"
                      , se = y !== "viewport" && n.layout.get("symbol-placement") !== "point"
                      , de = J && !re && !se
                      , ue = !n.layout.get("symbol-sort-key").isConstant();
                    let ge = !1;
                    const Te = h.getDepthModeForSublayer(0, Vr.ReadOnly)
                      , he = n._unevaluatedLayout.hasValue("text-variable-anchor") || n._unevaluatedLayout.hasValue("text-variable-anchor-offset")
                      , De = []
                      , He = ee.getCircleRadiusCorrection();
                    for (const je of s) {
                        const qe = e.getTile(je)
                          , $e = qe.getBucket(n);
                        if (!$e)
                            continue;
                        const Rt = u ? $e.text : $e.icon;
                        if (!Rt || !Rt.segments.get().length || !Rt.hasVisibleVertices)
                            continue;
                        const Nt = Rt.programConfigurations.get(n.id)
                          , yt = u || $e.sdfIcons
                          , sr = u ? $e.textSizeData : $e.iconSizeData
                          , Xr = re || ee.pitch !== 0
                          , xi = h.useProgram(fl(yt, u, $e), Nt)
                          , ki = o.an(sr, ee.zoom)
                          , Pi = h.style.map.terrain && h.style.map.terrain.getTerrainData(je);
                        let ji, Ui, Wr, Ei, Qi = [0, 0], dn = null;
                        if (u)
                            Ui = qe.glyphAtlasTexture,
                            Wr = U.LINEAR,
                            ji = qe.glyphAtlasTexture.size,
                            $e.iconsInText && (Qi = qe.imageAtlasTexture.size,
                            dn = qe.imageAtlasTexture,
                            Ei = Xr || h.options.rotating || h.options.zooming || sr.kind === "composite" || sr.kind === "camera" ? U.LINEAR : U.NEAREST);
                        else {
                            const en = n.layout.get("icon-size").constantOr(0) !== 1 || $e.iconsNeedLinear;
                            Ui = qe.imageAtlasTexture,
                            Wr = yt || h.options.rotating || h.options.zooming || en || Xr ? U.LINEAR : U.NEAREST,
                            ji = qe.imageAtlasTexture.size
                        }
                        const xn = o.aC(qe, 1, h.transform.zoom)
                          , qn = $r(J, h.transform, xn)
                          , Sa = o.L();
                        o.aq(Sa, qn);
                        const as = mr(re, J, h.transform, xn)
                          , ss = o.aD(ee, qe, d, m)
                          , Ys = ee.getProjectionData({
                            overscaledTileID: je,
                            applyGlobeMatrix: !z,
                            applyTerrainMatrix: !0
                        })
                          , Js = he && $e.hasTextData()
                          , Is = n.layout.get("icon-text-fit") !== "none" && Js && $e.hasIconData();
                        if (se) {
                            const en = h.style.map.terrain ? (da, tn) => h.style.map.terrain.getElevation(je, da, tn) : null
                              , pn = n.layout.get("text-rotation-alignment") === "map";
                            di($e, h, u, qn, Sa, re, P, pn, je.toUnwrapped(), ee.width, ee.height, ss, en)
                        }
                        const Ms = u && he || Is
                          , Kn = se || Ms ? pp : re ? qn : h.transform.clipSpaceToPixelsMatrix
                          , Pa = yt && n.paint.get(u ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
                        let Vn;
                        Vn = yt ? $e.iconsInText ? sp(sr.kind, ki, de, re, se, Ms, h, Kn, as, ss, ji, Qi, He) : Th(sr.kind, ki, de, re, se, Ms, h, Kn, as, ss, u, ji, 0, He) : xo(sr.kind, ki, de, re, se, Ms, h, Kn, as, ss, u, ji, He);
                        const os = {
                            program: xi,
                            buffers: Rt,
                            uniformValues: Vn,
                            projectionData: Ys,
                            atlasTexture: Ui,
                            atlasTextureIcon: dn,
                            atlasInterpolation: Wr,
                            atlasInterpolationIcon: Ei,
                            isSDF: yt,
                            hasHalo: Pa
                        };
                        if (ue && $e.canOverlap) {
                            ge = !0;
                            const en = Rt.segments.get();
                            for (const pn of en)
                                De.push({
                                    segments: new o.aM([pn]),
                                    sortKey: pn.sortKey,
                                    state: os,
                                    terrainData: Pi
                                })
                        } else
                            De.push({
                                segments: Rt.segments,
                                sortKey: 0,
                                state: os,
                                terrainData: Pi
                            })
                    }
                    ge && De.sort(( (je, qe) => je.sortKey - qe.sortKey));
                    for (const je of De) {
                        const qe = je.state;
                        if (B.activeTexture.set(U.TEXTURE0),
                        qe.atlasTexture.bind(qe.atlasInterpolation, U.CLAMP_TO_EDGE),
                        qe.atlasTextureIcon && (B.activeTexture.set(U.TEXTURE1),
                        qe.atlasTextureIcon && qe.atlasTextureIcon.bind(qe.atlasInterpolationIcon, U.CLAMP_TO_EDGE)),
                        qe.isSDF) {
                            const $e = qe.uniformValues;
                            qe.hasHalo && ($e.u_is_halo = 1,
                            So(qe.buffers, je.segments, n, h, qe.program, Te, M, D, $e, qe.projectionData, je.terrainData)),
                            $e.u_is_halo = 0
                        }
                        So(qe.buffers, je.segments, n, h, qe.program, Te, M, D, qe.uniformValues, qe.projectionData, je.terrainData)
                    }
                }
                function So(h, e, n, s, u, d, m, y, w, P, M) {
                    const D = s.context;
                    u.draw(D, D.gl.TRIANGLES, d, m, y, wr.backCCW, w, M, P, n.id, h.layoutVertexBuffer, h.indexBuffer, e, n.paint, s.transform.zoom, h.programConfigurations.get(n.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer)
                }
                function Dc(h, e, n, s, u) {
                    const d = h.context
                      , m = d.gl
                      , y = hi.disabled
                      , w = new Ti([m.ONE, m.ONE],o.bf.transparent,[!0, !0, !0, !0])
                      , P = e.getBucket(n);
                    if (!P)
                        return;
                    const M = s.key;
                    let D = n.heatmapFbos.get(M);
                    D || (D = Po(d, e.tileSize, e.tileSize),
                    n.heatmapFbos.set(M, D)),
                    d.bindFramebuffer.set(D.framebuffer),
                    d.viewport.set([0, 0, e.tileSize, e.tileSize]),
                    d.clear({
                        color: o.bf.transparent
                    });
                    const z = P.programConfigurations.get(n.id)
                      , B = h.useProgram("heatmap", z, !u)
                      , U = h.transform.getProjectionData({
                        overscaledTileID: e.tileID,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                    })
                      , ee = h.style.map.terrain.getTerrainData(s);
                    B.draw(d, m.TRIANGLES, Vr.disabled, y, w, wr.disabled, vh(e, h.transform.zoom, n.paint.get("heatmap-intensity"), 1), ee, U, n.id, P.layoutVertexBuffer, P.indexBuffer, P.segments, n.paint, h.transform.zoom, z)
                }
                function Fh(h, e, n, s, u) {
                    const d = h.context
                      , m = d.gl
                      , y = h.transform;
                    d.setColorMode(h.colorModeForRenderPass());
                    const w = Io(d, e)
                      , P = n.key
                      , M = e.heatmapFbos.get(P);
                    if (!M)
                        return;
                    d.activeTexture.set(m.TEXTURE0),
                    m.bindTexture(m.TEXTURE_2D, M.colorAttachment.get()),
                    d.activeTexture.set(m.TEXTURE1),
                    w.bind(m.LINEAR, m.CLAMP_TO_EDGE);
                    const D = y.getProjectionData({
                        overscaledTileID: n,
                        applyTerrainMatrix: u,
                        applyGlobeMatrix: !s
                    });
                    h.useProgram("heatmapTexture").draw(d, m.TRIANGLES, Vr.disabled, hi.disabled, h.colorModeForRenderPass(), wr.disabled, xc(h, e, 0, 1), null, D, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, y.zoom),
                    M.destroy(),
                    e.heatmapFbos.delete(P)
                }
                function Po(h, e, n) {
                    var s, u;
                    const d = h.gl
                      , m = d.createTexture();
                    d.bindTexture(d.TEXTURE_2D, m),
                    d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE),
                    d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE),
                    d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR),
                    d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
                    const y = (s = h.HALF_FLOAT) !== null && s !== void 0 ? s : d.UNSIGNED_BYTE
                      , w = (u = h.RGBA16F) !== null && u !== void 0 ? u : d.RGBA;
                    d.texImage2D(d.TEXTURE_2D, 0, w, e, n, 0, d.RGBA, y, null);
                    const P = h.createFramebuffer(e, n, !1, !1);
                    return P.colorAttachment.set(m),
                    P
                }
                function Io(h, e) {
                    return e.colorRampTexture || (e.colorRampTexture = new o.T(h,e.colorRamp,h.gl.RGBA)),
                    e.colorRampTexture
                }
                function Mo(h, e, n, s, u) {
                    if (!n || !s || !s.imageAtlas)
                        return;
                    const d = s.imageAtlas.patternPositions;
                    let m = d[n.to.toString()]
                      , y = d[n.from.toString()];
                    if (!m && y && (m = y),
                    !y && m && (y = m),
                    !m || !y) {
                        const w = u.getPaintProperty(e);
                        m = d[w],
                        y = d[w]
                    }
                    m && y && h.setConstantPatternPositions(m, y)
                }
                function ml(h, e, n, s, u, d, m, y) {
                    const w = h.context.gl
                      , P = "fill-pattern"
                      , M = n.paint.get(P)
                      , D = M && M.constantOr(1)
                      , z = n.getCrossfadeParameters();
                    let B, U, ee, J, re;
                    const se = h.transform
                      , de = n.paint.get("fill-translate")
                      , ue = n.paint.get("fill-translate-anchor");
                    m ? (U = D && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline",
                    B = w.LINES) : (U = D ? "fillPattern" : "fill",
                    B = w.TRIANGLES);
                    const ge = M.constantOr(null);
                    for (const Te of s) {
                        const he = e.getTile(Te);
                        if (D && !he.patternsLoaded())
                            continue;
                        const De = he.getBucket(n);
                        if (!De)
                            continue;
                        const He = De.programConfigurations.get(n.id)
                          , je = h.useProgram(U, He)
                          , qe = h.style.map.terrain && h.style.map.terrain.getTerrainData(Te);
                        D && (h.context.activeTexture.set(w.TEXTURE0),
                        he.imageAtlasTexture.bind(w.LINEAR, w.CLAMP_TO_EDGE),
                        He.updatePaintBuffers(z)),
                        Mo(He, P, ge, he, n);
                        const $e = se.getProjectionData({
                            overscaledTileID: Te,
                            applyGlobeMatrix: !y,
                            applyTerrainMatrix: !0
                        })
                          , Rt = o.aD(se, he, de, ue);
                        if (m) {
                            J = De.indexBuffer2,
                            re = De.segments2;
                            const yt = [w.drawingBufferWidth, w.drawingBufferHeight];
                            ee = U === "fillOutlinePattern" && D ? vo(h, z, he, yt, Rt) : go(yt, Rt)
                        } else
                            J = De.indexBuffer,
                            re = De.segments,
                            ee = D ? nl(h, z, he, Rt) : {
                                u_fill_translate: Rt
                            };
                        const Nt = h.stencilModeForClipping(Te);
                        je.draw(h.context, B, u, Nt, d, wr.backCCW, ee, qe, $e, n.id, De.layoutVertexBuffer, J, re, n.paint, h.transform.zoom, He)
                    }
                }
                function Rc(h, e, n, s, u, d, m, y) {
                    const w = h.context
                      , P = w.gl
                      , M = "fill-extrusion-pattern"
                      , D = n.paint.get(M)
                      , z = D.constantOr(1)
                      , B = n.getCrossfadeParameters()
                      , U = n.paint.get("fill-extrusion-opacity")
                      , ee = D.constantOr(null)
                      , J = h.transform;
                    for (const re of s) {
                        const se = e.getTile(re)
                          , de = se.getBucket(n);
                        if (!de)
                            continue;
                        const ue = h.style.map.terrain && h.style.map.terrain.getTerrainData(re)
                          , ge = de.programConfigurations.get(n.id)
                          , Te = h.useProgram(z ? "fillExtrusionPattern" : "fillExtrusion", ge);
                        z && (h.context.activeTexture.set(P.TEXTURE0),
                        se.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE),
                        ge.updatePaintBuffers(B));
                        const he = J.getProjectionData({
                            overscaledTileID: re,
                            applyGlobeMatrix: !y,
                            applyTerrainMatrix: !0
                        });
                        Mo(ge, M, ee, se, n);
                        const De = o.aD(J, se, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor"))
                          , He = n.paint.get("fill-extrusion-vertical-gradient")
                          , je = z ? tp(h, He, U, De, re, B, se) : ya(h, He, U, De);
                        Te.draw(w, w.gl.TRIANGLES, u, d, m, wr.backCCW, je, ue, he, n.id, de.layoutVertexBuffer, de.indexBuffer, de.segments, n.paint, h.transform.zoom, ge, h.style.map.terrain && de.centroidVertexBuffer)
                    }
                }
                function bs(h, e, n, s, u, d, m, y, w) {
                    var P;
                    const M = h.style.projection
                      , D = h.context
                      , z = h.transform
                      , B = D.gl
                      , U = [`#define NUM_ILLUMINATION_SOURCES ${n.paint.get("hillshade-highlight-color").values.length}`]
                      , ee = h.useProgram("hillshade", null, !1, U)
                      , J = !h.options.moving;
                    for (const re of s) {
                        const se = e.getTile(re)
                          , de = se.fbo;
                        if (!de)
                            continue;
                        const ue = M.getMeshFromTileID(D, re.canonical, y, !0, "raster")
                          , ge = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(re);
                        D.activeTexture.set(B.TEXTURE0),
                        B.bindTexture(B.TEXTURE_2D, de.colorAttachment.get());
                        const Te = z.getProjectionData({
                            overscaledTileID: re,
                            aligned: J,
                            applyGlobeMatrix: !w,
                            applyTerrainMatrix: !0
                        });
                        ee.draw(D, B.TRIANGLES, d, u[re.overscaledZ], m, wr.backCCW, np(h, se, n), ge, Te, n.id, ue.vertexBuffer, ue.indexBuffer, ue.segments)
                    }
                }
                function Bc(h, e, n, s, u, d, m, y, w) {
                    var P;
                    const M = h.style.projection
                      , D = h.context
                      , z = h.transform
                      , B = D.gl
                      , U = h.useProgram("colorRelief")
                      , ee = !h.options.moving;
                    let J = !0
                      , re = 0;
                    for (const se of s) {
                        const de = e.getTile(se)
                          , ue = de.dem;
                        if (J) {
                            const je = B.getParameter(B.MAX_TEXTURE_SIZE)
                              , {elevationTexture: qe, colorTexture: $e} = n.getColorRampTextures(D, je, ue.getUnpackVector());
                            D.activeTexture.set(B.TEXTURE1),
                            qe.bind(B.NEAREST, B.CLAMP_TO_EDGE),
                            D.activeTexture.set(B.TEXTURE4),
                            $e.bind(B.LINEAR, B.CLAMP_TO_EDGE),
                            J = !1,
                            re = qe.size[0]
                        }
                        if (!ue || !ue.data)
                            continue;
                        const ge = ue.stride
                          , Te = ue.getPixels();
                        if (D.activeTexture.set(B.TEXTURE0),
                        D.pixelStoreUnpackPremultiplyAlpha.set(!1),
                        de.demTexture = de.demTexture || h.getTileTexture(ge),
                        de.demTexture) {
                            const je = de.demTexture;
                            je.update(Te, {
                                premultiply: !1
                            }),
                            je.bind(B.LINEAR, B.CLAMP_TO_EDGE)
                        } else
                            de.demTexture = new o.T(D,Te,B.RGBA,{
                                premultiply: !1
                            }),
                            de.demTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE);
                        const he = M.getMeshFromTileID(D, se.canonical, y, !0, "raster")
                          , De = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(se)
                          , He = z.getProjectionData({
                            overscaledTileID: se,
                            aligned: ee,
                            applyGlobeMatrix: !w,
                            applyTerrainMatrix: !0
                        });
                        U.draw(D, B.TRIANGLES, d, u[se.overscaledZ], m, wr.backCCW, xh(n, de.dem, re), De, He, n.id, he.vertexBuffer, he.indexBuffer, he.segments)
                    }
                }
                const _l = [new o.P(0,0), new o.P(o.$,0), new o.P(o.$,o.$), new o.P(0,o.$)];
                function ws(h, e, n, s, u, d, m, y, w=!1, P=!1) {
                    const M = s[s.length - 1].overscaledZ
                      , D = h.context
                      , z = D.gl
                      , B = h.useProgram("raster")
                      , U = h.transform
                      , ee = h.style.projection
                      , J = h.colorModeForRenderPass()
                      , re = !h.options.moving;
                    for (const se of s) {
                        const de = h.getDepthModeForSublayer(se.overscaledZ - M, n.paint.get("raster-opacity") === 1 ? Vr.ReadWrite : Vr.ReadOnly, z.LESS)
                          , ue = e.getTile(se);
                        ue.registerFadeDuration(n.paint.get("raster-fade-duration"));
                        const ge = e.findLoadedParent(se, 0)
                          , Te = e.findLoadedSibling(se)
                          , he = Fc(ue, ge || Te || null, e, n, h.transform, h.style.map.terrain);
                        let De, He;
                        const je = n.paint.get("raster-resampling") === "nearest" ? z.NEAREST : z.LINEAR;
                        D.activeTexture.set(z.TEXTURE0),
                        ue.texture.bind(je, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST),
                        D.activeTexture.set(z.TEXTURE1),
                        ge ? (ge.texture.bind(je, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST),
                        De = Math.pow(2, ge.tileID.overscaledZ - ue.tileID.overscaledZ),
                        He = [ue.tileID.canonical.x * De % 1, ue.tileID.canonical.y * De % 1]) : ue.texture.bind(je, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST),
                        ue.texture.useMipmap && D.extTextureFilterAnisotropic && h.transform.pitch > 20 && z.texParameterf(z.TEXTURE_2D, D.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, D.extTextureFilterAnisotropicMax);
                        const qe = h.style.map.terrain && h.style.map.terrain.getTerrainData(se)
                          , $e = U.getProjectionData({
                            overscaledTileID: se,
                            aligned: re,
                            applyGlobeMatrix: !P,
                            applyTerrainMatrix: !0
                        })
                          , Rt = yo(He || [0, 0], De || 1, he, n, y)
                          , Nt = ee.getMeshFromTileID(D, se.canonical, d, m, "raster");
                        B.draw(D, z.TRIANGLES, de, u ? u[se.overscaledZ] : hi.disabled, J, w ? wr.frontCCW : wr.backCCW, Rt, qe, $e, n.id, Nt.vertexBuffer, Nt.indexBuffer, Nt.segments)
                    }
                }
                function Fc(h, e, n, s, u, d) {
                    const m = s.paint.get("raster-fade-duration");
                    if (!d && m > 0) {
                        const y = ye.now()
                          , w = (y - h.timeAdded) / m
                          , P = e ? (y - e.timeAdded) / m : -1
                          , M = n.getSource()
                          , D = Ot(u, {
                            tileSize: M.tileSize,
                            roundZoom: M.roundZoom
                        })
                          , z = !e || Math.abs(e.tileID.overscaledZ - D) > Math.abs(h.tileID.overscaledZ - D)
                          , B = z && h.refreshedUponExpiration ? 1 : o.ah(z ? w : 1 - P, 0, 1);
                        return h.refreshedUponExpiration && w >= 1 && (h.refreshedUponExpiration = !1),
                        e ? {
                            opacity: 1,
                            mix: 1 - B
                        } : {
                            opacity: B,
                            mix: 0
                        }
                    }
                    return {
                        opacity: 1,
                        mix: 0
                    }
                }
                const Oh = new o.bf(1,0,0,1)
                  , Nh = new o.bf(0,1,0,1)
                  , gl = new o.bf(0,0,1,1)
                  , Oc = new o.bf(1,0,1,1)
                  , mp = new o.bf(0,1,1,1);
                function Nc(h, e, n, s) {
                    Oa(h, 0, e + n / 2, h.transform.width, n, s)
                }
                function Vi(h, e, n, s) {
                    Oa(h, e - n / 2, 0, n, h.transform.height, s)
                }
                function Oa(h, e, n, s, u, d) {
                    const m = h.context
                      , y = m.gl;
                    y.enable(y.SCISSOR_TEST),
                    y.scissor(e * h.pixelRatio, n * h.pixelRatio, s * h.pixelRatio, u * h.pixelRatio),
                    m.clear({
                        color: d
                    }),
                    y.disable(y.SCISSOR_TEST)
                }
                function ua(h, e, n) {
                    const s = h.context
                      , u = s.gl
                      , d = h.useProgram("debug")
                      , m = Vr.disabled
                      , y = hi.disabled
                      , w = h.colorModeForRenderPass()
                      , P = "$debug"
                      , M = h.style.map.terrain && h.style.map.terrain.getTerrainData(n);
                    s.activeTexture.set(u.TEXTURE0);
                    const D = e.getTileByID(n.key).latestRawTileData
                      , z = Math.floor((D && D.byteLength || 0) / 1024)
                      , B = e.getTile(n).tileSize
                      , U = 512 / Math.min(B, 512) * (n.overscaledZ / h.transform.zoom) * .5;
                    let ee = n.canonical.toString();
                    n.overscaledZ !== n.canonical.z && (ee += ` => ${n.overscaledZ}`),
                    (function(re, se) {
                        re.initDebugOverlayCanvas();
                        const de = re.debugOverlayCanvas
                          , ue = re.context.gl
                          , ge = re.debugOverlayCanvas.getContext("2d");
                        ge.clearRect(0, 0, de.width, de.height),
                        ge.shadowColor = "white",
                        ge.shadowBlur = 2,
                        ge.lineWidth = 1.5,
                        ge.strokeStyle = "white",
                        ge.textBaseline = "top",
                        ge.font = "bold 36px Open Sans, sans-serif",
                        ge.fillText(se, 5, 5),
                        ge.strokeText(se, 5, 5),
                        re.debugOverlayTexture.update(de),
                        re.debugOverlayTexture.bind(ue.LINEAR, ue.CLAMP_TO_EDGE)
                    }
                    )(h, `${ee} ${z}kB`);
                    const J = h.transform.getProjectionData({
                        overscaledTileID: n,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                    });
                    d.draw(s, u.TRIANGLES, m, y, Ti.alphaBlended, wr.disabled, _s(o.bf.transparent, U), null, J, P, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments),
                    d.draw(s, u.LINE_STRIP, m, y, w, wr.disabled, _s(o.bf.red), M, J, P, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments)
                }
                function vl(h, e, n, s) {
                    const {isRenderingGlobe: u} = s
                      , d = h.context
                      , m = d.gl
                      , y = h.transform
                      , w = h.colorModeForRenderPass()
                      , P = h.getDepthModeFor3D()
                      , M = h.useProgram("terrain");
                    d.bindFramebuffer.set(null),
                    d.viewport.set([0, 0, h.width, h.height]);
                    for (const D of n) {
                        const z = e.getTerrainMesh(D.tileID)
                          , B = h.renderToTexture.getTexture(D)
                          , U = e.getTerrainData(D.tileID);
                        d.activeTexture.set(m.TEXTURE0),
                        m.bindTexture(m.TEXTURE_2D, B.texture);
                        const ee = e.getMeshFrameDelta(y.zoom)
                          , J = y.calculateFogMatrix(D.tileID.toUnwrapped())
                          , re = rl(ee, J, h.style.sky, y.pitch, u)
                          , se = y.getProjectionData({
                            overscaledTileID: D.tileID,
                            applyTerrainMatrix: !1,
                            applyGlobeMatrix: !0
                        });
                        M.draw(d, m.TRIANGLES, P, hi.disabled, w, wr.backCCW, re, U, se, "terrain", z.vertexBuffer, z.indexBuffer, z.segments)
                    }
                }
                function Ao(h, e) {
                    if (!e.mesh) {
                        const n = new o.aL;
                        n.emplaceBack(-1, -1),
                        n.emplaceBack(1, -1),
                        n.emplaceBack(1, 1),
                        n.emplaceBack(-1, 1);
                        const s = new o.aN;
                        s.emplaceBack(0, 1, 2),
                        s.emplaceBack(0, 2, 3),
                        e.mesh = new Ri(h.createVertexBuffer(n, ui.members),h.createIndexBuffer(s),o.aM.simpleSegment(0, 0, n.length, s.length))
                    }
                    return e.mesh
                }
                class jh {
                    constructor(e, n) {
                        this.context = new Dh(e),
                        this.transform = n,
                        this._tileTextures = {},
                        this.terrainFacilitator = {
                            dirty: !0,
                            matrix: o.ag(new Float64Array(16)),
                            renderTime: 0
                        },
                        this.setup(),
                        this.numSublayers = Pt.maxUnderzooming + Pt.maxOverzooming + 1,
                        this.depthEpsilon = 1 / Math.pow(2, 16),
                        this.crossTileSymbolIndex = new gi
                    }
                    resize(e, n, s) {
                        if (this.width = Math.floor(e * s),
                        this.height = Math.floor(n * s),
                        this.pixelRatio = s,
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.style)
                            for (const u of this.style._order)
                                this.style._layers[u].resize()
                    }
                    setup() {
                        const e = this.context
                          , n = new o.aL;
                        n.emplaceBack(0, 0),
                        n.emplaceBack(o.$, 0),
                        n.emplaceBack(0, o.$),
                        n.emplaceBack(o.$, o.$),
                        this.tileExtentBuffer = e.createVertexBuffer(n, ui.members),
                        this.tileExtentSegments = o.aM.simpleSegment(0, 0, 4, 2);
                        const s = new o.aL;
                        s.emplaceBack(0, 0),
                        s.emplaceBack(o.$, 0),
                        s.emplaceBack(0, o.$),
                        s.emplaceBack(o.$, o.$),
                        this.debugBuffer = e.createVertexBuffer(s, ui.members),
                        this.debugSegments = o.aM.simpleSegment(0, 0, 4, 5);
                        const u = new o.c6;
                        u.emplaceBack(0, 0, 0, 0),
                        u.emplaceBack(o.$, 0, o.$, 0),
                        u.emplaceBack(0, o.$, 0, o.$),
                        u.emplaceBack(o.$, o.$, o.$, o.$),
                        this.rasterBoundsBuffer = e.createVertexBuffer(u, Qd.members),
                        this.rasterBoundsSegments = o.aM.simpleSegment(0, 0, 4, 2);
                        const d = new o.aL;
                        d.emplaceBack(0, 0),
                        d.emplaceBack(o.$, 0),
                        d.emplaceBack(0, o.$),
                        d.emplaceBack(o.$, o.$),
                        this.rasterBoundsBufferPosOnly = e.createVertexBuffer(d, ui.members),
                        this.rasterBoundsSegmentsPosOnly = o.aM.simpleSegment(0, 0, 4, 5);
                        const m = new o.aL;
                        m.emplaceBack(0, 0),
                        m.emplaceBack(1, 0),
                        m.emplaceBack(0, 1),
                        m.emplaceBack(1, 1),
                        this.viewportBuffer = e.createVertexBuffer(m, ui.members),
                        this.viewportSegments = o.aM.simpleSegment(0, 0, 4, 2);
                        const y = new o.c7;
                        y.emplaceBack(0),
                        y.emplaceBack(1),
                        y.emplaceBack(3),
                        y.emplaceBack(2),
                        y.emplaceBack(0),
                        this.tileBorderIndexBuffer = e.createIndexBuffer(y);
                        const w = new o.aN;
                        w.emplaceBack(1, 0, 2),
                        w.emplaceBack(1, 2, 3),
                        this.quadTriangleIndexBuffer = e.createIndexBuffer(w);
                        const P = this.context.gl;
                        this.stencilClearMode = new hi({
                            func: P.ALWAYS,
                            mask: 0
                        },0,255,P.ZERO,P.ZERO,P.ZERO),
                        this.tileExtentMesh = new Ri(this.tileExtentBuffer,this.quadTriangleIndexBuffer,this.tileExtentSegments)
                    }
                    clearStencil() {
                        const e = this.context
                          , n = e.gl;
                        this.nextStencilID = 1,
                        this.currentStencilSource = void 0;
                        const s = o.L();
                        o.bY(s, 0, this.width, this.height, 0, 0, 1),
                        o.N(s, s, [n.drawingBufferWidth, n.drawingBufferHeight, 0]);
                        const u = {
                            mainMatrix: s,
                            tileMercatorCoords: [0, 0, 1, 1],
                            clippingPlane: [0, 0, 0, 0],
                            projectionTransition: 0,
                            fallbackMatrix: s
                        };
                        this.useProgram("clippingMask", null, !0).draw(e, n.TRIANGLES, Vr.disabled, this.stencilClearMode, Ti.disabled, wr.disabled, null, null, u, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                    }
                    _renderTileClippingMasks(e, n, s) {
                        if (this.currentStencilSource === e.source || !e.isTileClipped() || !n || !n.length)
                            return;
                        this.currentStencilSource = e.source,
                        this.nextStencilID + n.length > 256 && this.clearStencil();
                        const u = this.context;
                        u.setColorMode(Ti.disabled),
                        u.setDepthMode(Vr.disabled);
                        const d = {};
                        for (const m of n)
                            d[m.key] = this.nextStencilID++;
                        this._renderTileMasks(d, n, s, !0),
                        this._renderTileMasks(d, n, s, !1),
                        this._tileClippingMaskIDs = d
                    }
                    _renderTileMasks(e, n, s, u) {
                        const d = this.context
                          , m = d.gl
                          , y = this.style.projection
                          , w = this.transform
                          , P = this.useProgram("clippingMask");
                        for (const M of n) {
                            const D = e[M.key]
                              , z = this.style.map.terrain && this.style.map.terrain.getTerrainData(M)
                              , B = y.getMeshFromTileID(this.context, M.canonical, u, !0, "stencil")
                              , U = w.getProjectionData({
                                overscaledTileID: M,
                                applyGlobeMatrix: !s,
                                applyTerrainMatrix: !0
                            });
                            P.draw(d, m.TRIANGLES, Vr.disabled, new hi({
                                func: m.ALWAYS,
                                mask: 0
                            },D,255,m.KEEP,m.KEEP,m.REPLACE), Ti.disabled, s ? wr.disabled : wr.backCCW, null, z, U, "$clipping", B.vertexBuffer, B.indexBuffer, B.segments)
                        }
                    }
                    _renderTilesDepthBuffer() {
                        const e = this.context
                          , n = e.gl
                          , s = this.style.projection
                          , u = this.transform
                          , d = this.useProgram("depth")
                          , m = this.getDepthModeFor3D()
                          , y = xe(u, {
                            tileSize: u.tileSize
                        });
                        for (const w of y) {
                            const P = this.style.map.terrain && this.style.map.terrain.getTerrainData(w)
                              , M = s.getMeshFromTileID(this.context, w.canonical, !0, !0, "raster")
                              , D = u.getProjectionData({
                                overscaledTileID: w,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0
                            });
                            d.draw(e, n.TRIANGLES, m, hi.disabled, Ti.disabled, wr.backCCW, null, P, D, "$clipping", M.vertexBuffer, M.indexBuffer, M.segments)
                        }
                    }
                    stencilModeFor3D() {
                        this.currentStencilSource = void 0,
                        this.nextStencilID + 1 > 256 && this.clearStencil();
                        const e = this.nextStencilID++
                          , n = this.context.gl;
                        return new hi({
                            func: n.NOTEQUAL,
                            mask: 255
                        },e,255,n.KEEP,n.KEEP,n.REPLACE)
                    }
                    stencilModeForClipping(e) {
                        const n = this.context.gl;
                        return new hi({
                            func: n.EQUAL,
                            mask: 255
                        },this._tileClippingMaskIDs[e.key],0,n.KEEP,n.KEEP,n.REPLACE)
                    }
                    getStencilConfigForOverlapAndUpdateStencilID(e) {
                        const n = this.context.gl
                          , s = e.sort(( (m, y) => y.overscaledZ - m.overscaledZ))
                          , u = s[s.length - 1].overscaledZ
                          , d = s[0].overscaledZ - u + 1;
                        if (d > 1) {
                            this.currentStencilSource = void 0,
                            this.nextStencilID + d > 256 && this.clearStencil();
                            const m = {};
                            for (let y = 0; y < d; y++)
                                m[y + u] = new hi({
                                    func: n.GEQUAL,
                                    mask: 255
                                },y + this.nextStencilID,255,n.KEEP,n.KEEP,n.REPLACE);
                            return this.nextStencilID += d,
                            [m, s]
                        }
                        return [{
                            [u]: hi.disabled
                        }, s]
                    }
                    stencilConfigForOverlapTwoPass(e) {
                        const n = this.context.gl
                          , s = e.sort(( (m, y) => y.overscaledZ - m.overscaledZ))
                          , u = s[s.length - 1].overscaledZ
                          , d = s[0].overscaledZ - u + 1;
                        if (this.clearStencil(),
                        d > 1) {
                            const m = {}
                              , y = {};
                            for (let w = 0; w < d; w++)
                                m[w + u] = new hi({
                                    func: n.GREATER,
                                    mask: 255
                                },d + 1 + w,255,n.KEEP,n.KEEP,n.REPLACE),
                                y[w + u] = new hi({
                                    func: n.GREATER,
                                    mask: 255
                                },1 + w,255,n.KEEP,n.KEEP,n.REPLACE);
                            return this.nextStencilID = 2 * d + 1,
                            [m, y, s]
                        }
                        return this.nextStencilID = 3,
                        [{
                            [u]: new hi({
                                func: n.GREATER,
                                mask: 255
                            },2,255,n.KEEP,n.KEEP,n.REPLACE)
                        }, {
                            [u]: new hi({
                                func: n.GREATER,
                                mask: 255
                            },1,255,n.KEEP,n.KEEP,n.REPLACE)
                        }, s]
                    }
                    colorModeForRenderPass() {
                        const e = this.context.gl;
                        return this._showOverdrawInspector ? new Ti([e.CONSTANT_COLOR, e.ONE],new o.bf(.125,.125,.125,0),[!0, !0, !0, !0]) : this.renderPass === "opaque" ? Ti.unblended : Ti.alphaBlended
                    }
                    getDepthModeForSublayer(e, n, s) {
                        if (!this.opaquePassEnabledForLayer())
                            return Vr.disabled;
                        const u = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                        return new Vr(s || this.context.gl.LEQUAL,n,[u, u])
                    }
                    getDepthModeFor3D() {
                        return new Vr(this.context.gl.LEQUAL,Vr.ReadWrite,this.depthRangeFor3D)
                    }
                    opaquePassEnabledForLayer() {
                        return this.currentLayer < this.opaquePassCutoff
                    }
                    render(e, n) {
                        var s, u;
                        this.style = e,
                        this.options = n,
                        this.lineAtlas = e.lineAtlas,
                        this.imageManager = e.imageManager,
                        this.glyphManager = e.glyphManager,
                        this.symbolFadeChange = e.placement.symbolFadeChange(ye.now()),
                        this.imageManager.beginFrame();
                        const d = this.style._order
                          , m = this.style.sourceCaches
                          , y = {}
                          , w = {}
                          , P = {}
                          , M = {
                            isRenderingToTexture: !1,
                            isRenderingGlobe: ((s = e.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0
                        };
                        for (const z in m) {
                            const B = m[z];
                            B.used && B.prepare(this.context),
                            y[z] = B.getVisibleCoordinates(!1),
                            w[z] = y[z].slice().reverse(),
                            P[z] = B.getVisibleCoordinates(!0).reverse()
                        }
                        this.opaquePassCutoff = 1 / 0;
                        for (let z = 0; z < d.length; z++)
                            if (this.style._layers[d[z]].is3D()) {
                                this.opaquePassCutoff = z;
                                break
                            }
                        this.maybeDrawDepthAndCoords(!1),
                        this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom),
                        this.opaquePassCutoff = 0),
                        this.renderPass = "offscreen";
                        for (const z of d) {
                            const B = this.style._layers[z];
                            if (!B.hasOffscreenPass() || B.isHidden(this.transform.zoom))
                                continue;
                            const U = w[B.source];
                            (B.type === "custom" || U.length) && this.renderLayer(this, m[B.source], B, U, M)
                        }
                        if ((u = this.style.projection) === null || u === void 0 || u.updateGPUdependent({
                            context: this.context,
                            useProgram: z => this.useProgram(z)
                        }),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.bindFramebuffer.set(null),
                        this.context.clear({
                            color: n.showOverdrawInspector ? o.bf.black : o.bf.transparent,
                            depth: 1
                        }),
                        this.clearStencil(),
                        this.style.sky && (function(z, B) {
                            const U = z.context
                              , ee = U.gl
                              , J = ( (Te, he, De) => {
                                const He = Math.cos(he.rollInRadians)
                                  , je = Math.sin(he.rollInRadians)
                                  , qe = le(he)
                                  , $e = he.getProjectionData({
                                    overscaledTileID: null,
                                    applyGlobeMatrix: !0,
                                    applyTerrainMatrix: !0
                                }).projectionTransition;
                                return {
                                    u_sky_color: Te.properties.get("sky-color"),
                                    u_horizon_color: Te.properties.get("horizon-color"),
                                    u_horizon: [(he.width / 2 - qe * je) * De, (he.height / 2 + qe * He) * De],
                                    u_horizon_normal: [-je, He],
                                    u_sky_horizon_blend: Te.properties.get("sky-horizon-blend") * he.height / 2 * De,
                                    u_sky_blend: $e
                                }
                            }
                            )(B, z.style.map.transform, z.pixelRatio)
                              , re = new Vr(ee.LEQUAL,Vr.ReadWrite,[0, 1])
                              , se = hi.disabled
                              , de = z.colorModeForRenderPass()
                              , ue = z.useProgram("sky")
                              , ge = Ao(U, B);
                            ue.draw(U, ee.TRIANGLES, re, se, de, wr.disabled, J, null, void 0, "sky", ge.vertexBuffer, ge.indexBuffer, ge.segments)
                        }
                        )(this, this.style.sky),
                        this._showOverdrawInspector = n.showOverdrawInspector,
                        this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon],
                        !this.renderToTexture)
                            for (this.renderPass = "opaque",
                            this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                                const z = this.style._layers[d[this.currentLayer]]
                                  , B = m[z.source]
                                  , U = y[z.source];
                                this._renderTileClippingMasks(z, U, !1),
                                this.renderLayer(this, B, z, U, M)
                            }
                        this.renderPass = "translucent";
                        let D = !1;
                        for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
                            const z = this.style._layers[d[this.currentLayer]]
                              , B = m[z.source];
                            if (this.renderToTexture && this.renderToTexture.renderLayer(z, M))
                                continue;
                            this.opaquePassEnabledForLayer() || D || (D = !0,
                            M.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
                            const U = (z.type === "symbol" ? P : w)[z.source];
                            this._renderTileClippingMasks(z, y[z.source], !!this.renderToTexture),
                            this.renderLayer(this, B, z, U, M)
                        }
                        if (M.isRenderingGlobe && (function(z, B, U) {
                            const ee = z.context
                              , J = ee.gl
                              , re = z.useProgram("atmosphere")
                              , se = new Vr(J.LEQUAL,Vr.ReadOnly,[0, 1])
                              , de = z.transform
                              , ue = (function($e, Rt) {
                                const Nt = $e.properties.get("position")
                                  , yt = [-Nt.x, -Nt.y, -Nt.z]
                                  , sr = o.ag(new Float64Array(16));
                                return $e.properties.get("anchor") === "map" && (o.b6(sr, sr, Rt.rollInRadians),
                                o.b7(sr, sr, -Rt.pitchInRadians),
                                o.b6(sr, sr, Rt.bearingInRadians),
                                o.b7(sr, sr, Rt.center.lat * Math.PI / 180),
                                o.bz(sr, sr, -Rt.center.lng * Math.PI / 180)),
                                o.c5(yt, yt, sr),
                                yt
                            }
                            )(U, z.transform)
                              , ge = de.getProjectionData({
                                overscaledTileID: null,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0
                            })
                              , Te = B.properties.get("atmosphere-blend") * ge.projectionTransition;
                            if (Te === 0)
                                return;
                            const he = Bs(de.worldSize, de.center.lat)
                              , De = de.inverseProjectionMatrix
                              , He = new Float64Array(4);
                            He[3] = 1,
                            o.aw(He, He, de.modelViewProjectionMatrix),
                            He[0] /= He[3],
                            He[1] /= He[3],
                            He[2] /= He[3],
                            He[3] = 1,
                            o.aw(He, He, De),
                            He[0] /= He[3],
                            He[1] /= He[3],
                            He[2] /= He[3],
                            He[3] = 1;
                            const je = ( ($e, Rt, Nt, yt, sr) => ({
                                u_sun_pos: $e,
                                u_atmosphere_blend: Rt,
                                u_globe_position: Nt,
                                u_globe_radius: yt,
                                u_inv_proj_matrix: sr
                            }))(ue, Te, [He[0], He[1], He[2]], he, De)
                              , qe = Ao(ee, B);
                            re.draw(ee, J.TRIANGLES, se, hi.disabled, Ti.alphaBlended, wr.disabled, je, null, null, "atmosphere", qe.vertexBuffer, qe.indexBuffer, qe.segments)
                        }
                        )(this, this.style.sky, this.style.light),
                        this.options.showTileBoundaries) {
                            const z = (function(B, U) {
                                let ee = null;
                                const J = Object.values(B._layers).flatMap((ue => ue.source && !ue.isHidden(U) ? [B.sourceCaches[ue.source]] : []))
                                  , re = J.filter((ue => ue.getSource().type === "vector"))
                                  , se = J.filter((ue => ue.getSource().type !== "vector"))
                                  , de = ue => {
                                    (!ee || ee.getSource().maxzoom < ue.getSource().maxzoom) && (ee = ue)
                                }
                                ;
                                return re.forEach((ue => de(ue))),
                                ee || se.forEach((ue => de(ue))),
                                ee
                            }
                            )(this.style, this.transform.zoom);
                            z && (function(B, U, ee) {
                                for (let J = 0; J < ee.length; J++)
                                    ua(B, U, ee[J])
                            }
                            )(this, z, z.getVisibleCoordinates())
                        }
                        this.options.showPadding && (function(z) {
                            const B = z.transform.padding;
                            Nc(z, z.transform.height - (B.top || 0), 3, Oh),
                            Nc(z, B.bottom || 0, 3, Nh),
                            Vi(z, B.left || 0, 3, gl),
                            Vi(z, z.transform.width - (B.right || 0), 3, Oc);
                            const U = z.transform.centerPoint;
                            (function(ee, J, re, se) {
                                Oa(ee, J - 1, re - 10, 2, 20, se),
                                Oa(ee, J - 10, re - 1, 20, 2, se)
                            }
                            )(z, U.x, z.transform.height - U.y, mp)
                        }
                        )(this),
                        this.context.setDefault()
                    }
                    maybeDrawDepthAndCoords(e) {
                        if (!this.style || !this.style.map || !this.style.map.terrain)
                            return;
                        const n = this.terrainFacilitator.matrix
                          , s = this.transform.modelViewProjectionMatrix;
                        let u = this.terrainFacilitator.dirty;
                        u || (u = e ? !o.c8(n, s) : !o.c9(n, s)),
                        u || (u = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)),
                        u && (o.ca(n, s),
                        this.terrainFacilitator.renderTime = Date.now(),
                        this.terrainFacilitator.dirty = !1,
                        (function(d, m) {
                            const y = d.context
                              , w = y.gl
                              , P = d.transform
                              , M = Ti.unblended
                              , D = new Vr(w.LEQUAL,Vr.ReadWrite,[0, 1])
                              , z = m.sourceCache.getRenderableTiles()
                              , B = d.useProgram("terrainDepth");
                            y.bindFramebuffer.set(m.getFramebuffer("depth").framebuffer),
                            y.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]),
                            y.clear({
                                color: o.bf.transparent,
                                depth: 1
                            });
                            for (const U of z) {
                                const ee = m.getTerrainMesh(U.tileID)
                                  , J = m.getTerrainData(U.tileID)
                                  , re = P.getProjectionData({
                                    overscaledTileID: U.tileID,
                                    applyTerrainMatrix: !1,
                                    applyGlobeMatrix: !0
                                })
                                  , se = {
                                    u_ele_delta: m.getMeshFrameDelta(P.zoom)
                                };
                                B.draw(y, w.TRIANGLES, D, hi.disabled, M, wr.backCCW, se, J, re, "terrain", ee.vertexBuffer, ee.indexBuffer, ee.segments)
                            }
                            y.bindFramebuffer.set(null),
                            y.viewport.set([0, 0, d.width, d.height])
                        }
                        )(this, this.style.map.terrain),
                        (function(d, m) {
                            const y = d.context
                              , w = y.gl
                              , P = d.transform
                              , M = Ti.unblended
                              , D = new Vr(w.LEQUAL,Vr.ReadWrite,[0, 1])
                              , z = m.getCoordsTexture()
                              , B = m.sourceCache.getRenderableTiles()
                              , U = d.useProgram("terrainCoords");
                            y.bindFramebuffer.set(m.getFramebuffer("coords").framebuffer),
                            y.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]),
                            y.clear({
                                color: o.bf.transparent,
                                depth: 1
                            }),
                            m.coordsIndex = [];
                            for (const ee of B) {
                                const J = m.getTerrainMesh(ee.tileID)
                                  , re = m.getTerrainData(ee.tileID);
                                y.activeTexture.set(w.TEXTURE0),
                                w.bindTexture(w.TEXTURE_2D, z.texture);
                                const se = {
                                    u_terrain_coords_id: (255 - m.coordsIndex.length) / 255,
                                    u_texture: 0,
                                    u_ele_delta: m.getMeshFrameDelta(P.zoom)
                                }
                                  , de = P.getProjectionData({
                                    overscaledTileID: ee.tileID,
                                    applyTerrainMatrix: !1,
                                    applyGlobeMatrix: !0
                                });
                                U.draw(y, w.TRIANGLES, D, hi.disabled, M, wr.backCCW, se, re, de, "terrain", J.vertexBuffer, J.indexBuffer, J.segments),
                                m.coordsIndex.push(ee.tileID.key)
                            }
                            y.bindFramebuffer.set(null),
                            y.viewport.set([0, 0, d.width, d.height])
                        }
                        )(this, this.style.map.terrain))
                    }
                    renderLayer(e, n, s, u, d) {
                        s.isHidden(this.transform.zoom) || (s.type === "background" || s.type === "custom" || (u || []).length) && (this.id = s.id,
                        o.cb(s) ? (function(m, y, w, P, M, D) {
                            if (m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: z} = D
                              , B = hi.disabled
                              , U = m.colorModeForRenderPass();
                            (w._unevaluatedLayout.hasValue("text-variable-anchor") || w._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(ee, J, re, se, de, ue, ge, Te, he) {
                                const De = J.transform
                                  , He = J.style.map.terrain
                                  , je = de === "map"
                                  , qe = ue === "map";
                                for (const $e of ee) {
                                    const Rt = se.getTile($e)
                                      , Nt = Rt.getBucket(re);
                                    if (!Nt || !Nt.text || !Nt.text.segments.get().length)
                                        continue;
                                    const yt = o.an(Nt.textSizeData, De.zoom)
                                      , sr = o.aC(Rt, 1, J.transform.zoom)
                                      , Xr = $r(je, J.transform, sr)
                                      , xi = re.layout.get("icon-text-fit") !== "none" && Nt.hasIconData();
                                    if (yt) {
                                        const ki = Math.pow(2, De.zoom - Rt.tileID.overscaledZ)
                                          , Pi = He ? (ji, Ui) => He.getElevation($e, ji, Ui) : null;
                                        Lc(Nt, je, qe, he, De, Xr, ki, yt, xi, o.aD(De, Rt, ge, Te), $e.toUnwrapped(), Pi)
                                    }
                                }
                            }
                            )(P, m, w, y, w.layout.get("text-rotation-alignment"), w.layout.get("text-pitch-alignment"), w.paint.get("text-translate"), w.paint.get("text-translate-anchor"), M),
                            w.paint.get("icon-opacity").constantOr(1) !== 0 && Co(m, y, w, P, !1, w.paint.get("icon-translate"), w.paint.get("icon-translate-anchor"), w.layout.get("icon-rotation-alignment"), w.layout.get("icon-pitch-alignment"), w.layout.get("icon-keep-upright"), B, U, z),
                            w.paint.get("text-opacity").constantOr(1) !== 0 && Co(m, y, w, P, !0, w.paint.get("text-translate"), w.paint.get("text-translate-anchor"), w.layout.get("text-rotation-alignment"), w.layout.get("text-pitch-alignment"), w.layout.get("text-keep-upright"), B, U, z),
                            y.map.showCollisionBoxes && (Rh(m, y, w, P, !0),
                            Rh(m, y, w, P, !1))
                        }
                        )(e, n, s, u, this.style.placement.variableOffsets, d) : o.cc(s) ? (function(m, y, w, P, M) {
                            if (m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: D} = M
                              , z = w.paint.get("circle-opacity")
                              , B = w.paint.get("circle-stroke-width")
                              , U = w.paint.get("circle-stroke-opacity")
                              , ee = !w.layout.get("circle-sort-key").isConstant();
                            if (z.constantOr(1) === 0 && (B.constantOr(1) === 0 || U.constantOr(1) === 0))
                                return;
                            const J = m.context
                              , re = J.gl
                              , se = m.transform
                              , de = m.getDepthModeForSublayer(0, Vr.ReadOnly)
                              , ue = hi.disabled
                              , ge = m.colorModeForRenderPass()
                              , Te = []
                              , he = se.getCircleRadiusCorrection();
                            for (let De = 0; De < P.length; De++) {
                                const He = P[De]
                                  , je = y.getTile(He)
                                  , qe = je.getBucket(w);
                                if (!qe)
                                    continue;
                                const $e = w.paint.get("circle-translate")
                                  , Rt = w.paint.get("circle-translate-anchor")
                                  , Nt = o.aD(se, je, $e, Rt)
                                  , yt = qe.programConfigurations.get(w.id)
                                  , sr = m.useProgram("circle", yt)
                                  , Xr = qe.layoutVertexBuffer
                                  , xi = qe.indexBuffer
                                  , ki = m.style.map.terrain && m.style.map.terrain.getTerrainData(He)
                                  , Pi = {
                                    programConfiguration: yt,
                                    program: sr,
                                    layoutVertexBuffer: Xr,
                                    indexBuffer: xi,
                                    uniformValues: rp(m, je, w, Nt, he),
                                    terrainData: ki,
                                    projectionData: se.getProjectionData({
                                        overscaledTileID: He,
                                        applyGlobeMatrix: !D,
                                        applyTerrainMatrix: !0
                                    })
                                };
                                if (ee) {
                                    const ji = qe.segments.get();
                                    for (const Ui of ji)
                                        Te.push({
                                            segments: new o.aM([Ui]),
                                            sortKey: Ui.sortKey,
                                            state: Pi
                                        })
                                } else
                                    Te.push({
                                        segments: qe.segments,
                                        sortKey: 0,
                                        state: Pi
                                    })
                            }
                            ee && Te.sort(( (De, He) => De.sortKey - He.sortKey));
                            for (const De of Te) {
                                const {programConfiguration: He, program: je, layoutVertexBuffer: qe, indexBuffer: $e, uniformValues: Rt, terrainData: Nt, projectionData: yt} = De.state;
                                je.draw(J, re.TRIANGLES, de, ue, ge, wr.backCCW, Rt, Nt, yt, w.id, qe, $e, De.segments, w.paint, m.transform.zoom, He)
                            }
                        }
                        )(e, n, s, u, d) : o.cd(s) ? (function(m, y, w, P, M) {
                            if (w.paint.get("heatmap-opacity") === 0)
                                return;
                            const D = m.context
                              , {isRenderingToTexture: z, isRenderingGlobe: B} = M;
                            if (m.style.map.terrain) {
                                for (const U of P) {
                                    const ee = y.getTile(U);
                                    y.hasRenderableParent(U) || (m.renderPass === "offscreen" ? Dc(m, ee, w, U, B) : m.renderPass === "translucent" && Fh(m, w, U, z, B))
                                }
                                D.viewport.set([0, 0, m.width, m.height])
                            } else
                                m.renderPass === "offscreen" ? (function(U, ee, J, re) {
                                    const se = U.context
                                      , de = se.gl
                                      , ue = U.transform
                                      , ge = hi.disabled
                                      , Te = new Ti([de.ONE, de.ONE],o.bf.transparent,[!0, !0, !0, !0]);
                                    (function(he, De, He) {
                                        const je = he.gl;
                                        he.activeTexture.set(je.TEXTURE1),
                                        he.viewport.set([0, 0, De.width / 4, De.height / 4]);
                                        let qe = He.heatmapFbos.get(o.c2);
                                        qe ? (je.bindTexture(je.TEXTURE_2D, qe.colorAttachment.get()),
                                        he.bindFramebuffer.set(qe.framebuffer)) : (qe = Po(he, De.width / 4, De.height / 4),
                                        He.heatmapFbos.set(o.c2, qe))
                                    }
                                    )(se, U, J),
                                    se.clear({
                                        color: o.bf.transparent
                                    });
                                    for (let he = 0; he < re.length; he++) {
                                        const De = re[he];
                                        if (ee.hasRenderableParent(De))
                                            continue;
                                        const He = ee.getTile(De)
                                          , je = He.getBucket(J);
                                        if (!je)
                                            continue;
                                        const qe = je.programConfigurations.get(J.id)
                                          , $e = U.useProgram("heatmap", qe)
                                          , Rt = ue.getProjectionData({
                                            overscaledTileID: De,
                                            applyGlobeMatrix: !0,
                                            applyTerrainMatrix: !1
                                        })
                                          , Nt = ue.getCircleRadiusCorrection();
                                        $e.draw(se, de.TRIANGLES, Vr.disabled, ge, Te, wr.backCCW, vh(He, ue.zoom, J.paint.get("heatmap-intensity"), Nt), null, Rt, J.id, je.layoutVertexBuffer, je.indexBuffer, je.segments, J.paint, ue.zoom, qe)
                                    }
                                    se.viewport.set([0, 0, U.width, U.height])
                                }
                                )(m, y, w, P) : m.renderPass === "translucent" && (function(U, ee) {
                                    const J = U.context
                                      , re = J.gl;
                                    J.setColorMode(U.colorModeForRenderPass());
                                    const se = ee.heatmapFbos.get(o.c2);
                                    se && (J.activeTexture.set(re.TEXTURE0),
                                    re.bindTexture(re.TEXTURE_2D, se.colorAttachment.get()),
                                    J.activeTexture.set(re.TEXTURE1),
                                    Io(J, ee).bind(re.LINEAR, re.CLAMP_TO_EDGE),
                                    U.useProgram("heatmapTexture").draw(J, re.TRIANGLES, Vr.disabled, hi.disabled, U.colorModeForRenderPass(), wr.disabled, xc(U, ee, 0, 1), null, null, ee.id, U.viewportBuffer, U.quadTriangleIndexBuffer, U.viewportSegments, ee.paint, U.transform.zoom))
                                }
                                )(m, w)
                        }
                        )(e, n, s, u, d) : o.ce(s) ? (function(m, y, w, P, M) {
                            if (m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: D} = M
                              , z = w.paint.get("line-opacity")
                              , B = w.paint.get("line-width");
                            if (z.constantOr(1) === 0 || B.constantOr(1) === 0)
                                return;
                            const U = m.getDepthModeForSublayer(0, Vr.ReadOnly)
                              , ee = m.colorModeForRenderPass()
                              , J = w.paint.get("line-dasharray")
                              , re = w.paint.get("line-pattern")
                              , se = re.constantOr(1)
                              , de = w.paint.get("line-gradient")
                              , ue = w.getCrossfadeParameters()
                              , ge = se ? "linePattern" : J ? "lineSDF" : de ? "lineGradient" : "line"
                              , Te = m.context
                              , he = Te.gl
                              , De = m.transform;
                            let He = !0;
                            for (const je of P) {
                                const qe = y.getTile(je);
                                if (se && !qe.patternsLoaded())
                                    continue;
                                const $e = qe.getBucket(w);
                                if (!$e)
                                    continue;
                                const Rt = $e.programConfigurations.get(w.id)
                                  , Nt = m.context.program.get()
                                  , yt = m.useProgram(ge, Rt)
                                  , sr = He || yt.program !== Nt
                                  , Xr = m.style.map.terrain && m.style.map.terrain.getTerrainData(je)
                                  , xi = re.constantOr(null);
                                if (xi && qe.imageAtlas) {
                                    const Wr = qe.imageAtlas
                                      , Ei = Wr.patternPositions[xi.to.toString()]
                                      , Qi = Wr.patternPositions[xi.from.toString()];
                                    Ei && Qi && Rt.setConstantPatternPositions(Ei, Qi)
                                }
                                const ki = De.getProjectionData({
                                    overscaledTileID: je,
                                    applyGlobeMatrix: !D,
                                    applyTerrainMatrix: !0
                                })
                                  , Pi = De.getPixelScale()
                                  , ji = se ? wh(m, qe, w, Pi, ue) : J ? gs(m, qe, w, Pi, J, ue) : de ? bh(m, qe, w, Pi, $e.lineClipsArray.length) : sl(m, qe, w, Pi);
                                if (se)
                                    Te.activeTexture.set(he.TEXTURE0),
                                    qe.imageAtlasTexture.bind(he.LINEAR, he.CLAMP_TO_EDGE),
                                    Rt.updatePaintBuffers(ue);
                                else if (J && (sr || m.lineAtlas.dirty))
                                    Te.activeTexture.set(he.TEXTURE0),
                                    m.lineAtlas.bind(Te);
                                else if (de) {
                                    const Wr = $e.gradients[w.id];
                                    let Ei = Wr.texture;
                                    if (w.gradientVersion !== Wr.version) {
                                        let Qi = 256;
                                        if (w.stepInterpolant) {
                                            const dn = y.getSource().maxzoom
                                              , xn = je.canonical.z === dn ? Math.ceil(1 << m.transform.maxZoom - je.canonical.z) : 1;
                                            Qi = o.ah(o.c3($e.maxLineLength / o.$ * 1024 * xn), 256, Te.maxTextureSize)
                                        }
                                        Wr.gradient = o.c4({
                                            expression: w.gradientExpression(),
                                            evaluationKey: "lineProgress",
                                            resolution: Qi,
                                            image: Wr.gradient || void 0,
                                            clips: $e.lineClipsArray
                                        }),
                                        Wr.texture ? Wr.texture.update(Wr.gradient) : Wr.texture = new o.T(Te,Wr.gradient,he.RGBA),
                                        Wr.version = w.gradientVersion,
                                        Ei = Wr.texture
                                    }
                                    Te.activeTexture.set(he.TEXTURE0),
                                    Ei.bind(w.stepInterpolant ? he.NEAREST : he.LINEAR, he.CLAMP_TO_EDGE)
                                }
                                const Ui = m.stencilModeForClipping(je);
                                yt.draw(Te, he.TRIANGLES, U, Ui, ee, wr.disabled, ji, Xr, ki, w.id, $e.layoutVertexBuffer, $e.indexBuffer, $e.segments, w.paint, m.transform.zoom, Rt, $e.layoutVertexBuffer2),
                                He = !1
                            }
                        }
                        )(e, n, s, u, d) : o.cf(s) ? (function(m, y, w, P, M) {
                            const D = w.paint.get("fill-color")
                              , z = w.paint.get("fill-opacity");
                            if (z.constantOr(1) === 0)
                                return;
                            const {isRenderingToTexture: B} = M
                              , U = m.colorModeForRenderPass()
                              , ee = w.paint.get("fill-pattern")
                              , J = m.opaquePassEnabledForLayer() && !ee.constantOr(1) && D.constantOr(o.bf.transparent).a === 1 && z.constantOr(0) === 1 ? "opaque" : "translucent";
                            if (m.renderPass === J) {
                                const re = m.getDepthModeForSublayer(1, m.renderPass === "opaque" ? Vr.ReadWrite : Vr.ReadOnly);
                                ml(m, y, w, P, re, U, !1, B)
                            }
                            if (m.renderPass === "translucent" && w.paint.get("fill-antialias")) {
                                const re = m.getDepthModeForSublayer(w.getPaintProperty("fill-outline-color") ? 2 : 0, Vr.ReadOnly);
                                ml(m, y, w, P, re, U, !0, B)
                            }
                        }
                        )(e, n, s, u, d) : o.cg(s) ? (function(m, y, w, P, M) {
                            const D = w.paint.get("fill-extrusion-opacity");
                            if (D === 0)
                                return;
                            const {isRenderingToTexture: z} = M;
                            if (m.renderPass === "translucent") {
                                const B = new Vr(m.context.gl.LEQUAL,Vr.ReadWrite,m.depthRangeFor3D);
                                if (D !== 1 || w.paint.get("fill-extrusion-pattern").constantOr(1))
                                    Rc(m, y, w, P, B, hi.disabled, Ti.disabled, z),
                                    Rc(m, y, w, P, B, m.stencilModeFor3D(), m.colorModeForRenderPass(), z);
                                else {
                                    const U = m.colorModeForRenderPass();
                                    Rc(m, y, w, P, B, hi.disabled, U, z)
                                }
                            }
                        }
                        )(e, n, s, u, d) : o.ch(s) ? (function(m, y, w, P, M) {
                            if (m.renderPass !== "offscreen" && m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: D} = M
                              , z = m.context
                              , B = m.style.projection.useSubdivision
                              , U = m.getDepthModeForSublayer(0, Vr.ReadOnly)
                              , ee = m.colorModeForRenderPass();
                            if (m.renderPass === "offscreen")
                                (function(J, re, se, de, ue, ge, Te) {
                                    const he = J.context
                                      , De = he.gl;
                                    for (const He of se) {
                                        const je = re.getTile(He)
                                          , qe = je.dem;
                                        if (!qe || !qe.data || !je.needsHillshadePrepare)
                                            continue;
                                        const $e = qe.dim
                                          , Rt = qe.stride
                                          , Nt = qe.getPixels();
                                        if (he.activeTexture.set(De.TEXTURE1),
                                        he.pixelStoreUnpackPremultiplyAlpha.set(!1),
                                        je.demTexture = je.demTexture || J.getTileTexture(Rt),
                                        je.demTexture) {
                                            const sr = je.demTexture;
                                            sr.update(Nt, {
                                                premultiply: !1
                                            }),
                                            sr.bind(De.NEAREST, De.CLAMP_TO_EDGE)
                                        } else
                                            je.demTexture = new o.T(he,Nt,De.RGBA,{
                                                premultiply: !1
                                            }),
                                            je.demTexture.bind(De.NEAREST, De.CLAMP_TO_EDGE);
                                        he.activeTexture.set(De.TEXTURE0);
                                        let yt = je.fbo;
                                        if (!yt) {
                                            const sr = new o.T(he,{
                                                width: $e,
                                                height: $e,
                                                data: null
                                            },De.RGBA);
                                            sr.bind(De.LINEAR, De.CLAMP_TO_EDGE),
                                            yt = je.fbo = he.createFramebuffer($e, $e, !0, !1),
                                            yt.colorAttachment.set(sr.texture)
                                        }
                                        he.bindFramebuffer.set(yt.framebuffer),
                                        he.viewport.set([0, 0, $e, $e]),
                                        J.useProgram("hillshadePrepare").draw(he, De.TRIANGLES, ue, ge, Te, wr.disabled, yh(je.tileID, qe), null, null, de.id, J.rasterBoundsBuffer, J.quadTriangleIndexBuffer, J.rasterBoundsSegments),
                                        je.needsHillshadePrepare = !1
                                    }
                                }
                                )(m, y, P, w, U, hi.disabled, ee),
                                z.viewport.set([0, 0, m.width, m.height]);
                            else if (m.renderPass === "translucent")
                                if (B) {
                                    const [J,re,se] = m.stencilConfigForOverlapTwoPass(P);
                                    bs(m, y, w, se, J, U, ee, !1, D),
                                    bs(m, y, w, se, re, U, ee, !0, D)
                                } else {
                                    const [J,re] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                                    bs(m, y, w, re, J, U, ee, !1, D)
                                }
                        }
                        )(e, n, s, u, d) : o.ci(s) ? (function(m, y, w, P, M) {
                            if (m.renderPass !== "translucent" || !P.length)
                                return;
                            const {isRenderingToTexture: D} = M
                              , z = m.style.projection.useSubdivision
                              , B = m.getDepthModeForSublayer(0, Vr.ReadOnly)
                              , U = m.colorModeForRenderPass();
                            if (z) {
                                const [ee,J,re] = m.stencilConfigForOverlapTwoPass(P);
                                Bc(m, y, w, re, ee, B, U, !1, D),
                                Bc(m, y, w, re, J, B, U, !0, D)
                            } else {
                                const [ee,J] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                                Bc(m, y, w, J, ee, B, U, !1, D)
                            }
                        }
                        )(e, n, s, u, d) : o.cj(s) ? (function(m, y, w, P, M) {
                            if (m.renderPass !== "translucent" || w.paint.get("raster-opacity") === 0 || !P.length)
                                return;
                            const {isRenderingToTexture: D} = M
                              , z = y.getSource()
                              , B = m.style.projection.useSubdivision;
                            if (z instanceof Ft)
                                ws(m, y, w, P, null, !1, !1, z.tileCoords, z.flippedWindingOrder, D);
                            else if (B) {
                                const [U,ee,J] = m.stencilConfigForOverlapTwoPass(P);
                                ws(m, y, w, J, U, !1, !0, _l, !1, D),
                                ws(m, y, w, J, ee, !0, !0, _l, !1, D)
                            } else {
                                const [U,ee] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                                ws(m, y, w, ee, U, !1, !0, _l, !1, D)
                            }
                        }
                        )(e, n, s, u, d) : o.ck(s) ? (function(m, y, w, P, M) {
                            const D = w.paint.get("background-color")
                              , z = w.paint.get("background-opacity");
                            if (z === 0)
                                return;
                            const {isRenderingToTexture: B} = M
                              , U = m.context
                              , ee = U.gl
                              , J = m.style.projection
                              , re = m.transform
                              , se = re.tileSize
                              , de = w.paint.get("background-pattern");
                            if (m.isPatternMissing(de))
                                return;
                            const ue = !de && D.a === 1 && z === 1 && m.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                            if (m.renderPass !== ue)
                                return;
                            const ge = hi.disabled
                              , Te = m.getDepthModeForSublayer(0, ue === "opaque" ? Vr.ReadWrite : Vr.ReadOnly)
                              , he = m.colorModeForRenderPass()
                              , De = m.useProgram(de ? "backgroundPattern" : "background")
                              , He = P || xe(re, {
                                tileSize: se,
                                terrain: m.style.map.terrain
                            });
                            de && (U.activeTexture.set(ee.TEXTURE0),
                            m.imageManager.bind(m.context));
                            const je = w.getCrossfadeParameters();
                            for (const qe of He) {
                                const $e = re.getProjectionData({
                                    overscaledTileID: qe,
                                    applyGlobeMatrix: !B,
                                    applyTerrainMatrix: !0
                                })
                                  , Rt = de ? Sh(z, m, de, {
                                    tileID: qe,
                                    tileSize: se
                                }, je) : Ch(z, D)
                                  , Nt = m.style.map.terrain && m.style.map.terrain.getTerrainData(qe)
                                  , yt = J.getMeshFromTileID(U, qe.canonical, !1, !0, "raster");
                                De.draw(U, ee.TRIANGLES, Te, ge, he, wr.backCCW, Rt, Nt, $e, w.id, yt.vertexBuffer, yt.indexBuffer, yt.segments)
                            }
                        }
                        )(e, 0, s, u, d) : o.cl(s) && (function(m, y, w, P) {
                            const {isRenderingGlobe: M} = P
                              , D = m.context
                              , z = w.implementation
                              , B = m.style.projection
                              , U = m.transform
                              , ee = U.getProjectionDataForCustomLayer(M)
                              , J = {
                                farZ: U.farZ,
                                nearZ: U.nearZ,
                                fov: U.fov * Math.PI / 180,
                                modelViewProjectionMatrix: U.modelViewProjectionMatrix,
                                projectionMatrix: U.projectionMatrix,
                                shaderData: {
                                    variantName: B.shaderVariantName,
                                    vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${B.shaderPreludeCode.vertexSource}`,
                                    define: B.shaderDefine
                                },
                                defaultProjectionData: ee
                            }
                              , re = z.renderingMode ? z.renderingMode : "2d";
                            if (m.renderPass === "offscreen") {
                                const se = z.prerender;
                                se && (m.setCustomLayerDefaults(),
                                D.setColorMode(m.colorModeForRenderPass()),
                                se.call(z, D.gl, J),
                                D.setDirty(),
                                m.setBaseState())
                            } else if (m.renderPass === "translucent") {
                                m.setCustomLayerDefaults(),
                                D.setColorMode(m.colorModeForRenderPass()),
                                D.setStencilMode(hi.disabled);
                                const se = re === "3d" ? m.getDepthModeFor3D() : m.getDepthModeForSublayer(0, Vr.ReadOnly);
                                D.setDepthMode(se),
                                z.render(D.gl, J),
                                D.setDirty(),
                                m.setBaseState(),
                                D.bindFramebuffer.set(null)
                            }
                        }
                        )(e, 0, s, d))
                    }
                    saveTileTexture(e) {
                        const n = this._tileTextures[e.size[0]];
                        n ? n.push(e) : this._tileTextures[e.size[0]] = [e]
                    }
                    getTileTexture(e) {
                        const n = this._tileTextures[e];
                        return n && n.length > 0 ? n.pop() : null
                    }
                    isPatternMissing(e) {
                        if (!e)
                            return !1;
                        if (!e.from || !e.to)
                            return !0;
                        const n = this.imageManager.getPattern(e.from.toString())
                          , s = this.imageManager.getPattern(e.to.toString());
                        return !n || !s
                    }
                    useProgram(e, n, s=!1, u=[]) {
                        this.cache = this.cache || {};
                        const d = !!this.style.map.terrain
                          , m = this.style.projection
                          , y = s ? pi.projectionMercator : m.shaderPreludeCode
                          , w = s ? Jr : m.shaderDefine
                          , P = e + (n ? n.cacheKey : "") + `/${s ? ti : m.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (d ? "/terrain" : "") + (u ? `/${u.join("/")}` : "");
                        return this.cache[P] || (this.cache[P] = new yc(this.context,pi[e],n,Sc[e],this._showOverdrawInspector,d,y,w,u)),
                        this.cache[P]
                    }
                    setCustomLayerDefaults() {
                        this.context.unbindVAO(),
                        this.context.cullFace.setDefault(),
                        this.context.activeTexture.setDefault(),
                        this.context.pixelStoreUnpack.setDefault(),
                        this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.context.pixelStoreUnpackFlipY.setDefault()
                    }
                    setBaseState() {
                        const e = this.context.gl;
                        this.context.cullFace.set(!1),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.blendEquation.set(e.FUNC_ADD)
                    }
                    initDebugOverlayCanvas() {
                        this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"),
                        this.debugOverlayCanvas.width = 512,
                        this.debugOverlayCanvas.height = 512,
                        this.debugOverlayTexture = new o.T(this.context,this.debugOverlayCanvas,this.context.gl.RGBA))
                    }
                    destroy() {
                        this.debugOverlayTexture && this.debugOverlayTexture.destroy()
                    }
                    overLimit() {
                        const {drawingBufferWidth: e, drawingBufferHeight: n} = this.context.gl;
                        return this.width !== e || this.height !== n
                    }
                }
                function Ts(h, e) {
                    let n, s = !1, u = null, d = null;
                    const m = () => {
                        u = null,
                        s && (h.apply(d, n),
                        u = setTimeout(m, e),
                        s = !1)
                    }
                    ;
                    return (...y) => (s = !0,
                    d = this,
                    n = y,
                    u || m(),
                    u)
                }
                class yl {
                    constructor(e) {
                        this._getCurrentHash = () => {
                            const n = window.location.hash.replace("#", "");
                            if (this._hashName) {
                                let s;
                                return n.split("&").map((u => u.split("="))).forEach((u => {
                                    u[0] === this._hashName && (s = u)
                                }
                                )),
                                (s && s[1] || "").split("/")
                            }
                            return n.split("/")
                        }
                        ,
                        this._onHashChange = () => {
                            const n = this._getCurrentHash();
                            if (!this._isValidHash(n))
                                return !1;
                            const s = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(n[3] || 0) : this._map.getBearing();
                            return this._map.jumpTo({
                                center: [+n[2], +n[1]],
                                zoom: +n[0],
                                bearing: s,
                                pitch: +(n[4] || 0)
                            }),
                            !0
                        }
                        ,
                        this._updateHashUnthrottled = () => {
                            const n = window.location.href.replace(/(#.*)?$/, this.getHashString());
                            window.history.replaceState(window.history.state, null, n)
                        }
                        ,
                        this._removeHash = () => {
                            const n = this._getCurrentHash();
                            if (n.length === 0)
                                return;
                            const s = n.join("/");
                            let u = s;
                            u.split("&").length > 0 && (u = u.split("&")[0]),
                            this._hashName && (u = `${this._hashName}=${s}`);
                            let d = window.location.hash.replace(u, "");
                            d.startsWith("#&") ? d = d.slice(0, 1) + d.slice(2) : d === "#" && (d = "");
                            let m = window.location.href.replace(/(#.+)?$/, d);
                            m = m.replace("&&", "&"),
                            window.history.replaceState(window.history.state, null, m)
                        }
                        ,
                        this._updateHash = Ts(this._updateHashUnthrottled, 300),
                        this._hashName = e && encodeURIComponent(e)
                    }
                    addTo(e) {
                        return this._map = e,
                        addEventListener("hashchange", this._onHashChange, !1),
                        this._map.on("moveend", this._updateHash),
                        this
                    }
                    remove() {
                        return removeEventListener("hashchange", this._onHashChange, !1),
                        this._map.off("moveend", this._updateHash),
                        clearTimeout(this._updateHash()),
                        this._removeHash(),
                        delete this._map,
                        this
                    }
                    getHashString(e) {
                        const n = this._map.getCenter()
                          , s = Math.round(100 * this._map.getZoom()) / 100
                          , u = Math.ceil((s * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10)
                          , d = Math.pow(10, u)
                          , m = Math.round(n.lng * d) / d
                          , y = Math.round(n.lat * d) / d
                          , w = this._map.getBearing()
                          , P = this._map.getPitch();
                        let M = "";
                        if (M += e ? `/${m}/${y}/${s}` : `${s}/${y}/${m}`,
                        (w || P) && (M += "/" + Math.round(10 * w) / 10),
                        P && (M += `/${Math.round(P)}`),
                        this._hashName) {
                            const D = this._hashName;
                            let z = !1;
                            const B = window.location.hash.slice(1).split("&").map((U => {
                                const ee = U.split("=")[0];
                                return ee === D ? (z = !0,
                                `${ee}=${M}`) : U
                            }
                            )).filter((U => U));
                            return z || B.push(`${D}=${M}`),
                            `#${B.join("&")}`
                        }
                        return `#${M}`
                    }
                    _isValidHash(e) {
                        if (e.length < 3 || e.some(isNaN))
                            return !1;
                        try {
                            new o.S(+e[2],+e[1])
                        } catch {
                            return !1
                        }
                        const n = +e[0]
                          , s = +(e[3] || 0)
                          , u = +(e[4] || 0);
                        return n >= this._map.getMinZoom() && n <= this._map.getMaxZoom() && s >= -180 && s <= 180 && u >= this._map.getMinPitch() && u <= this._map.getMaxPitch()
                    }
                }
                const Ga = {
                    linearity: .3,
                    easing: o.cm(0, 0, .3, 1)
                }
                  , jc = o.e({
                    deceleration: 2500,
                    maxSpeed: 1400
                }, Ga)
                  , qh = o.e({
                    deceleration: 20,
                    maxSpeed: 1400
                }, Ga)
                  , Vh = o.e({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, Ga)
                  , Uh = o.e({
                    deceleration: 1e3,
                    maxSpeed: 90
                }, Ga)
                  , Zh = o.e({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, Ga);
                class $h {
                    constructor(e) {
                        this._map = e,
                        this.clear()
                    }
                    clear() {
                        this._inertiaBuffer = []
                    }
                    record(e) {
                        this._drainInertiaBuffer(),
                        this._inertiaBuffer.push({
                            time: ye.now(),
                            settings: e
                        })
                    }
                    _drainInertiaBuffer() {
                        const e = this._inertiaBuffer
                          , n = ye.now();
                        for (; e.length > 0 && n - e[0].time > 160; )
                            e.shift()
                    }
                    _onMoveEnd(e) {
                        if (this._drainInertiaBuffer(),
                        this._inertiaBuffer.length < 2)
                            return;
                        const n = {
                            zoom: 0,
                            bearing: 0,
                            pitch: 0,
                            roll: 0,
                            pan: new o.P(0,0),
                            pinchAround: void 0,
                            around: void 0
                        };
                        for (const {settings: d} of this._inertiaBuffer)
                            n.zoom += d.zoomDelta || 0,
                            n.bearing += d.bearingDelta || 0,
                            n.pitch += d.pitchDelta || 0,
                            n.roll += d.rollDelta || 0,
                            d.panDelta && n.pan._add(d.panDelta),
                            d.around && (n.around = d.around),
                            d.pinchAround && (n.pinchAround = d.pinchAround);
                        const s = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time
                          , u = {};
                        if (n.pan.mag()) {
                            const d = js(n.pan.mag(), s, o.e({}, jc, e || {}))
                              , m = n.pan.mult(d.amount / n.pan.mag())
                              , y = this._map.cameraHelper.handlePanInertia(m, this._map.transform);
                            u.center = y.easingCenter,
                            u.offset = y.easingOffset,
                            xa(u, d)
                        }
                        if (n.zoom) {
                            const d = js(n.zoom, s, qh);
                            u.zoom = this._map.transform.zoom + d.amount,
                            xa(u, d)
                        }
                        if (n.bearing) {
                            const d = js(n.bearing, s, Vh);
                            u.bearing = this._map.transform.bearing + o.ah(d.amount, -179, 179),
                            xa(u, d)
                        }
                        if (n.pitch) {
                            const d = js(n.pitch, s, Uh);
                            u.pitch = this._map.transform.pitch + d.amount,
                            xa(u, d)
                        }
                        if (n.roll) {
                            const d = js(n.roll, s, Zh);
                            u.roll = this._map.transform.roll + o.ah(d.amount, -179, 179),
                            xa(u, d)
                        }
                        if (u.zoom || u.bearing) {
                            const d = n.pinchAround === void 0 ? n.around : n.pinchAround;
                            u.around = d ? this._map.unproject(d) : this._map.getCenter()
                        }
                        return this.clear(),
                        o.e(u, {
                            noMoveStart: !0
                        })
                    }
                }
                function xa(h, e) {
                    (!h.duration || h.duration < e.duration) && (h.duration = e.duration,
                    h.easing = e.easing)
                }
                function js(h, e, n) {
                    const {maxSpeed: s, linearity: u, deceleration: d} = n
                      , m = o.ah(h * u / (e / 1e3), -s, s)
                      , y = Math.abs(m) / (d * u);
                    return {
                        easing: n.easing,
                        duration: 1e3 * y,
                        amount: m * (y / 2)
                    }
                }
                class Wn extends o.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, n, s, u={}) {
                        s = s instanceof MouseEvent ? s : new MouseEvent(e,s);
                        const d = X.mousePos(n.getCanvas(), s)
                          , m = n.unproject(d);
                        super(e, o.e({
                            point: d,
                            lngLat: m,
                            originalEvent: s
                        }, u)),
                        this._defaultPrevented = !1,
                        this.target = n
                    }
                }
                class qs extends o.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, n, s) {
                        const u = e === "touchend" ? s.changedTouches : s.touches
                          , d = X.touchPos(n.getCanvasContainer(), u)
                          , m = d.map((w => n.unproject(w)))
                          , y = d.reduce(( (w, P, M, D) => w.add(P.div(D.length))), new o.P(0,0));
                        super(e, {
                            points: d,
                            point: y,
                            lngLats: m,
                            lngLat: n.unproject(y),
                            originalEvent: s
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class qc extends o.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, n, s) {
                        super(e, {
                            originalEvent: s
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class Gh {
                    constructor(e, n) {
                        this._map = e,
                        this._clickTolerance = n.clickTolerance
                    }
                    reset() {
                        delete this._mousedownPos
                    }
                    wheel(e) {
                        return this._firePreventable(new qc(e.type,this._map,e))
                    }
                    mousedown(e, n) {
                        return this._mousedownPos = n,
                        this._firePreventable(new Wn(e.type,this._map,e))
                    }
                    mouseup(e) {
                        this._map.fire(new Wn(e.type,this._map,e))
                    }
                    click(e, n) {
                        this._mousedownPos && this._mousedownPos.dist(n) >= this._clickTolerance || this._map.fire(new Wn(e.type,this._map,e))
                    }
                    dblclick(e) {
                        return this._firePreventable(new Wn(e.type,this._map,e))
                    }
                    mouseover(e) {
                        this._map.fire(new Wn(e.type,this._map,e))
                    }
                    mouseout(e) {
                        this._map.fire(new Wn(e.type,this._map,e))
                    }
                    touchstart(e) {
                        return this._firePreventable(new qs(e.type,this._map,e))
                    }
                    touchmove(e) {
                        this._map.fire(new qs(e.type,this._map,e))
                    }
                    touchend(e) {
                        this._map.fire(new qs(e.type,this._map,e))
                    }
                    touchcancel(e) {
                        this._map.fire(new qs(e.type,this._map,e))
                    }
                    _firePreventable(e) {
                        if (this._map.fire(e),
                        e.defaultPrevented)
                            return {}
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class Hh {
                    constructor(e) {
                        this._map = e
                    }
                    reset() {
                        this._delayContextMenu = !1,
                        this._ignoreContextMenu = !0,
                        delete this._contextMenuEvent
                    }
                    mousemove(e) {
                        this._map.fire(new Wn(e.type,this._map,e))
                    }
                    mousedown() {
                        this._delayContextMenu = !0,
                        this._ignoreContextMenu = !1
                    }
                    mouseup() {
                        this._delayContextMenu = !1,
                        this._contextMenuEvent && (this._map.fire(new Wn("contextmenu",this._map,this._contextMenuEvent)),
                        delete this._contextMenuEvent)
                    }
                    contextmenu(e) {
                        this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Wn(e.type,this._map,e)),
                        this._map.listens("contextmenu") && e.preventDefault()
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class Vs {
                    constructor(e) {
                        this._map = e
                    }
                    get transform() {
                        return this._map._requestedCameraState || this._map.transform
                    }
                    get center() {
                        return {
                            lng: this.transform.center.lng,
                            lat: this.transform.center.lat
                        }
                    }
                    get zoom() {
                        return this.transform.zoom
                    }
                    get pitch() {
                        return this.transform.pitch
                    }
                    get bearing() {
                        return this.transform.bearing
                    }
                    unproject(e) {
                        return this.transform.screenPointToLocation(o.P.convert(e), this._map.terrain)
                    }
                }
                class Vc {
                    constructor(e, n) {
                        this._map = e,
                        this._tr = new Vs(e),
                        this._el = e.getCanvasContainer(),
                        this._container = e.getContainer(),
                        this._clickTolerance = n.clickTolerance || 1
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                    enable() {
                        this.isEnabled() || (this._enabled = !0)
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    mousedown(e, n) {
                        this.isEnabled() && e.shiftKey && e.button === 0 && (X.disableDrag(),
                        this._startPos = this._lastPos = n,
                        this._active = !0)
                    }
                    mousemoveWindow(e, n) {
                        if (!this._active)
                            return;
                        const s = n;
                        if (this._lastPos.equals(s) || !this._box && s.dist(this._startPos) < this._clickTolerance)
                            return;
                        const u = this._startPos;
                        this._lastPos = s,
                        this._box || (this._box = X.create("div", "maplibregl-boxzoom", this._container),
                        this._container.classList.add("maplibregl-crosshair"),
                        this._fireEvent("boxzoomstart", e));
                        const d = Math.min(u.x, s.x)
                          , m = Math.max(u.x, s.x)
                          , y = Math.min(u.y, s.y)
                          , w = Math.max(u.y, s.y);
                        X.setTransform(this._box, `translate(${d}px,${y}px)`),
                        this._box.style.width = m - d + "px",
                        this._box.style.height = w - y + "px"
                    }
                    mouseupWindow(e, n) {
                        if (!this._active || e.button !== 0)
                            return;
                        const s = this._startPos
                          , u = n;
                        if (this.reset(),
                        X.suppressClick(),
                        s.x !== u.x || s.y !== u.y)
                            return this._map.fire(new o.l("boxzoomend",{
                                originalEvent: e
                            })),
                            {
                                cameraAnimation: d => d.fitScreenCoordinates(s, u, this._tr.bearing, {
                                    linear: !0
                                })
                            };
                        this._fireEvent("boxzoomcancel", e)
                    }
                    keydown(e) {
                        this._active && e.keyCode === 27 && (this.reset(),
                        this._fireEvent("boxzoomcancel", e))
                    }
                    reset() {
                        this._active = !1,
                        this._container.classList.remove("maplibregl-crosshair"),
                        this._box && (X.remove(this._box),
                        this._box = null),
                        X.enableDrag(),
                        delete this._startPos,
                        delete this._lastPos
                    }
                    _fireEvent(e, n) {
                        return this._map.fire(new o.l(e,{
                            originalEvent: n
                        }))
                    }
                }
                function Us(h, e) {
                    if (h.length !== e.length)
                        throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
                    const n = {};
                    for (let s = 0; s < h.length; s++)
                        n[h[s].identifier] = e[s];
                    return n
                }
                class Wh {
                    constructor(e) {
                        this.reset(),
                        this.numTouches = e.numTouches
                    }
                    reset() {
                        delete this.centroid,
                        delete this.startTime,
                        delete this.touches,
                        this.aborted = !1
                    }
                    touchstart(e, n, s) {
                        (this.centroid || s.length > this.numTouches) && (this.aborted = !0),
                        this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp),
                        s.length === this.numTouches && (this.centroid = (function(u) {
                            const d = new o.P(0,0);
                            for (const m of u)
                                d._add(m);
                            return d.div(u.length)
                        }
                        )(n),
                        this.touches = Us(s, n)))
                    }
                    touchmove(e, n, s) {
                        if (this.aborted || !this.centroid)
                            return;
                        const u = Us(s, n);
                        for (const d in this.touches) {
                            const m = u[d];
                            (!m || m.dist(this.touches[d]) > 30) && (this.aborted = !0)
                        }
                    }
                    touchend(e, n, s) {
                        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0),
                        s.length === 0) {
                            const u = !this.aborted && this.centroid;
                            if (this.reset(),
                            u)
                                return u
                        }
                    }
                }
                class Xn {
                    constructor(e) {
                        this.singleTap = new Wh(e),
                        this.numTaps = e.numTaps,
                        this.reset()
                    }
                    reset() {
                        this.lastTime = 1 / 0,
                        delete this.lastTap,
                        this.count = 0,
                        this.singleTap.reset()
                    }
                    touchstart(e, n, s) {
                        this.singleTap.touchstart(e, n, s)
                    }
                    touchmove(e, n, s) {
                        this.singleTap.touchmove(e, n, s)
                    }
                    touchend(e, n, s) {
                        const u = this.singleTap.touchend(e, n, s);
                        if (u) {
                            const d = e.timeStamp - this.lastTime < 500
                              , m = !this.lastTap || this.lastTap.dist(u) < 30;
                            if (d && m || this.reset(),
                            this.count++,
                            this.lastTime = e.timeStamp,
                            this.lastTap = u,
                            this.count === this.numTaps)
                                return this.reset(),
                                u
                        }
                    }
                }
                class ba {
                    constructor(e) {
                        this._tr = new Vs(e),
                        this._zoomIn = new Xn({
                            numTouches: 1,
                            numTaps: 2
                        }),
                        this._zoomOut = new Xn({
                            numTouches: 2,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._zoomIn.reset(),
                        this._zoomOut.reset()
                    }
                    touchstart(e, n, s) {
                        this._zoomIn.touchstart(e, n, s),
                        this._zoomOut.touchstart(e, n, s)
                    }
                    touchmove(e, n, s) {
                        this._zoomIn.touchmove(e, n, s),
                        this._zoomOut.touchmove(e, n, s)
                    }
                    touchend(e, n, s) {
                        const u = this._zoomIn.touchend(e, n, s)
                          , d = this._zoomOut.touchend(e, n, s)
                          , m = this._tr;
                        return u ? (this._active = !0,
                        e.preventDefault(),
                        setTimeout(( () => this.reset()), 0),
                        {
                            cameraAnimation: y => y.easeTo({
                                duration: 300,
                                zoom: m.zoom + 1,
                                around: m.unproject(u)
                            }, {
                                originalEvent: e
                            })
                        }) : d ? (this._active = !0,
                        e.preventDefault(),
                        setTimeout(( () => this.reset()), 0),
                        {
                            cameraAnimation: y => y.easeTo({
                                duration: 300,
                                zoom: m.zoom - 1,
                                around: m.unproject(d)
                            }, {
                                originalEvent: e
                            })
                        }) : void 0
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Zs {
                    constructor(e) {
                        this._enabled = !!e.enable,
                        this._moveStateManager = e.moveStateManager,
                        this._clickTolerance = e.clickTolerance || 1,
                        this._moveFunction = e.move,
                        this._activateOnStart = !!e.activateOnStart,
                        e.assignEvents(this),
                        this.reset()
                    }
                    reset(e) {
                        this._active = !1,
                        this._moved = !1,
                        delete this._lastPoint,
                        this._moveStateManager.endMove(e)
                    }
                    _move(...e) {
                        const n = this._moveFunction(...e);
                        if (n.bearingDelta || n.pitchDelta || n.rollDelta || n.around || n.panDelta)
                            return this._active = !0,
                            n
                    }
                    dragStart(e, n) {
                        this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e),
                        this._lastPoint = Array.isArray(n) ? n[0] : n,
                        this._activateOnStart && this._lastPoint && (this._active = !0))
                    }
                    dragMove(e, n) {
                        if (!this.isEnabled())
                            return;
                        const s = this._lastPoint;
                        if (!s)
                            return;
                        if (e.preventDefault(),
                        !this._moveStateManager.isValidMoveEvent(e))
                            return void this.reset(e);
                        const u = Array.isArray(n) ? n[0] : n;
                        return !this._moved && u.dist(s) < this._clickTolerance ? void 0 : (this._moved = !0,
                        this._lastPoint = u,
                        this._move(s, u))
                    }
                    dragEnd(e) {
                        this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && X.suppressClick(),
                        this.reset(e))
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    getClickTolerance() {
                        return this._clickTolerance
                    }
                }
                const wa = 0
                  , $s = 2
                  , _p = {
                    [wa]: 1,
                    [$s]: 2
                };
                class ko {
                    constructor(e) {
                        this._correctEvent = e.checkCorrectEvent
                    }
                    startMove(e) {
                        const n = X.mouseButton(e);
                        this._eventButton = n
                    }
                    endMove(e) {
                        delete this._eventButton
                    }
                    isValidStartEvent(e) {
                        return this._correctEvent(e)
                    }
                    isValidMoveEvent(e) {
                        return !(function(n, s) {
                            const u = _p[s];
                            return n.buttons === void 0 || (n.buttons & u) !== u
                        }
                        )(e, this._eventButton)
                    }
                    isValidEndEvent(e) {
                        return X.mouseButton(e) === this._eventButton
                    }
                }
                class gp {
                    constructor() {
                        this._firstTouch = void 0
                    }
                    _isOneFingerTouch(e) {
                        return e.targetTouches.length === 1
                    }
                    _isSameTouchEvent(e) {
                        return e.targetTouches[0].identifier === this._firstTouch
                    }
                    startMove(e) {
                        this._firstTouch = e.targetTouches[0].identifier
                    }
                    endMove(e) {
                        delete this._firstTouch
                    }
                    isValidStartEvent(e) {
                        return this._isOneFingerTouch(e)
                    }
                    isValidMoveEvent(e) {
                        return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
                    }
                    isValidEndEvent(e) {
                        return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
                    }
                }
                class vp {
                    constructor(e=new ko({
                        checkCorrectEvent: () => !0
                    }), n=new gp) {
                        this.mouseMoveStateManager = e,
                        this.oneFingerTouchMoveStateManager = n
                    }
                    _executeRelevantHandler(e, n, s) {
                        return e instanceof MouseEvent ? n(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? s(e) : void 0
                    }
                    startMove(e) {
                        this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.startMove(n)), (n => this.oneFingerTouchMoveStateManager.startMove(n)))
                    }
                    endMove(e) {
                        this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.endMove(n)), (n => this.oneFingerTouchMoveStateManager.endMove(n)))
                    }
                    isValidStartEvent(e) {
                        return this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.isValidStartEvent(n)), (n => this.oneFingerTouchMoveStateManager.isValidStartEvent(n)))
                    }
                    isValidMoveEvent(e) {
                        return this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.isValidMoveEvent(n)), (n => this.oneFingerTouchMoveStateManager.isValidMoveEvent(n)))
                    }
                    isValidEndEvent(e) {
                        return this._executeRelevantHandler(e, (n => this.mouseMoveStateManager.isValidEndEvent(n)), (n => this.oneFingerTouchMoveStateManager.isValidEndEvent(n)))
                    }
                }
                const Eo = h => {
                    h.mousedown = h.dragStart,
                    h.mousemoveWindow = h.dragMove,
                    h.mouseup = h.dragEnd,
                    h.contextmenu = e => {
                        e.preventDefault()
                    }
                }
                ;
                class zo {
                    constructor(e, n) {
                        this._clickTolerance = e.clickTolerance || 1,
                        this._map = n,
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._touches = {},
                        this._sum = new o.P(0,0)
                    }
                    _shouldBePrevented(e) {
                        return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
                    }
                    touchstart(e, n, s) {
                        return this._calculateTransform(e, n, s)
                    }
                    touchmove(e, n, s) {
                        if (this._active) {
                            if (!this._shouldBePrevented(s.length))
                                return e.preventDefault(),
                                this._calculateTransform(e, n, s);
                            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
                        }
                    }
                    touchend(e, n, s) {
                        this._calculateTransform(e, n, s),
                        this._active && this._shouldBePrevented(s.length) && this.reset()
                    }
                    touchcancel() {
                        this.reset()
                    }
                    _calculateTransform(e, n, s) {
                        s.length > 0 && (this._active = !0);
                        const u = Us(s, n)
                          , d = new o.P(0,0)
                          , m = new o.P(0,0);
                        let y = 0;
                        for (const P in u) {
                            const M = u[P]
                              , D = this._touches[P];
                            D && (d._add(M),
                            m._add(M.sub(D)),
                            y++,
                            u[P] = M)
                        }
                        if (this._touches = u,
                        this._shouldBePrevented(y) || !m.mag())
                            return;
                        const w = m.div(y);
                        return this._sum._add(w),
                        this._sum.mag() < this._clickTolerance ? void 0 : {
                            around: d.div(y),
                            panDelta: w
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Ta {
                    constructor() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        delete this._firstTwoTouches
                    }
                    touchstart(e, n, s) {
                        this._firstTwoTouches || s.length < 2 || (this._firstTwoTouches = [s[0].identifier, s[1].identifier],
                        this._start([n[0], n[1]]))
                    }
                    touchmove(e, n, s) {
                        if (!this._firstTwoTouches)
                            return;
                        e.preventDefault();
                        const [u,d] = this._firstTwoTouches
                          , m = Kt(s, n, u)
                          , y = Kt(s, n, d);
                        if (!m || !y)
                            return;
                        const w = this._aroundCenter ? null : m.add(y).div(2);
                        return this._move([m, y], w, e)
                    }
                    touchend(e, n, s) {
                        if (!this._firstTwoTouches)
                            return;
                        const [u,d] = this._firstTwoTouches
                          , m = Kt(s, n, u)
                          , y = Kt(s, n, d);
                        m && y || (this._active && X.suppressClick(),
                        this.reset())
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable(e) {
                        this._enabled = !0,
                        this._aroundCenter = !!e && e.around === "center"
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                }
                function Kt(h, e, n) {
                    for (let s = 0; s < h.length; s++)
                        if (h[s].identifier === n)
                            return e[s]
                }
                function Uc(h, e) {
                    return Math.log(h / e) / Math.LN2
                }
                class xl extends Ta {
                    reset() {
                        super.reset(),
                        delete this._distance,
                        delete this._startDistance
                    }
                    _start(e) {
                        this._startDistance = this._distance = e[0].dist(e[1])
                    }
                    _move(e, n) {
                        const s = this._distance;
                        if (this._distance = e[0].dist(e[1]),
                        this._active || !(Math.abs(Uc(this._distance, this._startDistance)) < .1))
                            return this._active = !0,
                            {
                                zoomDelta: Uc(this._distance, s),
                                pinchAround: n
                            }
                    }
                }
                function Zc(h, e) {
                    return 180 * h.angleWith(e) / Math.PI
                }
                class Gs extends Ta {
                    reset() {
                        super.reset(),
                        delete this._minDiameter,
                        delete this._startVector,
                        delete this._vector
                    }
                    _start(e) {
                        this._startVector = this._vector = e[0].sub(e[1]),
                        this._minDiameter = e[0].dist(e[1])
                    }
                    _move(e, n, s) {
                        const u = this._vector;
                        if (this._vector = e[0].sub(e[1]),
                        this._active || !this._isBelowThreshold(this._vector))
                            return this._active = !0,
                            {
                                bearingDelta: Zc(this._vector, u),
                                pinchAround: n
                            }
                    }
                    _isBelowThreshold(e) {
                        this._minDiameter = Math.min(this._minDiameter, e.mag());
                        const n = 25 / (Math.PI * this._minDiameter) * 360
                          , s = Zc(e, this._startVector);
                        return Math.abs(s) < n
                    }
                }
                function Cs(h) {
                    return Math.abs(h.y) > Math.abs(h.x)
                }
                class bl extends Ta {
                    constructor(e) {
                        super(),
                        this._currentTouchCount = 0,
                        this._map = e
                    }
                    reset() {
                        super.reset(),
                        this._valid = void 0,
                        delete this._firstMove,
                        delete this._lastPoints
                    }
                    touchstart(e, n, s) {
                        super.touchstart(e, n, s),
                        this._currentTouchCount = s.length
                    }
                    _start(e) {
                        this._lastPoints = e,
                        Cs(e[0].sub(e[1])) && (this._valid = !1)
                    }
                    _move(e, n, s) {
                        if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
                            return;
                        const u = e[0].sub(this._lastPoints[0])
                          , d = e[1].sub(this._lastPoints[1]);
                        return this._valid = this.gestureBeginsVertically(u, d, s.timeStamp),
                        this._valid ? (this._lastPoints = e,
                        this._active = !0,
                        {
                            pitchDelta: (u.y + d.y) / 2 * -.5
                        }) : void 0
                    }
                    gestureBeginsVertically(e, n, s) {
                        if (this._valid !== void 0)
                            return this._valid;
                        const u = e.mag() >= 2
                          , d = n.mag() >= 2;
                        if (!u && !d)
                            return;
                        if (!u || !d)
                            return this._firstMove === void 0 && (this._firstMove = s),
                            s - this._firstMove < 100 && void 0;
                        const m = e.y > 0 == n.y > 0;
                        return Cs(e) && Cs(n) && m
                    }
                }
                const si = {
                    panStep: 100,
                    bearingStep: 15,
                    pitchStep: 10
                };
                class wl {
                    constructor(e) {
                        this._tr = new Vs(e);
                        const n = si;
                        this._panStep = n.panStep,
                        this._bearingStep = n.bearingStep,
                        this._pitchStep = n.pitchStep,
                        this._rotationDisabled = !1
                    }
                    reset() {
                        this._active = !1
                    }
                    keydown(e) {
                        if (e.altKey || e.ctrlKey || e.metaKey)
                            return;
                        let n = 0
                          , s = 0
                          , u = 0
                          , d = 0
                          , m = 0;
                        switch (e.keyCode) {
                        case 61:
                        case 107:
                        case 171:
                        case 187:
                            n = 1;
                            break;
                        case 189:
                        case 109:
                        case 173:
                            n = -1;
                            break;
                        case 37:
                            e.shiftKey ? s = -1 : (e.preventDefault(),
                            d = -1);
                            break;
                        case 39:
                            e.shiftKey ? s = 1 : (e.preventDefault(),
                            d = 1);
                            break;
                        case 38:
                            e.shiftKey ? u = 1 : (e.preventDefault(),
                            m = -1);
                            break;
                        case 40:
                            e.shiftKey ? u = -1 : (e.preventDefault(),
                            m = 1);
                            break;
                        default:
                            return
                        }
                        return this._rotationDisabled && (s = 0,
                        u = 0),
                        {
                            cameraAnimation: y => {
                                const w = this._tr;
                                y.easeTo({
                                    duration: 300,
                                    easeId: "keyboardHandler",
                                    easing: yp,
                                    zoom: n ? Math.round(w.zoom) + n * (e.shiftKey ? 2 : 1) : w.zoom,
                                    bearing: w.bearing + s * this._bearingStep,
                                    pitch: w.pitch + u * this._pitchStep,
                                    offset: [-d * this._panStep, -m * this._panStep],
                                    center: w.center
                                }, {
                                    originalEvent: e
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    disableRotation() {
                        this._rotationDisabled = !0
                    }
                    enableRotation() {
                        this._rotationDisabled = !1
                    }
                }
                function yp(h) {
                    return h * (2 - h)
                }
                const Tl = 4.000244140625
                  , xp = 1 / 450;
                class Xh {
                    constructor(e, n) {
                        this._onTimeout = s => {
                            this._type = "wheel",
                            this._delta -= this._lastValue,
                            this._active || this._start(s)
                        }
                        ,
                        this._map = e,
                        this._tr = new Vs(e),
                        this._triggerRenderFrame = n,
                        this._delta = 0,
                        this._defaultZoomRate = .01,
                        this._wheelZoomRate = xp
                    }
                    setZoomRate(e) {
                        this._defaultZoomRate = e
                    }
                    setWheelZoomRate(e) {
                        this._wheelZoomRate = e
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active || this._finishTimeout !== void 0
                    }
                    isZooming() {
                        return !!this._zooming
                    }
                    enable(e) {
                        this.isEnabled() || (this._enabled = !0,
                        this._aroundCenter = !!e && e.around === "center")
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    _shouldBePrevented(e) {
                        return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
                    }
                    wheel(e) {
                        if (!this.isEnabled())
                            return;
                        if (this._shouldBePrevented(e))
                            return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
                        let n = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
                        const s = ye.now()
                          , u = s - (this._lastWheelEventTime || 0);
                        this._lastWheelEventTime = s,
                        n !== 0 && n % Tl == 0 ? this._type = "wheel" : n !== 0 && Math.abs(n) < 4 ? this._type = "trackpad" : u > 400 ? (this._type = null,
                        this._lastValue = n,
                        this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(u * n) < 200 ? "trackpad" : "wheel",
                        this._timeout && (clearTimeout(this._timeout),
                        this._timeout = null,
                        n += this._lastValue)),
                        e.shiftKey && n && (n /= 4),
                        this._type && (this._lastWheelEvent = e,
                        this._delta -= n,
                        this._active || this._start(e)),
                        e.preventDefault()
                    }
                    _start(e) {
                        if (!this._delta)
                            return;
                        this._frameId && (this._frameId = null),
                        this._active = !0,
                        this.isZooming() || (this._zooming = !0),
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout);
                        const n = X.mousePos(this._map.getCanvas(), e)
                          , s = this._tr;
                        this._aroundPoint = this._aroundCenter ? s.transform.locationToScreenPoint(o.S.convert(s.center)) : n,
                        this._frameId || (this._frameId = !0,
                        this._triggerRenderFrame())
                    }
                    renderFrame() {
                        if (!this._frameId || (this._frameId = null,
                        !this.isActive()))
                            return;
                        const e = this._tr.transform;
                        if (typeof this._lastExpectedZoom == "number") {
                            const y = e.zoom - this._lastExpectedZoom;
                            typeof this._startZoom == "number" && (this._startZoom += y),
                            typeof this._targetZoom == "number" && (this._targetZoom += y)
                        }
                        if (this._delta !== 0) {
                            const y = this._type === "wheel" && Math.abs(this._delta) > Tl ? this._wheelZoomRate : this._defaultZoomRate;
                            let w = 2 / (1 + Math.exp(-Math.abs(this._delta * y)));
                            this._delta < 0 && w !== 0 && (w = 1 / w);
                            const P = typeof this._targetZoom != "number" ? e.scale : o.af(this._targetZoom);
                            this._targetZoom = e.getConstrained(e.getCameraLngLat(), o.ak(P * w)).zoom,
                            this._type === "wheel" && (this._startZoom = e.zoom,
                            this._easing = this._smoothOutEasing(200)),
                            this._delta = 0
                        }
                        const n = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom
                          , s = this._startZoom
                          , u = this._easing;
                        let d, m = !1;
                        if (this._type === "wheel" && s && u) {
                            const y = ye.now() - this._lastWheelEventTime
                              , w = Math.min((y + 5) / 200, 1)
                              , P = u(w);
                            d = o.C.number(s, n, P),
                            w < 1 ? this._frameId || (this._frameId = !0) : m = !0
                        } else
                            d = n,
                            m = !0;
                        return this._active = !0,
                        m && (this._active = !1,
                        this._finishTimeout = setTimeout(( () => {
                            this._zooming = !1,
                            this._triggerRenderFrame(),
                            delete this._targetZoom,
                            delete this._lastExpectedZoom,
                            delete this._finishTimeout
                        }
                        ), 200)),
                        this._lastExpectedZoom = d,
                        {
                            noInertia: !0,
                            needsRenderFrame: !m,
                            zoomDelta: d - e.zoom,
                            around: this._aroundPoint,
                            originalEvent: this._lastWheelEvent
                        }
                    }
                    _smoothOutEasing(e) {
                        let n = o.co;
                        if (this._prevEase) {
                            const s = this._prevEase
                              , u = (ye.now() - s.start) / s.duration
                              , d = s.easing(u + .01) - s.easing(u)
                              , m = .27 / Math.sqrt(d * d + 1e-4) * .01
                              , y = Math.sqrt(.0729 - m * m);
                            n = o.cm(m, y, .25, 1)
                        }
                        return this._prevEase = {
                            start: ye.now(),
                            duration: e,
                            easing: n
                        },
                        n
                    }
                    reset() {
                        this._active = !1,
                        this._zooming = !1,
                        delete this._targetZoom,
                        delete this._lastExpectedZoom,
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout)
                    }
                }
                class $c {
                    constructor(e, n) {
                        this._clickZoom = e,
                        this._tapZoom = n
                    }
                    enable() {
                        this._clickZoom.enable(),
                        this._tapZoom.enable()
                    }
                    disable() {
                        this._clickZoom.disable(),
                        this._tapZoom.disable()
                    }
                    isEnabled() {
                        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                    }
                    isActive() {
                        return this._clickZoom.isActive() || this._tapZoom.isActive()
                    }
                }
                class Gc {
                    constructor(e) {
                        this._tr = new Vs(e),
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    dblclick(e, n) {
                        return e.preventDefault(),
                        {
                            cameraAnimation: s => {
                                s.easeTo({
                                    duration: 300,
                                    zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                                    around: this._tr.unproject(n)
                                }, {
                                    originalEvent: e
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Kh {
                    constructor() {
                        this._tap = new Xn({
                            numTouches: 1,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        delete this._swipePoint,
                        delete this._swipeTouch,
                        delete this._tapTime,
                        delete this._tapPoint,
                        this._tap.reset()
                    }
                    touchstart(e, n, s) {
                        if (!this._swipePoint)
                            if (this._tapTime) {
                                const u = n[0]
                                  , d = e.timeStamp - this._tapTime < 500
                                  , m = this._tapPoint.dist(u) < 30;
                                d && m ? s.length > 0 && (this._swipePoint = u,
                                this._swipeTouch = s[0].identifier) : this.reset()
                            } else
                                this._tap.touchstart(e, n, s)
                    }
                    touchmove(e, n, s) {
                        if (this._tapTime) {
                            if (this._swipePoint) {
                                if (s[0].identifier !== this._swipeTouch)
                                    return;
                                const u = n[0]
                                  , d = u.y - this._swipePoint.y;
                                return this._swipePoint = u,
                                e.preventDefault(),
                                this._active = !0,
                                {
                                    zoomDelta: d / 128
                                }
                            }
                        } else
                            this._tap.touchmove(e, n, s)
                    }
                    touchend(e, n, s) {
                        if (this._tapTime)
                            this._swipePoint && s.length === 0 && this.reset();
                        else {
                            const u = this._tap.touchend(e, n, s);
                            u && (this._tapTime = e.timeStamp,
                            this._tapPoint = u)
                        }
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Yh {
                    constructor(e, n, s) {
                        this._el = e,
                        this._mousePan = n,
                        this._touchPan = s
                    }
                    enable(e) {
                        this._inertiaOptions = e || {},
                        this._mousePan.enable(),
                        this._touchPan.enable(),
                        this._el.classList.add("maplibregl-touch-drag-pan")
                    }
                    disable() {
                        this._mousePan.disable(),
                        this._touchPan.disable(),
                        this._el.classList.remove("maplibregl-touch-drag-pan")
                    }
                    isEnabled() {
                        return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                    }
                    isActive() {
                        return this._mousePan.isActive() || this._touchPan.isActive()
                    }
                }
                class Hc {
                    constructor(e, n, s, u) {
                        this._pitchWithRotate = e.pitchWithRotate,
                        this._rollEnabled = e.rollEnabled,
                        this._mouseRotate = n,
                        this._mousePitch = s,
                        this._mouseRoll = u
                    }
                    enable() {
                        this._mouseRotate.enable(),
                        this._pitchWithRotate && this._mousePitch.enable(),
                        this._rollEnabled && this._mouseRoll.enable()
                    }
                    disable() {
                        this._mouseRotate.disable(),
                        this._mousePitch.disable(),
                        this._mouseRoll.disable()
                    }
                    isEnabled() {
                        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
                    }
                    isActive() {
                        return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
                    }
                }
                class Jh {
                    constructor(e, n, s, u) {
                        this._el = e,
                        this._touchZoom = n,
                        this._touchRotate = s,
                        this._tapDragZoom = u,
                        this._rotationDisabled = !1,
                        this._enabled = !0
                    }
                    enable(e) {
                        this._touchZoom.enable(e),
                        this._rotationDisabled || this._touchRotate.enable(e),
                        this._tapDragZoom.enable(),
                        this._el.classList.add("maplibregl-touch-zoom-rotate")
                    }
                    disable() {
                        this._touchZoom.disable(),
                        this._touchRotate.disable(),
                        this._tapDragZoom.disable(),
                        this._el.classList.remove("maplibregl-touch-zoom-rotate")
                    }
                    isEnabled() {
                        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                    }
                    isActive() {
                        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                    }
                    disableRotation() {
                        this._rotationDisabled = !0,
                        this._touchRotate.disable()
                    }
                    enableRotation() {
                        this._rotationDisabled = !1,
                        this._touchZoom.isEnabled() && this._touchRotate.enable()
                    }
                }
                class Qh {
                    constructor(e, n) {
                        this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey",
                        this._map = e,
                        this._options = n,
                        this._enabled = !1
                    }
                    isActive() {
                        return !1
                    }
                    reset() {}
                    _setupUI() {
                        if (this._container)
                            return;
                        const e = this._map.getCanvasContainer();
                        e.classList.add("maplibregl-cooperative-gestures"),
                        this._container = X.create("div", "maplibregl-cooperative-gesture-screen", e);
                        let n = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
                        this._bypassKey === "metaKey" && (n = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
                        const s = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText")
                          , u = document.createElement("div");
                        u.className = "maplibregl-desktop-message",
                        u.textContent = n,
                        this._container.appendChild(u);
                        const d = document.createElement("div");
                        d.className = "maplibregl-mobile-message",
                        d.textContent = s,
                        this._container.appendChild(d),
                        this._container.setAttribute("aria-hidden", "true")
                    }
                    _destroyUI() {
                        this._container && (X.remove(this._container),
                        this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")),
                        delete this._container
                    }
                    enable() {
                        this._setupUI(),
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this._destroyUI()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isBypassed(e) {
                        return e[this._bypassKey]
                    }
                    notifyGestureBlocked(e, n) {
                        this._enabled && (this._map.fire(new o.l("cooperativegestureprevented",{
                            gestureType: e,
                            originalEvent: n
                        })),
                        this._container.classList.add("maplibregl-show"),
                        setTimeout(( () => {
                            this._container.classList.remove("maplibregl-show")
                        }
                        ), 100))
                    }
                }
                const Ca = h => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
                class Oi extends o.l {
                }
                function Hs(h) {
                    return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta
                }
                class Wc {
                    constructor(e, n) {
                        this.handleWindowEvent = u => {
                            this.handleEvent(u, `${u.type}Window`)
                        }
                        ,
                        this.handleEvent = (u, d) => {
                            if (u.type === "blur")
                                return void this.stop(!0);
                            this._updatingCamera = !0;
                            const m = u.type === "renderFrame" ? void 0 : u
                              , y = {
                                needsRenderFrame: !1
                            }
                              , w = {}
                              , P = {};
                            for (const {handlerName: z, handler: B, allowed: U} of this._handlers) {
                                if (!B.isEnabled())
                                    continue;
                                let ee;
                                if (this._blockedByActive(P, U, z))
                                    B.reset();
                                else if (B[d || u.type]) {
                                    if (o.cp(u, d || u.type)) {
                                        const J = X.mousePos(this._map.getCanvas(), u);
                                        ee = B[d || u.type](u, J)
                                    } else if (o.cq(u, d || u.type)) {
                                        const J = this._getMapTouches(u.touches)
                                          , re = X.touchPos(this._map.getCanvas(), J);
                                        ee = B[d || u.type](u, re, J)
                                    } else
                                        o.cr(d || u.type) || (ee = B[d || u.type](u));
                                    this.mergeHandlerResult(y, w, ee, z, m),
                                    ee && ee.needsRenderFrame && this._triggerRenderFrame()
                                }
                                (ee || B.isActive()) && (P[z] = B)
                            }
                            const M = {};
                            for (const z in this._previousActiveHandlers)
                                P[z] || (M[z] = m);
                            this._previousActiveHandlers = P,
                            (Object.keys(M).length || Hs(y)) && (this._changes.push([y, w, M]),
                            this._triggerRenderFrame()),
                            (Object.keys(P).length || Hs(y)) && this._map._stop(!0),
                            this._updatingCamera = !1;
                            const {cameraAnimation: D} = y;
                            D && (this._inertia.clear(),
                            this._fireEvents({}, {}, !0),
                            this._changes = [],
                            D(this._map))
                        }
                        ,
                        this._map = e,
                        this._el = this._map.getCanvasContainer(),
                        this._handlers = [],
                        this._handlersById = {},
                        this._changes = [],
                        this._inertia = new $h(e),
                        this._bearingSnap = n.bearingSnap,
                        this._previousActiveHandlers = {},
                        this._eventsInProgress = {},
                        this._addDefaultHandlers(n);
                        const s = this._el;
                        this._listeners = [[s, "touchstart", {
                            passive: !0
                        }], [s, "touchmove", {
                            passive: !1
                        }], [s, "touchend", void 0], [s, "touchcancel", void 0], [s, "mousedown", void 0], [s, "mousemove", void 0], [s, "mouseup", void 0], [document, "mousemove", {
                            capture: !0
                        }], [document, "mouseup", void 0], [s, "mouseover", void 0], [s, "mouseout", void 0], [s, "dblclick", void 0], [s, "click", void 0], [s, "keydown", {
                            capture: !1
                        }], [s, "keyup", void 0], [s, "wheel", {
                            passive: !1
                        }], [s, "contextmenu", void 0], [window, "blur", void 0]];
                        for (const [u,d,m] of this._listeners)
                            X.addEventListener(u, d, u === document ? this.handleWindowEvent : this.handleEvent, m)
                    }
                    destroy() {
                        for (const [e,n,s] of this._listeners)
                            X.removeEventListener(e, n, e === document ? this.handleWindowEvent : this.handleEvent, s)
                    }
                    _addDefaultHandlers(e) {
                        const n = this._map
                          , s = n.getCanvasContainer();
                        this._add("mapEvent", new Gh(n,e));
                        const u = n.boxZoom = new Vc(n,e);
                        this._add("boxZoom", u),
                        e.interactive && e.boxZoom && u.enable();
                        const d = n.cooperativeGestures = new Qh(n,e.cooperativeGestures);
                        this._add("cooperativeGestures", d),
                        e.cooperativeGestures && d.enable();
                        const m = new ba(n)
                          , y = new Gc(n);
                        n.doubleClickZoom = new $c(y,m),
                        this._add("tapZoom", m),
                        this._add("clickZoom", y),
                        e.interactive && e.doubleClickZoom && n.doubleClickZoom.enable();
                        const w = new Kh;
                        this._add("tapDragZoom", w);
                        const P = n.touchPitch = new bl(n);
                        this._add("touchPitch", P),
                        e.interactive && e.touchPitch && n.touchPitch.enable(e.touchPitch);
                        const M = () => n.project(n.getCenter())
                          , D = (function({enable: ue, clickTolerance: ge, aroundCenter: Te=!0, minPixelCenterThreshold: he=100, rotateDegreesPerPixelMoved: De=.8}, He) {
                            const je = new ko({
                                checkCorrectEvent: qe => X.mouseButton(qe) === 0 && qe.ctrlKey || X.mouseButton(qe) === 2 && !qe.ctrlKey
                            });
                            return new Zs({
                                clickTolerance: ge,
                                move: (qe, $e) => {
                                    const Rt = He();
                                    if (Te && Math.abs(Rt.y - qe.y) > he)
                                        return {
                                            bearingDelta: o.cn(new o.P(qe.x,$e.y), $e, Rt)
                                        };
                                    let Nt = ($e.x - qe.x) * De;
                                    return Te && $e.y < Rt.y && (Nt = -Nt),
                                    {
                                        bearingDelta: Nt
                                    }
                                }
                                ,
                                moveStateManager: je,
                                enable: ue,
                                assignEvents: Eo
                            })
                        }
                        )(e, M)
                          , z = (function({enable: ue, clickTolerance: ge, pitchDegreesPerPixelMoved: Te=-.5}) {
                            const he = new ko({
                                checkCorrectEvent: De => X.mouseButton(De) === 0 && De.ctrlKey || X.mouseButton(De) === 2
                            });
                            return new Zs({
                                clickTolerance: ge,
                                move: (De, He) => ({
                                    pitchDelta: (He.y - De.y) * Te
                                }),
                                moveStateManager: he,
                                enable: ue,
                                assignEvents: Eo
                            })
                        }
                        )(e)
                          , B = (function({enable: ue, clickTolerance: ge, rollDegreesPerPixelMoved: Te=.3}, he) {
                            const De = new ko({
                                checkCorrectEvent: He => X.mouseButton(He) === 2 && He.ctrlKey
                            });
                            return new Zs({
                                clickTolerance: ge,
                                move: (He, je) => {
                                    const qe = he();
                                    let $e = (je.x - He.x) * Te;
                                    return je.y < qe.y && ($e = -$e),
                                    {
                                        rollDelta: $e
                                    }
                                }
                                ,
                                moveStateManager: De,
                                enable: ue,
                                assignEvents: Eo
                            })
                        }
                        )(e, M);
                        n.dragRotate = new Hc(e,D,z,B),
                        this._add("mouseRotate", D, ["mousePitch"]),
                        this._add("mousePitch", z, ["mouseRotate", "mouseRoll"]),
                        this._add("mouseRoll", B, ["mousePitch"]),
                        e.interactive && e.dragRotate && n.dragRotate.enable();
                        const U = (function({enable: ue, clickTolerance: ge}) {
                            const Te = new ko({
                                checkCorrectEvent: he => X.mouseButton(he) === 0 && !he.ctrlKey
                            });
                            return new Zs({
                                clickTolerance: ge,
                                move: (he, De) => ({
                                    around: De,
                                    panDelta: De.sub(he)
                                }),
                                activateOnStart: !0,
                                moveStateManager: Te,
                                enable: ue,
                                assignEvents: Eo
                            })
                        }
                        )(e)
                          , ee = new zo(e,n);
                        n.dragPan = new Yh(s,U,ee),
                        this._add("mousePan", U),
                        this._add("touchPan", ee, ["touchZoom", "touchRotate"]),
                        e.interactive && e.dragPan && n.dragPan.enable(e.dragPan);
                        const J = new Gs
                          , re = new xl;
                        n.touchZoomRotate = new Jh(s,re,J,w),
                        this._add("touchRotate", J, ["touchPan", "touchZoom"]),
                        this._add("touchZoom", re, ["touchPan", "touchRotate"]),
                        e.interactive && e.touchZoomRotate && n.touchZoomRotate.enable(e.touchZoomRotate);
                        const se = n.scrollZoom = new Xh(n,( () => this._triggerRenderFrame()));
                        this._add("scrollZoom", se, ["mousePan"]),
                        e.interactive && e.scrollZoom && n.scrollZoom.enable(e.scrollZoom);
                        const de = n.keyboard = new wl(n);
                        this._add("keyboard", de),
                        e.interactive && e.keyboard && n.keyboard.enable(),
                        this._add("blockableMapEvent", new Hh(n))
                    }
                    _add(e, n, s) {
                        this._handlers.push({
                            handlerName: e,
                            handler: n,
                            allowed: s
                        }),
                        this._handlersById[e] = n
                    }
                    stop(e) {
                        if (!this._updatingCamera) {
                            for (const {handler: n} of this._handlers)
                                n.reset();
                            this._inertia.clear(),
                            this._fireEvents({}, {}, e),
                            this._changes = []
                        }
                    }
                    isActive() {
                        for (const {handler: e} of this._handlers)
                            if (e.isActive())
                                return !0;
                        return !1
                    }
                    isZooming() {
                        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                    }
                    isRotating() {
                        return !!this._eventsInProgress.rotate
                    }
                    isMoving() {
                        return !!Ca(this._eventsInProgress) || this.isZooming()
                    }
                    _blockedByActive(e, n, s) {
                        for (const u in e)
                            if (u !== s && (!n || n.indexOf(u) < 0))
                                return !0;
                        return !1
                    }
                    _getMapTouches(e) {
                        const n = [];
                        for (const s of e)
                            this._el.contains(s.target) && n.push(s);
                        return n
                    }
                    mergeHandlerResult(e, n, s, u, d) {
                        if (!s)
                            return;
                        o.e(e, s);
                        const m = {
                            handlerName: u,
                            originalEvent: s.originalEvent || d
                        };
                        s.zoomDelta !== void 0 && (n.zoom = m),
                        s.panDelta !== void 0 && (n.drag = m),
                        s.rollDelta !== void 0 && (n.roll = m),
                        s.pitchDelta !== void 0 && (n.pitch = m),
                        s.bearingDelta !== void 0 && (n.rotate = m)
                    }
                    _applyChanges() {
                        const e = {}
                          , n = {}
                          , s = {};
                        for (const [u,d,m] of this._changes)
                            u.panDelta && (e.panDelta = (e.panDelta || new o.P(0,0))._add(u.panDelta)),
                            u.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + u.zoomDelta),
                            u.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + u.bearingDelta),
                            u.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + u.pitchDelta),
                            u.rollDelta && (e.rollDelta = (e.rollDelta || 0) + u.rollDelta),
                            u.around !== void 0 && (e.around = u.around),
                            u.pinchAround !== void 0 && (e.pinchAround = u.pinchAround),
                            u.noInertia && (e.noInertia = u.noInertia),
                            o.e(n, d),
                            o.e(s, m);
                        this._updateMapTransform(e, n, s),
                        this._changes = []
                    }
                    _updateMapTransform(e, n, s) {
                        const u = this._map
                          , d = u._getTransformForUpdate()
                          , m = u.terrain;
                        if (!(Hs(e) || m && this._terrainMovement))
                            return this._fireEvents(n, s, !0);
                        u._stop(!0);
                        let {panDelta: y, zoomDelta: w, bearingDelta: P, pitchDelta: M, rollDelta: D, around: z, pinchAround: B} = e;
                        B !== void 0 && (z = B),
                        z = z || u.transform.centerPoint,
                        m && !d.isPointOnMapSurface(z) && (z = d.centerPoint);
                        const U = {
                            panDelta: y,
                            zoomDelta: w,
                            rollDelta: D,
                            pitchDelta: M,
                            bearingDelta: P,
                            around: z
                        };
                        this._map.cameraHelper.useGlobeControls && !d.isPointOnMapSurface(z) && (z = d.centerPoint);
                        const ee = z.distSqr(d.centerPoint) < .01 ? d.center : d.screenPointToLocation(y ? z.sub(y) : z);
                        m ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(U, d),
                        this._terrainMovement || !n.drag && !n.zoom ? n.drag && this._terrainMovement ? d.setCenter(d.screenPointToLocation(d.centerPoint.sub(y))) : this._map.cameraHelper.handleMapControlsPan(U, d, ee) : (this._terrainMovement = !0,
                        this._map._elevationFreeze = !0,
                        this._map.cameraHelper.handleMapControlsPan(U, d, ee))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(U, d),
                        this._map.cameraHelper.handleMapControlsPan(U, d, ee)),
                        u._applyUpdatedTransform(d),
                        this._map._update(),
                        e.noInertia || this._inertia.record(e),
                        this._fireEvents(n, s, !0)
                    }
                    _fireEvents(e, n, s) {
                        const u = Ca(this._eventsInProgress)
                          , d = Ca(e)
                          , m = {};
                        for (const D in e) {
                            const {originalEvent: z} = e[D];
                            this._eventsInProgress[D] || (m[`${D}start`] = z),
                            this._eventsInProgress[D] = e[D]
                        }
                        !u && d && this._fireEvent("movestart", d.originalEvent);
                        for (const D in m)
                            this._fireEvent(D, m[D]);
                        d && this._fireEvent("move", d.originalEvent);
                        for (const D in e) {
                            const {originalEvent: z} = e[D];
                            this._fireEvent(D, z)
                        }
                        const y = {};
                        let w;
                        for (const D in this._eventsInProgress) {
                            const {handlerName: z, originalEvent: B} = this._eventsInProgress[D];
                            this._handlersById[z].isActive() || (delete this._eventsInProgress[D],
                            w = n[z] || B,
                            y[`${D}end`] = w)
                        }
                        for (const D in y)
                            this._fireEvent(D, y[D]);
                        const P = Ca(this._eventsInProgress)
                          , M = (u || d) && !P;
                        if (M && this._terrainMovement) {
                            this._map._elevationFreeze = !1,
                            this._terrainMovement = !1;
                            const D = this._map._getTransformForUpdate();
                            this._map.getCenterClampedToGround() && D.recalculateZoomAndCenter(this._map.terrain),
                            this._map._applyUpdatedTransform(D)
                        }
                        if (s && M) {
                            this._updatingCamera = !0;
                            const D = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)
                              , z = B => B !== 0 && -this._bearingSnap < B && B < this._bearingSnap;
                            !D || !D.essential && ye.prefersReducedMotion ? (this._map.fire(new o.l("moveend",{
                                originalEvent: w
                            })),
                            z(this._map.getBearing()) && this._map.resetNorth()) : (z(D.bearing || this._map.getBearing()) && (D.bearing = 0),
                            D.freezeElevation = !0,
                            this._map.easeTo(D, {
                                originalEvent: w
                            })),
                            this._updatingCamera = !1
                        }
                    }
                    _fireEvent(e, n) {
                        this._map.fire(new o.l(e,n ? {
                            originalEvent: n
                        } : {}))
                    }
                    _requestFrame() {
                        return this._map.triggerRepaint(),
                        this._map._renderTaskQueue.add((e => {
                            delete this._frameId,
                            this.handleEvent(new Oi("renderFrame",{
                                timeStamp: e
                            })),
                            this._applyChanges()
                        }
                        ))
                    }
                    _triggerRenderFrame() {
                        this._frameId === void 0 && (this._frameId = this._requestFrame())
                    }
                }
                class ed extends o.E {
                    constructor(e, n, s) {
                        super(),
                        this._renderFrameCallback = () => {
                            const u = Math.min((ye.now() - this._easeStart) / this._easeOptions.duration, 1);
                            this._onEaseFrame(this._easeOptions.easing(u)),
                            u < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                        }
                        ,
                        this._moving = !1,
                        this._zooming = !1,
                        this.transform = e,
                        this._bearingSnap = s.bearingSnap,
                        this.cameraHelper = n,
                        this.on("moveend", ( () => {
                            delete this._requestedCameraState
                        }
                        ))
                    }
                    migrateProjection(e, n) {
                        e.apply(this.transform),
                        this.transform = e,
                        this.cameraHelper = n
                    }
                    getCenter() {
                        return new o.S(this.transform.center.lng,this.transform.center.lat)
                    }
                    setCenter(e, n) {
                        return this.jumpTo({
                            center: e
                        }, n)
                    }
                    getCenterElevation() {
                        return this.transform.elevation
                    }
                    setCenterElevation(e, n) {
                        return this.jumpTo({
                            elevation: e
                        }, n),
                        this
                    }
                    getCenterClampedToGround() {
                        return this._centerClampedToGround
                    }
                    setCenterClampedToGround(e) {
                        this._centerClampedToGround = e
                    }
                    panBy(e, n, s) {
                        return e = o.P.convert(e).mult(-1),
                        this.panTo(this.transform.center, o.e({
                            offset: e
                        }, n), s)
                    }
                    panTo(e, n, s) {
                        return this.easeTo(o.e({
                            center: e
                        }, n), s)
                    }
                    getZoom() {
                        return this.transform.zoom
                    }
                    setZoom(e, n) {
                        return this.jumpTo({
                            zoom: e
                        }, n),
                        this
                    }
                    zoomTo(e, n, s) {
                        return this.easeTo(o.e({
                            zoom: e
                        }, n), s)
                    }
                    zoomIn(e, n) {
                        return this.zoomTo(this.getZoom() + 1, e, n),
                        this
                    }
                    zoomOut(e, n) {
                        return this.zoomTo(this.getZoom() - 1, e, n),
                        this
                    }
                    getVerticalFieldOfView() {
                        return this.transform.fov
                    }
                    setVerticalFieldOfView(e, n) {
                        return e != this.transform.fov && (this.transform.setFov(e),
                        this.fire(new o.l("movestart",n)).fire(new o.l("move",n)).fire(new o.l("moveend",n))),
                        this
                    }
                    getBearing() {
                        return this.transform.bearing
                    }
                    setBearing(e, n) {
                        return this.jumpTo({
                            bearing: e
                        }, n),
                        this
                    }
                    getPadding() {
                        return this.transform.padding
                    }
                    setPadding(e, n) {
                        return this.jumpTo({
                            padding: e
                        }, n),
                        this
                    }
                    rotateTo(e, n, s) {
                        return this.easeTo(o.e({
                            bearing: e
                        }, n), s)
                    }
                    resetNorth(e, n) {
                        return this.rotateTo(0, o.e({
                            duration: 1e3
                        }, e), n),
                        this
                    }
                    resetNorthPitch(e, n) {
                        return this.easeTo(o.e({
                            bearing: 0,
                            pitch: 0,
                            roll: 0,
                            duration: 1e3
                        }, e), n),
                        this
                    }
                    snapToNorth(e, n) {
                        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, n) : this
                    }
                    getPitch() {
                        return this.transform.pitch
                    }
                    setPitch(e, n) {
                        return this.jumpTo({
                            pitch: e
                        }, n),
                        this
                    }
                    getRoll() {
                        return this.transform.roll
                    }
                    setRoll(e, n) {
                        return this.jumpTo({
                            roll: e
                        }, n),
                        this
                    }
                    cameraForBounds(e, n) {
                        e = dt.convert(e).adjustAntiMeridian();
                        const s = n && n.bearing || 0;
                        return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), s, n)
                    }
                    _cameraForBoxAndBearing(e, n, s, u) {
                        const d = {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                        if (typeof (u = o.e({
                            padding: d,
                            offset: [0, 0],
                            maxZoom: this.transform.maxZoom
                        }, u)).padding == "number") {
                            const P = u.padding;
                            u.padding = {
                                top: P,
                                bottom: P,
                                right: P,
                                left: P
                            }
                        }
                        const m = o.e(d, u.padding);
                        u.padding = m;
                        const y = this.transform
                          , w = new dt(e,n);
                        return this.cameraHelper.cameraForBoxAndBearing(u, m, w, s, y)
                    }
                    fitBounds(e, n, s) {
                        return this._fitInternal(this.cameraForBounds(e, n), n, s)
                    }
                    fitScreenCoordinates(e, n, s, u, d) {
                        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(e)), this.transform.screenPointToLocation(o.P.convert(n)), s, u), u, d)
                    }
                    _fitInternal(e, n, s) {
                        return e ? (delete (n = o.e(e, n)).padding,
                        n.linear ? this.easeTo(n, s) : this.flyTo(n, s)) : this
                    }
                    jumpTo(e, n) {
                        this.stop();
                        const s = this._getTransformForUpdate();
                        let u = !1
                          , d = !1
                          , m = !1;
                        const y = s.zoom;
                        this.cameraHelper.handleJumpToCenterZoom(s, e);
                        const w = s.zoom !== y;
                        return "elevation"in e && s.elevation !== +e.elevation && s.setElevation(+e.elevation),
                        "bearing"in e && s.bearing !== +e.bearing && (u = !0,
                        s.setBearing(+e.bearing)),
                        "pitch"in e && s.pitch !== +e.pitch && (d = !0,
                        s.setPitch(+e.pitch)),
                        "roll"in e && s.roll !== +e.roll && (m = !0,
                        s.setRoll(+e.roll)),
                        e.padding == null || s.isPaddingEqual(e.padding) || s.setPadding(e.padding),
                        this._applyUpdatedTransform(s),
                        this.fire(new o.l("movestart",n)).fire(new o.l("move",n)),
                        w && this.fire(new o.l("zoomstart",n)).fire(new o.l("zoom",n)).fire(new o.l("zoomend",n)),
                        u && this.fire(new o.l("rotatestart",n)).fire(new o.l("rotate",n)).fire(new o.l("rotateend",n)),
                        d && this.fire(new o.l("pitchstart",n)).fire(new o.l("pitch",n)).fire(new o.l("pitchend",n)),
                        m && this.fire(new o.l("rollstart",n)).fire(new o.l("roll",n)).fire(new o.l("rollend",n)),
                        this.fire(new o.l("moveend",n))
                    }
                    calculateCameraOptionsFromTo(e, n, s, u=0) {
                        const d = o.a1.fromLngLat(e, n)
                          , m = o.a1.fromLngLat(s, u)
                          , y = m.x - d.x
                          , w = m.y - d.y
                          , P = m.z - d.z
                          , M = Math.hypot(y, w, P);
                        if (M === 0)
                            throw new Error("Can't calculate camera options with same From and To");
                        const D = Math.hypot(y, w)
                          , z = o.ak(this.transform.cameraToCenterDistance / M / this.transform.tileSize)
                          , B = 180 * Math.atan2(y, -w) / Math.PI;
                        let U = 180 * Math.acos(D / M) / Math.PI;
                        return U = P < 0 ? 90 - U : 90 + U,
                        {
                            center: m.toLngLat(),
                            elevation: u,
                            zoom: z,
                            pitch: U,
                            bearing: B
                        }
                    }
                    calculateCameraOptionsFromCameraLngLatAltRotation(e, n, s, u, d) {
                        const m = this.transform.calculateCenterFromCameraLngLatAlt(e, n, s, u);
                        return {
                            center: m.center,
                            elevation: m.elevation,
                            zoom: m.zoom,
                            bearing: s,
                            pitch: u,
                            roll: d
                        }
                    }
                    easeTo(e, n) {
                        this._stop(!1, e.easeId),
                        ((e = o.e({
                            offset: [0, 0],
                            duration: 500,
                            easing: o.co
                        }, e)).animate === !1 || !e.essential && ye.prefersReducedMotion) && (e.duration = 0);
                        const s = this._getTransformForUpdate()
                          , u = this.getBearing()
                          , d = s.pitch
                          , m = s.roll
                          , y = "bearing"in e ? this._normalizeBearing(e.bearing, u) : u
                          , w = "pitch"in e ? +e.pitch : d
                          , P = "roll"in e ? this._normalizeBearing(e.roll, m) : m
                          , M = "padding"in e ? e.padding : s.padding
                          , D = o.P.convert(e.offset);
                        let z, B;
                        e.around && (z = o.S.convert(e.around),
                        B = s.locationToScreenPoint(z));
                        const U = {
                            moving: this._moving,
                            zooming: this._zooming,
                            rotating: this._rotating,
                            pitching: this._pitching,
                            rolling: this._rolling
                        }
                          , ee = this.cameraHelper.handleEaseTo(s, {
                            bearing: y,
                            pitch: w,
                            roll: P,
                            padding: M,
                            around: z,
                            aroundPoint: B,
                            offsetAsPoint: D,
                            offset: e.offset,
                            zoom: e.zoom,
                            center: e.center
                        });
                        return this._rotating = this._rotating || u !== y,
                        this._pitching = this._pitching || w !== d,
                        this._rolling = this._rolling || P !== m,
                        this._padding = !s.isPaddingEqual(M),
                        this._zooming = this._zooming || ee.isZooming,
                        this._easeId = e.easeId,
                        this._prepareEase(n, e.noMoveStart, U),
                        this.terrain && this._prepareElevation(ee.elevationCenter),
                        this._ease((J => {
                            ee.easeFunc(J),
                            this.terrain && !e.freezeElevation && this._updateElevation(J),
                            this._applyUpdatedTransform(s),
                            this._fireMoveEvents(n)
                        }
                        ), (J => {
                            this.terrain && e.freezeElevation && this._finalizeElevation(),
                            this._afterEase(n, J)
                        }
                        ), e),
                        this
                    }
                    _prepareEase(e, n, s={}) {
                        this._moving = !0,
                        n || s.moving || this.fire(new o.l("movestart",e)),
                        this._zooming && !s.zooming && this.fire(new o.l("zoomstart",e)),
                        this._rotating && !s.rotating && this.fire(new o.l("rotatestart",e)),
                        this._pitching && !s.pitching && this.fire(new o.l("pitchstart",e)),
                        this._rolling && !s.rolling && this.fire(new o.l("rollstart",e))
                    }
                    _prepareElevation(e) {
                        this._elevationCenter = e,
                        this._elevationStart = this.transform.elevation,
                        this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom),
                        this._elevationFreeze = !0
                    }
                    _updateElevation(e) {
                        this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
                        const n = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
                        if (e < 1 && n !== this._elevationTarget) {
                            const s = this._elevationTarget - this._elevationStart;
                            this._elevationStart += e * (s - (n - (s * e + this._elevationStart)) / (1 - e)),
                            this._elevationTarget = n
                        }
                        this.transform.setElevation(o.C.number(this._elevationStart, this._elevationTarget, e))
                    }
                    _finalizeElevation() {
                        this._elevationFreeze = !1,
                        this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
                    }
                    _getTransformForUpdate() {
                        return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()),
                        this._requestedCameraState) : this.transform
                    }
                    _elevateCameraIfInsideTerrain(e) {
                        if (!this.terrain && e.elevation >= 0 && e.pitch <= 90)
                            return {};
                        const n = e.getCameraLngLat()
                          , s = e.getCameraAltitude()
                          , u = this.terrain ? this.terrain.getElevationForLngLatZoom(n, e.zoom) : 0;
                        if (s < u) {
                            const d = this.calculateCameraOptionsFromTo(n, u, e.center, e.elevation);
                            return {
                                pitch: d.pitch,
                                zoom: d.zoom
                            }
                        }
                        return {}
                    }
                    _applyUpdatedTransform(e) {
                        const n = [];
                        if (n.push((u => this._elevateCameraIfInsideTerrain(u))),
                        this.transformCameraUpdate && n.push((u => this.transformCameraUpdate(u))),
                        !n.length)
                            return;
                        const s = e.clone();
                        for (const u of n) {
                            const d = s.clone()
                              , {center: m, zoom: y, roll: w, pitch: P, bearing: M, elevation: D} = u(d);
                            m && d.setCenter(m),
                            D !== void 0 && d.setElevation(D),
                            y !== void 0 && d.setZoom(y),
                            w !== void 0 && d.setRoll(w),
                            P !== void 0 && d.setPitch(P),
                            M !== void 0 && d.setBearing(M),
                            s.apply(d)
                        }
                        this.transform.apply(s)
                    }
                    _fireMoveEvents(e) {
                        this.fire(new o.l("move",e)),
                        this._zooming && this.fire(new o.l("zoom",e)),
                        this._rotating && this.fire(new o.l("rotate",e)),
                        this._pitching && this.fire(new o.l("pitch",e)),
                        this._rolling && this.fire(new o.l("roll",e))
                    }
                    _afterEase(e, n) {
                        if (this._easeId && n && this._easeId === n)
                            return;
                        delete this._easeId;
                        const s = this._zooming
                          , u = this._rotating
                          , d = this._pitching
                          , m = this._rolling;
                        this._moving = !1,
                        this._zooming = !1,
                        this._rotating = !1,
                        this._pitching = !1,
                        this._rolling = !1,
                        this._padding = !1,
                        s && this.fire(new o.l("zoomend",e)),
                        u && this.fire(new o.l("rotateend",e)),
                        d && this.fire(new o.l("pitchend",e)),
                        m && this.fire(new o.l("rollend",e)),
                        this.fire(new o.l("moveend",e))
                    }
                    flyTo(e, n) {
                        if (!e.essential && ye.prefersReducedMotion) {
                            const $e = o.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
                            return this.jumpTo($e, n)
                        }
                        this.stop(),
                        e = o.e({
                            offset: [0, 0],
                            speed: 1.2,
                            curve: 1.42,
                            easing: o.co
                        }, e);
                        const s = this._getTransformForUpdate()
                          , u = s.bearing
                          , d = s.pitch
                          , m = s.roll
                          , y = s.padding
                          , w = "bearing"in e ? this._normalizeBearing(e.bearing, u) : u
                          , P = "pitch"in e ? +e.pitch : d
                          , M = "roll"in e ? this._normalizeBearing(e.roll, m) : m
                          , D = "padding"in e ? e.padding : s.padding
                          , z = o.P.convert(e.offset);
                        let B = s.centerPoint.add(z);
                        const U = s.screenPointToLocation(B)
                          , ee = this.cameraHelper.handleFlyTo(s, {
                            bearing: w,
                            pitch: P,
                            roll: M,
                            padding: D,
                            locationAtOffset: U,
                            offsetAsPoint: z,
                            center: e.center,
                            minZoom: e.minZoom,
                            zoom: e.zoom
                        });
                        let J = e.curve;
                        const re = Math.max(s.width, s.height)
                          , se = re / ee.scaleOfZoom
                          , de = ee.pixelPathLength;
                        typeof ee.scaleOfMinZoom == "number" && (J = Math.sqrt(re / ee.scaleOfMinZoom / de * 2));
                        const ue = J * J;
                        function ge($e) {
                            const Rt = (se * se - re * re + ($e ? -1 : 1) * ue * ue * de * de) / (2 * ($e ? se : re) * ue * de);
                            return Math.log(Math.sqrt(Rt * Rt + 1) - Rt)
                        }
                        function Te($e) {
                            return (Math.exp($e) - Math.exp(-$e)) / 2
                        }
                        function he($e) {
                            return (Math.exp($e) + Math.exp(-$e)) / 2
                        }
                        const De = ge(!1);
                        let He = function($e) {
                            return he(De) / he(De + J * $e)
                        }
                          , je = function($e) {
                            return re * ((he(De) * (Te(Rt = De + J * $e) / he(Rt)) - Te(De)) / ue) / de;
                            var Rt
                        }
                          , qe = (ge(!0) - De) / J;
                        if (Math.abs(de) < 2e-6 || !isFinite(qe)) {
                            if (Math.abs(re - se) < 1e-6)
                                return this.easeTo(e, n);
                            const $e = se < re ? -1 : 1;
                            qe = Math.abs(Math.log(se / re)) / J,
                            je = () => 0,
                            He = Rt => Math.exp($e * J * Rt)
                        }
                        return e.duration = "duration"in e ? +e.duration : 1e3 * qe / ("screenSpeed"in e ? +e.screenSpeed / J : +e.speed),
                        e.maxDuration && e.duration > e.maxDuration && (e.duration = 0),
                        this._zooming = !0,
                        this._rotating = u !== w,
                        this._pitching = P !== d,
                        this._rolling = M !== m,
                        this._padding = !s.isPaddingEqual(D),
                        this._prepareEase(n, !1),
                        this.terrain && this._prepareElevation(ee.targetCenter),
                        this._ease(($e => {
                            const Rt = $e * qe
                              , Nt = 1 / He(Rt)
                              , yt = je(Rt);
                            this._rotating && s.setBearing(o.C.number(u, w, $e)),
                            this._pitching && s.setPitch(o.C.number(d, P, $e)),
                            this._rolling && s.setRoll(o.C.number(m, M, $e)),
                            this._padding && (s.interpolatePadding(y, D, $e),
                            B = s.centerPoint.add(z)),
                            ee.easeFunc($e, Nt, yt, B),
                            this.terrain && !e.freezeElevation && this._updateElevation($e),
                            this._applyUpdatedTransform(s),
                            this._fireMoveEvents(n)
                        }
                        ), ( () => {
                            this.terrain && e.freezeElevation && this._finalizeElevation(),
                            this._afterEase(n)
                        }
                        ), e),
                        this
                    }
                    isEasing() {
                        return !!this._easeFrameId
                    }
                    stop() {
                        return this._stop()
                    }
                    _stop(e, n) {
                        var s;
                        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId),
                        delete this._easeFrameId,
                        delete this._onEaseFrame),
                        this._onEaseEnd) {
                            const u = this._onEaseEnd;
                            delete this._onEaseEnd,
                            u.call(this, n)
                        }
                        return e || (s = this.handlers) === null || s === void 0 || s.stop(!1),
                        this
                    }
                    _ease(e, n, s) {
                        s.animate === !1 || s.duration === 0 ? (e(1),
                        n()) : (this._easeStart = ye.now(),
                        this._easeOptions = s,
                        this._onEaseFrame = e,
                        this._onEaseEnd = n,
                        this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                    }
                    _normalizeBearing(e, n) {
                        e = o.aO(e, -180, 180);
                        const s = Math.abs(e - n);
                        return Math.abs(e - 360 - n) < s && (e -= 360),
                        Math.abs(e + 360 - n) < s && (e += 360),
                        e
                    }
                    queryTerrainElevation(e) {
                        return this.terrain ? this.terrain.getElevationForLngLatZoom(o.S.convert(e), this.transform.tileZoom) : null
                    }
                }
                const Xc = {
                    compact: !0,
                    customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
                };
                class Kc {
                    constructor(e=Xc) {
                        this._toggleAttribution = () => {
                            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""),
                            this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"),
                            this._container.removeAttribute("open")))
                        }
                        ,
                        this._updateData = n => {
                            !n || n.sourceDataType !== "metadata" && n.sourceDataType !== "visibility" && n.dataType !== "style" && n.type !== "terrain" || this._updateAttributions()
                        }
                        ,
                        this._updateCompact = () => {
                            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""),
                            this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""),
                            this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
                        }
                        ,
                        this._updateCompactMinimize = () => {
                            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
                        }
                        ,
                        this.options = e
                    }
                    getDefaultPosition() {
                        return "bottom-right"
                    }
                    onAdd(e) {
                        return this._map = e,
                        this._compact = this.options.compact,
                        this._container = X.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"),
                        this._compactButton = X.create("summary", "maplibregl-ctrl-attrib-button", this._container),
                        this._compactButton.addEventListener("click", this._toggleAttribution),
                        this._setElementTitle(this._compactButton, "ToggleAttribution"),
                        this._innerContainer = X.create("div", "maplibregl-ctrl-attrib-inner", this._container),
                        this._updateAttributions(),
                        this._updateCompact(),
                        this._map.on("styledata", this._updateData),
                        this._map.on("sourcedata", this._updateData),
                        this._map.on("terrain", this._updateData),
                        this._map.on("resize", this._updateCompact),
                        this._map.on("drag", this._updateCompactMinimize),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("styledata", this._updateData),
                        this._map.off("sourcedata", this._updateData),
                        this._map.off("terrain", this._updateData),
                        this._map.off("resize", this._updateCompact),
                        this._map.off("drag", this._updateCompactMinimize),
                        this._map = void 0,
                        this._compact = void 0,
                        this._attribHTML = void 0
                    }
                    _setElementTitle(e, n) {
                        const s = this._map._getUIString(`AttributionControl.${n}`);
                        e.title = s,
                        e.setAttribute("aria-label", s)
                    }
                    _updateAttributions() {
                        if (!this._map.style)
                            return;
                        let e = [];
                        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((u => typeof u != "string" ? "" : u))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)),
                        this._map.style.stylesheet) {
                            const u = this._map.style.stylesheet;
                            this.styleOwner = u.owner,
                            this.styleId = u.id
                        }
                        const n = this._map.style.sourceCaches;
                        for (const u in n) {
                            const d = n[u];
                            if (d.used || d.usedForTerrain) {
                                const m = d.getSource();
                                m.attribution && e.indexOf(m.attribution) < 0 && e.push(m.attribution)
                            }
                        }
                        e = e.filter((u => String(u).trim())),
                        e.sort(( (u, d) => u.length - d.length)),
                        e = e.filter(( (u, d) => {
                            for (let m = d + 1; m < e.length; m++)
                                if (e[m].indexOf(u) >= 0)
                                    return !1;
                            return !0
                        }
                        ));
                        const s = e.join(" | ");
                        s !== this._attribHTML && (this._attribHTML = s,
                        e.length ? (this._innerContainer.innerHTML = X.sanitize(s),
                        this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"),
                        this._updateCompact(),
                        this._editLink = null)
                    }
                }
                class td {
                    constructor(e={}) {
                        this._updateCompact = () => {
                            const n = this._container.children;
                            if (n.length) {
                                const s = n[0];
                                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && s.classList.add("maplibregl-compact") : s.classList.remove("maplibregl-compact")
                            }
                        }
                        ,
                        this.options = e
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    onAdd(e) {
                        this._map = e,
                        this._compact = this.options && this.options.compact,
                        this._container = X.create("div", "maplibregl-ctrl");
                        const n = X.create("a", "maplibregl-ctrl-logo");
                        return n.target = "_blank",
                        n.rel = "noopener nofollow",
                        n.href = "https://maplibre.org/",
                        n.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")),
                        n.setAttribute("rel", "noopener nofollow"),
                        this._container.appendChild(n),
                        this._container.style.display = "block",
                        this._map.on("resize", this._updateCompact),
                        this._updateCompact(),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("resize", this._updateCompact),
                        this._map = void 0,
                        this._compact = void 0
                    }
                }
                class Na {
                    constructor() {
                        this._queue = [],
                        this._id = 0,
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    add(e) {
                        const n = ++this._id;
                        return this._queue.push({
                            callback: e,
                            id: n,
                            cancelled: !1
                        }),
                        n
                    }
                    remove(e) {
                        const n = this._currentlyRunning
                          , s = n ? this._queue.concat(n) : this._queue;
                        for (const u of s)
                            if (u.id === e)
                                return void (u.cancelled = !0)
                    }
                    run(e=0) {
                        if (this._currentlyRunning)
                            throw new Error("Attempting to run(), but is already running.");
                        const n = this._currentlyRunning = this._queue;
                        this._queue = [];
                        for (const s of n)
                            if (!s.cancelled && (s.callback(e),
                            this._cleared))
                                break;
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    clear() {
                        this._currentlyRunning && (this._cleared = !0),
                        this._queue = []
                    }
                }
                var Cl = o.aJ([{
                    name: "a_pos3d",
                    type: "Int16",
                    components: 3
                }]);
                class hr extends o.E {
                    constructor(e) {
                        super(),
                        this._lastTilesetChange = ye.now(),
                        this.sourceCache = e,
                        this._tiles = {},
                        this._renderableTilesKeys = [],
                        this._sourceTileCache = {},
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.deltaZoom = 1,
                        this.tileSize = e._source.tileSize * 2 ** this.deltaZoom,
                        e.usedForTerrain = !0,
                        e.tileSize = this.tileSize
                    }
                    destruct() {
                        this.sourceCache.usedForTerrain = !1,
                        this.sourceCache.tileSize = null
                    }
                    update(e, n) {
                        this.sourceCache.update(e, n),
                        this._renderableTilesKeys = [];
                        const s = {};
                        for (const u of xe(e, {
                            tileSize: this.tileSize,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            reparseOverscaled: !1,
                            terrain: n,
                            calculateTileZoom: this.sourceCache._source.calculateTileZoom
                        }))
                            s[u.key] = !0,
                            this._renderableTilesKeys.push(u.key),
                            this._tiles[u.key] || (u.terrainRttPosMatrix32f = new Float64Array(16),
                            o.bY(u.terrainRttPosMatrix32f, 0, o.$, o.$, 0, 0, 1),
                            this._tiles[u.key] = new Nr(u,this.tileSize),
                            this._lastTilesetChange = ye.now());
                        for (const u in this._tiles)
                            s[u] || delete this._tiles[u]
                    }
                    freeRtt(e) {
                        for (const n in this._tiles) {
                            const s = this._tiles[n];
                            (!e || s.tileID.equals(e) || s.tileID.isChildOf(e) || e.isChildOf(s.tileID)) && (s.rtt = [])
                        }
                    }
                    getRenderableTiles() {
                        return this._renderableTilesKeys.map((e => this.getTileByID(e)))
                    }
                    getTileByID(e) {
                        return this._tiles[e]
                    }
                    getTerrainCoords(e, n) {
                        return n ? this._getTerrainCoordsForTileRanges(e, n) : this._getTerrainCoordsForRegularTile(e)
                    }
                    _getTerrainCoordsForRegularTile(e) {
                        const n = {};
                        for (const s of this._renderableTilesKeys) {
                            const u = this._tiles[s].tileID
                              , d = e.clone()
                              , m = o.ba();
                            if (u.canonical.equals(e.canonical))
                                o.bY(m, 0, o.$, o.$, 0, 0, 1);
                            else if (u.canonical.isChildOf(e.canonical)) {
                                const y = u.canonical.z - e.canonical.z
                                  , w = u.canonical.x - (u.canonical.x >> y << y)
                                  , P = u.canonical.y - (u.canonical.y >> y << y)
                                  , M = o.$ >> y;
                                o.bY(m, 0, M, M, 0, 0, 1),
                                o.M(m, m, [-w * M, -P * M, 0])
                            } else {
                                if (!e.canonical.isChildOf(u.canonical))
                                    continue;
                                {
                                    const y = e.canonical.z - u.canonical.z
                                      , w = e.canonical.x - (e.canonical.x >> y << y)
                                      , P = e.canonical.y - (e.canonical.y >> y << y)
                                      , M = o.$ >> y;
                                    o.bY(m, 0, o.$, o.$, 0, 0, 1),
                                    o.M(m, m, [w * M, P * M, 0]),
                                    o.N(m, m, [1 / 2 ** y, 1 / 2 ** y, 0])
                                }
                            }
                            d.terrainRttPosMatrix32f = new Float32Array(m),
                            n[s] = d
                        }
                        return n
                    }
                    _getTerrainCoordsForTileRanges(e, n) {
                        const s = {};
                        for (const u of this._renderableTilesKeys) {
                            const d = this._tiles[u].tileID;
                            if (!this._isWithinTileRanges(d, n))
                                continue;
                            const m = e.clone()
                              , y = o.ba();
                            if (d.canonical.z === e.canonical.z) {
                                const w = e.canonical.x - d.canonical.x
                                  , P = e.canonical.y - d.canonical.y;
                                o.bY(y, 0, o.$, o.$, 0, 0, 1),
                                o.M(y, y, [w * o.$, P * o.$, 0])
                            } else if (d.canonical.z > e.canonical.z) {
                                const w = d.canonical.z - e.canonical.z
                                  , P = d.canonical.x - (d.canonical.x >> w << w)
                                  , M = d.canonical.y - (d.canonical.y >> w << w)
                                  , D = e.canonical.x - (d.canonical.x >> w)
                                  , z = e.canonical.y - (d.canonical.y >> w)
                                  , B = o.$ >> w;
                                o.bY(y, 0, B, B, 0, 0, 1),
                                o.M(y, y, [-P * B + D * o.$, -M * B + z * o.$, 0])
                            } else {
                                const w = e.canonical.z - d.canonical.z
                                  , P = e.canonical.x - (e.canonical.x >> w << w)
                                  , M = e.canonical.y - (e.canonical.y >> w << w)
                                  , D = (e.canonical.x >> w) - d.canonical.x
                                  , z = (e.canonical.y >> w) - d.canonical.y
                                  , B = o.$ << w;
                                o.bY(y, 0, B, B, 0, 0, 1),
                                o.M(y, y, [P * o.$ + D * B, M * o.$ + z * B, 0])
                            }
                            m.terrainRttPosMatrix32f = new Float32Array(y),
                            s[u] = m
                        }
                        return s
                    }
                    getSourceTile(e, n) {
                        const s = this.sourceCache._source;
                        let u = e.overscaledZ - this.deltaZoom;
                        if (u > s.maxzoom && (u = s.maxzoom),
                        u < s.minzoom)
                            return null;
                        this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(u).key);
                        let d = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
                        if ((!d || !d.dem) && n)
                            for (; u >= s.minzoom && (!d || !d.dem); )
                                d = this.sourceCache.getTileByID(e.scaledTo(u--).key);
                        return d
                    }
                    anyTilesAfterTime(e=Date.now()) {
                        return this._lastTilesetChange >= e
                    }
                    _isWithinTileRanges(e, n) {
                        return n[e.canonical.z] && e.canonical.x >= n[e.canonical.z].minTileX && e.canonical.x <= n[e.canonical.z].maxTileX && e.canonical.y >= n[e.canonical.z].minTileY && e.canonical.y <= n[e.canonical.z].maxTileY
                    }
                }
                class Rr {
                    constructor(e, n, s) {
                        this._meshCache = {},
                        this.painter = e,
                        this.sourceCache = new hr(n),
                        this.options = s,
                        this.exaggeration = typeof s.exaggeration == "number" ? s.exaggeration : 1,
                        this.qualityFactor = 2,
                        this.meshSize = 128,
                        this._demMatrixCache = {},
                        this.coordsIndex = [],
                        this._coordsTextureSize = 1024
                    }
                    getDEMElevation(e, n, s, u=o.$) {
                        var d;
                        if (!(n >= 0 && n < u && s >= 0 && s < u))
                            return 0;
                        const m = this.getTerrainData(e)
                          , y = (d = m.tile) === null || d === void 0 ? void 0 : d.dem;
                        if (!y)
                            return 0;
                        const w = o.cs([], [n / u * o.$, s / u * o.$], m.u_terrain_matrix)
                          , P = [w[0] * y.dim, w[1] * y.dim]
                          , M = Math.floor(P[0])
                          , D = Math.floor(P[1])
                          , z = P[0] - M
                          , B = P[1] - D;
                        return y.get(M, D) * (1 - z) * (1 - B) + y.get(M + 1, D) * z * (1 - B) + y.get(M, D + 1) * (1 - z) * B + y.get(M + 1, D + 1) * z * B
                    }
                    getElevationForLngLatZoom(e, n) {
                        if (!o.ct(n, e.wrap()))
                            return 0;
                        const {tileID: s, mercatorX: u, mercatorY: d} = this._getOverscaledTileIDFromLngLatZoom(e, n);
                        return this.getElevation(s, u % o.$, d % o.$, o.$)
                    }
                    getElevation(e, n, s, u=o.$) {
                        return this.getDEMElevation(e, n, s, u) * this.exaggeration
                    }
                    getTerrainData(e) {
                        if (!this._emptyDemTexture) {
                            const u = this.painter.context
                              , d = new o.R({
                                width: 1,
                                height: 1
                            },new Uint8Array(4));
                            this._emptyDepthTexture = new o.T(u,d,u.gl.RGBA,{
                                premultiply: !1
                            }),
                            this._emptyDemUnpack = [0, 0, 0, 0],
                            this._emptyDemTexture = new o.T(u,new o.R({
                                width: 1,
                                height: 1
                            }),u.gl.RGBA,{
                                premultiply: !1
                            }),
                            this._emptyDemTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE),
                            this._emptyDemMatrix = o.ag([])
                        }
                        const n = this.sourceCache.getSourceTile(e, !0);
                        if (n && n.dem && (!n.demTexture || n.needsTerrainPrepare)) {
                            const u = this.painter.context;
                            n.demTexture = this.painter.getTileTexture(n.dem.stride),
                            n.demTexture ? n.demTexture.update(n.dem.getPixels(), {
                                premultiply: !1
                            }) : n.demTexture = new o.T(u,n.dem.getPixels(),u.gl.RGBA,{
                                premultiply: !1
                            }),
                            n.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE),
                            n.needsTerrainPrepare = !1
                        }
                        const s = n && n + n.tileID.key + e.key;
                        if (s && !this._demMatrixCache[s]) {
                            const u = this.sourceCache.sourceCache._source.maxzoom;
                            let d = e.canonical.z - n.tileID.canonical.z;
                            e.overscaledZ > e.canonical.z && (e.canonical.z >= u ? d = e.canonical.z - u : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                            const m = e.canonical.x - (e.canonical.x >> d << d)
                              , y = e.canonical.y - (e.canonical.y >> d << d)
                              , w = o.cu(new Float64Array(16), [1 / (o.$ << d), 1 / (o.$ << d), 0]);
                            o.M(w, w, [m * o.$, y * o.$, 0]),
                            this._demMatrixCache[e.key] = {
                                matrix: w,
                                coord: e
                            }
                        }
                        return {
                            u_depth: 2,
                            u_terrain: 3,
                            u_terrain_dim: n && n.dem && n.dem.dim || 1,
                            u_terrain_matrix: s ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
                            u_terrain_unpack: n && n.dem && n.dem.getUnpackVector() || this._emptyDemUnpack,
                            u_terrain_exaggeration: this.exaggeration,
                            texture: (n && n.demTexture || this._emptyDemTexture).texture,
                            depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
                            tile: n
                        }
                    }
                    getFramebuffer(e) {
                        const n = this.painter
                          , s = n.width / devicePixelRatio
                          , u = n.height / devicePixelRatio;
                        return !this._fbo || this._fbo.width === s && this._fbo.height === u || (this._fbo.destroy(),
                        this._fboCoordsTexture.destroy(),
                        this._fboDepthTexture.destroy(),
                        delete this._fbo,
                        delete this._fboDepthTexture,
                        delete this._fboCoordsTexture),
                        this._fboCoordsTexture || (this._fboCoordsTexture = new o.T(n.context,{
                            width: s,
                            height: u,
                            data: null
                        },n.context.gl.RGBA,{
                            premultiply: !1
                        }),
                        this._fboCoordsTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)),
                        this._fboDepthTexture || (this._fboDepthTexture = new o.T(n.context,{
                            width: s,
                            height: u,
                            data: null
                        },n.context.gl.RGBA,{
                            premultiply: !1
                        }),
                        this._fboDepthTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)),
                        this._fbo || (this._fbo = n.context.createFramebuffer(s, u, !0, !1),
                        this._fbo.depthAttachment.set(n.context.createRenderbuffer(n.context.gl.DEPTH_COMPONENT16, s, u))),
                        this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture),
                        this._fbo
                    }
                    getCoordsTexture() {
                        const e = this.painter.context;
                        if (this._coordsTexture)
                            return this._coordsTexture;
                        const n = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
                        for (let d = 0, m = 0; d < this._coordsTextureSize; d++)
                            for (let y = 0; y < this._coordsTextureSize; y++,
                            m += 4)
                                n[m + 0] = 255 & y,
                                n[m + 1] = 255 & d,
                                n[m + 2] = y >> 8 << 4 | d >> 8,
                                n[m + 3] = 0;
                        const s = new o.R({
                            width: this._coordsTextureSize,
                            height: this._coordsTextureSize
                        },new Uint8Array(n.buffer))
                          , u = new o.T(e,s,e.gl.RGBA,{
                            premultiply: !1
                        });
                        return u.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE),
                        this._coordsTexture = u,
                        u
                    }
                    pointCoordinate(e) {
                        this.painter.maybeDrawDepthAndCoords(!0);
                        const n = new Uint8Array(4)
                          , s = this.painter.context
                          , u = s.gl
                          , d = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio)
                          , m = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio)
                          , y = Math.round(this.painter.height / devicePixelRatio);
                        s.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer),
                        u.readPixels(d, y - m - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, n),
                        s.bindFramebuffer.set(null);
                        const w = n[0] + (n[2] >> 4 << 8)
                          , P = n[1] + ((15 & n[2]) << 8)
                          , M = this.coordsIndex[255 - n[3]]
                          , D = M && this.sourceCache.getTileByID(M);
                        if (!D)
                            return null;
                        const z = this._coordsTextureSize
                          , B = (1 << D.tileID.canonical.z) * z;
                        return new o.a1((D.tileID.canonical.x * z + w) / B + D.tileID.wrap,(D.tileID.canonical.y * z + P) / B,this.getElevation(D.tileID, w, P, z))
                    }
                    depthAtPoint(e) {
                        const n = new Uint8Array(4)
                          , s = this.painter.context
                          , u = s.gl;
                        return s.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer),
                        u.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, n),
                        s.bindFramebuffer.set(null),
                        (n[0] / 16777216 + n[1] / 65536 + n[2] / 256 + n[3]) / 256
                    }
                    getTerrainMesh(e) {
                        var n;
                        const s = ((n = this.painter.style.projection) === null || n === void 0 ? void 0 : n.transitionState) > 0
                          , u = s && e.canonical.y === 0
                          , d = s && e.canonical.y === (1 << e.canonical.z) - 1
                          , m = `m_${u ? "n" : ""}_${d ? "s" : ""}`;
                        if (this._meshCache[m])
                            return this._meshCache[m];
                        const y = this.painter.context
                          , w = new o.cv
                          , P = new o.aN
                          , M = this.meshSize
                          , D = o.$ / M
                          , z = M * M;
                        for (let he = 0; he <= M; he++)
                            for (let De = 0; De <= M; De++)
                                w.emplaceBack(De * D, he * D, 0);
                        for (let he = 0; he < z; he += M + 1)
                            for (let De = 0; De < M; De++)
                                P.emplaceBack(De + he, M + De + he + 1, M + De + he + 2),
                                P.emplaceBack(De + he, M + De + he + 2, De + he + 1);
                        const B = w.length
                          , U = B + (M + 1)
                          , ee = (M + 1) * M
                          , J = u ? o.bh : 0
                          , re = u ? 0 : 1
                          , se = d ? o.bi : o.$
                          , de = d ? 0 : 1;
                        for (let he = 0; he <= M; he++)
                            w.emplaceBack(he * D, J, re);
                        for (let he = 0; he <= M; he++)
                            w.emplaceBack(he * D, se, de);
                        for (let he = 0; he < M; he++)
                            P.emplaceBack(ee + he, U + he, U + he + 1),
                            P.emplaceBack(ee + he, U + he + 1, ee + he + 1),
                            P.emplaceBack(0 + he, B + he + 1, B + he),
                            P.emplaceBack(0 + he, 0 + he + 1, B + he + 1);
                        const ue = w.length
                          , ge = ue + 2 * (M + 1);
                        for (const he of [0, 1])
                            for (let De = 0; De <= M; De++)
                                for (const He of [0, 1])
                                    w.emplaceBack(he * o.$, De * D, He);
                        for (let he = 0; he < 2 * M; he += 2)
                            P.emplaceBack(ue + he, ue + he + 1, ue + he + 3),
                            P.emplaceBack(ue + he, ue + he + 3, ue + he + 2),
                            P.emplaceBack(ge + he, ge + he + 3, ge + he + 1),
                            P.emplaceBack(ge + he, ge + he + 2, ge + he + 3);
                        const Te = new Ri(y.createVertexBuffer(w, Cl.members),y.createIndexBuffer(P),o.aM.simpleSegment(0, 0, w.length, P.length));
                        return this._meshCache[m] = Te,
                        Te
                    }
                    getMeshFrameDelta(e) {
                        return 2 * Math.PI * o.bu / Math.pow(2, Math.max(e, 0)) / 5
                    }
                    getMinTileElevationForLngLatZoom(e, n) {
                        var s;
                        const {tileID: u} = this._getOverscaledTileIDFromLngLatZoom(e, n);
                        return (s = this.getMinMaxElevation(u).minElevation) !== null && s !== void 0 ? s : 0
                    }
                    getMinMaxElevation(e) {
                        const n = this.getTerrainData(e).tile
                          , s = {
                            minElevation: null,
                            maxElevation: null
                        };
                        return n && n.dem && (s.minElevation = n.dem.min * this.exaggeration,
                        s.maxElevation = n.dem.max * this.exaggeration),
                        s
                    }
                    _getOverscaledTileIDFromLngLatZoom(e, n) {
                        const s = o.a1.fromLngLat(e.wrap())
                          , u = (1 << n) * o.$
                          , d = s.x * u
                          , m = s.y * u
                          , y = Math.floor(d / o.$)
                          , w = Math.floor(m / o.$);
                        return {
                            tileID: new o.Z(n,0,n,y,w),
                            mercatorX: d,
                            mercatorY: m
                        }
                    }
                }
                class Sl {
                    constructor(e, n, s) {
                        this._context = e,
                        this._size = n,
                        this._tileSize = s,
                        this._objects = [],
                        this._recentlyUsed = [],
                        this._stamp = 0
                    }
                    destruct() {
                        for (const e of this._objects)
                            e.texture.destroy(),
                            e.fbo.destroy()
                    }
                    _createObject(e) {
                        const n = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0)
                          , s = new o.T(this._context,{
                            width: this._tileSize,
                            height: this._tileSize,
                            data: null
                        },this._context.gl.RGBA);
                        return s.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE),
                        this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax),
                        n.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)),
                        n.colorAttachment.set(s.texture),
                        {
                            id: e,
                            fbo: n,
                            texture: s,
                            stamp: -1,
                            inUse: !1
                        }
                    }
                    getObjectForId(e) {
                        return this._objects[e]
                    }
                    useObject(e) {
                        e.inUse = !0,
                        this._recentlyUsed = this._recentlyUsed.filter((n => e.id !== n)),
                        this._recentlyUsed.push(e.id)
                    }
                    stampObject(e) {
                        e.stamp = ++this._stamp
                    }
                    getOrCreateFreeObject() {
                        for (const n of this._recentlyUsed)
                            if (!this._objects[n].inUse)
                                return this._objects[n];
                        if (this._objects.length >= this._size)
                            throw new Error("No free RenderPool available, call freeAllObjects() required!");
                        const e = this._createObject(this._objects.length);
                        return this._objects.push(e),
                        e
                    }
                    freeObject(e) {
                        e.inUse = !1
                    }
                    freeAllObjects() {
                        for (const e of this._objects)
                            this.freeObject(e)
                    }
                    isFull() {
                        return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
                    }
                }
                const ns = {
                    background: !0,
                    fill: !0,
                    line: !0,
                    raster: !0,
                    hillshade: !0,
                    "color-relief": !0
                };
                class Pl {
                    constructor(e, n) {
                        this.painter = e,
                        this.terrain = n,
                        this.pool = new Sl(e.context,30,n.sourceCache.tileSize * n.qualityFactor)
                    }
                    destruct() {
                        this.pool.destruct()
                    }
                    getTexture(e) {
                        return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
                    }
                    prepareForRender(e, n) {
                        this._stacks = [],
                        this._prevType = null,
                        this._rttTiles = [],
                        this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(),
                        this._renderableLayerIds = e._order.filter((s => !e._layers[s].isHidden(n))),
                        this._coordsAscending = {};
                        for (const s in e.sourceCaches) {
                            this._coordsAscending[s] = {};
                            const u = e.sourceCaches[s].getVisibleCoordinates()
                              , d = e.sourceCaches[s].getSource()
                              , m = d instanceof Ft ? d.terrainTileRanges : null;
                            for (const y of u) {
                                const w = this.terrain.sourceCache.getTerrainCoords(y, m);
                                for (const P in w)
                                    this._coordsAscending[s][P] || (this._coordsAscending[s][P] = []),
                                    this._coordsAscending[s][P].push(w[P])
                            }
                        }
                        this._coordsAscendingStr = {};
                        for (const s of e._order) {
                            const u = e._layers[s]
                              , d = u.source;
                            if (ns[u.type] && !this._coordsAscendingStr[d]) {
                                this._coordsAscendingStr[d] = {};
                                for (const m in this._coordsAscending[d])
                                    this._coordsAscendingStr[d][m] = this._coordsAscending[d][m].map((y => y.key)).sort().join()
                            }
                        }
                        for (const s of this._renderableTiles)
                            for (const u in this._coordsAscendingStr) {
                                const d = this._coordsAscendingStr[u][s.tileID.key];
                                d && d !== s.rttCoords[u] && (s.rtt = [])
                            }
                    }
                    renderLayer(e, n) {
                        if (e.isHidden(this.painter.transform.zoom))
                            return !1;
                        const s = Object.assign(Object.assign({}, n), {
                            isRenderingToTexture: !0
                        })
                          , u = e.type
                          , d = this.painter
                          , m = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
                        if (ns[u] && (this._prevType && ns[this._prevType] || this._stacks.push([]),
                        this._prevType = u,
                        this._stacks[this._stacks.length - 1].push(e.id),
                        !m))
                            return !0;
                        if (ns[this._prevType] || ns[u] && m) {
                            this._prevType = u;
                            const y = this._stacks.length - 1
                              , w = this._stacks[y] || [];
                            for (const P of this._renderableTiles) {
                                if (this.pool.isFull() && (vl(this.painter, this.terrain, this._rttTiles, s),
                                this._rttTiles = [],
                                this.pool.freeAllObjects()),
                                this._rttTiles.push(P),
                                P.rtt[y]) {
                                    const D = this.pool.getObjectForId(P.rtt[y].id);
                                    if (D.stamp === P.rtt[y].stamp) {
                                        this.pool.useObject(D);
                                        continue
                                    }
                                }
                                const M = this.pool.getOrCreateFreeObject();
                                this.pool.useObject(M),
                                this.pool.stampObject(M),
                                P.rtt[y] = {
                                    id: M.id,
                                    stamp: M.stamp
                                },
                                d.context.bindFramebuffer.set(M.fbo.framebuffer),
                                d.context.clear({
                                    color: o.bf.transparent,
                                    stencil: 0
                                }),
                                d.currentStencilSource = void 0;
                                for (let D = 0; D < w.length; D++) {
                                    const z = d.style._layers[w[D]]
                                      , B = z.source ? this._coordsAscending[z.source][P.tileID.key] : [P.tileID];
                                    d.context.viewport.set([0, 0, M.fbo.width, M.fbo.height]),
                                    d._renderTileClippingMasks(z, B, !0),
                                    d.renderLayer(d, d.style.sourceCaches[z.source], z, B, s),
                                    z.source && (P.rttCoords[z.source] = this._coordsAscendingStr[z.source][P.tileID.key])
                                }
                            }
                            return vl(this.painter, this.terrain, this._rttTiles, s),
                            this._rttTiles = [],
                            this.pool.freeAllObjects(),
                            ns[u]
                        }
                        return !1
                    }
                }
                const jn = {
                    "AttributionControl.ToggleAttribution": "Toggle attribution",
                    "AttributionControl.MapFeedback": "Map feedback",
                    "FullscreenControl.Enter": "Enter fullscreen",
                    "FullscreenControl.Exit": "Exit fullscreen",
                    "GeolocateControl.FindMyLocation": "Find my location",
                    "GeolocateControl.LocationNotAvailable": "Location not available",
                    "LogoControl.Title": "MapLibre logo",
                    "Map.Title": "Map",
                    "Marker.Title": "Map marker",
                    "NavigationControl.ResetBearing": "Reset bearing to north",
                    "NavigationControl.ZoomIn": "Zoom in",
                    "NavigationControl.ZoomOut": "Zoom out",
                    "Popup.Close": "Close popup",
                    "ScaleControl.Feet": "ft",
                    "ScaleControl.Meters": "m",
                    "ScaleControl.Kilometers": "km",
                    "ScaleControl.Miles": "mi",
                    "ScaleControl.NauticalMiles": "nm",
                    "GlobeControl.Enable": "Enable globe",
                    "GlobeControl.Disable": "Disable globe",
                    "TerrainControl.Enable": "Enable terrain",
                    "TerrainControl.Disable": "Disable terrain",
                    "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
                    "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map",
                    "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
                }
                  , rd = $
                  , ha = {
                    hash: !1,
                    interactive: !0,
                    bearingSnap: 7,
                    attributionControl: Xc,
                    maplibreLogo: !1,
                    refreshExpiredTiles: !0,
                    canvasContextAttributes: {
                        antialias: !1,
                        preserveDrawingBuffer: !1,
                        powerPreference: "high-performance",
                        failIfMajorPerformanceCaveat: !1,
                        desynchronized: !1,
                        contextType: void 0
                    },
                    scrollZoom: !0,
                    minZoom: -2,
                    maxZoom: 22,
                    minPitch: 0,
                    maxPitch: 60,
                    boxZoom: !0,
                    dragRotate: !0,
                    dragPan: !0,
                    keyboard: !0,
                    doubleClickZoom: !0,
                    touchZoomRotate: !0,
                    touchPitch: !0,
                    cooperativeGestures: !1,
                    trackResize: !0,
                    center: [0, 0],
                    elevation: 0,
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    roll: 0,
                    renderWorldCopies: !0,
                    maxTileCacheSize: null,
                    maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS,
                    transformRequest: null,
                    transformCameraUpdate: null,
                    fadeDuration: 300,
                    crossSourceCollisions: !0,
                    clickTolerance: 3,
                    localIdeographFontFamily: "sans-serif",
                    pitchWithRotate: !0,
                    rollEnabled: !1,
                    validateStyle: !0,
                    maxCanvasSize: [4096, 4096],
                    cancelPendingTileRequestsWhileZooming: !0,
                    centerClampedToGround: !0
                }
                  , bp = {
                    showCompass: !0,
                    showZoom: !0,
                    visualizePitch: !1,
                    visualizeRoll: !0
                };
                class Lo {
                    constructor(e, n, s=!1) {
                        this.mousedown = d => {
                            this.startMove(d, X.mousePos(this.element, d)),
                            X.addEventListener(window, "mousemove", this.mousemove),
                            X.addEventListener(window, "mouseup", this.mouseup)
                        }
                        ,
                        this.mousemove = d => {
                            this.move(d, X.mousePos(this.element, d))
                        }
                        ,
                        this.mouseup = d => {
                            this._rotatePitchHandler.dragEnd(d),
                            this.offTemp()
                        }
                        ,
                        this.touchstart = d => {
                            d.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = X.touchPos(this.element, d.targetTouches)[0],
                            this.startMove(d, this._startPos),
                            X.addEventListener(window, "touchmove", this.touchmove, {
                                passive: !1
                            }),
                            X.addEventListener(window, "touchend", this.touchend))
                        }
                        ,
                        this.touchmove = d => {
                            d.targetTouches.length !== 1 ? this.reset() : (this._lastPos = X.touchPos(this.element, d.targetTouches)[0],
                            this.move(d, this._lastPos))
                        }
                        ,
                        this.touchend = d => {
                            d.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(),
                            delete this._startPos,
                            delete this._lastPos,
                            this.offTemp()
                        }
                        ,
                        this.reset = () => {
                            this._rotatePitchHandler.reset(),
                            delete this._startPos,
                            delete this._lastPos,
                            this.offTemp()
                        }
                        ,
                        this._clickTolerance = 10,
                        this.element = n;
                        const u = new vp;
                        this._rotatePitchHandler = new Zs({
                            clickTolerance: 3,
                            move: (d, m) => {
                                const y = n.getBoundingClientRect()
                                  , w = new o.P((y.bottom - y.top) / 2,(y.right - y.left) / 2);
                                return {
                                    bearingDelta: o.cn(new o.P(d.x,m.y), m, w),
                                    pitchDelta: s ? -.5 * (m.y - d.y) : void 0
                                }
                            }
                            ,
                            moveStateManager: u,
                            enable: !0,
                            assignEvents: () => {}
                        }),
                        this.map = e,
                        X.addEventListener(n, "mousedown", this.mousedown),
                        X.addEventListener(n, "touchstart", this.touchstart, {
                            passive: !1
                        }),
                        X.addEventListener(n, "touchcancel", this.reset)
                    }
                    startMove(e, n) {
                        this._rotatePitchHandler.dragStart(e, n),
                        X.disableDrag()
                    }
                    move(e, n) {
                        const s = this.map
                          , {bearingDelta: u, pitchDelta: d} = this._rotatePitchHandler.dragMove(e, n) || {};
                        u && s.setBearing(s.getBearing() + u),
                        d && s.setPitch(s.getPitch() + d)
                    }
                    off() {
                        const e = this.element;
                        X.removeEventListener(e, "mousedown", this.mousedown),
                        X.removeEventListener(e, "touchstart", this.touchstart, {
                            passive: !1
                        }),
                        X.removeEventListener(window, "touchmove", this.touchmove, {
                            passive: !1
                        }),
                        X.removeEventListener(window, "touchend", this.touchend),
                        X.removeEventListener(e, "touchcancel", this.reset),
                        this.offTemp()
                    }
                    offTemp() {
                        X.enableDrag(),
                        X.removeEventListener(window, "mousemove", this.mousemove),
                        X.removeEventListener(window, "mouseup", this.mouseup),
                        X.removeEventListener(window, "touchmove", this.touchmove, {
                            passive: !1
                        }),
                        X.removeEventListener(window, "touchend", this.touchend)
                    }
                }
                let Ai;
                function Hi(h, e, n, s=!1) {
                    if (s || !n.getCoveringTilesDetailsProvider().allowWorldCopies())
                        return h == null ? void 0 : h.wrap();
                    const u = new o.S(h.lng,h.lat);
                    if (h = new o.S(h.lng,h.lat),
                    e) {
                        const d = new o.S(h.lng - 360,h.lat)
                          , m = new o.S(h.lng + 360,h.lat)
                          , y = n.locationToScreenPoint(h).distSqr(e);
                        n.locationToScreenPoint(d).distSqr(e) < y ? h = d : n.locationToScreenPoint(m).distSqr(e) < y && (h = m)
                    }
                    for (; Math.abs(h.lng - n.center.lng) > 180; ) {
                        const d = n.locationToScreenPoint(h);
                        if (d.x >= 0 && d.y >= 0 && d.x <= n.width && d.y <= n.height)
                            break;
                        h.lng > n.center.lng ? h.lng -= 360 : h.lng += 360
                    }
                    return h.lng !== u.lng && n.isPointOnMapSurface(n.locationToScreenPoint(h)) ? h : u
                }
                const Il = {
                    center: "translate(-50%,-50%)",
                    top: "translate(-50%,0)",
                    "top-left": "translate(0,0)",
                    "top-right": "translate(-100%,0)",
                    bottom: "translate(-50%,-100%)",
                    "bottom-left": "translate(0,-100%)",
                    "bottom-right": "translate(-100%,-100%)",
                    left: "translate(0,-50%)",
                    right: "translate(-100%,-50%)"
                };
                function Ws(h, e, n) {
                    const s = h.classList;
                    for (const u in Il)
                        s.remove(`maplibregl-${n}-anchor-${u}`);
                    s.add(`maplibregl-${n}-anchor-${e}`)
                }
                class Xs extends o.E {
                    constructor(e) {
                        if (super(),
                        this._onKeyPress = n => {
                            const s = n.code
                              , u = n.charCode || n.keyCode;
                            s !== "Space" && s !== "Enter" && u !== 32 && u !== 13 || this.togglePopup()
                        }
                        ,
                        this._onMapClick = n => {
                            const s = n.originalEvent.target
                              , u = this._element;
                            this._popup && (s === u || u.contains(s)) && this.togglePopup()
                        }
                        ,
                        this._update = n => {
                            if (!this._map)
                                return;
                            const s = this._map.loaded() && !this._map.isMoving();
                            ((n == null ? void 0 : n.type) === "terrain" || (n == null ? void 0 : n.type) === "render" && !s) && this._map.once("render", this._update),
                            this._lngLat = Hi(this._lngLat, this._flatPos, this._map.transform),
                            this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset),
                            this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                            let u = "";
                            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? u = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (u = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                            let d = "";
                            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? d = "rotateX(0deg)" : this._pitchAlignment === "map" && (d = `rotateX(${this._map.getPitch()}deg)`),
                            this._subpixelPositioning || n && n.type !== "moveend" || (this._pos = this._pos.round()),
                            X.setTransform(this._element, `${Il[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${d} ${u}`),
                            ye.frameAsync(new AbortController).then(( () => {
                                this._updateOpacity(n && n.type === "moveend")
                            }
                            )).catch(( () => {}
                            ))
                        }
                        ,
                        this._onMove = n => {
                            if (!this._isDragging) {
                                const s = this._clickTolerance || this._map._clickTolerance;
                                this._isDragging = n.point.dist(this._pointerdownPos) >= s
                            }
                            this._isDragging && (this._pos = n.point.sub(this._positionDelta),
                            this._lngLat = this._map.unproject(this._pos),
                            this.setLngLat(this._lngLat),
                            this._element.style.pointerEvents = "none",
                            this._state === "pending" && (this._state = "active",
                            this.fire(new o.l("dragstart"))),
                            this.fire(new o.l("drag")))
                        }
                        ,
                        this._onUp = () => {
                            this._element.style.pointerEvents = "auto",
                            this._positionDelta = null,
                            this._pointerdownPos = null,
                            this._isDragging = !1,
                            this._map.off("mousemove", this._onMove),
                            this._map.off("touchmove", this._onMove),
                            this._state === "active" && this.fire(new o.l("dragend")),
                            this._state = "inactive"
                        }
                        ,
                        this._addDragHandler = n => {
                            this._element.contains(n.originalEvent.target) && (n.preventDefault(),
                            this._positionDelta = n.point.sub(this._pos).add(this._offset),
                            this._pointerdownPos = n.point,
                            this._state = "pending",
                            this._map.on("mousemove", this._onMove),
                            this._map.on("touchmove", this._onMove),
                            this._map.once("mouseup", this._onUp),
                            this._map.once("touchend", this._onUp))
                        }
                        ,
                        this._anchor = e && e.anchor || "center",
                        this._color = e && e.color || "#3FB1CE",
                        this._scale = e && e.scale || 1,
                        this._draggable = e && e.draggable || !1,
                        this._clickTolerance = e && e.clickTolerance || 0,
                        this._subpixelPositioning = e && e.subpixelPositioning || !1,
                        this._isDragging = !1,
                        this._state = "inactive",
                        this._rotation = e && e.rotation || 0,
                        this._rotationAlignment = e && e.rotationAlignment || "auto",
                        this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment,
                        this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered),
                        e && e.element)
                            this._element = e.element,
                            this._offset = o.P.convert(e && e.offset || [0, 0]);
                        else {
                            this._defaultMarker = !0,
                            this._element = X.create("div");
                            const n = X.createNS("http://www.w3.org/2000/svg", "svg")
                              , s = 41
                              , u = 27;
                            n.setAttributeNS(null, "display", "block"),
                            n.setAttributeNS(null, "height", `${s}px`),
                            n.setAttributeNS(null, "width", `${u}px`),
                            n.setAttributeNS(null, "viewBox", `0 0 ${u} ${s}`);
                            const d = X.createNS("http://www.w3.org/2000/svg", "g");
                            d.setAttributeNS(null, "stroke", "none"),
                            d.setAttributeNS(null, "stroke-width", "1"),
                            d.setAttributeNS(null, "fill", "none"),
                            d.setAttributeNS(null, "fill-rule", "evenodd");
                            const m = X.createNS("http://www.w3.org/2000/svg", "g");
                            m.setAttributeNS(null, "fill-rule", "nonzero");
                            const y = X.createNS("http://www.w3.org/2000/svg", "g");
                            y.setAttributeNS(null, "transform", "translate(3.0, 29.0)"),
                            y.setAttributeNS(null, "fill", "#000000");
                            const w = [{
                                rx: "10.5",
                                ry: "5.25002273"
                            }, {
                                rx: "10.5",
                                ry: "5.25002273"
                            }, {
                                rx: "9.5",
                                ry: "4.77275007"
                            }, {
                                rx: "8.5",
                                ry: "4.29549936"
                            }, {
                                rx: "7.5",
                                ry: "3.81822308"
                            }, {
                                rx: "6.5",
                                ry: "3.34094679"
                            }, {
                                rx: "5.5",
                                ry: "2.86367051"
                            }, {
                                rx: "4.5",
                                ry: "2.38636864"
                            }];
                            for (const re of w) {
                                const se = X.createNS("http://www.w3.org/2000/svg", "ellipse");
                                se.setAttributeNS(null, "opacity", "0.04"),
                                se.setAttributeNS(null, "cx", "10.5"),
                                se.setAttributeNS(null, "cy", "5.80029008"),
                                se.setAttributeNS(null, "rx", re.rx),
                                se.setAttributeNS(null, "ry", re.ry),
                                y.appendChild(se)
                            }
                            const P = X.createNS("http://www.w3.org/2000/svg", "g");
                            P.setAttributeNS(null, "fill", this._color);
                            const M = X.createNS("http://www.w3.org/2000/svg", "path");
                            M.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"),
                            P.appendChild(M);
                            const D = X.createNS("http://www.w3.org/2000/svg", "g");
                            D.setAttributeNS(null, "opacity", "0.25"),
                            D.setAttributeNS(null, "fill", "#000000");
                            const z = X.createNS("http://www.w3.org/2000/svg", "path");
                            z.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"),
                            D.appendChild(z);
                            const B = X.createNS("http://www.w3.org/2000/svg", "g");
                            B.setAttributeNS(null, "transform", "translate(6.0, 7.0)"),
                            B.setAttributeNS(null, "fill", "#FFFFFF");
                            const U = X.createNS("http://www.w3.org/2000/svg", "g");
                            U.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                            const ee = X.createNS("http://www.w3.org/2000/svg", "circle");
                            ee.setAttributeNS(null, "fill", "#000000"),
                            ee.setAttributeNS(null, "opacity", "0.25"),
                            ee.setAttributeNS(null, "cx", "5.5"),
                            ee.setAttributeNS(null, "cy", "5.5"),
                            ee.setAttributeNS(null, "r", "5.4999962");
                            const J = X.createNS("http://www.w3.org/2000/svg", "circle");
                            J.setAttributeNS(null, "fill", "#FFFFFF"),
                            J.setAttributeNS(null, "cx", "5.5"),
                            J.setAttributeNS(null, "cy", "5.5"),
                            J.setAttributeNS(null, "r", "5.4999962"),
                            U.appendChild(ee),
                            U.appendChild(J),
                            m.appendChild(y),
                            m.appendChild(P),
                            m.appendChild(D),
                            m.appendChild(B),
                            m.appendChild(U),
                            n.appendChild(m),
                            n.setAttributeNS(null, "height", s * this._scale + "px"),
                            n.setAttributeNS(null, "width", u * this._scale + "px"),
                            this._element.appendChild(n),
                            this._offset = o.P.convert(e && e.offset || [0, -14])
                        }
                        if (this._element.classList.add("maplibregl-marker"),
                        this._element.addEventListener("dragstart", (n => {
                            n.preventDefault()
                        }
                        )),
                        this._element.addEventListener("mousedown", (n => {
                            n.preventDefault()
                        }
                        )),
                        Ws(this._element, this._anchor, "marker"),
                        e && e.className)
                            for (const n of e.className.split(" "))
                                this._element.classList.add(n);
                        this._popup = null
                    }
                    addTo(e) {
                        return this.remove(),
                        this._map = e,
                        this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")),
                        e.getCanvasContainer().appendChild(this._element),
                        e.on("move", this._update),
                        e.on("moveend", this._update),
                        e.on("terrain", this._update),
                        e.on("projectiontransition", this._update),
                        this.setDraggable(this._draggable),
                        this._update(),
                        this._map.on("click", this._onMapClick),
                        this
                    }
                    remove() {
                        return this._opacityTimeout && (clearTimeout(this._opacityTimeout),
                        delete this._opacityTimeout),
                        this._map && (this._map.off("click", this._onMapClick),
                        this._map.off("move", this._update),
                        this._map.off("moveend", this._update),
                        this._map.off("terrain", this._update),
                        this._map.off("projectiontransition", this._update),
                        this._map.off("mousedown", this._addDragHandler),
                        this._map.off("touchstart", this._addDragHandler),
                        this._map.off("mouseup", this._onUp),
                        this._map.off("touchend", this._onUp),
                        this._map.off("mousemove", this._onMove),
                        this._map.off("touchmove", this._onMove),
                        delete this._map),
                        X.remove(this._element),
                        this._popup && this._popup.remove(),
                        this
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(e) {
                        return this._lngLat = o.S.convert(e),
                        this._pos = null,
                        this._popup && this._popup.setLngLat(this._lngLat),
                        this._update(),
                        this
                    }
                    getElement() {
                        return this._element
                    }
                    setPopup(e) {
                        if (this._popup && (this._popup.remove(),
                        this._popup = null,
                        this._element.removeEventListener("keypress", this._onKeyPress),
                        this._originalTabIndex || this._element.removeAttribute("tabindex")),
                        e) {
                            if (!("offset"in e.options)) {
                                const u = Math.abs(13.5) / Math.SQRT2;
                                e.options.offset = this._defaultMarker ? {
                                    top: [0, 0],
                                    "top-left": [0, 0],
                                    "top-right": [0, 0],
                                    bottom: [0, -38.1],
                                    "bottom-left": [u, -1 * (38.1 - 13.5 + u)],
                                    "bottom-right": [-u, -1 * (38.1 - 13.5 + u)],
                                    left: [13.5, -1 * (38.1 - 13.5)],
                                    right: [-13.5, -1 * (38.1 - 13.5)]
                                } : this._offset
                            }
                            this._popup = e,
                            this._originalTabIndex = this._element.getAttribute("tabindex"),
                            this._originalTabIndex || this._element.setAttribute("tabindex", "0"),
                            this._element.addEventListener("keypress", this._onKeyPress)
                        }
                        return this
                    }
                    setSubpixelPositioning(e) {
                        return this._subpixelPositioning = e,
                        this
                    }
                    getPopup() {
                        return this._popup
                    }
                    togglePopup() {
                        const e = this._popup;
                        return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat),
                        e.addTo(this._map)),
                        this) : this
                    }
                    _updateOpacity(e=!1) {
                        var n, s;
                        const u = (n = this._map) === null || n === void 0 ? void 0 : n.terrain
                          , d = this._map.transform.isLocationOccluded(this._lngLat);
                        if (!u || d) {
                            const B = d ? this._opacityWhenCovered : this._opacity;
                            return void (this._element.style.opacity !== B && (this._element.style.opacity = B))
                        }
                        if (e)
                            this._opacityTimeout = null;
                        else {
                            if (this._opacityTimeout)
                                return;
                            this._opacityTimeout = setTimeout(( () => {
                                this._opacityTimeout = null
                            }
                            ), 100)
                        }
                        const m = this._map
                          , y = m.terrain.depthAtPoint(this._pos)
                          , w = m.terrain.getElevationForLngLatZoom(this._lngLat, m.transform.tileZoom);
                        if (m.transform.lngLatToCameraDepth(this._lngLat, w) - y < .006)
                            return void (this._element.style.opacity = this._opacity);
                        const P = -this._offset.y / m.transform.pixelsPerMeter
                          , M = Math.sin(m.getPitch() * Math.PI / 180) * P
                          , D = m.terrain.depthAtPoint(new o.P(this._pos.x,this._pos.y - this._offset.y))
                          , z = m.transform.lngLatToCameraDepth(this._lngLat, w + M) - D > .006;
                        !((s = this._popup) === null || s === void 0) && s.isOpen() && z && this._popup.remove(),
                        this._element.style.opacity = z ? this._opacityWhenCovered : this._opacity
                    }
                    getOffset() {
                        return this._offset
                    }
                    setOffset(e) {
                        return this._offset = o.P.convert(e),
                        this._update(),
                        this
                    }
                    addClassName(e) {
                        this._element.classList.add(e)
                    }
                    removeClassName(e) {
                        this._element.classList.remove(e)
                    }
                    toggleClassName(e) {
                        return this._element.classList.toggle(e)
                    }
                    setDraggable(e) {
                        return this._draggable = !!e,
                        this._map && (e ? (this._map.on("mousedown", this._addDragHandler),
                        this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler),
                        this._map.off("touchstart", this._addDragHandler))),
                        this
                    }
                    isDraggable() {
                        return this._draggable
                    }
                    setRotation(e) {
                        return this._rotation = e || 0,
                        this._update(),
                        this
                    }
                    getRotation() {
                        return this._rotation
                    }
                    setRotationAlignment(e) {
                        return this._rotationAlignment = e || "auto",
                        this._update(),
                        this
                    }
                    getRotationAlignment() {
                        return this._rotationAlignment
                    }
                    setPitchAlignment(e) {
                        return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment,
                        this._update(),
                        this
                    }
                    getPitchAlignment() {
                        return this._pitchAlignment
                    }
                    setOpacity(e, n) {
                        return (this._opacity === void 0 || e === void 0 && n === void 0) && (this._opacity = "1",
                        this._opacityWhenCovered = "0.2"),
                        e !== void 0 && (this._opacity = e),
                        n !== void 0 && (this._opacityWhenCovered = n),
                        this._map && this._updateOpacity(!0),
                        this
                    }
                }
                const Yc = {
                    positionOptions: {
                        enableHighAccuracy: !1,
                        maximumAge: 0,
                        timeout: 6e3
                    },
                    fitBoundsOptions: {
                        maxZoom: 15
                    },
                    trackUserLocation: !1,
                    showAccuracyCircle: !0,
                    showUserLocation: !0
                };
                let Ks = 0
                  , Ss = !1;
                const Do = {
                    maxWidth: 100,
                    unit: "metric"
                };
                function Ml(h, e, n) {
                    const s = n && n.maxWidth || 100
                      , u = h._container.clientHeight / 2
                      , d = h._container.clientWidth / 2
                      , m = h.unproject([d - s / 2, u])
                      , y = h.unproject([d + s / 2, u])
                      , w = Math.round(h.project(y).x - h.project(m).x)
                      , P = Math.min(s, w, h._container.clientWidth)
                      , M = m.distanceTo(y);
                    if (n && n.unit === "imperial") {
                        const D = 3.2808 * M;
                        D > 5280 ? Ps(e, P, D / 5280, h._getUIString("ScaleControl.Miles")) : Ps(e, P, D, h._getUIString("ScaleControl.Feet"))
                    } else
                        n && n.unit === "nautical" ? Ps(e, P, M / 1852, h._getUIString("ScaleControl.NauticalMiles")) : M >= 1e3 ? Ps(e, P, M / 1e3, h._getUIString("ScaleControl.Kilometers")) : Ps(e, P, M, h._getUIString("ScaleControl.Meters"))
                }
                function Ps(h, e, n, s) {
                    const u = (function(d) {
                        const m = Math.pow(10, `${Math.floor(d)}`.length - 1);
                        let y = d / m;
                        return y = y >= 10 ? 10 : y >= 5 ? 5 : y >= 3 ? 3 : y >= 2 ? 2 : y >= 1 ? 1 : (function(w) {
                            const P = Math.pow(10, Math.ceil(-Math.log(w) / Math.LN10));
                            return Math.round(w * P) / P
                        }
                        )(y),
                        m * y
                    }
                    )(n);
                    h.style.width = e * (u / n) + "px",
                    h.innerHTML = `${u}&nbsp;${s}`
                }
                const Jc = {
                    closeButton: !0,
                    closeOnClick: !0,
                    focusAfterOpen: !0,
                    className: "",
                    maxWidth: "240px",
                    subpixelPositioning: !1,
                    locationOccludedOpacity: void 0
                }
                  , Qc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
                function Al(h) {
                    if (h) {
                        if (typeof h == "number") {
                            const e = Math.round(Math.abs(h) / Math.SQRT2);
                            return {
                                center: new o.P(0,0),
                                top: new o.P(0,h),
                                "top-left": new o.P(e,e),
                                "top-right": new o.P(-e,e),
                                bottom: new o.P(0,-h),
                                "bottom-left": new o.P(e,-e),
                                "bottom-right": new o.P(-e,-e),
                                left: new o.P(h,0),
                                right: new o.P(-h,0)
                            }
                        }
                        if (h instanceof o.P || Array.isArray(h)) {
                            const e = o.P.convert(h);
                            return {
                                center: e,
                                top: e,
                                "top-left": e,
                                "top-right": e,
                                bottom: e,
                                "bottom-left": e,
                                "bottom-right": e,
                                left: e,
                                right: e
                            }
                        }
                        return {
                            center: o.P.convert(h.center || [0, 0]),
                            top: o.P.convert(h.top || [0, 0]),
                            "top-left": o.P.convert(h["top-left"] || [0, 0]),
                            "top-right": o.P.convert(h["top-right"] || [0, 0]),
                            bottom: o.P.convert(h.bottom || [0, 0]),
                            "bottom-left": o.P.convert(h["bottom-left"] || [0, 0]),
                            "bottom-right": o.P.convert(h["bottom-right"] || [0, 0]),
                            left: o.P.convert(h.left || [0, 0]),
                            right: o.P.convert(h.right || [0, 0])
                        }
                    }
                    return Al(new o.P(0,0))
                }
                const eu = $;
                T.AJAXError = o.cz,
                T.Event = o.l,
                T.Evented = o.E,
                T.LngLat = o.S,
                T.MercatorCoordinate = o.a1,
                T.Point = o.P,
                T.addProtocol = o.cA,
                T.config = o.a,
                T.removeProtocol = o.cB,
                T.AttributionControl = Kc,
                T.BoxZoomHandler = Vc,
                T.CanvasSource = _r,
                T.CooperativeGesturesHandler = Qh,
                T.DoubleClickZoomHandler = $c,
                T.DragPanHandler = Yh,
                T.DragRotateHandler = Hc,
                T.EdgeInsets = on,
                T.FullscreenControl = class extends o.E {
                    constructor(h={}) {
                        super(),
                        this._onFullscreenChange = () => {
                            var e;
                            let n = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
                            for (; !((e = n == null ? void 0 : n.shadowRoot) === null || e === void 0) && e.fullscreenElement; )
                                n = n.shadowRoot.fullscreenElement;
                            n === this._container !== this._fullscreen && this._handleFullscreenChange()
                        }
                        ,
                        this._onClickFullscreen = () => {
                            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
                        }
                        ,
                        this._fullscreen = !1,
                        h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : o.w("Full screen control 'container' must be a DOM element.")),
                        "onfullscreenchange"in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange"in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange"in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange"in document && (this._fullscreenchange = "MSFullscreenChange")
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container || (this._container = this._map.getContainer()),
                        this._controlContainer = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._setupUI(),
                        this._controlContainer
                    }
                    onRemove() {
                        X.remove(this._controlContainer),
                        this._map = null,
                        window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
                    }
                    _setupUI() {
                        const h = this._fullscreenButton = X.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
                        X.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"),
                        h.type = "button",
                        this._updateTitle(),
                        this._fullscreenButton.addEventListener("click", this._onClickFullscreen),
                        window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
                    }
                    _updateTitle() {
                        const h = this._getTitle();
                        this._fullscreenButton.setAttribute("aria-label", h),
                        this._fullscreenButton.title = h
                    }
                    _getTitle() {
                        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                    }
                    _isFullscreen() {
                        return this._fullscreen
                    }
                    _handleFullscreenChange() {
                        this._fullscreen = !this._fullscreen,
                        this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"),
                        this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"),
                        this._updateTitle(),
                        this._fullscreen ? (this.fire(new o.l("fullscreenstart")),
                        this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(),
                        this._map.cooperativeGestures.disable()) : (this.fire(new o.l("fullscreenend")),
                        this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
                    }
                    _exitFullscreen() {
                        window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
                    }
                    _requestFullscreen() {
                        this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
                    }
                    _togglePseudoFullScreen() {
                        this._container.classList.toggle("maplibregl-pseudo-fullscreen"),
                        this._handleFullscreenChange(),
                        this._map.resize()
                    }
                }
                ,
                T.GeoJSONSource = ar,
                T.GeolocateControl = class extends o.E {
                    constructor(h) {
                        super(),
                        this._onSuccess = e => {
                            if (this._map) {
                                if (this._isOutOfMapMaxBounds(e))
                                    return this._setErrorState(),
                                    this.fire(new o.l("outofmaxbounds",e)),
                                    this._updateMarker(),
                                    void this._finish();
                                if (this.options.trackUserLocation)
                                    switch (this._lastKnownPosition = e,
                                    this._watchState) {
                                    case "WAITING_ACTIVE":
                                    case "ACTIVE_LOCK":
                                    case "ACTIVE_ERROR":
                                        this._watchState = "ACTIVE_LOCK",
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                        break;
                                    case "BACKGROUND":
                                    case "BACKGROUND_ERROR":
                                        this._watchState = "BACKGROUND",
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                                        break;
                                    default:
                                        throw new Error(`Unexpected watchState ${this._watchState}`)
                                    }
                                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e),
                                this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e),
                                this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"),
                                this.fire(new o.l("geolocate",e)),
                                this._finish()
                            }
                        }
                        ,
                        this._updateCamera = e => {
                            const n = new o.S(e.coords.longitude,e.coords.latitude)
                              , s = e.coords.accuracy
                              , u = this._map.getBearing()
                              , d = o.e({
                                bearing: u
                            }, this.options.fitBoundsOptions)
                              , m = dt.fromLngLat(n, s);
                            this._map.fitBounds(m, d, {
                                geolocateSource: !0
                            })
                        }
                        ,
                        this._updateMarker = e => {
                            if (e) {
                                const n = new o.S(e.coords.longitude,e.coords.latitude);
                                this._accuracyCircleMarker.setLngLat(n).addTo(this._map),
                                this._userLocationDotMarker.setLngLat(n).addTo(this._map),
                                this._accuracy = e.coords.accuracy,
                                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                            } else
                                this._userLocationDotMarker.remove(),
                                this._accuracyCircleMarker.remove()
                        }
                        ,
                        this._onZoom = () => {
                            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        }
                        ,
                        this._onError = e => {
                            if (this._map) {
                                if (e.code === 1) {
                                    this._watchState = "OFF",
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                    this._geolocateButton.disabled = !0;
                                    const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.title = n,
                                    this._geolocateButton.setAttribute("aria-label", n),
                                    this._geolocationWatchID !== void 0 && this._clearWatch()
                                } else {
                                    if (e.code === 3 && Ss)
                                        return;
                                    this.options.trackUserLocation && this._setErrorState()
                                }
                                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"),
                                this.fire(new o.l("error",e)),
                                this._finish()
                            }
                        }
                        ,
                        this._finish = () => {
                            this._timeoutId && clearTimeout(this._timeoutId),
                            this._timeoutId = void 0
                        }
                        ,
                        this._setupUI = () => {
                            this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())),
                            this._geolocateButton = X.create("button", "maplibregl-ctrl-geolocate", this._container),
                            X.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"),
                            this._geolocateButton.type = "button",
                            this._geolocateButton.disabled = !0)
                        }
                        ,
                        this._finishSetupUI = e => {
                            if (this._map) {
                                if (e === !1) {
                                    o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                                    const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.disabled = !0,
                                    this._geolocateButton.title = n,
                                    this._geolocateButton.setAttribute("aria-label", n)
                                } else {
                                    const n = this._map._getUIString("GeolocateControl.FindMyLocation");
                                    this._geolocateButton.disabled = !1,
                                    this._geolocateButton.title = n,
                                    this._geolocateButton.setAttribute("aria-label", n)
                                }
                                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                                this._watchState = "OFF"),
                                this.options.showUserLocation && (this._dotElement = X.create("div", "maplibregl-user-location-dot"),
                                this._userLocationDotMarker = new Xs({
                                    element: this._dotElement
                                }),
                                this._circleElement = X.create("div", "maplibregl-user-location-accuracy-circle"),
                                this._accuracyCircleMarker = new Xs({
                                    element: this._circleElement,
                                    pitchAlignment: "map"
                                }),
                                this.options.trackUserLocation && (this._watchState = "OFF"),
                                this._map.on("zoom", this._onZoom)),
                                this._geolocateButton.addEventListener("click", ( () => this.trigger())),
                                this._setup = !0,
                                this.options.trackUserLocation && this._map.on("movestart", (n => {
                                    const s = (n == null ? void 0 : n[0])instanceof ResizeObserverEntry;
                                    n.geolocateSource || this._watchState !== "ACTIVE_LOCK" || s || this._map.isZooming() || (this._watchState = "BACKGROUND",
                                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                    this.fire(new o.l("trackuserlocationend")),
                                    this.fire(new o.l("userlocationlostfocus")))
                                }
                                ))
                            }
                        }
                        ,
                        this.options = o.e({}, Yc, h)
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._setupUI(),
                        (function() {
                            return o._(this, arguments, void 0, (function*(e=!1) {
                                if (Ai !== void 0 && !e)
                                    return Ai;
                                if (window.navigator.permissions === void 0)
                                    return Ai = !!window.navigator.geolocation,
                                    Ai;
                                try {
                                    Ai = (yield window.navigator.permissions.query({
                                        name: "geolocation"
                                    })).state !== "denied"
                                } catch {
                                    Ai = !!window.navigator.geolocation
                                }
                                return Ai
                            }
                            ))
                        }
                        )().then((e => this._finishSetupUI(e))),
                        this._container
                    }
                    onRemove() {
                        this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID),
                        this._geolocationWatchID = void 0),
                        this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(),
                        this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(),
                        X.remove(this._container),
                        this._map.off("zoom", this._onZoom),
                        this._map = void 0,
                        Ks = 0,
                        Ss = !1
                    }
                    _isOutOfMapMaxBounds(h) {
                        const e = this._map.getMaxBounds()
                          , n = h.coords;
                        return e && (n.longitude < e.getWest() || n.longitude > e.getEast() || n.latitude < e.getSouth() || n.latitude > e.getNorth())
                    }
                    _setErrorState() {
                        switch (this._watchState) {
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "ACTIVE_ERROR":
                            break;
                        default:
                            throw new Error(`Unexpected watchState ${this._watchState}`)
                        }
                    }
                    _updateCircleRadius() {
                        const h = this._map.getBounds()
                          , e = h.getSouthEast()
                          , n = h.getNorthEast()
                          , s = e.distanceTo(n)
                          , u = Math.ceil(this._accuracy / (s / this._map._container.clientHeight) * 2);
                        this._circleElement.style.width = `${u}px`,
                        this._circleElement.style.height = `${u}px`
                    }
                    trigger() {
                        if (!this._setup)
                            return o.w("Geolocate control triggered before added to a map"),
                            !1;
                        if (this.options.trackUserLocation) {
                            switch (this._watchState) {
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE",
                                this.fire(new o.l("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                Ks--,
                                Ss = !1,
                                this._watchState = "OFF",
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                this.fire(new o.l("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK",
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                                this.fire(new o.l("trackuserlocationstart")),
                                this.fire(new o.l("userlocationfocus"));
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                            }
                            switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "OFF":
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                            }
                            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                                this._clearWatch();
                            else if (this._geolocationWatchID === void 0) {
                                let h;
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.setAttribute("aria-pressed", "true"),
                                Ks++,
                                Ks > 1 ? (h = {
                                    maximumAge: 6e5,
                                    timeout: 0
                                },
                                Ss = !0) : (h = this.options.positionOptions,
                                Ss = !1),
                                this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h)
                            }
                        } else
                            window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions),
                            this._timeoutId = setTimeout(this._finish, 1e4);
                        return !0
                    }
                    _clearWatch() {
                        window.navigator.geolocation.clearWatch(this._geolocationWatchID),
                        this._geolocationWatchID = void 0,
                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                        this._geolocateButton.setAttribute("aria-pressed", "false"),
                        this.options.showUserLocation && this._updateMarker(null)
                    }
                }
                ,
                T.GlobeControl = class {
                    constructor() {
                        this._toggleProjection = () => {
                            var h;
                            const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
                            this._map.setProjection(e !== "mercator" && e ? {
                                type: "mercator"
                            } : {
                                type: "globe"
                            }),
                            this._updateGlobeIcon()
                        }
                        ,
                        this._updateGlobeIcon = () => {
                            var h;
                            this._globeButton.classList.remove("maplibregl-ctrl-globe"),
                            this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"),
                            ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"),
                            this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"),
                            this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
                        }
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._globeButton = X.create("button", "maplibregl-ctrl-globe", this._container),
                        X.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"),
                        this._globeButton.type = "button",
                        this._globeButton.addEventListener("click", this._toggleProjection),
                        this._updateGlobeIcon(),
                        this._map.on("styledata", this._updateGlobeIcon),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("styledata", this._updateGlobeIcon),
                        this._globeButton.removeEventListener("click", this._toggleProjection),
                        this._map = void 0
                    }
                }
                ,
                T.Hash = yl,
                T.ImageSource = Ft,
                T.KeyboardHandler = wl,
                T.LngLatBounds = dt,
                T.LogoControl = td,
                T.Map = class extends ed {
                    constructor(h) {
                        var e, n;
                        o.cw.mark(o.cx.create);
                        const s = Object.assign(Object.assign(Object.assign({}, ha), h), {
                            canvasContextAttributes: Object.assign(Object.assign({}, ha.canvasContextAttributes), h.canvasContextAttributes)
                        });
                        if (s.minZoom != null && s.maxZoom != null && s.minZoom > s.maxZoom)
                            throw new Error("maxZoom must be greater than or equal to minZoom");
                        if (s.minPitch != null && s.maxPitch != null && s.minPitch > s.maxPitch)
                            throw new Error("maxPitch must be greater than or equal to minPitch");
                        if (s.minPitch != null && s.minPitch < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (s.maxPitch != null && s.maxPitch > 180)
                            throw new Error("maxPitch must be less than or equal to 180");
                        const u = new wi
                          , d = new hn;
                        if (s.minZoom !== void 0 && u.setMinZoom(s.minZoom),
                        s.maxZoom !== void 0 && u.setMaxZoom(s.maxZoom),
                        s.minPitch !== void 0 && u.setMinPitch(s.minPitch),
                        s.maxPitch !== void 0 && u.setMaxPitch(s.maxPitch),
                        s.renderWorldCopies !== void 0 && u.setRenderWorldCopies(s.renderWorldCopies),
                        super(u, d, {
                            bearingSnap: s.bearingSnap
                        }),
                        this._idleTriggered = !1,
                        this._crossFadingFactor = 1,
                        this._renderTaskQueue = new Na,
                        this._controls = [],
                        this._mapId = o.a7(),
                        this._contextLost = y => {
                            y.preventDefault(),
                            this._frameRequest && (this._frameRequest.abort(),
                            this._frameRequest = null),
                            this.fire(new o.l("webglcontextlost",{
                                originalEvent: y
                            }))
                        }
                        ,
                        this._contextRestored = y => {
                            this._setupPainter(),
                            this.resize(),
                            this._update(),
                            this.fire(new o.l("webglcontextrestored",{
                                originalEvent: y
                            }))
                        }
                        ,
                        this._onMapScroll = y => {
                            if (y.target === this._container)
                                return this._container.scrollTop = 0,
                                this._container.scrollLeft = 0,
                                !1
                        }
                        ,
                        this._onWindowOnline = () => {
                            this._update()
                        }
                        ,
                        this._interactive = s.interactive,
                        this._maxTileCacheSize = s.maxTileCacheSize,
                        this._maxTileCacheZoomLevels = s.maxTileCacheZoomLevels,
                        this._canvasContextAttributes = Object.assign({}, s.canvasContextAttributes),
                        this._trackResize = s.trackResize === !0,
                        this._bearingSnap = s.bearingSnap,
                        this._centerClampedToGround = s.centerClampedToGround,
                        this._refreshExpiredTiles = s.refreshExpiredTiles === !0,
                        this._fadeDuration = s.fadeDuration,
                        this._crossSourceCollisions = s.crossSourceCollisions === !0,
                        this._collectResourceTiming = s.collectResourceTiming === !0,
                        this._locale = Object.assign(Object.assign({}, jn), s.locale),
                        this._clickTolerance = s.clickTolerance,
                        this._overridePixelRatio = s.pixelRatio,
                        this._maxCanvasSize = s.maxCanvasSize,
                        this.transformCameraUpdate = s.transformCameraUpdate,
                        this.cancelPendingTileRequestsWhileZooming = s.cancelPendingTileRequestsWhileZooming === !0,
                        this._imageQueueHandle = Ne.addThrottleControl(( () => this.isMoving())),
                        this._requestManager = new ft(s.transformRequest),
                        typeof s.container == "string") {
                            if (this._container = document.getElementById(s.container),
                            !this._container)
                                throw new Error(`Container '${s.container}' not found.`)
                        } else {
                            if (!(s.container instanceof HTMLElement))
                                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                            this._container = s.container
                        }
                        if (s.maxBounds && this.setMaxBounds(s.maxBounds),
                        this._setupContainer(),
                        this._setupPainter(),
                        this.on("move", ( () => this._update(!1))),
                        this.on("moveend", ( () => this._update(!1))),
                        this.on("zoom", ( () => this._update(!0))),
                        this.on("terrain", ( () => {
                            this.painter.terrainFacilitator.dirty = !0,
                            this._update(!0)
                        }
                        )),
                        this.once("idle", ( () => {
                            this._idleTriggered = !0
                        }
                        )),
                        typeof window < "u") {
                            addEventListener("online", this._onWindowOnline, !1);
                            let y = !1;
                            const w = Ts((P => {
                                this._trackResize && !this._removed && (this.resize(P),
                                this.redraw())
                            }
                            ), 50);
                            this._resizeObserver = new ResizeObserver((P => {
                                y ? w(P) : y = !0
                            }
                            )),
                            this._resizeObserver.observe(this._container)
                        }
                        this.handlers = new Wc(this,s),
                        this._hash = s.hash && new yl(typeof s.hash == "string" && s.hash || void 0).addTo(this),
                        this._hash && this._hash._onHashChange() || (this.jumpTo({
                            center: s.center,
                            elevation: s.elevation,
                            zoom: s.zoom,
                            bearing: s.bearing,
                            pitch: s.pitch,
                            roll: s.roll
                        }),
                        s.bounds && (this.resize(),
                        this.fitBounds(s.bounds, o.e({}, s.fitBoundsOptions, {
                            duration: 0
                        }))));
                        const m = typeof s.style == "string" || ((n = (e = s.style) === null || e === void 0 ? void 0 : e.projection) === null || n === void 0 ? void 0 : n.type) !== "globe";
                        this.resize(null, m),
                        this._localIdeographFontFamily = s.localIdeographFontFamily,
                        this._validateStyle = s.validateStyle,
                        s.style && this.setStyle(s.style, {
                            localIdeographFontFamily: s.localIdeographFontFamily
                        }),
                        s.attributionControl && this.addControl(new Kc(typeof s.attributionControl == "boolean" ? void 0 : s.attributionControl)),
                        s.maplibreLogo && this.addControl(new td, s.logoPosition),
                        this.on("style.load", ( () => {
                            if (m || this._resizeTransform(),
                            this.transform.unmodified) {
                                const y = o.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                                this.jumpTo(y)
                            }
                        }
                        )),
                        this.on("data", (y => {
                            this._update(y.dataType === "style"),
                            this.fire(new o.l(`${y.dataType}data`,y))
                        }
                        )),
                        this.on("dataloading", (y => {
                            this.fire(new o.l(`${y.dataType}dataloading`,y))
                        }
                        )),
                        this.on("dataabort", (y => {
                            this.fire(new o.l("sourcedataabort",y))
                        }
                        ))
                    }
                    _getMapId() {
                        return this._mapId
                    }
                    setGlobalStateProperty(h, e) {
                        return this.style.setGlobalStateProperty(h, e),
                        this._update(!0)
                    }
                    getGlobalState() {
                        return this.style.getGlobalState()
                    }
                    addControl(h, e) {
                        if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"),
                        !h || !h.onAdd)
                            return this.fire(new o.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const n = h.onAdd(this);
                        this._controls.push(h);
                        const s = this._controlPositions[e];
                        return e.indexOf("bottom") !== -1 ? s.insertBefore(n, s.firstChild) : s.appendChild(n),
                        this
                    }
                    removeControl(h) {
                        if (!h || !h.onRemove)
                            return this.fire(new o.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const e = this._controls.indexOf(h);
                        return e > -1 && this._controls.splice(e, 1),
                        h.onRemove(this),
                        this
                    }
                    hasControl(h) {
                        return this._controls.indexOf(h) > -1
                    }
                    calculateCameraOptionsFromTo(h, e, n, s) {
                        return s == null && this.terrain && (s = this.terrain.getElevationForLngLatZoom(n, this.transform.tileZoom)),
                        super.calculateCameraOptionsFromTo(h, e, n, s)
                    }
                    resize(h, e=!0) {
                        const [n,s] = this._containerDimensions()
                          , u = this._getClampedPixelRatio(n, s);
                        if (this._resizeCanvas(n, s, u),
                        this.painter.resize(n, s, u),
                        this.painter.overLimit()) {
                            const m = this.painter.context.gl;
                            this._maxCanvasSize = [m.drawingBufferWidth, m.drawingBufferHeight];
                            const y = this._getClampedPixelRatio(n, s);
                            this._resizeCanvas(n, s, y),
                            this.painter.resize(n, s, y)
                        }
                        this._resizeTransform(e);
                        const d = !this._moving;
                        return d && (this.stop(),
                        this.fire(new o.l("movestart",h)).fire(new o.l("move",h))),
                        this.fire(new o.l("resize",h)),
                        d && this.fire(new o.l("moveend",h)),
                        this
                    }
                    _resizeTransform(h=!0) {
                        var e;
                        const [n,s] = this._containerDimensions();
                        this.transform.resize(n, s, h),
                        (e = this._requestedCameraState) === null || e === void 0 || e.resize(n, s, h)
                    }
                    _getClampedPixelRatio(h, e) {
                        const {0: n, 1: s} = this._maxCanvasSize
                          , u = this.getPixelRatio()
                          , d = h * u
                          , m = e * u;
                        return Math.min(d > n ? n / d : 1, m > s ? s / m : 1) * u
                    }
                    getPixelRatio() {
                        var h;
                        return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio
                    }
                    setPixelRatio(h) {
                        this._overridePixelRatio = h,
                        this.resize()
                    }
                    getBounds() {
                        return this.transform.getBounds()
                    }
                    getMaxBounds() {
                        return this.transform.getMaxBounds()
                    }
                    setMaxBounds(h) {
                        return this.transform.setMaxBounds(dt.convert(h)),
                        this._update()
                    }
                    setMinZoom(h) {
                        if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom)
                            return this.transform.setMinZoom(h),
                            this._update(),
                            this.getZoom() < h && this.setZoom(h),
                            this;
                        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                    }
                    getMinZoom() {
                        return this.transform.minZoom
                    }
                    setMaxZoom(h) {
                        if ((h = h ?? 22) >= this.transform.minZoom)
                            return this.transform.setMaxZoom(h),
                            this._update(),
                            this.getZoom() > h && this.setZoom(h),
                            this;
                        throw new Error("maxZoom must be greater than the current minZoom")
                    }
                    getMaxZoom() {
                        return this.transform.maxZoom
                    }
                    setMinPitch(h) {
                        if ((h = h ?? 0) < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (h >= 0 && h <= this.transform.maxPitch)
                            return this.transform.setMinPitch(h),
                            this._update(),
                            this.getPitch() < h && this.setPitch(h),
                            this;
                        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                    }
                    getMinPitch() {
                        return this.transform.minPitch
                    }
                    setMaxPitch(h) {
                        if ((h = h ?? 60) > 180)
                            throw new Error("maxPitch must be less than or equal to 180");
                        if (h >= this.transform.minPitch)
                            return this.transform.setMaxPitch(h),
                            this._update(),
                            this.getPitch() > h && this.setPitch(h),
                            this;
                        throw new Error("maxPitch must be greater than the current minPitch")
                    }
                    getMaxPitch() {
                        return this.transform.maxPitch
                    }
                    getRenderWorldCopies() {
                        return this.transform.renderWorldCopies
                    }
                    setRenderWorldCopies(h) {
                        return this.transform.setRenderWorldCopies(h),
                        this._update()
                    }
                    project(h) {
                        return this.transform.locationToScreenPoint(o.S.convert(h), this.style && this.terrain)
                    }
                    unproject(h) {
                        return this.transform.screenPointToLocation(o.P.convert(h), this.terrain)
                    }
                    isMoving() {
                        var h;
                        return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving())
                    }
                    isZooming() {
                        var h;
                        return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming())
                    }
                    isRotating() {
                        var h;
                        return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating())
                    }
                    _createDelegatedListener(h, e, n) {
                        if (h === "mouseenter" || h === "mouseover") {
                            let s = !1;
                            return {
                                layers: e,
                                listener: n,
                                delegates: {
                                    mousemove: d => {
                                        const m = e.filter((w => this.getLayer(w)))
                                          , y = m.length !== 0 ? this.queryRenderedFeatures(d.point, {
                                            layers: m
                                        }) : [];
                                        y.length ? s || (s = !0,
                                        n.call(this, new Wn(h,this,d.originalEvent,{
                                            features: y
                                        }))) : s = !1
                                    }
                                    ,
                                    mouseout: () => {
                                        s = !1
                                    }
                                }
                            }
                        }
                        if (h === "mouseleave" || h === "mouseout") {
                            let s = !1;
                            return {
                                layers: e,
                                listener: n,
                                delegates: {
                                    mousemove: m => {
                                        const y = e.filter((w => this.getLayer(w)));
                                        (y.length !== 0 ? this.queryRenderedFeatures(m.point, {
                                            layers: y
                                        }) : []).length ? s = !0 : s && (s = !1,
                                        n.call(this, new Wn(h,this,m.originalEvent)))
                                    }
                                    ,
                                    mouseout: m => {
                                        s && (s = !1,
                                        n.call(this, new Wn(h,this,m.originalEvent)))
                                    }
                                }
                            }
                        }
                        {
                            const s = u => {
                                const d = e.filter((y => this.getLayer(y)))
                                  , m = d.length !== 0 ? this.queryRenderedFeatures(u.point, {
                                    layers: d
                                }) : [];
                                m.length && (u.features = m,
                                n.call(this, u),
                                delete u.features)
                            }
                            ;
                            return {
                                layers: e,
                                listener: n,
                                delegates: {
                                    [h]: s
                                }
                            }
                        }
                    }
                    _saveDelegatedListener(h, e) {
                        this._delegatedListeners = this._delegatedListeners || {},
                        this._delegatedListeners[h] = this._delegatedListeners[h] || [],
                        this._delegatedListeners[h].push(e)
                    }
                    _removeDelegatedListener(h, e, n) {
                        if (!this._delegatedListeners || !this._delegatedListeners[h])
                            return;
                        const s = this._delegatedListeners[h];
                        for (let u = 0; u < s.length; u++) {
                            const d = s[u];
                            if (d.listener === n && d.layers.length === e.length && d.layers.every((m => e.includes(m)))) {
                                for (const m in d.delegates)
                                    this.off(m, d.delegates[m]);
                                return void s.splice(u, 1)
                            }
                        }
                    }
                    on(h, e, n) {
                        if (n === void 0)
                            return super.on(h, e);
                        const s = typeof e == "string" ? [e] : e
                          , u = this._createDelegatedListener(h, s, n);
                        this._saveDelegatedListener(h, u);
                        for (const d in u.delegates)
                            this.on(d, u.delegates[d]);
                        return {
                            unsubscribe: () => {
                                this._removeDelegatedListener(h, s, n)
                            }
                        }
                    }
                    once(h, e, n) {
                        if (n === void 0)
                            return super.once(h, e);
                        const s = typeof e == "string" ? [e] : e
                          , u = this._createDelegatedListener(h, s, n);
                        for (const d in u.delegates) {
                            const m = u.delegates[d];
                            u.delegates[d] = (...y) => {
                                this._removeDelegatedListener(h, s, n),
                                m(...y)
                            }
                        }
                        this._saveDelegatedListener(h, u);
                        for (const d in u.delegates)
                            this.once(d, u.delegates[d]);
                        return this
                    }
                    off(h, e, n) {
                        return n === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, n),
                        this)
                    }
                    queryRenderedFeatures(h, e) {
                        if (!this.style)
                            return [];
                        let n;
                        const s = h instanceof o.P || Array.isArray(h)
                          , u = s ? h : [[0, 0], [this.transform.width, this.transform.height]];
                        if (e = e || (s ? {} : h) || {},
                        u instanceof o.P || typeof u[0] == "number")
                            n = [o.P.convert(u)];
                        else {
                            const d = o.P.convert(u[0])
                              , m = o.P.convert(u[1]);
                            n = [d, new o.P(m.x,d.y), m, new o.P(d.x,m.y), d]
                        }
                        return this.style.queryRenderedFeatures(n, e, this.transform)
                    }
                    querySourceFeatures(h, e) {
                        return this.style.querySourceFeatures(h, e)
                    }
                    setStyle(h, e) {
                        return (e = o.e({}, {
                            localIdeographFontFamily: this._localIdeographFontFamily,
                            validate: this._validateStyle
                        }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e),
                        this) : (this._localIdeographFontFamily = e.localIdeographFontFamily,
                        this._updateStyle(h, e))
                    }
                    setTransformRequest(h) {
                        return this._requestManager.setTransformRequest(h),
                        this
                    }
                    _getUIString(h) {
                        const e = this._locale[h];
                        if (e == null)
                            throw new Error(`Missing UI string '${h}'`);
                        return e
                    }
                    _updateStyle(h, e) {
                        var n, s;
                        if (e.transformStyle && this.style && !this.style._loaded)
                            return void this.style.once("style.load", ( () => this._updateStyle(h, e)));
                        const u = this.style && e.transformStyle ? this.style.serialize() : void 0;
                        return this.style && (this.style.setEventedParent(null),
                        this.style._remove(!h)),
                        h ? (this.style = new gc(this,e || {}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        typeof h == "string" ? this.style.loadURL(h, e, u) : this.style.loadJSON(h, e, u),
                        this) : ((s = (n = this.style) === null || n === void 0 ? void 0 : n.projection) === null || s === void 0 || s.destroy(),
                        delete this.style,
                        this)
                    }
                    _lazyInitEmptyStyle() {
                        this.style || (this.style = new gc(this,{}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        this.style.loadEmpty())
                    }
                    _diffStyle(h, e) {
                        if (typeof h == "string") {
                            const n = this._requestManager.transformRequest(h, "Style");
                            o.j(n, new AbortController).then((s => {
                                this._updateDiff(s.data, e)
                            }
                            )).catch((s => {
                                s && this.fire(new o.k(s))
                            }
                            ))
                        } else
                            typeof h == "object" && this._updateDiff(h, e)
                    }
                    _updateDiff(h, e) {
                        try {
                            this.style.setState(h, e) && this._update(!0)
                        } catch (n) {
                            o.w(`Unable to perform style diff: ${n.message || n.error || n}.  Rebuilding the style from scratch.`),
                            this._updateStyle(h, e)
                        }
                    }
                    getStyle() {
                        if (this.style)
                            return this.style.serialize()
                    }
                    isStyleLoaded() {
                        return this.style ? this.style.loaded() : o.w("There is no style added to the map.")
                    }
                    addSource(h, e) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addSource(h, e),
                        this._update(!0)
                    }
                    isSourceLoaded(h) {
                        const e = this.style && this.style.sourceCaches[h];
                        if (e !== void 0)
                            return e.loaded();
                        this.fire(new o.k(new Error(`There is no source with ID '${h}'`)))
                    }
                    setTerrain(h) {
                        if (this.style._checkLoaded(),
                        this._terrainDataCallback && this.style.off("data", this._terrainDataCallback),
                        h) {
                            const e = this.style.sourceCaches[h.source];
                            if (!e)
                                throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
                            this.terrain === null && e.reload();
                            for (const n in this.style._layers) {
                                const s = this.style._layers[n];
                                s.type === "hillshade" && s.source === h.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."),
                                s.type === "color-relief" && s.source === h.source && o.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
                            }
                            this.terrain = new Rr(this.painter,e,h),
                            this.painter.renderToTexture = new Pl(this.painter,this.terrain),
                            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                            this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                            this._terrainDataCallback = n => {
                                var s;
                                n.dataType === "style" ? this.terrain.sourceCache.freeRtt() : n.dataType === "source" && n.tile && (n.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                                this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))),
                                ((s = n.source) === null || s === void 0 ? void 0 : s.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(n.tile.tileID))
                            }
                            ,
                            this.style.on("data", this._terrainDataCallback)
                        } else
                            this.terrain && this.terrain.sourceCache.destruct(),
                            this.terrain = null,
                            this.painter.renderToTexture && this.painter.renderToTexture.destruct(),
                            this.painter.renderToTexture = null,
                            this.transform.setMinElevationForCurrentTile(0),
                            this._centerClampedToGround && this.transform.setElevation(0);
                        return this.fire(new o.l("terrain",{
                            terrain: h
                        })),
                        this
                    }
                    getTerrain() {
                        var h, e;
                        return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null
                    }
                    areTilesLoaded() {
                        const h = this.style && this.style.sourceCaches;
                        for (const e in h) {
                            const n = h[e]._tiles;
                            for (const s in n) {
                                const u = n[s];
                                if (u.state !== "loaded" && u.state !== "errored")
                                    return !1
                            }
                        }
                        return !0
                    }
                    removeSource(h) {
                        return this.style.removeSource(h),
                        this._update(!0)
                    }
                    getSource(h) {
                        return this.style.getSource(h)
                    }
                    setSourceTileLodParams(h, e, n) {
                        if (n) {
                            const s = this.getSource(n);
                            if (!s)
                                throw new Error(`There is no source with ID "${n}", cannot set LOD parameters`);
                            s.calculateTileZoom = ot(Math.max(1, h), Math.max(1, e))
                        } else
                            for (const s in this.style.sourceCaches)
                                this.style.sourceCaches[s].getSource().calculateTileZoom = ot(Math.max(1, h), Math.max(1, e));
                        return this._update(!0),
                        this
                    }
                    refreshTiles(h, e) {
                        const n = this.style.sourceCaches[h];
                        if (!n)
                            throw new Error(`There is no source cache with ID "${h}", cannot refresh tile`);
                        e === void 0 ? n.reload(!0) : n.refreshTiles(e.map((s => new o.a4(s.z,s.x,s.y))))
                    }
                    addImage(h, e, n={}) {
                        const {pixelRatio: s=1, sdf: u=!1, stretchX: d, stretchY: m, content: y, textFitWidth: w, textFitHeight: P} = n;
                        if (this._lazyInitEmptyStyle(),
                        !(e instanceof HTMLImageElement || o.b(e))) {
                            if (e.width === void 0 || e.height === void 0)
                                return this.fire(new o.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                            {
                                const {width: M, height: D, data: z} = e
                                  , B = e;
                                return this.style.addImage(h, {
                                    data: new o.R({
                                        width: M,
                                        height: D
                                    },new Uint8Array(z)),
                                    pixelRatio: s,
                                    stretchX: d,
                                    stretchY: m,
                                    content: y,
                                    textFitWidth: w,
                                    textFitHeight: P,
                                    sdf: u,
                                    version: 0,
                                    userImage: B
                                }),
                                B.onAdd && B.onAdd(this, h),
                                this
                            }
                        }
                        {
                            const {width: M, height: D, data: z} = ye.getImageData(e);
                            this.style.addImage(h, {
                                data: new o.R({
                                    width: M,
                                    height: D
                                },z),
                                pixelRatio: s,
                                stretchX: d,
                                stretchY: m,
                                content: y,
                                textFitWidth: w,
                                textFitHeight: P,
                                sdf: u,
                                version: 0
                            })
                        }
                    }
                    updateImage(h, e) {
                        const n = this.style.getImage(h);
                        if (!n)
                            return this.fire(new o.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                        const s = e instanceof HTMLImageElement || o.b(e) ? ye.getImageData(e) : e
                          , {width: u, height: d, data: m} = s;
                        if (u === void 0 || d === void 0)
                            return this.fire(new o.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        if (u !== n.data.width || d !== n.data.height)
                            return this.fire(new o.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
                        const y = !(e instanceof HTMLImageElement || o.b(e));
                        return n.data.replace(m, y),
                        this.style.updateImage(h, n),
                        this
                    }
                    getImage(h) {
                        return this.style.getImage(h)
                    }
                    hasImage(h) {
                        return h ? !!this.style.getImage(h) : (this.fire(new o.k(new Error("Missing required image id"))),
                        !1)
                    }
                    removeImage(h) {
                        this.style.removeImage(h)
                    }
                    loadImage(h) {
                        return Ne.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController)
                    }
                    listImages() {
                        return this.style.listImages()
                    }
                    addLayer(h, e) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addLayer(h, e),
                        this._update(!0)
                    }
                    moveLayer(h, e) {
                        return this.style.moveLayer(h, e),
                        this._update(!0)
                    }
                    removeLayer(h) {
                        return this.style.removeLayer(h),
                        this._update(!0)
                    }
                    getLayer(h) {
                        return this.style.getLayer(h)
                    }
                    getLayersOrder() {
                        return this.style.getLayersOrder()
                    }
                    setLayerZoomRange(h, e, n) {
                        return this.style.setLayerZoomRange(h, e, n),
                        this._update(!0)
                    }
                    setFilter(h, e, n={}) {
                        return this.style.setFilter(h, e, n),
                        this._update(!0)
                    }
                    getFilter(h) {
                        return this.style.getFilter(h)
                    }
                    setPaintProperty(h, e, n, s={}) {
                        return this.style.setPaintProperty(h, e, n, s),
                        this._update(!0)
                    }
                    getPaintProperty(h, e) {
                        return this.style.getPaintProperty(h, e)
                    }
                    setLayoutProperty(h, e, n, s={}) {
                        return this.style.setLayoutProperty(h, e, n, s),
                        this._update(!0)
                    }
                    getLayoutProperty(h, e) {
                        return this.style.getLayoutProperty(h, e)
                    }
                    setGlyphs(h, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setGlyphs(h, e),
                        this._update(!0)
                    }
                    getGlyphs() {
                        return this.style.getGlyphsUrl()
                    }
                    addSprite(h, e, n={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addSprite(h, e, n, (s => {
                            s || this._update(!0)
                        }
                        )),
                        this
                    }
                    removeSprite(h) {
                        return this._lazyInitEmptyStyle(),
                        this.style.removeSprite(h),
                        this._update(!0)
                    }
                    getSprite() {
                        return this.style.getSprite()
                    }
                    setSprite(h, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setSprite(h, e, (n => {
                            n || this._update(!0)
                        }
                        )),
                        this
                    }
                    setLight(h, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setLight(h, e),
                        this._update(!0)
                    }
                    getLight() {
                        return this.style.getLight()
                    }
                    setSky(h, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setSky(h, e),
                        this._update(!0)
                    }
                    getSky() {
                        return this.style.getSky()
                    }
                    setFeatureState(h, e) {
                        return this.style.setFeatureState(h, e),
                        this._update()
                    }
                    removeFeatureState(h, e) {
                        return this.style.removeFeatureState(h, e),
                        this._update()
                    }
                    getFeatureState(h) {
                        return this.style.getFeatureState(h)
                    }
                    getContainer() {
                        return this._container
                    }
                    getCanvasContainer() {
                        return this._canvasContainer
                    }
                    getCanvas() {
                        return this._canvas
                    }
                    _containerDimensions() {
                        let h = 0
                          , e = 0;
                        return this._container && (h = this._container.clientWidth || 400,
                        e = this._container.clientHeight || 300),
                        [h, e]
                    }
                    _setupContainer() {
                        const h = this._container;
                        h.classList.add("maplibregl-map");
                        const e = this._canvasContainer = X.create("div", "maplibregl-canvas-container", h);
                        this._interactive && e.classList.add("maplibregl-interactive"),
                        this._canvas = X.create("canvas", "maplibregl-canvas", e),
                        this._canvas.addEventListener("webglcontextlost", this._contextLost, !1),
                        this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"),
                        this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")),
                        this._canvas.setAttribute("role", "region");
                        const n = this._containerDimensions()
                          , s = this._getClampedPixelRatio(n[0], n[1]);
                        this._resizeCanvas(n[0], n[1], s);
                        const u = this._controlContainer = X.create("div", "maplibregl-control-container", h)
                          , d = this._controlPositions = {};
                        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((m => {
                            d[m] = X.create("div", `maplibregl-ctrl-${m} `, u)
                        }
                        )),
                        this._container.addEventListener("scroll", this._onMapScroll, !1)
                    }
                    _resizeCanvas(h, e, n) {
                        this._canvas.width = Math.floor(n * h),
                        this._canvas.height = Math.floor(n * e),
                        this._canvas.style.width = `${h}px`,
                        this._canvas.style.height = `${e}px`
                    }
                    _setupPainter() {
                        const h = Object.assign(Object.assign({}, this._canvasContextAttributes), {
                            alpha: !0,
                            depth: !0,
                            stencil: !0,
                            premultipliedAlpha: !0
                        });
                        let e = null;
                        this._canvas.addEventListener("webglcontextcreationerror", (s => {
                            e = {
                                requestedAttributes: h
                            },
                            s && (e.statusMessage = s.statusMessage,
                            e.type = s.type)
                        }
                        ), {
                            once: !0
                        });
                        let n = null;
                        if (n = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h),
                        !n) {
                            const s = "Failed to initialize WebGL";
                            throw e ? (e.message = s,
                            new Error(JSON.stringify(e))) : new Error(s)
                        }
                        this.painter = new jh(n,this.transform),
                        Se.testSupport(n)
                    }
                    migrateProjection(h, e) {
                        super.migrateProjection(h, e),
                        this.painter.transform = h,
                        this.fire(new o.l("projectiontransition",{
                            newProjection: this.style.projection.name
                        }))
                    }
                    loaded() {
                        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                    }
                    _update(h) {
                        return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h,
                        this._sourcesDirty = !0,
                        this.triggerRepaint(),
                        this) : this
                    }
                    _requestRenderFrame(h) {
                        return this._update(),
                        this._renderTaskQueue.add(h)
                    }
                    _cancelRenderFrame(h) {
                        this._renderTaskQueue.remove(h)
                    }
                    _render(h) {
                        var e, n, s, u, d;
                        const m = this._idleTriggered ? this._fadeDuration : 0
                          , y = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
                        if (this.painter.context.setDirty(),
                        this.painter.setBaseState(),
                        this._renderTaskQueue.run(h),
                        this._removed)
                            return;
                        let w = !1;
                        if (this.style && this._styleDirty) {
                            this._styleDirty = !1;
                            const D = this.transform.zoom
                              , z = ye.now();
                            this.style.zoomHistory.update(D, z);
                            const B = new o.F(D,{
                                now: z,
                                fadeDuration: m,
                                zoomHistory: this.style.zoomHistory,
                                transition: this.style.getTransition(),
                                globalState: this.style.getGlobalState()
                            })
                              , U = B.crossFadingFactor();
                            U === 1 && U === this._crossFadingFactor || (w = !0,
                            this._crossFadingFactor = U),
                            this.style.update(B)
                        }
                        const P = ((n = this.style.projection) === null || n === void 0 ? void 0 : n.transitionState) > 0 !== y;
                        (s = this.style.projection) === null || s === void 0 || s.setErrorQueryLatitudeDegrees(this.transform.center.lat),
                        this.transform.setTransitionState((u = this.style.projection) === null || u === void 0 ? void 0 : u.transitionState, (d = this.style.projection) === null || d === void 0 ? void 0 : d.latitudeErrorCorrectionRadians),
                        this.style && (this._sourcesDirty || P) && (this._sourcesDirty = !1,
                        this.style._updateSources(this.transform)),
                        this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain),
                        this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                        !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0),
                        this._centerClampedToGround && this.transform.setElevation(0)),
                        this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, m, this._crossSourceCollisions, P),
                        this.painter.render(this.style, {
                            showTileBoundaries: this.showTileBoundaries,
                            showOverdrawInspector: this._showOverdrawInspector,
                            rotating: this.isRotating(),
                            zooming: this.isZooming(),
                            moving: this.isMoving(),
                            fadeDuration: m,
                            showPadding: this.showPadding
                        }),
                        this.fire(new o.l("render")),
                        this.loaded() && !this._loaded && (this._loaded = !0,
                        o.cw.mark(o.cx.load),
                        this.fire(new o.l("load"))),
                        this.style && (this.style.hasTransitions() || w) && (this._styleDirty = !0),
                        this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
                        const M = this._sourcesDirty || this._styleDirty || this._placementDirty;
                        return M || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.l("idle")),
                        !this._loaded || this._fullyLoaded || M || (this._fullyLoaded = !0,
                        o.cw.mark(o.cx.fullLoad)),
                        this
                    }
                    redraw() {
                        return this.style && (this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._render(0)),
                        this
                    }
                    remove() {
                        var h;
                        this._hash && this._hash.remove();
                        for (const n of this._controls)
                            n.onRemove(this);
                        this._controls = [],
                        this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._renderTaskQueue.clear(),
                        this.painter.destroy(),
                        this.handlers.destroy(),
                        delete this.handlers,
                        this.setStyle(null),
                        typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1),
                        Ne.removeThrottleControl(this._imageQueueHandle),
                        (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
                        const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
                        e != null && e.loseContext && e.loseContext(),
                        this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1),
                        X.remove(this._canvasContainer),
                        X.remove(this._controlContainer),
                        this._container.removeEventListener("scroll", this._onMapScroll, !1),
                        this._container.classList.remove("maplibregl-map"),
                        o.cw.clearMetrics(),
                        this._removed = !0,
                        this.fire(new o.l("remove"))
                    }
                    triggerRepaint() {
                        this.style && !this._frameRequest && (this._frameRequest = new AbortController,
                        ye.frame(this._frameRequest, (h => {
                            o.cw.frame(h),
                            this._frameRequest = null;
                            try {
                                this._render(h)
                            } catch (e) {
                                if (!o.cy(e) && !(function(n) {
                                    return n.message === To
                                }
                                )(e))
                                    throw e
                            }
                        }
                        ), ( () => {}
                        )))
                    }
                    get showTileBoundaries() {
                        return !!this._showTileBoundaries
                    }
                    set showTileBoundaries(h) {
                        this._showTileBoundaries !== h && (this._showTileBoundaries = h,
                        this._update())
                    }
                    get showPadding() {
                        return !!this._showPadding
                    }
                    set showPadding(h) {
                        this._showPadding !== h && (this._showPadding = h,
                        this._update())
                    }
                    get showCollisionBoxes() {
                        return !!this._showCollisionBoxes
                    }
                    set showCollisionBoxes(h) {
                        this._showCollisionBoxes !== h && (this._showCollisionBoxes = h,
                        h ? this.style._generateCollisionBoxes() : this._update())
                    }
                    get showOverdrawInspector() {
                        return !!this._showOverdrawInspector
                    }
                    set showOverdrawInspector(h) {
                        this._showOverdrawInspector !== h && (this._showOverdrawInspector = h,
                        this._update())
                    }
                    get repaint() {
                        return !!this._repaint
                    }
                    set repaint(h) {
                        this._repaint !== h && (this._repaint = h,
                        this.triggerRepaint())
                    }
                    get vertices() {
                        return !!this._vertices
                    }
                    set vertices(h) {
                        this._vertices = h,
                        this._update()
                    }
                    get version() {
                        return rd
                    }
                    getCameraTargetElevation() {
                        return this.transform.elevation
                    }
                    getProjection() {
                        return this.style.getProjection()
                    }
                    setProjection(h) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setProjection(h),
                        this._update(!0)
                    }
                }
                ,
                T.MapMouseEvent = Wn,
                T.MapTouchEvent = qs,
                T.MapWheelEvent = qc,
                T.Marker = Xs,
                T.NavigationControl = class {
                    constructor(h) {
                        this._updateZoomButtons = () => {
                            const e = this._map.getZoom()
                              , n = e === this._map.getMaxZoom()
                              , s = e === this._map.getMinZoom();
                            this._zoomInButton.disabled = n,
                            this._zoomOutButton.disabled = s,
                            this._zoomInButton.setAttribute("aria-disabled", n.toString()),
                            this._zoomOutButton.setAttribute("aria-disabled", s.toString())
                        }
                        ,
                        this._rotateCompassArrow = () => {
                            this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
                        }
                        ,
                        this._setButtonTitle = (e, n) => {
                            const s = this._map._getUIString(`NavigationControl.${n}`);
                            e.title = s,
                            e.setAttribute("aria-label", s)
                        }
                        ,
                        this.options = o.e({}, bp, h),
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._container.addEventListener("contextmenu", (e => e.preventDefault())),
                        this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
                            originalEvent: e
                        }))),
                        X.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"),
                        this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
                            originalEvent: e
                        }))),
                        X.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")),
                        this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
                            this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                                originalEvent: e
                            }) : this._map.resetNorth({}, {
                                originalEvent: e
                            })
                        }
                        )),
                        this._compassIcon = X.create("span", "maplibregl-ctrl-icon", this._compass),
                        this._compassIcon.setAttribute("aria-hidden", "true"))
                    }
                    onAdd(h) {
                        return this._map = h,
                        this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        this._map.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                        this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow),
                        this._map.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        this._handler = new Lo(this._map,this._compass,this.options.visualizePitch)),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this.options.showZoom && this._map.off("zoom", this._updateZoomButtons),
                        this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow),
                        this._map.off("rotate", this._rotateCompassArrow),
                        this._handler.off(),
                        delete this._handler),
                        delete this._map
                    }
                    _createButton(h, e) {
                        const n = X.create("button", h, this._container);
                        return n.type = "button",
                        n.addEventListener("click", e),
                        n
                    }
                }
                ,
                T.Popup = class extends o.E {
                    constructor(h) {
                        super(),
                        this._updateOpacity = () => {
                            this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
                        }
                        ,
                        this.remove = () => (this._content && X.remove(this._content),
                        this._container && (X.remove(this._container),
                        delete this._container),
                        this._map && (this._map.off("move", this._update),
                        this._map.off("move", this._onClose),
                        this._map.off("click", this._onClose),
                        this._map.off("remove", this.remove),
                        this._map.off("mousemove", this._onMouseMove),
                        this._map.off("mouseup", this._onMouseUp),
                        this._map.off("drag", this._onDrag),
                        this._map._canvasContainer.classList.remove("maplibregl-track-pointer"),
                        delete this._map,
                        this.fire(new o.l("close"))),
                        this),
                        this._onMouseUp = e => {
                            this._update(e.point)
                        }
                        ,
                        this._onMouseMove = e => {
                            this._update(e.point)
                        }
                        ,
                        this._onDrag = e => {
                            this._update(e.point)
                        }
                        ,
                        this._update = e => {
                            if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                                return;
                            if (!this._container) {
                                if (this._container = X.create("div", "maplibregl-popup", this._map.getContainer()),
                                this._tip = X.create("div", "maplibregl-popup-tip", this._container),
                                this._container.appendChild(this._content),
                                this.options.className)
                                    for (const m of this.options.className.split(" "))
                                        this._container.classList.add(m);
                                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")),
                                this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
                            }
                            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth),
                            this._lngLat = Hi(this._lngLat, this._flatPos, this._map.transform, this._trackPointer),
                            this._trackPointer && !e)
                                return;
                            const n = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
                            this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
                            let s = this.options.anchor;
                            const u = Al(this.options.offset);
                            if (!s) {
                                const m = this._container.offsetWidth
                                  , y = this._container.offsetHeight;
                                let w;
                                w = n.y + u.bottom.y < y ? ["top"] : n.y > this._map.transform.height - y ? ["bottom"] : [],
                                n.x < m / 2 ? w.push("left") : n.x > this._map.transform.width - m / 2 && w.push("right"),
                                s = w.length === 0 ? "bottom" : w.join("-")
                            }
                            let d = n.add(u[s]);
                            this.options.subpixelPositioning || (d = d.round()),
                            X.setTransform(this._container, `${Il[s]} translate(${d.x}px,${d.y}px)`),
                            Ws(this._container, s, "popup"),
                            this._updateOpacity()
                        }
                        ,
                        this._onClose = () => {
                            this.remove()
                        }
                        ,
                        this.options = o.e(Object.create(Jc), h)
                    }
                    addTo(h) {
                        return this._map && this.remove(),
                        this._map = h,
                        this.options.closeOnClick && this._map.on("click", this._onClose),
                        this.options.closeOnMove && this._map.on("move", this._onClose),
                        this._map.on("remove", this.remove),
                        this._update(),
                        this._focusFirstElement(),
                        this._trackPointer ? (this._map.on("mousemove", this._onMouseMove),
                        this._map.on("mouseup", this._onMouseUp),
                        this._container && this._container.classList.add("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update),
                        this.fire(new o.l("open")),
                        this
                    }
                    isOpen() {
                        return !!this._map
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(h) {
                        return this._lngLat = o.S.convert(h),
                        this._pos = null,
                        this._flatPos = null,
                        this._trackPointer = !1,
                        this._update(),
                        this._map && (this._map.on("move", this._update),
                        this._map.off("mousemove", this._onMouseMove),
                        this._container && this._container.classList.remove("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.remove("maplibregl-track-pointer")),
                        this
                    }
                    trackPointer() {
                        return this._trackPointer = !0,
                        this._pos = null,
                        this._flatPos = null,
                        this._update(),
                        this._map && (this._map.off("move", this._update),
                        this._map.on("mousemove", this._onMouseMove),
                        this._map.on("drag", this._onDrag),
                        this._container && this._container.classList.add("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.add("maplibregl-track-pointer")),
                        this
                    }
                    getElement() {
                        return this._container
                    }
                    setText(h) {
                        return this.setDOMContent(document.createTextNode(h))
                    }
                    setHTML(h) {
                        const e = document.createDocumentFragment()
                          , n = document.createElement("body");
                        let s;
                        for (n.innerHTML = h; s = n.firstChild,
                        s; )
                            e.appendChild(s);
                        return this.setDOMContent(e)
                    }
                    getMaxWidth() {
                        var h;
                        return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth
                    }
                    setMaxWidth(h) {
                        return this.options.maxWidth = h,
                        this._update(),
                        this
                    }
                    setDOMContent(h) {
                        if (this._content)
                            for (; this._content.hasChildNodes(); )
                                this._content.firstChild && this._content.removeChild(this._content.firstChild);
                        else
                            this._content = X.create("div", "maplibregl-popup-content", this._container);
                        return this._content.appendChild(h),
                        this._createCloseButton(),
                        this._update(),
                        this._focusFirstElement(),
                        this
                    }
                    addClassName(h) {
                        return this._container && this._container.classList.add(h),
                        this
                    }
                    removeClassName(h) {
                        return this._container && this._container.classList.remove(h),
                        this
                    }
                    setOffset(h) {
                        return this.options.offset = h,
                        this._update(),
                        this
                    }
                    toggleClassName(h) {
                        if (this._container)
                            return this._container.classList.toggle(h)
                    }
                    setSubpixelPositioning(h) {
                        this.options.subpixelPositioning = h
                    }
                    _createCloseButton() {
                        this.options.closeButton && (this._closeButton = X.create("button", "maplibregl-popup-close-button", this._content),
                        this._closeButton.type = "button",
                        this._closeButton.innerHTML = "&#215;",
                        this._closeButton.addEventListener("click", this._onClose))
                    }
                    _focusFirstElement() {
                        if (!this.options.focusAfterOpen || !this._container)
                            return;
                        const h = this._container.querySelector(Qc);
                        h && h.focus()
                    }
                }
                ,
                T.RasterDEMTileSource = nr,
                T.RasterTileSource = Yt,
                T.ScaleControl = class {
                    constructor(h) {
                        this._onMove = () => {
                            Ml(this._map, this._container, this.options)
                        }
                        ,
                        this.setUnit = e => {
                            this.options.unit = e,
                            Ml(this._map, this._container, this.options)
                        }
                        ,
                        this.options = Object.assign(Object.assign({}, Do), h)
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()),
                        this._map.on("move", this._onMove),
                        this._onMove(),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("move", this._onMove),
                        this._map = void 0
                    }
                }
                ,
                T.ScrollZoomHandler = Xh,
                T.Style = gc,
                T.TerrainControl = class {
                    constructor(h) {
                        this._toggleTerrain = () => {
                            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options),
                            this._updateTerrainIcon()
                        }
                        ,
                        this._updateTerrainIcon = () => {
                            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"),
                            this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"),
                            this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"),
                            this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"),
                            this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
                        }
                        ,
                        this.options = h
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._terrainButton = X.create("button", "maplibregl-ctrl-terrain", this._container),
                        X.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"),
                        this._terrainButton.type = "button",
                        this._terrainButton.addEventListener("click", this._toggleTerrain),
                        this._updateTerrainIcon(),
                        this._map.on("terrain", this._updateTerrainIcon),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("terrain", this._updateTerrainIcon),
                        this._map = void 0
                    }
                }
                ,
                T.TwoFingersTouchPitchHandler = bl,
                T.TwoFingersTouchRotateHandler = Gs,
                T.TwoFingersTouchZoomHandler = xl,
                T.TwoFingersTouchZoomRotateHandler = Jh,
                T.VectorTileSource = Xt,
                T.VideoSource = dr,
                T.addSourceType = (h, e) => o._(void 0, void 0, void 0, (function*() {
                    if (jr(h))
                        throw new Error(`A source type called "${h}" already exists.`);
                    ( (n, s) => {
                        Ir[n] = s
                    }
                    )(h, e)
                }
                )),
                T.clearPrewarmedResources = function() {
                    const h = We;
                    h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(Pe),
                    We = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
                }
                ,
                T.createTileMesh = mc,
                T.getMaxParallelImageRequests = function() {
                    return o.a.MAX_PARALLEL_IMAGE_REQUESTS
                }
                ,
                T.getRTLTextPluginStatus = function() {
                    return kr().getRTLTextPluginStatus()
                }
                ,
                T.getVersion = function() {
                    return eu
                }
                ,
                T.getWorkerCount = function() {
                    return Me.workerCount
                }
                ,
                T.getWorkerUrl = function() {
                    return o.a.WORKER_URL
                }
                ,
                T.importScriptInWorkers = function(h) {
                    return tt().broadcast("IS", h)
                }
                ,
                T.prewarm = function() {
                    _t().acquire(Pe)
                }
                ,
                T.setMaxParallelImageRequests = function(h) {
                    o.a.MAX_PARALLEL_IMAGE_REQUESTS = h
                }
                ,
                T.setRTLTextPlugin = function(h, e) {
                    return kr().setRTLTextPlugin(h, e)
                }
                ,
                T.setWorkerCount = function(h) {
                    Me.workerCount = h
                }
                ,
                T.setWorkerUrl = function(h) {
                    o.a.WORKER_URL = h
                }
            }
            ));
            var O = _;
            return O
        }
        ))
    }
    )(Pd)),
    Pd.exports
}
var CP = TP();
const bd = nm(CP);
class fg {
    constructor(l) {
        lr(this, "gm");
        lr(this, "markers", new Map);
        lr(this, "canvases", new Map);
        lr(this, "canvasSize");
        lr(this, "canvasOpacity", .8);
        this.input = l,
        this.gm = new hc(this.input.tileSize);
        const _ = rv(l.img);
        this.canvasSize = Math.ceil(2e3 / _)
    }
    place([l,_]) {
        const C = this.gm.latLonToPixelsFloor(l, _, this.input.zoom)
          , L = this.getMarkerId(C)
          , O = this.gm.latLonToPixelBoundsLatLon(l, _, this.input.zoom)
          , T = this.input.map;
        if (this.input.markerFn && !this.markers.has(L)) {
            const pe = this.input.markerFn();
            pe.setLngLat({
                lat: O.min[0],
                lng: (O.max[1] + O.min[1]) / 2
            }).addTo(T),
            this.markers.set(L, pe)
        }
        const {key: o, pos: $, innerPos: W} = this.getCanvasPos(C);
        let ie = this.canvases.get(o);
        if (!ie) {
            const pe = this.canvasSize
              , ye = $.x * pe
              , X = $.y * pe
              , Se = ye + pe - 1
              , we = X + pe - 1
              , Re = this.gm.pixelsToLatLon(ye, we + 1, this.input.zoom)
              , ke = this.gm.pixelsToLatLon(Se + 1, X, this.input.zoom);
            ie = new SP({
                id: `${this.input.id}-${o}`,
                img: this.input.img,
                canvasSize: this.canvasSize,
                coordinates: rm({
                    min: Re,
                    max: ke
                }),
                layerPaint: {
                    "raster-resampling": "nearest",
                    "raster-opacity": this.canvasOpacity
                }
            }),
            ie.addTo(this.input.map),
            this.canvases.set(o, ie)
        }
        ie.place(W.x, W.y)
    }
    clear() {
        const l = this.input.map;
        for (const _ of this.canvases.values())
            _.removeFrom(l),
            _.removeDOM();
        this.canvases.clear();
        for (const _ of this.markers.values())
            _.remove();
        this.markers.clear()
    }
    clearAndPlace(l) {
        this.clear(),
        this.place(l)
    }
    remove([l,_]) {
        let C = !1;
        const L = this.gm.latLonToPixelsFloor(l, _, this.input.zoom)
          , {key: O, innerPos: T} = this.getCanvasPos(L)
          , o = this.canvases.get(O);
        o && (C = o.remove(T.x, T.y),
        o.annotationsCount() === 0 && (this.canvases.delete(O),
        o.removeFrom(this.input.map),
        o.removeDOM()));
        const $ = this.getMarkerId(L)
          , W = this.markers.get($);
        return W == null || W.remove(),
        this.markers.delete($),
        C
    }
    setCanvasOpacity(l) {
        this.canvasOpacity = l;
        for (const _ of this.canvases.values())
            _.setOpacity(l)
    }
    getMarkerId([l,_]) {
        return `${this.input.id}:${l},${_}`
    }
    getCanvasPos([l,_]) {
        const C = {
            x: Math.floor(l / this.canvasSize),
            y: Math.floor(_ / this.canvasSize)
        }
          , L = {
            x: l % this.canvasSize,
            y: _ % this.canvasSize
        }
          , O = `${C.x},${C.y}`;
        return {
            pos: C,
            innerPos: L,
            key: O
        }
    }
}
class SP {
    constructor(l) {
        lr(this, "annotations", new Set);
        lr(this, "canvas");
        lr(this, "imgSize");
        lr(this, "maps", new Set);
        this.input = l,
        this.imgSize = rv(l.img),
        this.canvas = document.createElement("canvas"),
        this.canvas.width = this.input.canvasSize * this.imgSize,
        this.canvas.height = this.input.canvasSize * this.imgSize
    }
    place(l, _) {
        const C = this.getPixelKey(l, _);
        if (this.annotations.has(C))
            return !1;
        const L = this.canvas.getContext("2d");
        if (L) {
            const O = l * this.imgSize
              , T = _ * this.imgSize;
            L.drawImage(this.input.img, O, T)
        }
        return this.annotations.add(C),
        !0
    }
    remove(l, _) {
        const C = this.getPixelKey(l, _);
        if (!this.annotations.has(C))
            return !1;
        const L = this.canvas.getContext("2d");
        if (L) {
            const O = l * this.imgSize
              , T = _ * this.imgSize;
            L.clearRect(O, T, this.imgSize, this.imgSize)
        }
        return this.annotations.delete(C),
        !0
    }
    addTo(l) {
        const _ = this.input.id;
        l.getSource(_) || l.addSource(_, {
            type: "canvas",
            canvas: this.canvas,
            coordinates: this.input.coordinates
        }),
        l.getLayer(_) || l.addLayer({
            id: _,
            type: "raster",
            source: _,
            paint: this.input.layerPaint
        }),
        this.maps.add(l)
    }
    removeFrom(l) {
        const {id: _} = this.input;
        l.getLayer(_) && l.removeLayer(_),
        l.getSource(_) && l.removeSource(_),
        this.maps.delete(l)
    }
    removeDOM() {
        this.canvas.remove()
    }
    annotationsCount() {
        return this.annotations.size
    }
    setOpacity(l) {
        for (const _ of this.maps.values())
            _.setPaintProperty(this.input.id, "raster-opacity", l)
    }
    getPixelKey(l, _) {
        return `${l},${_}`
    }
}
function rv(b) {
    return Math.max(b.naturalWidth, b.naturalHeight)
}
function PP() {
    return window.matchMedia("(display-mode: standalone)").matches || "standalone"in window.navigator && window.navigator.standalone === !0
}
function Cu(b, l) {
    return l.includes(b)
}
function IP(b) {
    const l = {
        opaque: !0
    }
      , _ = b.searchParams.get("lat")
      , C = b.searchParams.get("lng");
    _ && C && (l.pos = {
        lat: parseFloat(_),
        lng: parseFloat(C)
    });
    const L = b.searchParams.get("zoom");
    L && (l.zoom = parseFloat(L));
    const O = b.searchParams.get("season");
    O && (l.season = parseInt(O));
    const T = b.searchParams.get("opaque");
    return T && (l.opaque = T !== "0"),
    b.searchParams.get("select") && (l.select = !0),
    l.newUser = !!b.searchParams.get("new-user"),
    l.alliance = !!b.searchParams.get("alliance"),
    l
}
function MP(b, l) {
    return b = new URL(b),
    l.pos !== void 0 && (b.searchParams.set("lat", l.pos.lat.toString()),
    b.searchParams.set("lng", l.pos.lng.toString())),
    l.zoom !== void 0 && b.searchParams.set("zoom", l.zoom.toString()),
    l.season !== void 0 && b.searchParams.set("season", l.season.toString()),
    l.opaque !== void 0 && b.searchParams.set("opaque", l.opaque ? "1" : "0"),
    l.newUser !== void 0 && b.searchParams.set("new-user", l.newUser ? "1" : "0"),
    l.alliance !== void 0 && b.searchParams.set("alliance", l.alliance ? "1" : "0"),
    l.select && b.searchParams.set("alliance", "1"),
    b
}
const Id = zn({
    shouldReload: !0
});
var AP = Ie('<legend class="fieldset-legend"> </legend>')
  , kP = Ie('<span class="text-base-content/80"> </span>')
  , EP = Ie('<fieldset class="fieldset"><!> <textarea></textarea> <div class="flex items-center justify-between text-xs"><span class="text-error"> </span> <!></div></fieldset>');
function iv(b, l) {
    Sr(l, !0);
    let _ = Et(l, "value", 15)
      , C = Et(l, "validate", 15)
      , L = Qt(l, ["$$slots", "$$events", "$$legacy", "label", "placeholder", "value", "max", "min", "validate"])
      , O = nt("");
    const T = lt( () => {
        var ke;
        return ((ke = _()) == null ? void 0 : ke.length) ?? 0
    }
    );
    C(o);
    function o() {
        return l.min !== void 0 && x(T) < l.min ? (oe(O, x(T) === 0 ? "Required" : `Min. characters: ${l.min}`, !0),
        !1) : l.max !== void 0 && x(T) > l.max ? (oe(O, `Max. characters: ${l.max}`),
        !1) : !0
    }
    Zr( () => {
        var ke;
        l.max !== void 0 && x(T) > l.max && _((ke = _()) == null ? void 0 : ke.substring(0, l.max))
    }
    );
    var $ = EP()
      , W = k($);
    {
        var ie = ke => {
            var Oe = AP()
              , Ee = k(Oe, !0);
            A(Oe),
            Ge( () => fe(Ee, l.label)),
            H(ke, Oe)
        }
        ;
        Ue(W, ke => {
            l.label && ke(ie)
        }
        )
    }
    var pe = V(W, 2);
    Oy(pe),
    er(pe, () => ({
        ...L,
        class: `textarea w-full ${l.class ?? ""}`,
        placeholder: l.placeholder
    }));
    var ye = V(pe, 2)
      , X = k(ye)
      , Se = k(X, !0);
    A(X);
    var we = V(X, 2);
    {
        var Re = ke => {
            var Oe = kP()
              , Ee = k(Oe, !0);
            A(Oe),
            Ge( () => fe(Ee, l.max - x(T))),
            H(ke, Oe)
        }
        ;
        Ue(we, ke => {
            l.max !== void 0 && ke(Re)
        }
        )
    }
    A(ye),
    A($),
    Ge( () => fe(Se, x(O))),
    jd(pe, _),
    H(b, $),
    Pr()
}
var zP = (b, l) => {
    var _;
    (_ = l()) == null || _.close()
}
  , LP = Ie('<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function DP(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15)
      , C = nt(!1)
      , L = nt(zn(l.description))
      , O = nt(void 0);
    Ii( () => {
        const Oe = Ee => {
            var Ne;
            Ee.key === "Escape" && ((Ne = _()) == null || Ne.close())
        }
        ;
        return document.addEventListener("keydown", Oe),
        () => document.removeEventListener("keydown", Oe)
    }
    );
    var T = LP()
      , o = k(T)
      , $ = k(o)
      , W = k($, !0);
    A($);
    var ie = V($, 2)
      , pe = k(ie)
      , ye = k(pe);
    {
        let Oe = lt( () => Hg());
        iv(ye, {
            class: "h-24 rounded-lg",
            get placeholder() {
                return x(Oe)
            },
            max: 512,
            get value() {
                return x(L)
            },
            set value(Ee) {
                oe(L, Ee, !0)
            },
            get validate() {
                return x(O)
            },
            set validate(Ee) {
                oe(O, Ee, !0)
            }
        })
    }
    A(pe);
    var X = V(pe, 2)
      , Se = k(X);
    Se.__click = [zP, _];
    var we = k(Se, !0);
    A(Se);
    var Re = V(Se, 2)
      , ke = k(Re, !0);
    A(Re),
    A(X),
    A(ie),
    A(o),
    fi(2),
    A(T),
    ps(T, Oe => _(Oe), () => _()),
    Ge( (Oe, Ee, Ne) => {
        fe(W, Oe),
        Se.disabled = x(C),
        fe(we, Ee),
        Re.disabled = x(C),
        fe(ke, Ne)
    }
    , [ () => Uy(), () => qd(), () => kT()]),
    an("submit", ie, async () => {
        var Oe, Ee, Ne;
        try {
            if (!((Oe = x(O)) != null && Oe()))
                return;
            oe(C, !0),
            l.description !== x(L) && await ni.updateAllianceDescription(x(L)),
            await ((Ee = l.onsuccess) == null ? void 0 : Ee.call(l, x(L))),
            (Ne = _()) == null || Ne.close()
        } catch (ft) {
            qr.error(ft.message)
        } finally {
            oe(C, !1)
        }
    }
    ),
    H(b, T),
    Pr()
}
Wi(["click"]);
var RP = (b, l, _) => {
    navigator.clipboard.writeText(x(l).toString()),
    oe(_, !0),
    setTimeout( () => {
        oe(_, !1)
    }
    , 1e3)
}
  , BP = Ie('<span class="loading loading-spinner loading-md center-absolute absolute"></span>')
  , FP = Ie('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function OP(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15)
      , C = nt("")
      , L = nt(!1);
    const O = lt( () => La.url.origin + `/join?id=${x(C)}`);
    Zr( () => {
        _() && ni.getAllianceInvites().then(ht => {
            oe(C, ht[0], !0)
        }
        ).catch(ht => {
            qr.error(ht.message)
        }
        )
    }
    ),
    Ii( () => {
        const ht = Xe => {
            Xe.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", ht),
        () => document.removeEventListener("keydown", ht)
    }
    );
    var T = FP()
      , o = k(T)
      , $ = V(k(o), 2)
      , W = k($, !0);
    A($);
    var ie = V($, 2)
      , pe = k(ie, !0);
    A(ie);
    var ye = V(ie, 2)
      , X = k(ye);
    let Se;
    var we = k(X);
    ea(we);
    var Re = V(we, 2)
      , ke = k(Re);
    let Oe;
    ke.__click = [RP, O, L];
    var Ee = k(ke, !0);
    A(ke),
    A(Re),
    A(X);
    var Ne = V(X, 2);
    {
        var ft = ht => {
            var Xe = BP();
            H(ht, Xe)
        }
        ;
        Ue(Ne, ht => {
            x(C) || ht(ft)
        }
        )
    }
    A(ye),
    A(o),
    fi(2),
    A(T),
    On(T, () => ht => {
        Zr( () => {
            _() ? ht.show() : ht.close()
        }
        )
    }
    ),
    Ge( (ht, Xe, ct, Je, Be, st) => {
        fe(W, ht),
        fe(pe, Xe),
        Se = Or(X, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, Se, ct),
        Jl(we, Je),
        Oe = Or(ke, 1, "btn btn-primary", null, Oe, Be),
        fe(Ee, st)
    }
    , [ () => C5(), () => I5(), () => ({
        invisible: !x(C)
    }), () => x(O).toString(), () => ({
        "btn-success": x(L)
    }), () => x(L) ? Gg() : bf()]),
    an("close", T, () => _(!1)),
    H(b, T),
    Pr()
}
Wi(["click"]);
var NP = Tr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');
function am(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = NP();
    er(C, () => ({
        viewBox: "0 0 256 199",
        width: "256",
        height: "199",
        xmlns: "http://www.w3.org/2000/svg",
        preserveAspectRatio: "xMidYMid",
        ..._
    })),
    H(b, C)
}
var jP = async (b, l) => {
    await navigator.clipboard.writeText(l.username),
    qr.info(q3())
}
  , qP = Ie('<span class="tooltip h-4"><button><!></button></span>');
function ph(b, l) {
    Sr(l, !0);
    var _ = qP()
      , C = k(_);
    C.__click = [jP, l];
    var L = k(C);
    am(L, {
        class: "size-4 opacity-70"
    }),
    A(C),
    A(_),
    Ge( () => zr(_, "data-tip", `Discord: ${l.username}`)),
    H(b, _),
    Pr()
}
Wi(["click"]);
var VP = Ie('<input type="radio" class="tab max-[380px]:px-3"/>')
  , UP = Ie('<div class="tabs tabs-border w-max font-medium"></div>');
function sm(b, l) {
    Sr(l, !0);
    const _ = [];
    let C = Et(l, "value", 15, "today")
      , L = [{
        value: "today",
        label: Wd()
    }, {
        value: "week",
        label: U5()
    }, {
        value: "month",
        label: G5()
    }, {
        value: "all-time",
        label: X5()
    }];
    var O = UP();
    nn(O, 21, () => L, T => T.value, (T, o) => {
        var $ = VP();
        ea($);
        var W;
        Ge( () => {
            zr($, "aria-label", x(o).label),
            W !== (W = x(o).value) && ($.value = ($.__value = x(o).value) ?? "")
        }
        ),
        Vd(_, [], $, () => (x(o).value,
        C()), C),
        H(T, $)
    }
    ),
    A(O),
    H(b, O),
    Pr()
}
const ZP = typeof window < "u" ? window : void 0;
function $P(b) {
    let l = b.activeElement;
    for (; l != null && l.shadowRoot; ) {
        const _ = l.shadowRoot.activeElement;
        if (_ === l)
            break;
        l = _
    }
    return l
}
var rc, zu, Ig;
let GP = (Ig = class {
    constructor(l={}) {
        br(this, rc);
        br(this, zu);
        const {window: _=ZP, document: C=_ == null ? void 0 : _.document} = l;
        _ !== void 0 && (Jn(this, rc, C),
        Jn(this, zu, zg(L => {
            const O = Su(_, "focusin", L)
              , T = Su(_, "focusout", L);
            return () => {
                O(),
                T()
            }
        }
        )))
    }
    get current() {
        var l;
        return (l = et(this, zu)) == null || l.call(this),
        et(this, rc) ? $P(et(this, rc)) : null
    }
}
,
rc = new WeakMap,
zu = new WeakMap,
Ig);
new GP;
function HP(b, l) {
    switch (b) {
    case "post":
        Zr(l);
        break;
    case "pre":
        Hf(l);
        break
    }
}
function nv(b, l, _, C={}) {
    const {lazy: L=!1} = C;
    let O = !L
      , T = Array.isArray(b) ? [] : void 0;
    HP(l, () => {
        const o = Array.isArray(b) ? b.map(W => W()) : b();
        if (!O) {
            O = !0,
            T = o;
            return
        }
        const $ = Go( () => _(o, T));
        return T = o,
        $
    }
    )
}
function dc(b, l, _) {
    nv(b, "post", l, _)
}
function WP(b, l, _) {
    nv(b, "pre", l, _)
}
dc.pre = WP;
var XP = Ie('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>')
  , KP = Ie('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>')
  , YP = Ie('<span class="font-flag tooltip ml-0.5"> </span>')
  , JP = (b, l, _) => {
    l.onlastpixelclick({
        lat: x(_).lastLatitude ?? 0,
        lng: x(_).lastLongitude ?? 0
    })
}
  , QP = Ie("<button><!></button>")
  , eI = Ie('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>')
  , tI = Ie('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>')
  , rI = Ie('<div><!> <div class="mt-4"><!></div></div>');
function iI(b, l) {
    Sr(l, !0);
    let _ = Et(l, "reload", 15)
      , C = nt(!0)
      , L = nt([])
      , O = nt(0)
      , T = nt("today")
      , o = {};
    _($);
    function $() {
        const we = x(T);
        ni.allianceLeaderboard(we).then(Re => {
            oe(L, Re),
            o = {
                [we]: Re
            },
            oe(C, !1)
        }
        ).catch(Re => {
            qr.error(Re.message)
        }
        )
    }
    dc( () => [x(T)], () => {
        const we = x(T)
          , Re = o[we];
        if (Re) {
            oe(L, Re),
            oe(C, !1);
            return
        }
        oe(C, !0),
        ni.allianceLeaderboard(we).then(ke => {
            oe(L, ke),
            o[we] = ke,
            oe(C, !1)
        }
        ).catch(ke => {
            qr.error(ke.message)
        }
        )
    }
    );
    var W = rI()
      , ie = k(W);
    sm(ie, {
        get value() {
            return x(T)
        },
        set value(we) {
            oe(T, we, !0)
        }
    });
    var pe = V(ie, 2)
      , ye = k(pe);
    {
        var X = we => {
            var Re = XP();
            H(we, Re)
        }
          , Se = we => {
            var Re = Jt()
              , ke = zt(Re);
            {
                var Oe = Ne => {
                    var ft = KP()
                      , ht = k(ft)
                      , Xe = V(ht);
                    {
                        var ct = Be => {
                            var st = Fn();
                            Ge(it => fe(st, it), [ () => Wd().toLowerCase()]),
                            H(Be, st)
                        }
                          , Je = Be => {
                            var st = Jt()
                              , it = zt(st);
                            {
                                var Qe = vt => {
                                    var Q = Fn();
                                    Ge(te => fe(Q, te), [ () => Qf()]),
                                    H(vt, Q)
                                }
                                  , Ae = vt => {
                                    var Q = Jt()
                                      , te = zt(Q);
                                    {
                                        var _e = ne => {
                                            var Pe = Fn();
                                            Ge(Me => fe(Pe, Me), [ () => em()]),
                                            H(ne, Pe)
                                        }
                                        ;
                                        Ue(te, ne => {
                                            x(T) === "month" && ne(_e)
                                        }
                                        , !0)
                                    }
                                    H(vt, Q)
                                }
                                ;
                                Ue(it, vt => {
                                    x(T) === "week" ? vt(Qe) : vt(Ae, !1)
                                }
                                , !0)
                            }
                            H(Be, st)
                        }
                        ;
                        Ue(Xe, Be => {
                            x(T) === "today" ? Be(ct) : Be(Je, !1)
                        }
                        )
                    }
                    A(ft),
                    Ge(Be => fe(ht, `${Be ?? ""} `), [ () => Jf()]),
                    H(Ne, ft)
                }
                  , Ee = Ne => {
                    var ft = tI()
                      , ht = k(ft)
                      , Xe = k(ht)
                      , ct = V(k(Xe))
                      , Je = k(ct, !0);
                    A(ct);
                    var Be = V(ct)
                      , st = k(Be, !0);
                    A(Be),
                    A(Xe),
                    A(ht);
                    var it = V(ht);
                    nn(it, 31, () => x(L), Qe => Qe.userId, (Qe, Ae, vt) => {
                        const Q = lt( () => {
                            var Yt;
                            return ((Yt = Dt.data) == null ? void 0 : Yt.id) === x(Ae).userId
                        }
                        );
                        var te = eI();
                        let _e;
                        var ne = k(te)
                          , Pe = k(ne, !0);
                        A(ne);
                        var Me = V(ne)
                          , at = k(Me)
                          , We = k(at);
                        es(We, {
                            class: "size-10 border",
                            get userId() {
                                return x(Ae).userId
                            },
                            get pictureUrl() {
                                return x(Ae).picture
                            }
                        });
                        var Ct = V(We, 2)
                          , _t = k(Ct)
                          , xt = V(_t)
                          , tt = k(xt);
                        A(xt),
                        A(Ct);
                        var pt = V(Ct, 2);
                        {
                            var It = Yt => {
                                const nr = lt( () => ds(x(Ae).equippedFlag));
                                var ar = YP()
                                  , Ft = k(ar, !0);
                                A(ar),
                                Ge( () => {
                                    zr(ar, "data-tip", x(nr).name),
                                    fe(Ft, x(nr).flag)
                                }
                                ),
                                H(Yt, ar)
                            }
                            ;
                            Ue(pt, Yt => {
                                x(Ae).equippedFlag && Yt(It)
                            }
                            )
                        }
                        var ut = V(pt, 2);
                        {
                            var bt = Yt => {
                                ph(Yt, {
                                    get username() {
                                        return x(Ae).discord
                                    }
                                })
                            }
                            ;
                            Ue(ut, Yt => {
                                x(Ae).discord && Yt(bt)
                            }
                            )
                        }
                        A(at),
                        A(Me);
                        var wt = V(Me)
                          , dt = k(wt)
                          , Lt = V(dt);
                        {
                            var Xt = Yt => {
                                var nr = QP();
                                let ar;
                                nr.__click = [JP, l, Ae];
                                var Ft = k(nr);
                                Wf(Ft, {
                                    class: "size-4"
                                }),
                                A(nr),
                                Ge( (dr, _r) => {
                                    ar = Or(nr, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, ar, dr),
                                    zr(nr, "data-tip", _r)
                                }
                                , [ () => ({
                                    tooltip: x(O) > 640
                                }), () => nT()]),
                                H(Yt, nr)
                            }
                            ;
                            Ue(Lt, Yt => {
                                x(Ae).lastLatitude && x(Ae).lastLongitude && Yt(Xt)
                            }
                            )
                        }
                        A(wt),
                        A(te),
                        Ge( (Yt, nr, ar) => {
                            var Ft;
                            _e = Or(te, 1, "", null, _e, Yt),
                            fe(Pe, x(vt) + 1),
                            Or(Ct, 1, `font-semibold ${nr ?? ""} flex gap-1`),
                            fe(_t, `${(x(Q) ? ((Ft = Dt.data) == null ? void 0 : Ft.name) ?? x(Ae).name : x(Ae).name) ?? ""} `),
                            fe(tt, `#${x(Ae).userId ?? ""}`),
                            fe(dt, `${ar ?? ""} `)
                        }
                        , [ () => ({
                            "bg-base-200": x(Q)
                        }), () => Zn(x(Ae).userId), () => x(Ae).pixelsPainted.toLocaleString("en-US")]),
                        Zo(te, () => $o, () => ({
                            duration: 200
                        })),
                        H(Qe, te)
                    }
                    ),
                    A(it),
                    A(ft),
                    Ge( (Qe, Ae) => {
                        fe(Je, Qe),
                        fe(st, Ae)
                    }
                    , [ () => tm(), () => Xf()]),
                    H(Ne, ft)
                }
                ;
                Ue(ke, Ne => {
                    x(L).length === 0 ? Ne(Oe) : Ne(Ee, !1)
                }
                , !0)
            }
            H(we, Re)
        }
        ;
        Ue(ye, we => {
            x(C) ? we(X) : we(Se, !1)
        }
        )
    }
    A(pe),
    A(W),
    $d("innerWidth", we => oe(O, we, !0)),
    H(b, W),
    Pr()
}
Wi(["click"]);
var nI = Tr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');
function om(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = nI();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var aI = (b, l) => l.onclickback()
  , sI = Ie('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>')
  , oI = async (b, l) => {
    try {
        x(l).loading = !0,
        await ni.giveAllianceAdmin(x(l).id),
        x(l).role = "admin"
    } catch {
        qr.error(hC())
    } finally {
        x(l).loading = !1
    }
}
  , lI = async (b, l, _) => {
    try {
        x(l).loading = !0,
        await ni.banAllianceUser(x(l).id),
        _.data = _.data.filter(C => C.id !== x(l).id)
    } catch {
        qr.error(LT())
    } finally {
        x(l).loading = !1
    }
}
  , cI = Ie('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1)
  , uI = Ie('<li><button class="btn btn-ghost text-base-content/80"> </button></li>')
  , hI = Ie('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>')
  , dI = Ie('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>')
  , pI = (b, l, _) => {
    ni.unbanAllianceUser(x(l).id).then( () => {
        _.data = _.data.filter(C => C.id !== x(l).id)
    }
    ).catch(C => qr.error(C.message)).finally( () => {
        x(l).loading = !1
    }
    )
}
  , fI = Ie('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>')
  , mI = Ie('<div class="text-base-content/80 mt-4 flex justify-center"> </div>')
  , _I = Ie('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>')
  , gI = Ie('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');
function vI(b, l) {
    Sr(l, !0);
    let _ = zn({
        data: [],
        page: 0,
        hasNextPage: !0,
        loading: !1
    })
      , C = zn({
        data: [],
        page: 0,
        hasNextPage: !0,
        loading: !1
    });
    var L = gI()
      , O = k(L)
      , T = k(O);
    T.__click = [aI, l];
    var o = k(T);
    _x(o, {
        class: "size-5"
    }),
    A(T);
    var $ = V(T, 2)
      , W = k($, !0);
    A($),
    A(O);
    var ie = V(O, 2)
      , pe = k(ie);
    ea(pe);
    var ye = V(pe, 2)
      , X = k(ye)
      , Se = k(X);
    nn(Se, 21, () => _.data, Je => Je.id, (Je, Be, st) => {
        const it = lt( () => {
            var It;
            return ((It = Dt.data) == null ? void 0 : It.id) === x(Be).id
        }
        );
        var Qe = hI()
          , Ae = k(Qe)
          , vt = k(Ae)
          , Q = k(vt);
        es(Q, {
            class: "size-10 border",
            get userId() {
                return x(Be).id
            },
            get pictureUrl() {
                return x(Be).picture
            }
        });
        var te = V(Q, 2)
          , _e = k(te);
        A(te);
        var ne = V(te, 2);
        {
            var Pe = It => {
                var ut = sI();
                H(It, ut)
            }
            ;
            Ue(ne, It => {
                x(Be).role === "admin" && It(Pe)
            }
            )
        }
        A(vt),
        A(Ae);
        var Me = V(Ae)
          , at = k(Me)
          , We = k(at)
          , Ct = k(We);
        om(Ct, {
            class: "size-4"
        }),
        A(We);
        var _t = V(We, 2)
          , xt = k(_t);
        {
            var tt = It => {
                var ut = cI()
                  , bt = zt(ut)
                  , wt = k(bt);
                wt.__click = [oI, Be];
                var dt = k(wt, !0);
                A(wt),
                A(bt);
                var Lt = V(bt, 2)
                  , Xt = k(Lt);
                Xt.__click = [lI, Be, _];
                var Yt = k(Xt, !0);
                A(Xt),
                A(Lt),
                Ge( (nr, ar) => {
                    wt.disabled = x(Be).loading,
                    fe(dt, nr),
                    Xt.disabled = x(Be).loading,
                    fe(Yt, ar)
                }
                , [ () => _T(), () => Wg()]),
                H(It, ut)
            }
              , pt = It => {
                var ut = uI()
                  , bt = k(ut);
                bt.disabled = !0;
                var wt = k(bt, !0);
                A(bt),
                A(ut),
                Ge(dt => fe(wt, dt), [ () => bT()]),
                H(It, ut)
            }
            ;
            Ue(xt, It => {
                x(Be).role === "member" ? It(tt) : It(pt, !1)
            }
            )
        }
        A(_t),
        A(at),
        A(Me),
        A(Qe),
        Ge(It => {
            var ut;
            Or(te, 1, `font-semibold ${It ?? ""}`),
            fe(_e, `${(x(it) ? ((ut = Dt.data) == null ? void 0 : ut.name) ?? x(Be).name : x(Be).name) ?? ""} #${x(Be).id ?? ""}`)
        }
        , [ () => Zn(x(Be).id)]),
        H(Je, Qe)
    }
    ),
    A(Se),
    A(X);
    var we = V(X, 2);
    {
        var Re = Je => {
            var Be = Jt()
              , st = zt(Be);
            Pu(st, () => _.page, it => {
                var Qe = dI();
                On(Qe, () => Ae => {
                    const vt = new IntersectionObserver(Q => {
                        Q[0].isIntersecting && !_.loading && (_.loading = !0,
                        ni.getAllianceMembers(_.page).then(te => {
                            _.data = [..._.data, ...te.data],
                            _.hasNextPage = te.hasNext,
                            _.page++
                        }
                        ).catch(te => {
                            qr.error(te.message)
                        }
                        ).finally( () => {
                            _.loading = !1
                        }
                        ))
                    }
                    );
                    return vt.observe(Ae),
                    () => {
                        vt.disconnect()
                    }
                }
                ),
                H(it, Qe)
            }
            ),
            H(Je, Be)
        }
        ;
        Ue(we, Je => {
            _.hasNextPage && Je(Re)
        }
        )
    }
    A(ye);
    var ke = V(ye, 2)
      , Oe = V(ke, 2)
      , Ee = k(Oe)
      , Ne = k(Ee);
    nn(Ne, 21, () => C.data, Je => Je.id, (Je, Be, st) => {
        var it = fI()
          , Qe = k(it)
          , Ae = k(Qe)
          , vt = k(Ae);
        es(vt, {
            class: "size-10 border",
            get userId() {
                return x(Be).id
            },
            get pictureUrl() {
                return x(Be).picture
            }
        });
        var Q = V(vt, 2)
          , te = k(Q);
        A(Q),
        A(Ae),
        A(Qe);
        var _e = V(Qe)
          , ne = k(_e);
        ne.__click = [pI, Be, C];
        var Pe = k(ne, !0);
        A(ne),
        A(_e),
        A(it),
        Ge( (Me, at) => {
            Or(Q, 1, `font-semibold ${Me ?? ""}`),
            fe(te, `${x(Be).name ?? ""} #${x(Be).id ?? ""}`),
            ne.disabled = x(Be).loading,
            fe(Pe, at)
        }
        , [ () => Zn(x(Be).id), () => CT()]),
        H(Je, it)
    }
    ),
    A(Ne),
    A(Ee);
    var ft = V(Ee, 2);
    {
        var ht = Je => {
            var Be = mI()
              , st = k(Be, !0);
            A(Be),
            Ge(it => fe(st, it), [ () => IT()]),
            H(Je, Be)
        }
        ;
        Ue(ft, Je => {
            !C.hasNextPage && C.data.length === 0 && Je(ht)
        }
        )
    }
    var Xe = V(ft, 2);
    {
        var ct = Je => {
            var Be = Jt()
              , st = zt(Be);
            Pu(st, () => C.page, it => {
                var Qe = _I();
                On(Qe, () => Ae => {
                    const vt = new IntersectionObserver(Q => {
                        Q[0].isIntersecting && !C.loading && (C.loading = !0,
                        ni.getAllianceBannedMembers(C.page).then(te => {
                            C.data = [...C.data, ...te.data],
                            C.hasNextPage = te.hasNext,
                            C.page++
                        }
                        ).catch(te => {
                            qr.error(te.message)
                        }
                        ).finally( () => {
                            C.loading = !1
                        }
                        ))
                    }
                    );
                    return vt.observe(Ae),
                    () => {
                        vt.disconnect()
                    }
                }
                ),
                H(it, Qe)
            }
            ),
            H(Je, Be)
        }
        ;
        Ue(Xe, Je => {
            C.hasNextPage && Je(ct)
        }
        )
    }
    A(Oe),
    A(ie),
    A(L),
    Ge( (Je, Be, st) => {
        fe(W, Je),
        zr(pe, "aria-label", Be),
        zr(ke, "aria-label", st)
    }
    , [ () => $g(), () => BT(), () => NT()]),
    H(b, L),
    Pr()
}
Wi(["click"]);
var yI = Ie('<span class="label"> </span>')
  , xI = Ie('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>')
  , bI = Ie('<p class="text-error ml-3 text-sm"> </p>')
  , wI = Ie('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');
function Tf(b, l) {
    Sr(l, !0);
    let _ = Et(l, "value", 15)
      , C = Et(l, "validate", 15)
      , L = nt("");
    const O = lt( () => {
        var ke;
        return ((ke = _()) == null ? void 0 : ke.length) ?? 0
    }
    );
    C(T);
    function T() {
        return l.min !== void 0 && x(O) < l.min ? (oe(L, x(O) === 0 ? "Required" : `Min. characters: ${l.min}`, !0),
        !1) : l.max !== void 0 && x(O) > l.max ? (oe(L, `Max. characters: ${l.max}`),
        !1) : !0
    }
    Zr( () => {
        var ke;
        l.max !== void 0 && x(O) > l.max && _((ke = _()) == null ? void 0 : ke.substring(0, l.max))
    }
    );
    var o = wI()
      , $ = k(o);
    let W;
    var ie = k($);
    {
        var pe = ke => {
            var Oe = yI()
              , Ee = k(Oe, !0);
            A(Oe),
            Ge( () => fe(Ee, l.label)),
            H(ke, Oe)
        }
        ;
        Ue(ie, ke => {
            l.label && ke(pe)
        }
        )
    }
    var ye = V(ie, 2);
    ea(ye);
    var X = V(ye, 2);
    {
        var Se = ke => {
            var Oe = xI()
              , Ee = k(Oe, !0);
            A(Oe),
            Ge( () => fe(Ee, l.max - x(O))),
            H(ke, Oe)
        }
        ;
        Ue(X, ke => {
            l.max !== void 0 && ke(Se)
        }
        )
    }
    A($);
    var we = V($, 2);
    {
        var Re = ke => {
            var Oe = bI()
              , Ee = k(Oe, !0);
            A(Oe),
            Ge( () => fe(Ee, x(L))),
            H(ke, Oe)
        }
        ;
        Ue(we, ke => {
            x(L) && ke(Re)
        }
        )
    }
    A(o),
    Ge(ke => {
        W = Or($, 1, "input w-full", null, W, ke),
        zr(ye, "placeholder", l.placeholder),
        zr(ye, "maxlength", l.max)
    }
    , [ () => ({
        "input-error": !!x(L)
    })]),
    jd(ye, _),
    H(b, o),
    Pr()
}
var TI = (b, l) => {
    var _;
    (_ = l()) == null || _.close()
}
  , CI = Ie('<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function SI(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15)
      , C = nt(!1)
      , L = nt("")
      , O = nt(void 0);
    Ii( () => {
        const Oe = Ee => {
            var Ne;
            Ee.key === "Escape" && ((Ne = _()) == null || Ne.close())
        }
        ;
        return document.addEventListener("keydown", Oe),
        () => document.removeEventListener("keydown", Oe)
    }
    );
    var T = CI()
      , o = k(T)
      , $ = k(o)
      , W = k($, !0);
    A($);
    var ie = V($, 2)
      , pe = k(ie)
      , ye = k(pe);
    {
        let Oe = lt( () => xf())
          , Ee = lt( () => uT());
        Tf(ye, {
            get label() {
                return x(Oe)
            },
            get placeholder() {
                return x(Ee)
            },
            min: 1,
            max: 16,
            get value() {
                return x(L)
            },
            set value(Ne) {
                oe(L, Ne, !0)
            },
            get validate() {
                return x(O)
            },
            set validate(Ne) {
                oe(O, Ne, !0)
            }
        })
    }
    A(pe);
    var X = V(pe, 2)
      , Se = k(X);
    Se.__click = [TI, _];
    var we = k(Se, !0);
    A(Se);
    var Re = V(Se, 2)
      , ke = k(Re, !0);
    A(Re),
    A(X),
    A(ie),
    A(o),
    fi(2),
    A(T),
    ps(T, Oe => _(Oe), () => _()),
    Ge( (Oe, Ee, Ne) => {
        fe(W, Oe),
        Se.disabled = x(C),
        fe(we, Ee),
        Re.disabled = x(C),
        fe(ke, Ne)
    }
    , [ () => oT(), () => qd(), () => pT()]),
    an("submit", ie, async () => {
        var Oe, Ee;
        try {
            if (!((Oe = x(O)) != null && Oe()))
                return;
            oe(C, !0);
            const {id: Ne} = await ni.createAlliance(x(L));
            await l.onsuccess(Ne),
            (Ee = _()) == null || Ee.close()
        } catch (Ne) {
            qr.error(Ne.message)
        } finally {
            oe(C, !1)
        }
    }
    ),
    H(b, T),
    Pr()
}
Wi(["click"]);
var PI = Tr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');
function fh(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = PI();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var II = Tr('<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>')
  , MI = Tr('<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>');
function Cf(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var C = Jt()
      , L = zt(C);
    {
        var O = o => {
            var $ = II();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
          , T = o => {
            var $ = MI();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
        ;
        Ue(L, o => {
            l.filled ? o(O) : o(T, !1)
        }
        )
    }
    H(b, C)
}
var AI = Tr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');
function kI(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = AI();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var EI = Tr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');
function zI(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = EI();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var LI = Tr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');
function DI(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = LI();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var RI = Tr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');
function Xd(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = RI();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
function BI(b, l="_blank") {
    return b.replaceAll(/https?:\/\/[^\s]+/g, _ => `<a href="${_}"${l ? ` target="${l}"` : ""}>${_}</a>`)
}
var FI = Ie('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>')
  , OI = async (b, l, _, C) => {
    try {
        oe(l, !0),
        await ni.leaveAlliance(),
        oe(_, !0),
        await C()
    } catch (L) {
        qr.error(L.message)
    } finally {
        oe(l, !1)
    }
}
  , NI = (b, l) => {
    oe(l, !0)
}
  , jI = Ie('<div class="tooltip"><button class="btn"><!></button></div>')
  , qI = (b, l) => {
    var _;
    (_ = x(l)) == null || _.show()
}
  , VI = Ie('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>')
  , UI = Ie('<section class="text-base-content/80 highlight-link"><!> <!></section>')
  , ZI = Ie('<span class="font-semibold"> </span>')
  , $I = (b, l) => oe(l, !0)
  , GI = Ie('<button class="text-primary font-semibold underline"> </button>')
  , HI = (b, l, _) => {
    var C;
    (C = x(l)) != null && C.hq ? _.onhqclick({
        lat: x(l).hq.latitude,
        lng: x(l).hq.longitude
    }) : _.onhqchange()
}
  , WI = Ie('<span class="text-primary underline"> </span>')
  , XI = Ie('<span class="text-primary underline"> </span>')
  , KI = Ie('<button class="text-base-content/80 p-1"><!></button>')
  , YI = Ie('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>')
  , JI = Ie('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1)
  , QI = (b, l) => {
    var _;
    (_ = x(l)) == null || _.show()
}
  , eM = Ie('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1)
  , tM = Ie('<div class="h-full"><!></div>');
function rM(b, l) {
    Sr(l, !0);
    let _ = nt(void 0)
      , C = nt(!0)
      , L = nt(void 0)
      , O = nt(!1)
      , T = nt(void 0)
      , o = nt(!1)
      , $ = nt(!1)
      , W = nt( () => {}
    );
    dc( () => l.open, () => {
        l.open && Id.shouldReload && ie()
    }
    ),
    Ii( () => {
        const we = setInterval( () => {
            Id.shouldReload = !0
        }
        , 1e4);
        return () => {
            clearTimeout(we)
        }
    }
    );
    async function ie() {
        try {
            oe(_, await ni.getAlliance(), !0),
            x(_) && x(W)(),
            oe(C, !1),
            Id.shouldReload = !1
        } catch (we) {
            qr.error(we.message)
        }
    }
    var pe = tM()
      , ye = k(pe);
    {
        var X = we => {
            var Re = FI();
            H(we, Re)
        }
          , Se = we => {
            var Re = Jt()
              , ke = zt(Re);
            {
                var Oe = Ne => {
                    vI(Ne, {
                        onclickback: () => oe($, !1)
                    })
                }
                  , Ee = Ne => {
                    var ft = Jt()
                      , ht = zt(ft);
                    {
                        var Xe = Je => {
                            var Be = JI()
                              , st = zt(Be)
                              , it = k(st)
                              , Qe = k(it, !0);
                            A(it);
                            var Ae = V(it, 2)
                              , vt = k(Ae)
                              , Q = k(vt)
                              , te = k(Q);
                            om(te, {
                                class: "size-4"
                            }),
                            A(Q);
                            var _e = V(Q, 2)
                              , ne = k(_e)
                              , Pe = k(ne);
                            Pe.__click = [OI, O, C, ie];
                            var Me = k(Pe, !0);
                            A(Pe),
                            A(ne),
                            A(_e),
                            A(vt);
                            var at = V(vt, 2);
                            {
                                var We = ce => {
                                    var F = jI()
                                      , q = k(F);
                                    q.__click = [NI, o];
                                    var G = k(q);
                                    DI(G, {
                                        class: "size-4"
                                    }),
                                    A(q),
                                    A(F),
                                    Ge(K => zr(F, "data-tip", K), [ () => B5()]),
                                    H(ce, F)
                                }
                                ;
                                Ue(at, ce => {
                                    x(_).role == "admin" && ce(We)
                                }
                                )
                            }
                            A(Ae),
                            A(st);
                            var Ct = V(st, 2);
                            {
                                var _t = ce => {
                                    var F = UI()
                                      , q = k(F);
                                    lx(q, () => BI(x(_).description || Hg()));
                                    var G = V(q, 2);
                                    {
                                        var K = le => {
                                            var ve = VI();
                                            ve.__click = [qI, T];
                                            var Le = k(ve);
                                            Cf(Le, {
                                                class: "size-4"
                                            }),
                                            A(ve),
                                            H(le, ve)
                                        }
                                        ;
                                        Ue(G, le => {
                                            x(_).role === "admin" && le(K)
                                        }
                                        )
                                    }
                                    A(F),
                                    H(ce, F)
                                }
                                ;
                                Ue(Ct, ce => {
                                    (x(_).description || x(_).role === "admin") && ce(_t)
                                }
                                )
                            }
                            var xt = V(Ct, 2)
                              , tt = k(xt)
                              , pt = k(tt);
                            fh(pt, {
                                class: "inline size-4"
                            });
                            var It = V(pt, 2)
                              , ut = k(It)
                              , bt = V(ut)
                              , wt = k(bt, !0);
                            A(bt),
                            A(It),
                            A(tt);
                            var dt = V(tt, 2)
                              , Lt = k(dt);
                            Xd(Lt, {
                                class: "inline size-4"
                            });
                            var Xt = V(Lt, 2)
                              , Yt = k(Xt)
                              , nr = V(Yt);
                            {
                                var ar = ce => {
                                    var F = ZI()
                                      , q = k(F, !0);
                                    A(F),
                                    Ge(G => fe(q, G), [ () => x(_).members.toLocaleString("en-US")]),
                                    H(ce, F)
                                }
                                  , Ft = ce => {
                                    var F = GI();
                                    F.__click = [$I, $];
                                    var q = k(F, !0);
                                    A(F),
                                    Ge(G => fe(q, G), [ () => x(_).members.toLocaleString("en-US")]),
                                    H(ce, F)
                                }
                                ;
                                Ue(nr, ce => {
                                    x(_).role === "member" ? ce(ar) : ce(Ft, !1)
                                }
                                )
                            }
                            A(Xt),
                            A(dt);
                            var dr = V(dt, 2);
                            {
                                var _r = ce => {
                                    var F = YI()
                                      , q = k(F);
                                    kI(q, {
                                        class: "inline size-4"
                                    });
                                    var G = V(q, 2)
                                      , K = k(G)
                                      , le = V(K);
                                    le.__click = [HI, _, l];
                                    var ve = k(le);
                                    {
                                        var Le = Ye => {
                                            var Ot = WI()
                                              , xe = k(Ot);
                                            A(Ot),
                                            Ge( (At, Pt) => fe(xe, `${At ?? ""}, ${Pt ?? ""}`), [ () => x(_).hq.latitude.toFixed(3), () => x(_).hq.longitude.toFixed(3)]),
                                            H(Ye, Ot)
                                        }
                                          , Ce = Ye => {
                                            var Ot = XI()
                                              , xe = k(Ot, !0);
                                            A(Ot),
                                            Ge(At => fe(xe, At), [ () => c5()]),
                                            H(Ye, Ot)
                                        }
                                        ;
                                        Ue(ve, Ye => {
                                            x(_).hq ? Ye(Le) : Ye(Ce, !1)
                                        }
                                        )
                                    }
                                    A(le),
                                    A(G);
                                    var Ze = V(G, 2);
                                    {
                                        var ot = Ye => {
                                            var Ot = KI();
                                            Ot.__click = function(...At) {
                                                var Pt;
                                                (Pt = l.onhqchange) == null || Pt.apply(this, At)
                                            }
                                            ;
                                            var xe = k(Ot);
                                            Cf(xe, {
                                                class: "text-base-content/50 size-4"
                                            }),
                                            A(Ot),
                                            H(Ye, Ot)
                                        }
                                        ;
                                        Ue(Ze, Ye => {
                                            x(_).role === "admin" && Ye(ot)
                                        }
                                        )
                                    }
                                    A(F),
                                    Ge(Ye => fe(K, `${Ye ?? ""}: `), [ () => s5()]),
                                    H(ce, F)
                                }
                                ;
                                Ue(dr, ce => {
                                    (x(_).hq || x(_).role === "admin") && ce(_r)
                                }
                                )
                            }
                            A(xt);
                            var Ir = V(xt, 2)
                              , jr = k(Ir)
                              , ur = k(jr, !0);
                            A(jr);
                            var Mr = V(jr, 2)
                              , Ar = k(Mr);
                            iI(Ar, {
                                get allianceId() {
                                    return x(_).id
                                },
                                get onlastpixelclick() {
                                    return l.onlastpixelclick
                                },
                                get reload() {
                                    return x(W)
                                },
                                set reload(ce) {
                                    oe(W, ce, !0)
                                }
                            }),
                            A(Mr),
                            A(Ir);
                            var kr = V(Ir, 2);
                            DP(kr, {
                                get description() {
                                    return x(_).description
                                },
                                onsuccess: async ce => {
                                    x(_) && (x(_).description = ce)
                                }
                                ,
                                get ref() {
                                    return x(T)
                                },
                                set ref(ce) {
                                    oe(T, ce, !0)
                                }
                            });
                            var Nr = V(kr, 2);
                            OP(Nr, {
                                get open() {
                                    return x(o)
                                },
                                set open(ce) {
                                    oe(o, ce, !0)
                                }
                            }),
                            Ge( (ce, F, q, G, K) => {
                                fe(Qe, x(_).name),
                                Pe.disabled = x(O),
                                fe(Me, ce),
                                fe(ut, `${F ?? ""}: `),
                                fe(wt, q),
                                fe(Yt, `${G ?? ""}: `),
                                fe(ur, K)
                            }
                            , [ () => t5(), () => Xf(), () => x(_).pixelsPainted.toLocaleString("en-US"), () => $g(), () => Yf()]),
                            H(Je, Be)
                        }
                          , ct = Je => {
                            var Be = eM()
                              , st = zt(Be)
                              , it = k(st)
                              , Qe = k(it);
                            A(it);
                            var Ae = V(it, 2)
                              , vt = k(Ae);
                            zI(vt, {
                                class: "size-5"
                            });
                            var Q = V(vt, 1, !0);
                            A(Ae);
                            var te = V(Ae, 2)
                              , _e = k(te)
                              , ne = k(_e, !0);
                            A(_e),
                            A(te);
                            var Pe = V(te, 2);
                            Pe.__click = [QI, L];
                            var Me = k(Pe);
                            Dg(Me, {
                                class: "size-6"
                            });
                            var at = V(Me);
                            A(Pe),
                            A(st);
                            var We = V(st, 2);
                            SI(We, {
                                onsuccess: ie,
                                get ref() {
                                    return x(L)
                                },
                                set ref(Ct) {
                                    oe(L, Ct, !0)
                                }
                            }),
                            Ge( (Ct, _t, xt, tt) => {
                                fe(Qe, `${Ct ?? ""}:`),
                                fe(Q, _t),
                                fe(ne, xt),
                                fe(at, ` ${tt ?? ""}`)
                            }
                            , [ () => d5(), () => m5(), () => v5(), () => b5()]),
                            H(Je, Be)
                        }
                        ;
                        Ue(ht, Je => {
                            x(_) ? Je(Xe) : Je(ct, !1)
                        }
                        , !0)
                    }
                    H(Ne, ft)
                }
                ;
                Ue(ke, Ne => {
                    x($) ? Ne(Oe) : Ne(Ee, !1)
                }
                , !0)
            }
            H(we, Re)
        }
        ;
        Ue(ye, we => {
            x(C) ? we(X) : we(Se, !1)
        }
        )
    }
    A(pe),
    H(b, pe),
    Pr()
}
Wi(["click"]);
var iM = Tr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');
function Kd(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = iM();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
const nM = b => b;
function aM(b) {
    const l = b - 1;
    return l * l * l + 1
}
function Qn(b, {delay: l=0, duration: _=400, easing: C=nM}={}) {
    const L = +getComputedStyle(b).opacity;
    return {
        delay: l,
        duration: _,
        easing: C,
        css: O => `opacity: ${O * L}`
    }
}
function uf(b, {delay: l=0, duration: _=400, easing: C=aM, axis: L="y"}={}) {
    const O = getComputedStyle(b)
      , T = +O.opacity
      , o = L === "y" ? "height" : "width"
      , $ = parseFloat(O[o])
      , W = L === "y" ? ["top", "bottom"] : ["left", "right"]
      , ie = W.map(ke => `${ke[0].toUpperCase()}${ke.slice(1)}`)
      , pe = parseFloat(O[`padding${ie[0]}`])
      , ye = parseFloat(O[`padding${ie[1]}`])
      , X = parseFloat(O[`margin${ie[0]}`])
      , Se = parseFloat(O[`margin${ie[1]}`])
      , we = parseFloat(O[`border${ie[0]}Width`])
      , Re = parseFloat(O[`border${ie[1]}Width`]);
    return {
        delay: l,
        duration: _,
        easing: C,
        css: ke => `overflow: hidden;opacity: ${Math.min(ke * 20, 1) * T};${o}: ${ke * $}px;padding-${W[0]}: ${ke * pe}px;padding-${W[1]}: ${ke * ye}px;margin-${W[0]}: ${ke * X}px;margin-${W[1]}: ${ke * Se}px;border-${W[0]}-width: ${ke * we}px;border-${W[1]}-width: ${ke * Re}px;min-${o}: 0`
    }
}
var sM = Ie('<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function oM(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15);
    Ii( () => {
        const pe = ye => {
            ye.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", pe),
        () => document.removeEventListener("keydown", pe)
    }
    );
    var C = sM()
      , L = k(C)
      , O = V(k(L), 2)
      , T = k(O);
    Kd(T, {
        class: "size-5 max-sm:size-6"
    });
    var o = V(T, 2)
      , $ = k(o, !0);
    A(o),
    A(O);
    var W = V(O, 2)
      , ie = k(W);
    rM(ie, {
        get open() {
            return _()
        },
        get onhqchange() {
            return l.onhqchange
        },
        get onhqclick() {
            return l.onhqclick
        },
        get onlastpixelclick() {
            return l.onlastpixelclick
        }
    }),
    A(W),
    A(L),
    fi(2),
    A(C),
    On(C, () => pe => {
        Zr( () => {
            _() ? (pe.show(),
            La.url.searchParams.get("alliance") && (La.url.searchParams.delete("alliance"),
            Lg(La.url.toString()))) : pe.close()
        }
        )
    }
    ),
    Ge(pe => fe($, pe), [ () => Gd()]),
    an("close", C, () => _(!1)),
    En(2, W, () => Qn, () => ({
        duration: 300
    })),
    H(b, C),
    Pr()
}
var lM = Ie('<label class="flex gap-3"><input name="reason" class="radio radio-sm mt-1" type="radio"/> <div><div class="font-semibold"> </div> <div class="text-base-content/80 text-sm"> </div></div></label>')
  , cM = (b, l) => {
    l(!1)
}
  , uM = Ie('<dialog class="modal"><div class="modal-box max-h-[97%] max-w-xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <form method="POST"><input name="reportedUserId" hidden/> <input name="latitude" hidden/> <input name="longitude" hidden/> <input name="zoom" hidden/> <section class="flex gap-3"><!> <div><h2 class="text-xl font-semibold"><!></h2> <span><span> </span> <span> </span></span></div></section> <section class="mt-6"><h3 class="text-base-content/80 text-base"> </h3> <div class="mt-2 flex flex-col gap-3"></div></section> <section class="mt-6"><!></section> <section class="mt-3 flex justify-end gap-2"><button type="button" class="btn"> </button> <button class="btn btn-error"> </button></section></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function hM(b, l) {
    Sr(l, !0);
    const _ = [];
    let C = Et(l, "open", 15)
      , L = nt(!1)
      , O = nt("")
      , T = nt("")
      , o = nt(null)
      , $ = nt(null);
    const W = [{
        value: "inappropriate-content",
        label: Hy(),
        description: Gy()
    }, {
        value: "hate-speech",
        label: Xy(),
        description: Wy()
    }, {
        value: "doxxing",
        label: Yy(),
        description: Ky()
    }, {
        value: "bot",
        label: Qy(),
        description: Jy()
    }, {
        value: "griefing",
        label: tx(),
        description: ex()
    }, {
        value: "other",
        label: kS(),
        description: LS()
    }];
    Ii( () => {
        const _t = xt => {
            xt.key === "Escape" && C(!1)
        }
        ;
        return document.addEventListener("keydown", _t),
        () => document.removeEventListener("keydown", _t)
    }
    ),
    Zr( () => {
        C() || (oe(O, ""),
        oe(T, ""))
    }
    );
    const ie = {
        "report-user": `${Cd}/report-user`,
        timeout: `${Cd}/moderator/timeout-user`,
        ban: `${Cd}/admin/ban-user`
    };
    var pe = uM()
      , ye = k(pe)
      , X = V(k(ye), 2)
      , Se = k(X);
    ea(Se);
    var we = V(Se, 2);
    ea(we);
    var Re = V(we, 2);
    ea(Re);
    var ke = V(Re, 2);
    ea(ke);
    var Oe = V(ke, 2)
      , Ee = k(Oe);
    es(Ee, {
        get userId() {
            return l.paintedBy.id
        },
        get pictureUrl() {
            return l.paintedBy.picture
        },
        class: "size-14"
    });
    var Ne = V(Ee, 2)
      , ft = k(Ne)
      , ht = k(ft);
    {
        var Xe = _t => {
            var xt = Fn();
            Ge(tt => fe(xt, tt), [ () => Yg()]),
            H(_t, xt)
        }
          , ct = _t => {
            var xt = Jt()
              , tt = zt(xt);
            {
                var pt = ut => {
                    var bt = Fn();
                    Ge(wt => fe(bt, wt), [ () => Qg()]),
                    H(ut, bt)
                }
                  , It = ut => {
                    var bt = Jt()
                      , wt = zt(bt);
                    {
                        var dt = Lt => {
                            var Xt = Fn();
                            Ge(Yt => fe(Xt, Yt), [ () => Jg()]),
                            H(Lt, Xt)
                        }
                        ;
                        Ue(wt, Lt => {
                            l.action === "ban" && Lt(dt)
                        }
                        , !0)
                    }
                    H(ut, bt)
                }
                ;
                Ue(tt, ut => {
                    l.action === "timeout" ? ut(pt) : ut(It, !1)
                }
                , !0)
            }
            H(_t, xt)
        }
        ;
        Ue(ht, _t => {
            l.action === "report-user" ? _t(Xe) : _t(ct, !1)
        }
        )
    }
    A(ft);
    var Je = V(ft, 2)
      , Be = k(Je)
      , st = k(Be, !0);
    A(Be);
    var it = V(Be, 2)
      , Qe = k(it);
    A(it),
    A(Je),
    A(Ne),
    A(Oe);
    var Ae = V(Oe, 2)
      , vt = k(Ae)
      , Q = k(vt);
    A(vt);
    var te = V(vt, 2);
    nn(te, 21, () => W, _t => _t.value, (_t, xt) => {
        var tt = lM()
          , pt = k(tt);
        ea(pt);
        var It, ut = V(pt, 2), bt = k(ut), wt = k(bt, !0);
        A(bt);
        var dt = V(bt, 2)
          , Lt = k(dt, !0);
        A(dt),
        A(ut),
        A(tt),
        Ge( () => {
            zr(pt, "aria-label", x(xt).label),
            It !== (It = x(xt).value) && (pt.value = (pt.__value = x(xt).value) ?? ""),
            fe(wt, x(xt).label),
            fe(Lt, x(xt).description)
        }
        ),
        Vd(_, [], pt, () => (x(xt).value,
        x(O)), Xt => oe(O, Xt)),
        H(_t, tt)
    }
    ),
    A(te),
    A(Ae);
    var _e = V(Ae, 2)
      , ne = k(_e);
    {
        let _t = lt( () => BS());
        iv(ne, {
            class: "h-20 rounded-lg",
            name: "notes",
            get placeholder() {
                return x(_t)
            },
            max: 2056,
            get value() {
                return x(T)
            },
            set value(xt) {
                oe(T, xt, !0)
            },
            get validate() {
                return x($)
            },
            set validate(xt) {
                oe($, xt, !0)
            }
        })
    }
    A(_e);
    var Pe = V(_e, 2)
      , Me = k(Pe);
    Me.__click = [cM, C];
    var at = k(Me, !0);
    A(Me);
    var We = V(Me, 2)
      , Ct = k(We, !0);
    A(We),
    A(Pe),
    A(X),
    ps(X, _t => oe(o, _t), () => x(o)),
    A(ye),
    fi(2),
    A(pe),
    On(pe, () => _t => {
        Zr( () => {
            C() ? _t.show() : _t.close()
        }
        )
    }
    ),
    Ge( (_t, xt, tt, pt) => {
        zr(X, "action", ie[l.action]),
        Jl(Se, l.paintedBy.id),
        Jl(we, l.latLon[0]),
        Jl(Re, l.latLon[1]),
        Jl(ke, l.zoom),
        Or(Je, 1, `font-medium ${_t ?? ""} flex gap-1.5`),
        fe(st, l.paintedBy.name),
        fe(Qe, `#${l.paintedBy.id ?? ""}`),
        fe(Q, `${xt ?? ""}:`),
        fe(at, tt),
        We.disabled = x(L),
        fe(Ct, pt)
    }
    , [ () => Zn(l.paintedBy.id), () => IS(), () => qd(), () => NS()]),
    an("close", pe, () => C(!1)),
    an("submit", X, async _t => {
        if (_t.preventDefault(),
        !x(L))
            try {
                oe(L, !0);
                const xt = new FormData(x(o));
                if (!xt.get("reason")) {
                    qr.error($S());
                    return
                }
                const tt = await l.image;
                xt.append("image", tt, `report-${Date.now()}.jpeg`);
                const pt = await fetch(x(o).action, {
                    method: "POST",
                    body: xt,
                    credentials: "include"
                });
                pt.status === 200 || pt.status === 409 ? (qr.info(VS()),
                C(!1)) : qr.error(WS())
            } finally {
                oe(L, !1)
            }
    }
    ),
    H(b, pe),
    Pr()
}
Wi(["click"]);
function dM(b, l, _) {
    return new Promise( (C, L) => {
        b.once("render", () => {
            const O = b.getCanvas().toDataURL()
              , T = document.createElement("img");
            T.src = O,
            T.onload = () => {
                const o = document.createElement("canvas");
                o.width = T.width,
                o.height = T.height;
                const $ = o.getContext("2d");
                if ($) {
                    $.drawImage(T, 0, 0);
                    const [W,ie,pe,ye] = $.getImageData(l, _, 1, 1).data;
                    C([W, ie, pe, ye])
                } else
                    L(new Error("Could not get 2d context from canvas"));
                T.remove(),
                o.remove()
            }
        }
        ),
        b.triggerRepaint()
    }
    )
}
function av(b, l) {
    return new Promise( (_, C) => {
        b.once("render", () => {
            const L = b.getCanvas();
            let O = L;
            if (l != null && l.maxWidth || l != null && l.maxHeight) {
                const T = L.width
                  , o = L.height
                  , $ = (l == null ? void 0 : l.maxWidth) ?? T
                  , W = (l == null ? void 0 : l.maxHeight) ?? o;
                O = document.createElement("canvas");
                const ie = Math.min($ / T, W / o);
                O.width = Math.floor(T * ie),
                O.height = Math.floor(o * ie);
                const pe = O.getContext("2d");
                pe && pe.drawImage(L, 0, 0, O.width, O.height)
            }
            try {
                O.toBlob(T => {
                    T && _(T)
                }
                , (l == null ? void 0 : l.type) ?? "image/png", (l == null ? void 0 : l.quality) ?? 1)
            } catch (T) {
                C(T)
            } finally {
                O !== L && O.remove()
            }
        }
        )
    }
    )
}
var pM = Tr('<svg><path d="M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"></path></svg>');
function sv(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = pM();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var fM = Tr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');
function mM(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = fM();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var _M = Tr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');
function ov(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = _M();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
const Yl = {
    hour: 3600 * 1e3,
    min: 60 * 1e3,
    sec: 1e3
};
function zd(b) {
    const l = Math.floor(b / Yl.hour);
    b -= l * Yl.hour;
    const _ = Math.floor(b / Yl.min);
    b -= _ * Yl.min;
    const L = Math.floor(b / Yl.sec).toString().padStart(2, "0");
    return l > 0 ? `${l}:${_.toString().padStart(2, "0")}:${L}` : `${_}:${L}`
}
function gM(b) {
    const l = new Date
      , _ = l.getFullYear()
      , C = String(l.getMonth() + 1).padStart(2, "0")
      , L = String(l.getDate()).padStart(2, "0")
      , O = String(l.getHours()).padStart(2, "0")
      , T = String(l.getMinutes()).padStart(2, "0")
      , o = String(l.getSeconds()).padStart(2, "0");
    return `${_}-${C}-${L} ${O}:${T}:${o}`
}
var vM = (b, l, _) => {
    navigator.clipboard.writeText(l.url.toString()),
    oe(_, !0),
    setTimeout( () => {
        oe(_, !1)
    }
    , 1e3)
}
  , yM = Ie('<img class="border-base-content/20 border" alt="Screenshot"/>')
  , xM = Ie('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>')
  , bM = async (b, l) => {
    x(l) && (await navigator.clipboard.write([new ClipboardItem({
        "image/png": x(l)
    })]),
    qr.info(aS()))
}
  , wM = Ie('<div><h3 class="mb-1 mt-5 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>')
  , TM = Ie('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function CM(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15)
      , C = nt(!1);
    Ii( () => {
        const Ee = Ne => {
            Ne.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", Ee),
        () => document.removeEventListener("keydown", Ee)
    }
    );
    let L = nt(null)
      , O = nt("");
    Zr( () => {
        _() ? (l.hideHover(),
        setTimeout(async () => {
            av(l.map).then(Ee => {
                oe(L, Ee, !0),
                oe(O, URL.createObjectURL(x(L)), !0)
            }
            ).finally( () => {
                l.showHover()
            }
            )
        }
        , 500)) : x(O) && (URL.revokeObjectURL(x(O)),
        oe(L, null),
        oe(O, ""))
    }
    );
    var T = TM()
      , o = k(T)
      , $ = V(k(o), 2)
      , W = k($);
    ov(W, {
        class: "size-5"
    });
    var ie = V(W);
    A($);
    var pe = V($, 2)
      , ye = k(pe);
    ea(ye);
    var X = V(ye, 2)
      , Se = k(X);
    let we;
    Se.__click = [vM, l, C];
    var Re = k(Se, !0);
    A(Se),
    A(X),
    A(pe);
    var ke = V(pe, 2);
    {
        var Oe = Ee => {
            const Ne = lt( () => {
                var ne;
                return (ne = l.map) == null ? void 0 : ne.getCanvas()
            }
            );
            var ft = wM()
              , ht = k(ft)
              , Xe = k(ht);
            mM(Xe, {
                class: "inline size-5"
            });
            var ct = V(Xe);
            A(ht);
            var Je = V(ht, 2);
            {
                var Be = ne => {
                    var Pe = yM();
                    Ge( () => {
                        zr(Pe, "src", x(O)),
                        zr(Pe, "width", x(Ne).width),
                        zr(Pe, "height", x(Ne).height)
                    }
                    ),
                    H(ne, Pe)
                }
                  , st = ne => {
                    var Pe = xM();
                    Ge( () => uc(Pe, `aspect-ratio: ${x(Ne).width / x(Ne).height}`)),
                    H(ne, Pe)
                }
                ;
                Ue(Je, ne => {
                    x(O) ? ne(Be) : ne(st, !1)
                }
                )
            }
            var it = V(Je, 2)
              , Qe = k(it);
            Qe.__click = [bM, L];
            var Ae = k(Qe);
            Zy(Ae, {
                class: "size-5"
            });
            var vt = V(Ae);
            A(Qe);
            var Q = V(Qe, 2)
              , te = k(Q);
            sv(te, {
                class: "size-5"
            });
            var _e = V(te);
            A(Q),
            A(it),
            A(ft),
            Ge( (ne, Pe, Me, at) => {
                fe(ct, ` ${ne ?? ""}`),
                fe(vt, ` ${Pe ?? ""}`),
                zr(Q, "href", x(O)),
                zr(Q, "download", `wplace_${Me ?? ""}.png`),
                fe(_e, ` ${at ?? ""}`)
            }
            , [ () => QC(), () => bf(), () => gM().replaceAll(" ", "_").replaceAll(":", "-"), () => rS()]),
            En(2, ft, () => Qn, () => ({
                duration: 300
            })),
            H(Ee, ft)
        }
        ;
        Ue(ke, Ee => {
            _() && Ee(Oe)
        }
        )
    }
    A(o),
    fi(2),
    A(T),
    On(T, () => Ee => {
        Zr( () => {
            _() ? Ee.show() : Ee.close()
        }
        )
    }
    ),
    Ge( (Ee, Ne, ft, ht) => {
        fe(ie, ` ${Ee ?? ""}`),
        Jl(ye, Ne),
        we = Or(Se, 1, "btn btn-primary", null, we, ft),
        fe(Re, ht)
    }
    , [ () => P3(), () => l.url.toString(), () => ({
        "btn-success": x(C)
    }), () => x(C) ? Gg() : bf()]),
    an("close", T, () => _(!1)),
    H(b, T),
    Pr()
}
Wi(["click"]);
var SM = Tr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');
function PM(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = SM();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var IM = Ie('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>')
  , MM = Ie('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p></div></div>');
function lm(b, l) {
    Sr(l, !1);
    const _ = [R2(), z2(), O2(), q2(), Z2(), H2(), K2()];
    Og();
    var C = MM()
      , L = k(C)
      , O = k(L);
    PM(O, {
        class: "size-5"
    });
    var T = V(O, 2)
      , o = k(T)
      , $ = V(o)
      , W = k($, !0);
    A($),
    A(T),
    A(L);
    var ie = V(L, 2)
      , pe = k(ie);
    nn(pe, 5, () => _, Zd, (Se, we) => {
        var Re = IM()
          , ke = k(Re, !0);
        A(Re),
        Ge( () => fe(ke, x(we))),
        H(Se, Re)
    }
    ),
    A(pe);
    var ye = V(pe, 2)
      , X = k(ye, !0);
    A(ye),
    A(ie),
    A(C),
    Ge( (Se, we, Re) => {
        fe(o, `${Se ?? ""} `),
        fe(W, we),
        fe(X, Re)
    }
    , [ () => P2(), () => A2(), () => Q2()]),
    H(b, C),
    Pr()
}
var AM = (b, l) => {
    l(!1)
}
  , kM = Ie('<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">📑 Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function EM(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15);
    Ii( () => {
        const W = ie => {
            ie.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", W),
        () => document.removeEventListener("keydown", W)
    }
    );
    var C = kM()
      , L = k(C)
      , O = V(k(L), 2)
      , T = V(k(O), 2)
      , o = k(T);
    lm(o, {}),
    A(T);
    var $ = V(T, 2);
    $.__click = [AM, _],
    A(O),
    A(L),
    fi(2),
    A(C),
    On(C, () => W => {
        Zr( () => {
            _() ? W.show() : W.close()
        }
        )
    }
    ),
    an("close", C, () => _(!1)),
    H(b, C),
    Pr()
}
Wi(["click"]);
var zM = () => {
    La.url.searchParams.delete("new-user"),
    Lg(La.url.toString())
}
  , LM = Ie('<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');
function DM(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15);
    Ii( () => {
        const we = Re => {
            Re.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", we),
        () => document.removeEventListener("keydown", we)
    }
    );
    var C = LM()
      , L = k(C)
      , O = k(L)
      , T = k(O)
      , o = k(T)
      , $ = k(o, !0);
    A(o);
    var W = V(o, 2);
    Ng(W, {
        hasText: !0,
        size: "medium"
    }),
    A(T),
    A(O);
    var ie = V(O, 2)
      , pe = k(ie);
    lm(pe, {}),
    A(ie);
    var ye = V(ie, 2)
      , X = k(ye);
    X.__click = [zM];
    var Se = k(X, !0);
    A(X),
    A(ye),
    A(L),
    A(C),
    On(C, () => we => {
        Zr( () => {
            _() ? we.show() : we.close()
        }
        )
    }
    ),
    Ge( (we, Re) => {
        fe($, we),
        fe(Se, Re)
    }
    , [ () => T2(), () => rw()]),
    an("close", C, () => _(!1)),
    H(b, C),
    Pr()
}
Wi(["click"]);
function RM() {
    const b = navigator.userAgent
      , l = navigator.vendor;
    return /Chrome/.test(b) && /Google Inc/.test(l) ? "Chrome" : /Safari/.test(b) && /Apple Computer/.test(l) ? "Safari" : /Firefox/.test(b) ? "Firefox" : /Edge/.test(b) ? "Edge" : /Opera|OPR/.test(b) ? "Opera" : "Unknown"
}
var BM = Tr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');
function FM(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = BM();
    er(C, () => ({
        viewBox: "0 0 512 512",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg",
        ..._
    })),
    H(b, C)
}
var OM = Tr('<svg><path fill="#0A0A08" d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');
function NM(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = OM();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        preserveAspectRatio: "xMidYMid",
        viewBox: "0 0 256 256",
        ..._
    })),
    H(b, C)
}
var jM = Tr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');
function Ld(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = jM();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var qM = Ie(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1)
  , VM = Ie('<span class="link cursor-auto">chrome://settings/system</span>.', 1)
  , UM = Ie('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1)
  , ZM = Ie(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1)
  , $M = Ie('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a class="link" href="https://www.reddit.com/r/WplaceLive/comments/1lhzmmq/bug_reports_and_feature_requests/" target="_blank"> </a> <span class="mx-0.5">|</span> <a href="https://discord.gg/wplacelive" target="_blank"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank"><!> <span class="link">Instagram</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> · <a class="link" href="https://wplace.live/terms/terms-of-service" target="_blank"> </a> · <a class="link" href="https://wplace.live/terms/privacy" target="_blank"> </a></section></div>')
  , GM = Ie('<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');
function HM(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15);
    Ii( () => {
        const pe = ye => {
            ye.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", pe),
        () => document.removeEventListener("keydown", pe)
    }
    );
    const C = RM();
    var L = GM()
      , O = k(L)
      , T = V(k(O), 2);
    {
        var o = pe => {
            var ye = $M()
              , X = k(ye)
              , Se = k(X);
            Ng(Se, {
                hasText: !0,
                size: "medium"
            });
            var we = V(Se, 2)
              , Re = k(we)
              , ke = V(Re, 4);
            fi(),
            A(we);
            var Oe = V(we, 2)
              , Ee = k(Oe)
              , Ne = k(Ee)
              , ft = k(Ne, !0);
            A(Ne);
            var ht = V(Ne, 4)
              , Xe = k(ht);
            am(Xe, {
                class: "mr-0.5 inline size-4"
            }),
            fi(2),
            A(ht);
            var ct = V(ht, 4)
              , Je = k(ct);
            FM(Je, {
                class: "mr-0.5 inline size-4"
            }),
            fi(2),
            A(ct);
            var Be = V(ct, 4)
              , st = k(Be);
            NM(st, {
                class: "mr-0.5 inline size-4"
            }),
            fi(2),
            A(Be),
            A(Ee),
            A(Oe),
            A(X);
            var it = V(X, 2)
              , Qe = k(it)
              , Ae = k(Qe, !0);
            A(Qe);
            var vt = V(Qe, 2);
            A(it);
            var Q = V(it, 2)
              , te = k(Q)
              , _e = k(te, !0);
            A(te);
            var ne = V(te, 2)
              , Pe = k(ne)
              , Me = V(Pe)
              , at = k(Me);
            Ld(at, {
                class: "size-5"
            }),
            A(Me);
            var We = V(Me);
            A(ne);
            var Ct = V(ne, 2)
              , _t = k(Ct)
              , xt = V(_t)
              , tt = k(xt, !0);
            A(xt);
            var pt = V(xt);
            A(Ct),
            A(Q);
            var It = V(Q, 2)
              , ut = k(It)
              , bt = k(ut, !0);
            A(ut);
            var wt = V(ut, 2)
              , dt = k(wt);
            {
                var Lt = jr => {
                    var ur = qM()
                      , Mr = zt(ur);
                    fi(),
                    Ge(Ar => fe(Mr, `${Ar ?? ""}: `), [ () => xS()]),
                    H(jr, ur)
                }
                  , Xt = jr => {
                    var ur = ZM()
                      , Mr = zt(ur)
                      , Ar = V(Mr)
                      , kr = k(Ar, !0);
                    A(Ar);
                    var Nr = V(Ar)
                      , ce = V(Nr);
                    {
                        var F = G => {
                            var K = VM();
                            fi(),
                            H(G, K)
                        }
                          , q = G => {
                            var K = Jt()
                              , le = zt(K);
                            {
                                var ve = Le => {
                                    var Ce = UM();
                                    fi(),
                                    H(Le, Ce)
                                }
                                ;
                                Ue(le, Le => {
                                    C === "Edge" && Le(ve)
                                }
                                , !0)
                            }
                            H(G, K)
                        }
                        ;
                        Ue(ce, G => {
                            C === "Chrome" ? G(F) : G(q, !1)
                        }
                        )
                    }
                    Ge( (G, K, le) => {
                        fe(Mr, `${G ?? ""} `),
                        fe(kr, K),
                        fe(Nr, ` ${le ?? ""} `)
                    }
                    , [ () => hS(), () => fS(), () => gS()]),
                    H(jr, ur)
                }
                ;
                Ue(dt, jr => {
                    C !== "Chrome" && C !== "Edge" ? jr(Lt) : jr(Xt, !1)
                }
                )
            }
            A(wt),
            A(It);
            var Yt = V(It, 2)
              , nr = k(Yt);
            lm(nr, {}),
            A(Yt);
            var ar = V(Yt, 4)
              , Ft = V(k(ar), 2)
              , dr = k(Ft, !0);
            A(Ft);
            var _r = V(Ft, 2)
              , Ir = k(_r, !0);
            A(_r),
            A(ar),
            A(ye),
            Ge( (jr, ur, Mr, Ar, kr, Nr, ce, F, q, G, K, le, ve) => {
                fe(Re, `${jr ?? ""} `),
                fe(ke, ` ©
						${ur ?? ""} `),
                fe(ft, Mr),
                fe(Ae, Ar),
                zr(vt, "src", oa.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"),
                fe(_e, kr),
                fe(Pe, `${Nr ?? ""} `),
                fe(We, ` ${ce ?? ""}`),
                fe(_t, `${F ?? ""} `),
                fe(tt, q),
                fe(pt, ` ${G ?? ""}`),
                fe(bt, K),
                fe(dr, le),
                fe(Ir, ve)
            }
            , [ () => g1(), () => x1(), () => T1(), () => P1(), () => A1(), () => z1(), () => R1(), () => O1(), () => q1(), () => Z1(), () => lS(), () => eP(), () => iP()]),
            En(2, ye, () => Qn, () => ({
                duration: 300
            })),
            H(pe, ye)
        }
        ;
        Ue(T, pe => {
            _() && pe(o)
        }
        )
    }
    A(O);
    var $ = V(O, 2)
      , W = k($)
      , ie = k(W, !0);
    A(W),
    A($),
    A(L),
    On(L, () => pe => {
        Zr( () => {
            _() ? pe.show() : pe.close()
        }
        )
    }
    ),
    Ge(pe => fe(ie, pe), [ () => tc()]),
    an("close", L, () => _(!1)),
    H(b, L),
    Pr()
}
function WM(b) {
    return typeof b == "function"
}
function mh(b) {
    return b !== null && typeof b == "object"
}
const XM = ["string", "number", "bigint", "boolean"];
function Sf(b) {
    return b == null || XM.includes(typeof b) ? !0 : Array.isArray(b) ? b.every(l => Sf(l)) : typeof b == "object" ? Object.getPrototypeOf(b) === Object.prototype : !1
}
const Iu = Symbol("box")
  , cm = Symbol("is-writable");
function KM(b) {
    return mh(b) && Iu in b
}
function YM(b) {
    return cr.isBox(b) && cm in b
}
function cr(b) {
    let l = nt(zn(b));
    return {
        [Iu]: !0,
        [cm]: !0,
        get current() {
            return x(l)
        },
        set current(_) {
            oe(l, _, !0)
        }
    }
}
function JM(b, l) {
    const _ = lt(b);
    return l ? {
        [Iu]: !0,
        [cm]: !0,
        get current() {
            return x(_)
        },
        set current(C) {
            l(C)
        }
    } : {
        [Iu]: !0,
        get current() {
            return b()
        }
    }
}
function QM(b) {
    return cr.isBox(b) ? b : WM(b) ? cr.with(b) : cr(b)
}
function e4(b) {
    return Object.entries(b).reduce( (l, [_,C]) => cr.isBox(C) ? (cr.isWritableBox(C) ? Object.defineProperty(l, _, {
        get() {
            return C.current
        },
        set(L) {
            C.current = L
        }
    }) : Object.defineProperty(l, _, {
        get() {
            return C.current
        }
    }),
    l) : Object.assign(l, {
        [_]: C
    }), {})
}
function t4(b) {
    return cr.isWritableBox(b) ? {
        [Iu]: !0,
        get current() {
            return b.current
        }
    } : b
}
cr.from = QM;
cr.with = JM;
cr.flatten = e4;
cr.readonly = t4;
cr.isBox = KM;
cr.isWritableBox = YM;
function r4(...b) {
    return function(l) {
        var _;
        for (const C of b)
            if (C) {
                if (l.defaultPrevented)
                    return;
                typeof C == "function" ? C.call(this, l) : (_ = C.current) == null || _.call(this, l)
            }
    }
}
var Hl = {}, hf, mg;
function i4() {
    if (mg)
        return hf;
    mg = 1;
    var b = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g
      , l = /\n/g
      , _ = /^\s*/
      , C = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/
      , L = /^:\s*/
      , O = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/
      , T = /^[;\s]*/
      , o = /^\s+|\s+$/g
      , $ = `
`
      , W = "/"
      , ie = "*"
      , pe = ""
      , ye = "comment"
      , X = "declaration";
    hf = function(we, Re) {
        if (typeof we != "string")
            throw new TypeError("First argument must be a string");
        if (!we)
            return [];
        Re = Re || {};
        var ke = 1
          , Oe = 1;
        function Ee(Qe) {
            var Ae = Qe.match(l);
            Ae && (ke += Ae.length);
            var vt = Qe.lastIndexOf($);
            Oe = ~vt ? Qe.length - vt : Oe + Qe.length
        }
        function Ne() {
            var Qe = {
                line: ke,
                column: Oe
            };
            return function(Ae) {
                return Ae.position = new ft(Qe),
                ct(),
                Ae
            }
        }
        function ft(Qe) {
            this.start = Qe,
            this.end = {
                line: ke,
                column: Oe
            },
            this.source = Re.source
        }
        ft.prototype.content = we;
        function ht(Qe) {
            var Ae = new Error(Re.source + ":" + ke + ":" + Oe + ": " + Qe);
            if (Ae.reason = Qe,
            Ae.filename = Re.source,
            Ae.line = ke,
            Ae.column = Oe,
            Ae.source = we,
            !Re.silent)
                throw Ae
        }
        function Xe(Qe) {
            var Ae = Qe.exec(we);
            if (Ae) {
                var vt = Ae[0];
                return Ee(vt),
                we = we.slice(vt.length),
                Ae
            }
        }
        function ct() {
            Xe(_)
        }
        function Je(Qe) {
            var Ae;
            for (Qe = Qe || []; Ae = Be(); )
                Ae !== !1 && Qe.push(Ae);
            return Qe
        }
        function Be() {
            var Qe = Ne();
            if (!(W != we.charAt(0) || ie != we.charAt(1))) {
                for (var Ae = 2; pe != we.charAt(Ae) && (ie != we.charAt(Ae) || W != we.charAt(Ae + 1)); )
                    ++Ae;
                if (Ae += 2,
                pe === we.charAt(Ae - 1))
                    return ht("End of comment missing");
                var vt = we.slice(2, Ae - 2);
                return Oe += 2,
                Ee(vt),
                we = we.slice(Ae),
                Oe += 2,
                Qe({
                    type: ye,
                    comment: vt
                })
            }
        }
        function st() {
            var Qe = Ne()
              , Ae = Xe(C);
            if (Ae) {
                if (Be(),
                !Xe(L))
                    return ht("property missing ':'");
                var vt = Xe(O)
                  , Q = Qe({
                    type: X,
                    property: Se(Ae[0].replace(b, pe)),
                    value: vt ? Se(vt[0].replace(b, pe)) : pe
                });
                return Xe(T),
                Q
            }
        }
        function it() {
            var Qe = [];
            Je(Qe);
            for (var Ae; Ae = st(); )
                Ae !== !1 && (Qe.push(Ae),
                Je(Qe));
            return Qe
        }
        return ct(),
        it()
    }
    ;
    function Se(we) {
        return we ? we.replace(o, pe) : pe
    }
    return hf
}
var _g;
function n4() {
    if (_g)
        return Hl;
    _g = 1;
    var b = Hl && Hl.__importDefault || function(C) {
        return C && C.__esModule ? C : {
            default: C
        }
    }
    ;
    Object.defineProperty(Hl, "__esModule", {
        value: !0
    }),
    Hl.default = _;
    var l = b(i4());
    function _(C, L) {
        var O = null;
        if (!C || typeof C != "string")
            return O;
        var T = (0,
        l.default)(C)
          , o = typeof L == "function";
        return T.forEach(function($) {
            if ($.type === "declaration") {
                var W = $.property
                  , ie = $.value;
                o ? L(W, ie, $) : ie && (O = O || {},
                O[W] = ie)
            }
        }),
        O
    }
    return Hl
}
var a4 = n4();
const gg = nm(a4)
  , s4 = gg.default || gg
  , o4 = /\d/
  , l4 = ["-", "_", "/", "."];
function c4(b="") {
    if (!o4.test(b))
        return b !== b.toLowerCase()
}
function u4(b) {
    const l = [];
    let _ = "", C, L;
    for (const O of b) {
        const T = l4.includes(O);
        if (T === !0) {
            l.push(_),
            _ = "",
            C = void 0;
            continue
        }
        const o = c4(O);
        if (L === !1) {
            if (C === !1 && o === !0) {
                l.push(_),
                _ = O,
                C = o;
                continue
            }
            if (C === !0 && o === !1 && _.length > 1) {
                const $ = _.at(-1);
                l.push(_.slice(0, Math.max(0, _.length - 1))),
                _ = $ + O,
                C = o;
                continue
            }
        }
        _ += O,
        C = o,
        L = T
    }
    return l.push(_),
    l
}
function lv(b) {
    return b ? u4(b).map(l => d4(l)).join("") : ""
}
function h4(b) {
    return p4(lv(b || ""))
}
function d4(b) {
    return b ? b[0].toUpperCase() + b.slice(1) : ""
}
function p4(b) {
    return b ? b[0].toLowerCase() + b.slice(1) : ""
}
function wd(b) {
    if (!b)
        return {};
    const l = {};
    function _(C, L) {
        if (C.startsWith("-moz-") || C.startsWith("-webkit-") || C.startsWith("-ms-") || C.startsWith("-o-")) {
            l[lv(C)] = L;
            return
        }
        if (C.startsWith("--")) {
            l[C] = L;
            return
        }
        l[h4(C)] = L
    }
    return s4(b, _),
    l
}
function f4(...b) {
    return (...l) => {
        for (const _ of b)
            typeof _ == "function" && _(...l)
    }
}
function m4(b, l) {
    const _ = RegExp(b, "g");
    return C => {
        if (typeof C != "string")
            throw new TypeError(`expected an argument of type string, but got ${typeof C}`);
        return C.match(_) ? C.replace(_, l) : C
    }
}
const _4 = m4(/[A-Z]/, b => `-${b.toLowerCase()}`);
function g4(b) {
    if (!b || typeof b != "object" || Array.isArray(b))
        throw new TypeError(`expected an argument of type object, but got ${typeof b}`);
    return Object.keys(b).map(l => `${_4(l)}: ${b[l]};`).join(`
`)
}
function cv(b={}) {
    return g4(b).replace(`
`, " ")
}
const uv = {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0",
    transform: "translateX(-100%)"
};
cv(uv);
const v4 = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"]
  , y4 = new Set(v4);
function x4(b) {
    return y4.has(b)
}
function Da(...b) {
    const l = {
        ...b[0]
    };
    for (let _ = 1; _ < b.length; _++) {
        const C = b[_];
        if (C) {
            for (const L of Object.keys(C)) {
                const O = l[L]
                  , T = C[L]
                  , o = typeof O == "function"
                  , $ = typeof T == "function";
                if (o && x4(L)) {
                    const W = O
                      , ie = T;
                    l[L] = r4(W, ie)
                } else if (o && $)
                    l[L] = f4(O, T);
                else if (L === "class") {
                    const W = Sf(O)
                      , ie = Sf(T);
                    W && ie ? l[L] = Tu(O, T) : W ? l[L] = Tu(O) : ie && (l[L] = Tu(T))
                } else if (L === "style") {
                    const W = typeof O == "object"
                      , ie = typeof T == "object"
                      , pe = typeof O == "string"
                      , ye = typeof T == "string";
                    if (W && ie)
                        l[L] = {
                            ...O,
                            ...T
                        };
                    else if (W && ye) {
                        const X = wd(T);
                        l[L] = {
                            ...O,
                            ...X
                        }
                    } else if (pe && ie) {
                        const X = wd(O);
                        l[L] = {
                            ...X,
                            ...T
                        }
                    } else if (pe && ye) {
                        const X = wd(O)
                          , Se = wd(T);
                        l[L] = {
                            ...X,
                            ...Se
                        }
                    } else
                        W ? l[L] = O : ie ? l[L] = T : pe ? l[L] = O : ye && (l[L] = T)
                } else
                    l[L] = T !== void 0 ? T : O
            }
            for (const L of Object.getOwnPropertySymbols(C)) {
                const O = l[L]
                  , T = C[L];
                l[L] = T !== void 0 ? T : O
            }
        }
    }
    return typeof l.style == "object" && (l.style = cv(l.style).replaceAll(`
`, " ")),
    l.hidden !== !0 && (l.hidden = void 0,
    delete l.hidden),
    l.disabled !== !0 && (l.disabled = void 0,
    delete l.disabled),
    l
}
const b4 = typeof window < "u" ? window : void 0;
function w4(b) {
    let l = b.activeElement;
    for (; l != null && l.shadowRoot; ) {
        const _ = l.shadowRoot.activeElement;
        if (_ === l)
            break;
        l = _
    }
    return l
}
var ic, Lu;
class T4 {
    constructor(l={}) {
        br(this, ic);
        br(this, Lu);
        const {window: _=b4, document: C=_ == null ? void 0 : _.document} = l;
        _ !== void 0 && (Jn(this, ic, C),
        Jn(this, Lu, zg(L => {
            const O = Su(_, "focusin", L)
              , T = Su(_, "focusout", L);
            return () => {
                O(),
                T()
            }
        }
        )))
    }
    get current() {
        var l;
        return (l = et(this, Lu)) == null || l.call(this),
        et(this, ic) ? w4(et(this, ic)) : null
    }
}
ic = new WeakMap,
Lu = new WeakMap;
new T4;
var Du, zs;
class um {
    constructor(l) {
        br(this, Du);
        br(this, zs);
        Jn(this, Du, l),
        Jn(this, zs, Symbol(l))
    }
    get key() {
        return et(this, zs)
    }
    exists() {
        return Ny(et(this, zs))
    }
    get() {
        const l = ag(et(this, zs));
        if (l === void 0)
            throw new Error(`Context "${et(this, Du)}" not found`);
        return l
    }
    getOr(l) {
        const _ = ag(et(this, zs));
        return _ === void 0 ? l : _
    }
    set(l) {
        return jy(et(this, zs), l)
    }
}
Du = new WeakMap,
zs = new WeakMap;
function C4(b, l) {
    switch (b) {
    case "post":
        Zr(l);
        break;
    case "pre":
        Hf(l);
        break
    }
}
function hv(b, l, _, C={}) {
    const {lazy: L=!1} = C;
    let O = !L
      , T = Array.isArray(b) ? [] : void 0;
    C4(l, () => {
        const o = Array.isArray(b) ? b.map(W => W()) : b();
        if (!O) {
            O = !0,
            T = o;
            return
        }
        const $ = Go( () => _(o, T));
        return T = o,
        $
    }
    )
}
function oo(b, l, _) {
    hv(b, "post", l, _)
}
function S4(b, l, _) {
    hv(b, "pre", l, _)
}
oo.pre = S4;
var nc;
class P4 {
    constructor(l, _) {
        br(this, nc, nt(void 0));
        _ !== void 0 && oe(et(this, nc), _, !0),
        oo( () => l(), (C, L) => {
            oe(et(this, nc), L, !0)
        }
        )
    }
    get current() {
        return x(et(this, nc))
    }
}
nc = new WeakMap;
function I4(b, l) {
    return setTimeout(l, b)
}
function Wl(b) {
    Mg().then(b)
}
const M4 = 1
  , A4 = 9
  , k4 = 11;
function E4(b) {
    return mh(b) && b.nodeType === M4 && typeof b.nodeName == "string"
}
function dv(b) {
    return mh(b) && b.nodeType === A4
}
function z4(b) {
    var l;
    return mh(b) && ((l = b.constructor) == null ? void 0 : l.name) === "VisualViewport"
}
function L4(b) {
    return mh(b) && b.nodeType !== void 0
}
function D4(b) {
    return L4(b) && b.nodeType === k4 && "host"in b
}
function R4(b) {
    return dv(b) ? b : z4(b) ? b.document : (b == null ? void 0 : b.ownerDocument) ?? document
}
function pv(b) {
    var l;
    return D4(b) ? pv(b.host) : dv(b) ? b.defaultView ?? window : E4(b) ? ((l = b.ownerDocument) == null ? void 0 : l.defaultView) ?? window : window
}
function B4(b) {
    let l = b.activeElement;
    for (; l != null && l.shadowRoot; ) {
        const _ = l.shadowRoot.activeElement;
        if (_ === l)
            break;
        l = _
    }
    return l
}
var Ru;
class F4 {
    constructor(l) {
        lr(this, "element");
        br(this, Ru, lt( () => this.element.current ? this.element.current.getRootNode() ?? document : document));
        lr(this, "getDocument", () => R4(this.root));
        lr(this, "getWindow", () => this.getDocument().defaultView ?? window);
        lr(this, "getActiveElement", () => B4(this.root));
        lr(this, "isActiveElement", l => l === this.getActiveElement());
        lr(this, "querySelector", l => this.root ? this.root.querySelector(l) : null);
        lr(this, "querySelectorAll", l => this.root ? this.root.querySelectorAll(l) : []);
        lr(this, "setTimeout", (l, _) => this.getWindow().setTimeout(l, _));
        lr(this, "clearTimeout", l => this.getWindow().clearTimeout(l));
        typeof l == "function" ? this.element = cr.with(l) : this.element = l
    }
    get root() {
        return x(et(this, Ru))
    }
    set root(l) {
        oe(et(this, Ru), l)
    }
    getElementById(l) {
        return this.root.getElementById(l)
    }
}
Ru = new WeakMap;
function Va(b, l) {
    return {
        [Ix()]: _ => cr.isBox(b) ? (b.current = _,
        Go( () => l == null ? void 0 : l(_)),
        () => {
            "isConnected"in _ && _.isConnected || (b.current = null,
            l == null || l(null))
        }
        ) : (b(_),
        Go( () => l == null ? void 0 : l(_)),
        () => {
            "isConnected"in _ && _.isConnected || (b(null),
            l == null || l(null))
        }
        )
    }
}
function O4(b) {
    return b ? "true" : "false"
}
function N4(b) {
    return b ? "true" : "false"
}
function j4(b) {
    return b ? "" : void 0
}
function q4(b) {
    return b ? "true" : "false"
}
function V4(b) {
    return b ? "" : void 0
}
function U4(b) {
    return b ? !0 : void 0
}
var ac, Bu;
class Z4 {
    constructor(l) {
        br(this, ac);
        br(this, Bu);
        lr(this, "attrs");
        Jn(this, ac, l.getVariant ? l.getVariant() : null),
        Jn(this, Bu, et(this, ac) ? `data-${et(this, ac)}-` : `data-${l.component}-`),
        this.getAttr = this.getAttr.bind(this),
        this.selector = this.selector.bind(this),
        this.attrs = Object.fromEntries(l.parts.map(_ => [_, this.getAttr(_)]))
    }
    getAttr(l, _) {
        return _ ? `data-${_}-${l}` : `${et(this, Bu)}${l}`
    }
    selector(l, _) {
        return `[${this.getAttr(l, _)}]`
    }
}
ac = new WeakMap,
Bu = new WeakMap;
function fv(b) {
    const l = new Z4(b);
    return {
        ...l.attrs,
        selector: l.selector,
        getAttr: l.getAttr
    }
}
const $4 = "ArrowDown"
  , G4 = "ArrowLeft"
  , H4 = "ArrowRight"
  , W4 = "ArrowUp"
  , X4 = "End"
  , K4 = "Enter"
  , Y4 = "Home"
  , J4 = "p"
  , Q4 = "n"
  , e6 = "j"
  , t6 = "k"
  , r6 = "h"
  , i6 = "l";
function Mu() {}
function Ua(b, l) {
    return `bits-${b}`
}
function n6(b) {
    if (!b)
        return null;
    for (const l of b.childNodes)
        if (l.nodeType !== Node.COMMENT_NODE)
            return l;
    return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
    current: 0
});
function a6(b="bits") {
    return globalThis.bitsIdCounter.current++,
    `${b}-${globalThis.bitsIdCounter.current}`
}
function s6(b, l) {
    let _ = b.nextElementSibling;
    for (; _; ) {
        if (_.matches(l))
            return _;
        _ = _.nextElementSibling
    }
}
function o6(b, l) {
    let _ = b.previousElementSibling;
    for (; _; ) {
        if (_.matches(l))
            return _;
        _ = _.previousElementSibling
    }
}
function mv(b) {
    if (typeof CSS < "u" && typeof CSS.escape == "function")
        return CSS.escape(b);
    const l = b.length;
    let _ = -1, C, L = "";
    const O = b.charCodeAt(0);
    if (l === 1 && O === 45)
        return "\\" + b;
    for (; ++_ < l; ) {
        if (C = b.charCodeAt(_),
        C === 0) {
            L += "�";
            continue
        }
        if (C >= 1 && C <= 31 || C === 127 || _ === 0 && C >= 48 && C <= 57 || _ === 1 && C >= 48 && C <= 57 && O === 45) {
            L += "\\" + C.toString(16) + " ";
            continue
        }
        if (C >= 128 || C === 45 || C === 95 || C >= 48 && C <= 57 || C >= 65 && C <= 90 || C >= 97 && C <= 122) {
            L += b.charAt(_);
            continue
        }
        L += "\\" + b.charAt(_)
    }
    return L
}
const Uo = "data-value"
  , ma = fv({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
})
  , Xl = ma.selector("group")
  , df = ma.selector("group-items")
  , vg = ma.selector("group-heading")
  , _v = ma.selector("item")
  , pf = `${ma.selector("item")}:not([aria-disabled="true"])`
  , Xo = new um("Command.Root")
  , l6 = new um("Command.List")
  , Au = new um("Command.Group")
  , yg = {
    search: "",
    value: "",
    filtered: {
        count: 0,
        items: new Map,
        groups: new Set
    }
};
var sc, Fu, Ou, Nu, ju, qu, Vu, Uu, ir, gv, Md, If, Ad, kd, Ed, no, vv, yv, Mf, yu, Af, kf, xv, xu, Ef, zf, bv, bu, wu, Zu;
const pm = class pm {
    constructor(l) {
        br(this, ir);
        lr(this, "opts");
        lr(this, "attachment");
        br(this, sc, !1);
        br(this, Fu, !0);
        lr(this, "sortAfterTick", !1);
        lr(this, "sortAndFilterAfterTick", !1);
        lr(this, "allItems", new Set);
        lr(this, "allGroups", new Map);
        lr(this, "allIds", new Map);
        br(this, Ou, nt(0));
        br(this, Nu, nt(null));
        br(this, ju, nt(null));
        br(this, qu, nt(null));
        br(this, Vu, nt(yg));
        br(this, Uu, nt(zn(yg)));
        br(this, Zu, lt( () => ({
            id: this.opts.id.current,
            role: "application",
            [ma.root]: "",
            tabindex: -1,
            onkeydown: this.onkeydown,
            ...this.attachment
        })));
        this.opts = l,
        this.attachment = Va(this.opts.ref);
        const _ = {
            ...this._commandState,
            value: this.opts.value.current ?? ""
        };
        this._commandState = _,
        this.commandState = _,
        this.onkeydown = this.onkeydown.bind(this)
    }
    static create(l) {
        return Xo.set(new pm(l))
    }
    get key() {
        return x(et(this, Ou))
    }
    set key(l) {
        oe(et(this, Ou), l, !0)
    }
    get viewportNode() {
        return x(et(this, Nu))
    }
    set viewportNode(l) {
        oe(et(this, Nu), l, !0)
    }
    get inputNode() {
        return x(et(this, ju))
    }
    set inputNode(l) {
        oe(et(this, ju), l, !0)
    }
    get labelNode() {
        return x(et(this, qu))
    }
    set labelNode(l) {
        oe(et(this, qu), l, !0)
    }
    get commandState() {
        return x(et(this, Vu))
    }
    set commandState(l) {
        oe(et(this, Vu), l)
    }
    get _commandState() {
        return x(et(this, Uu))
    }
    set _commandState(l) {
        oe(et(this, Uu), l, !0)
    }
    setState(l, _, C) {
        Object.is(this._commandState[l], _) || (this._commandState[l] = _,
        l === "search" ? (Fr(this, ir, Ed).call(this),
        Fr(this, ir, Ad).call(this)) : l === "value" && (C || Fr(this, ir, vv).call(this)),
        Fr(this, ir, Md).call(this))
    }
    setValue(l, _) {
        l !== this.opts.value.current && l === "" && Wl( () => {
            this.key++
        }
        ),
        this.setState("value", l, _),
        this.opts.value.current = l
    }
    getValidItems() {
        const l = this.opts.ref.current;
        return l ? Array.from(l.querySelectorAll(pf)).filter(C => !!C) : []
    }
    getVisibleItems() {
        const l = this.opts.ref.current;
        return l ? Array.from(l.querySelectorAll(_v)).filter(C => !!C) : []
    }
    get itemsGrid() {
        var o, $, W, ie;
        if (!this.isGrid)
            return [];
        const l = this.opts.columns.current ?? 1
          , _ = this.getVisibleItems()
          , C = [[]];
        let L = (o = _[0]) == null ? void 0 : o.getAttribute("data-group")
          , O = 0
          , T = 0;
        for (let pe = 0; pe < _.length; pe++) {
            const ye = _[pe]
              , X = ye == null ? void 0 : ye.getAttribute("data-group");
            L !== X ? (L = X,
            O = 1,
            T++,
            C.push([{
                index: pe,
                firstRowOfGroup: !0,
                ref: ye
            }])) : (O++,
            O > l && (T++,
            O = 1,
            C.push([])),
            (ie = C[T]) == null || ie.push({
                index: pe,
                firstRowOfGroup: ((W = ($ = C[T]) == null ? void 0 : $[0]) == null ? void 0 : W.firstRowOfGroup) ?? pe === 0,
                ref: ye
            }))
        }
        return C
    }
    updateSelectedToIndex(l) {
        const _ = this.getValidItems()[l];
        _ && this.setValue(_.getAttribute(Uo) ?? "")
    }
    updateSelectedByItem(l) {
        const _ = Fr(this, ir, no).call(this)
          , C = this.getValidItems()
          , L = C.findIndex(T => T === _);
        let O = C[L + l];
        this.opts.loop.current && (O = L + l < 0 ? C[C.length - 1] : L + l === C.length ? C[0] : C[L + l]),
        O && this.setValue(O.getAttribute(Uo) ?? "")
    }
    updateSelectedByGroup(l) {
        const _ = Fr(this, ir, no).call(this);
        let C = _ == null ? void 0 : _.closest(Xl), L;
        for (; C && !L; )
            C = l > 0 ? s6(C, Xl) : o6(C, Xl),
            L = C == null ? void 0 : C.querySelector(pf);
        L ? this.setValue(L.getAttribute(Uo) ?? "") : this.updateSelectedByItem(l)
    }
    registerValue(l, _) {
        var C;
        return l && l === ((C = this.allIds.get(l)) == null ? void 0 : C.value) || this.allIds.set(l, {
            value: l,
            keywords: _
        }),
        this._commandState.filtered.items.set(l, Fr(this, ir, If).call(this, l, _)),
        this.sortAfterTick || (this.sortAfterTick = !0,
        Wl( () => {
            Fr(this, ir, Ad).call(this),
            this.sortAfterTick = !1
        }
        )),
        () => {
            this.allIds.delete(l)
        }
    }
    registerItem(l, _) {
        return this.allItems.add(l),
        _ && (this.allGroups.has(_) ? this.allGroups.get(_).add(l) : this.allGroups.set(_, new Set([l]))),
        this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0,
        Wl( () => {
            Fr(this, ir, Ed).call(this),
            Fr(this, ir, Ad).call(this),
            this.sortAndFilterAfterTick = !1
        }
        )),
        Fr(this, ir, Md).call(this),
        () => {
            const C = Fr(this, ir, no).call(this);
            this.allIds.delete(l),
            this.allItems.delete(l),
            this.commandState.filtered.items.delete(l),
            Fr(this, ir, Ed).call(this),
            (C == null ? void 0 : C.getAttribute("id")) === l && Fr(this, ir, kd).call(this),
            Fr(this, ir, Md).call(this)
        }
    }
    registerGroup(l) {
        return this.allGroups.has(l) || this.allGroups.set(l, new Set),
        () => {
            this.allIds.delete(l),
            this.allGroups.delete(l)
        }
    }
    get isGrid() {
        return this.opts.columns.current !== null
    }
    onkeydown(l) {
        const _ = this.opts.vimBindings.current && l.ctrlKey;
        switch (l.key) {
        case Q4:
        case e6:
            {
                _ && (this.isGrid ? Fr(this, ir, Af).call(this, l) : Fr(this, ir, yu).call(this, l));
                break
            }
        case i6:
            {
                _ && this.isGrid && Fr(this, ir, yu).call(this, l);
                break
            }
        case $4:
            this.isGrid ? Fr(this, ir, Af).call(this, l) : Fr(this, ir, yu).call(this, l);
            break;
        case H4:
            if (!this.isGrid)
                break;
            Fr(this, ir, yu).call(this, l);
            break;
        case J4:
        case t6:
            {
                _ && (this.isGrid ? Fr(this, ir, zf).call(this, l) : Fr(this, ir, wu).call(this, l));
                break
            }
        case r6:
            {
                _ && this.isGrid && Fr(this, ir, wu).call(this, l);
                break
            }
        case W4:
            this.isGrid ? Fr(this, ir, zf).call(this, l) : Fr(this, ir, wu).call(this, l);
            break;
        case G4:
            if (!this.isGrid)
                break;
            Fr(this, ir, wu).call(this, l);
            break;
        case Y4:
            l.preventDefault(),
            this.updateSelectedToIndex(0);
            break;
        case X4:
            l.preventDefault(),
            Fr(this, ir, Mf).call(this);
            break;
        case K4:
            if (!l.isComposing && l.keyCode !== 229) {
                l.preventDefault();
                const C = Fr(this, ir, no).call(this);
                C && (C == null || C.click())
            }
        }
    }
    get props() {
        return x(et(this, Zu))
    }
    set props(l) {
        oe(et(this, Zu), l)
    }
}
;
sc = new WeakMap,
Fu = new WeakMap,
Ou = new WeakMap,
Nu = new WeakMap,
ju = new WeakMap,
qu = new WeakMap,
Vu = new WeakMap,
Uu = new WeakMap,
ir = new WeakSet,
gv = function() {
    return Px(this._commandState)
}
,
Md = function() {
    et(this, sc) || (Jn(this, sc, !0),
    Wl( () => {
        var C, L;
        Jn(this, sc, !1);
        const l = Fr(this, ir, gv).call(this);
        !Object.is(this.commandState, l) && (this.commandState = l,
        (L = (C = this.opts.onStateChange) == null ? void 0 : C.current) == null || L.call(C, l))
    }
    ))
}
,
If = function(l, _) {
    const C = this.opts.filter.current ?? Cv;
    return l ? C(l, this._commandState.search, _) : 0
}
,
Ad = function() {
    var T;
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
        Fr(this, ir, kd).call(this);
        return
    }
    const l = this._commandState.filtered.items
      , _ = [];
    for (const o of this._commandState.filtered.groups) {
        const $ = this.allGroups.get(o);
        let W = 0;
        if (!$) {
            _.push([o, W]);
            continue
        }
        for (const ie of $) {
            const pe = l.get(ie);
            W = Math.max(pe ?? 0, W)
        }
        _.push([o, W])
    }
    const C = this.viewportNode
      , L = this.getValidItems().sort( (o, $) => {
        const W = o.getAttribute("data-value")
          , ie = $.getAttribute("data-value")
          , pe = l.get(W) ?? 0;
        return (l.get(ie) ?? 0) - pe
    }
    );
    for (const o of L) {
        const $ = o.closest(df);
        if ($) {
            const W = o.parentElement === $ ? o : o.closest(`${df} > *`);
            W && $.appendChild(W)
        } else {
            const W = o.parentElement === C ? o : o.closest(`${df} > *`);
            W && (C == null || C.appendChild(W))
        }
    }
    const O = _.sort( (o, $) => $[1] - o[1]);
    for (const o of O) {
        const $ = C == null ? void 0 : C.querySelector(`${Xl}[${Uo}="${mv(o[0])}"]`);
        (T = $ == null ? void 0 : $.parentElement) == null || T.appendChild($)
    }
    Fr(this, ir, kd).call(this)
}
,
kd = function() {
    Wl( () => {
        const l = this.getValidItems().find(L => L.getAttribute("aria-disabled") !== "true")
          , _ = l == null ? void 0 : l.getAttribute(Uo)
          , C = et(this, Fu) && this.opts.disableInitialScroll.current;
        this.setValue(_ ?? "", C),
        Jn(this, Fu, !1)
    }
    )
}
,
Ed = function() {
    var _, C;
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
        this._commandState.filtered.count = this.allItems.size;
        return
    }
    this._commandState.filtered.groups = new Set;
    let l = 0;
    for (const L of this.allItems) {
        const O = ((_ = this.allIds.get(L)) == null ? void 0 : _.value) ?? ""
          , T = ((C = this.allIds.get(L)) == null ? void 0 : C.keywords) ?? []
          , o = Fr(this, ir, If).call(this, O, T);
        this._commandState.filtered.items.set(L, o),
        o > 0 && l++
    }
    for (const [L,O] of this.allGroups)
        for (const T of O) {
            const o = this._commandState.filtered.items.get(T);
            if (o && o > 0) {
                this._commandState.filtered.groups.add(L);
                break
            }
        }
    this._commandState.filtered.count = l
}
,
no = function() {
    const l = this.opts.ref.current;
    if (!l)
        return;
    const _ = l.querySelector(`${pf}[data-selected]`);
    if (_)
        return _
}
,
vv = function() {
    Wl( () => {
        var C, L, O, T, o;
        const l = Fr(this, ir, no).call(this);
        if (!l)
            return;
        const _ = (C = l.parentElement) == null ? void 0 : C.parentElement;
        if (_) {
            if (this.isGrid) {
                const $ = Fr(this, ir, yv).call(this, l);
                if (l.scrollIntoView({
                    block: "nearest"
                }),
                $) {
                    const W = (L = l == null ? void 0 : l.closest(Xl)) == null ? void 0 : L.querySelector(vg);
                    W == null || W.scrollIntoView({
                        block: "nearest"
                    });
                    return
                }
            } else {
                const $ = n6(_);
                if ($ && ((O = $.dataset) == null ? void 0 : O.value) === ((T = l.dataset) == null ? void 0 : T.value)) {
                    const W = (o = l == null ? void 0 : l.closest(Xl)) == null ? void 0 : o.querySelector(vg);
                    W == null || W.scrollIntoView({
                        block: "nearest"
                    });
                    return
                }
            }
            l.scrollIntoView({
                block: "nearest"
            })
        }
    }
    )
}
,
yv = function(l) {
    const _ = this.itemsGrid;
    if (_.length === 0)
        return !1;
    for (let C = 0; C < _.length; C++) {
        const L = _[C];
        if (L !== void 0)
            for (let O = 0; O < L.length; O++) {
                const T = L[O];
                if (!(T === void 0 || T.ref !== l))
                    return T.firstRowOfGroup
            }
    }
    return !1
}
,
Mf = function() {
    return this.updateSelectedToIndex(this.getValidItems().length - 1)
}
,
yu = function(l) {
    l.preventDefault(),
    l.metaKey ? Fr(this, ir, Mf).call(this) : l.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}
,
Af = function(l) {
    this.opts.columns.current !== null && (l.preventDefault(),
    l.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(Fr(this, ir, xv).call(this, l)))
}
,
kf = function(l, _) {
    if (_.length === 0)
        return null;
    for (let C = 0; C < _.length; C++) {
        const L = _[C];
        if (L !== void 0)
            for (let O = 0; O < L.length; O++) {
                const T = L[O];
                if (!(T === void 0 || T.ref !== l))
                    return {
                        columnIndex: O,
                        rowIndex: C
                    }
            }
    }
    return null
}
,
xv = function(l) {
    const _ = this.itemsGrid
      , C = Fr(this, ir, no).call(this);
    if (!C)
        return 0;
    const L = Fr(this, ir, kf).call(this, C, _);
    if (!L)
        return 0;
    let O = null;
    const T = l.altKey ? 1 : 0;
    if (l.altKey && L.rowIndex === _.length - 2 && !this.opts.loop.current)
        O = Fr(this, ir, xu).call(this, {
            start: _.length - 1,
            end: _.length,
            expectedColumnIndex: L.columnIndex,
            grid: _
        });
    else if (L.rowIndex === _.length - 1) {
        if (!this.opts.loop.current)
            return 0;
        O = Fr(this, ir, xu).call(this, {
            start: 0 + T,
            end: L.rowIndex,
            expectedColumnIndex: L.columnIndex,
            grid: _
        })
    } else
        O = Fr(this, ir, xu).call(this, {
            start: L.rowIndex + 1 + T,
            end: _.length,
            expectedColumnIndex: L.columnIndex,
            grid: _
        }),
        O === null && this.opts.loop.current && (O = Fr(this, ir, xu).call(this, {
            start: 0,
            end: L.rowIndex,
            expectedColumnIndex: L.columnIndex,
            grid: _
        }));
    return Fr(this, ir, Ef).call(this, C, O)
}
,
xu = function({start: l, end: _, grid: C, expectedColumnIndex: L}) {
    var T;
    let O = null;
    for (let o = l; o < _; o++) {
        const $ = C[o];
        if (O = ((T = $[L]) == null ? void 0 : T.ref) ?? null,
        O !== null && Td(O)) {
            O = null;
            continue
        }
        if (O === null)
            for (let W = $.length - 1; W >= 0; W--) {
                const ie = $[$.length - 1];
                if (!(ie === void 0 || Td(ie.ref))) {
                    O = ie.ref;
                    break
                }
            }
        break
    }
    return O
}
,
Ef = function(l, _) {
    if (_ === null)
        return 0;
    const C = this.getValidItems()
      , L = C.findIndex(T => T === l);
    return C.findIndex(T => T === _) - L
}
,
zf = function(l) {
    this.opts.columns.current !== null && (l.preventDefault(),
    l.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(Fr(this, ir, bv).call(this, l)))
}
,
bv = function(l) {
    const _ = this.itemsGrid
      , C = Fr(this, ir, no).call(this);
    if (C === void 0)
        return 0;
    const L = Fr(this, ir, kf).call(this, C, _);
    if (L === null)
        return 0;
    let O = null;
    const T = l.altKey ? 1 : 0;
    if (l.altKey && L.rowIndex === 1 && this.opts.loop.current === !1)
        O = Fr(this, ir, bu).call(this, {
            start: 0,
            end: 0,
            expectedColumnIndex: L.columnIndex,
            grid: _
        });
    else if (L.rowIndex === 0) {
        if (this.opts.loop.current === !1)
            return 0;
        O = Fr(this, ir, bu).call(this, {
            start: _.length - 1 - T,
            end: L.rowIndex + 1,
            expectedColumnIndex: L.columnIndex,
            grid: _
        })
    } else
        O = Fr(this, ir, bu).call(this, {
            start: L.rowIndex - 1 - T,
            end: 0,
            expectedColumnIndex: L.columnIndex,
            grid: _
        }),
        O === null && this.opts.loop.current && (O = Fr(this, ir, bu).call(this, {
            start: _.length - 1,
            end: L.rowIndex + 1,
            expectedColumnIndex: L.columnIndex,
            grid: _
        }));
    return Fr(this, ir, Ef).call(this, C, O)
}
,
bu = function({start: l, end: _, grid: C, expectedColumnIndex: L}) {
    var T;
    let O = null;
    for (let o = l; o >= _; o--) {
        const $ = C[o];
        if ($ !== void 0) {
            if (O = ((T = $[L]) == null ? void 0 : T.ref) ?? null,
            O !== null && Td(O)) {
                O = null;
                continue
            }
            if (O === null)
                for (let W = $.length - 1; W >= 0; W--) {
                    const ie = $[$.length - 1];
                    if (!(ie === void 0 || Td(ie.ref))) {
                        O = ie.ref;
                        break
                    }
                }
            break
        }
    }
    return O
}
,
wu = function(l) {
    l.preventDefault(),
    l.metaKey ? this.updateSelectedToIndex(0) : l.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}
,
Zu = new WeakMap;
let Pf = pm;
function Td(b) {
    return b.getAttribute("aria-disabled") === "true"
}
var $u, Gu, Hu;
const fm = class fm {
    constructor(l, _) {
        lr(this, "opts");
        lr(this, "root");
        lr(this, "attachment");
        br(this, $u, lt( () => this.root._commandState.filtered.count === 0 && et(this, Gu) === !1 || this.opts.forceMount.current));
        br(this, Gu, !0);
        br(this, Hu, lt( () => ({
            id: this.opts.id.current,
            role: "presentation",
            [ma.empty]: "",
            ...this.attachment
        })));
        this.opts = l,
        this.root = _,
        this.attachment = Va(this.opts.ref),
        Hf( () => {
            Jn(this, Gu, !1)
        }
        )
    }
    static create(l) {
        return new fm(l,Xo.get())
    }
    get shouldRender() {
        return x(et(this, $u))
    }
    set shouldRender(l) {
        oe(et(this, $u), l)
    }
    get props() {
        return x(et(this, Hu))
    }
    set props(l) {
        oe(et(this, Hu), l)
    }
}
;
$u = new WeakMap,
Gu = new WeakMap,
Hu = new WeakMap;
let Lf = fm;
var Wu, Xu, Ku, Yu;
const mm = class mm {
    constructor(l, _) {
        lr(this, "opts");
        lr(this, "root");
        lr(this, "attachment");
        br(this, Wu, lt( () => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
        br(this, Xu, nt(null));
        br(this, Ku, nt(""));
        br(this, Yu, lt( () => ({
            id: this.opts.id.current,
            role: "presentation",
            hidden: this.shouldRender ? void 0 : !0,
            "data-value": this.trueValue,
            [ma.group]: "",
            ...this.attachment
        })));
        this.opts = l,
        this.root = _,
        this.attachment = Va(this.opts.ref),
        this.trueValue = l.value.current ?? l.id.current,
        oo( () => this.trueValue, () => this.root.registerGroup(this.trueValue)),
        Zr( () => this.opts.value.current ? (this.trueValue = this.opts.value.current,
        this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(),
        this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`,
        this.root.registerValue(this.trueValue)))
    }
    static create(l) {
        return Au.set(new mm(l,Xo.get()))
    }
    get shouldRender() {
        return x(et(this, Wu))
    }
    set shouldRender(l) {
        oe(et(this, Wu), l)
    }
    get headingNode() {
        return x(et(this, Xu))
    }
    set headingNode(l) {
        oe(et(this, Xu), l, !0)
    }
    get trueValue() {
        return x(et(this, Ku))
    }
    set trueValue(l) {
        oe(et(this, Ku), l, !0)
    }
    get props() {
        return x(et(this, Yu))
    }
    set props(l) {
        oe(et(this, Yu), l)
    }
}
;
Wu = new WeakMap,
Xu = new WeakMap,
Ku = new WeakMap,
Yu = new WeakMap;
let Df = mm;
var Ju;
const _m = class _m {
    constructor(l, _) {
        lr(this, "opts");
        lr(this, "group");
        lr(this, "attachment");
        br(this, Ju, lt( () => ({
            id: this.opts.id.current,
            [ma["group-heading"]]: "",
            ...this.attachment
        })));
        this.opts = l,
        this.group = _,
        this.attachment = Va(this.opts.ref, C => this.group.headingNode = C)
    }
    static create(l) {
        return new _m(l,Au.get())
    }
    get props() {
        return x(et(this, Ju))
    }
    set props(l) {
        oe(et(this, Ju), l)
    }
}
;
Ju = new WeakMap;
let Rf = _m;
var Qu;
const gm = class gm {
    constructor(l, _) {
        lr(this, "opts");
        lr(this, "group");
        lr(this, "attachment");
        br(this, Qu, lt( () => {
            var l;
            return {
                id: this.opts.id.current,
                role: "group",
                [ma["group-items"]]: "",
                "aria-labelledby": ((l = this.group.headingNode) == null ? void 0 : l.id) ?? void 0,
                ...this.attachment
            }
        }
        ));
        this.opts = l,
        this.group = _,
        this.attachment = Va(this.opts.ref)
    }
    static create(l) {
        return new gm(l,Au.get())
    }
    get props() {
        return x(et(this, Qu))
    }
    set props(l) {
        oe(et(this, Qu), l)
    }
}
;
Qu = new WeakMap;
let Bf = gm;
var Dd, eh;
const vm = class vm {
    constructor(l, _) {
        lr(this, "opts");
        lr(this, "root");
        lr(this, "attachment");
        br(this, Dd, lt( () => {
            var _;
            const l = (_ = this.root.viewportNode) == null ? void 0 : _.querySelector(`${_v}[${Uo}="${mv(this.root.opts.value.current)}"]`);
            if (l != null)
                return l.getAttribute("id") ?? void 0
        }
        ));
        br(this, eh, lt( () => {
            var l, _;
            return {
                id: this.opts.id.current,
                type: "text",
                [ma.input]: "",
                autocomplete: "off",
                autocorrect: "off",
                spellcheck: !1,
                "aria-autocomplete": "list",
                role: "combobox",
                "aria-expanded": N4(!0),
                "aria-controls": ((l = this.root.viewportNode) == null ? void 0 : l.id) ?? void 0,
                "aria-labelledby": ((_ = this.root.labelNode) == null ? void 0 : _.id) ?? void 0,
                "aria-activedescendant": x(et(this, Dd)),
                ...this.attachment
            }
        }
        ));
        this.opts = l,
        this.root = _,
        this.attachment = Va(this.opts.ref, C => this.root.inputNode = C),
        oo( () => this.opts.ref.current, () => {
            const C = this.opts.ref.current;
            C && this.opts.autofocus.current && I4(10, () => C.focus())
        }
        ),
        oo( () => this.opts.value.current, () => {
            this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
        }
        )
    }
    static create(l) {
        return new vm(l,Xo.get())
    }
    get props() {
        return x(et(this, eh))
    }
    set props(l) {
        oe(et(this, eh), l)
    }
}
;
Dd = new WeakMap,
eh = new WeakMap;
let Ff = vm;
var ao, Rd, th, rh, ih, Wo, wv, Nf, nh;
const ym = class ym {
    constructor(l, _) {
        br(this, Wo);
        lr(this, "opts");
        lr(this, "root");
        lr(this, "attachment");
        br(this, ao, null);
        br(this, Rd, lt( () => {
            var l;
            return this.opts.forceMount.current || ((l = et(this, ao)) == null ? void 0 : l.opts.forceMount.current) === !0
        }
        ));
        br(this, th, lt( () => {
            if (this.opts.ref.current,
            x(et(this, Rd)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search)
                return !0;
            const l = this.root.commandState.filtered.items.get(this.trueValue);
            return l === void 0 ? !1 : l > 0
        }
        ));
        br(this, rh, lt( () => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
        br(this, ih, nt(""));
        br(this, nh, lt( () => {
            var l;
            return {
                id: this.opts.id.current,
                "aria-disabled": O4(this.opts.disabled.current),
                "aria-selected": q4(this.isSelected),
                "data-disabled": j4(this.opts.disabled.current),
                "data-selected": V4(this.isSelected),
                "data-value": this.trueValue,
                "data-group": (l = et(this, ao)) == null ? void 0 : l.trueValue,
                [ma.item]: "",
                role: "option",
                onpointermove: this.onpointermove,
                onclick: this.onclick,
                ...this.attachment
            }
        }
        ));
        this.opts = l,
        this.root = _,
        Jn(this, ao, Au.getOr(null)),
        this.trueValue = l.value.current,
        this.attachment = Va(this.opts.ref),
        oo([ () => this.trueValue, () => {
            var C;
            return (C = et(this, ao)) == null ? void 0 : C.trueValue
        }
        , () => this.opts.forceMount.current], () => {
            var C;
            if (!this.opts.forceMount.current)
                return this.root.registerItem(this.trueValue, (C = et(this, ao)) == null ? void 0 : C.trueValue)
        }
        ),
        oo([ () => this.opts.value.current, () => this.opts.ref.current], () => {
            var C, L;
            !this.opts.value.current && ((C = this.opts.ref.current) != null && C.textContent) && (this.trueValue = this.opts.ref.current.textContent.trim()),
            this.root.registerValue(this.trueValue, l.keywords.current.map(O => O.trim())),
            (L = this.opts.ref.current) == null || L.setAttribute(Uo, this.trueValue)
        }
        ),
        this.onclick = this.onclick.bind(this),
        this.onpointermove = this.onpointermove.bind(this)
    }
    static create(l) {
        const _ = Au.getOr(null);
        return new ym({
            ...l,
            group: _
        },Xo.get())
    }
    get shouldRender() {
        return x(et(this, th))
    }
    set shouldRender(l) {
        oe(et(this, th), l)
    }
    get isSelected() {
        return x(et(this, rh))
    }
    set isSelected(l) {
        oe(et(this, rh), l)
    }
    get trueValue() {
        return x(et(this, ih))
    }
    set trueValue(l) {
        oe(et(this, ih), l, !0)
    }
    onpointermove(l) {
        this.opts.disabled.current || this.root.opts.disablePointerSelection.current || Fr(this, Wo, Nf).call(this)
    }
    onclick(l) {
        this.opts.disabled.current || Fr(this, Wo, wv).call(this)
    }
    get props() {
        return x(et(this, nh))
    }
    set props(l) {
        oe(et(this, nh), l)
    }
}
;
ao = new WeakMap,
Rd = new WeakMap,
th = new WeakMap,
rh = new WeakMap,
ih = new WeakMap,
Wo = new WeakSet,
wv = function() {
    var l;
    this.opts.disabled.current || (Fr(this, Wo, Nf).call(this),
    (l = this.opts.onSelect) == null || l.current())
}
,
Nf = function() {
    this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}
,
nh = new WeakMap;
let Of = ym;
var ah;
const xm = class xm {
    constructor(l, _) {
        lr(this, "opts");
        lr(this, "root");
        lr(this, "attachment");
        br(this, ah, lt( () => ({
            id: this.opts.id.current,
            role: "listbox",
            "aria-label": this.opts.ariaLabel.current,
            [ma.list]: "",
            ...this.attachment
        })));
        this.opts = l,
        this.root = _,
        this.attachment = Va(this.opts.ref)
    }
    static create(l) {
        return l6.set(new xm(l,Xo.get()))
    }
    get props() {
        return x(et(this, ah))
    }
    set props(l) {
        oe(et(this, ah), l)
    }
}
;
ah = new WeakMap;
let jf = xm;
var sh;
const bm = class bm {
    constructor(l, _) {
        lr(this, "opts");
        lr(this, "root");
        lr(this, "attachment");
        br(this, sh, lt( () => {
            var l;
            return {
                id: this.opts.id.current,
                [ma["input-label"]]: "",
                for: (l = this.opts.for) == null ? void 0 : l.current,
                style: uv,
                ...this.attachment
            }
        }
        ));
        this.opts = l,
        this.root = _,
        this.attachment = Va(this.opts.ref, C => this.root.labelNode = C)
    }
    static create(l) {
        return new bm(l,Xo.get())
    }
    get props() {
        return x(et(this, sh))
    }
    set props(l) {
        oe(et(this, sh), l)
    }
}
;
sh = new WeakMap;
let qf = bm;
var c6 = Ie("<label><!></label>");
function u6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "id", 19, () => Ua(_))
      , L = Et(l, "ref", 15, null)
      , O = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
    const T = qf.create({
        id: cr.with( () => C()),
        ref: cr.with( () => L(), ie => L(ie))
    })
      , o = lt( () => Da(O, T.props));
    var $ = c6();
    er($, () => ({
        ...x(o)
    }));
    var W = k($);
    Ji(W, () => l.children ?? fa),
    A($),
    H(b, $),
    Pr()
}
var h6 = Ie("<!> <!>", 1)
  , d6 = Ie("<div><!> <!></div>");
function p6(b, l) {
    const _ = ts();
    Sr(l, !0);
    const C = it => {
        u6(it, {
            children: (Qe, Ae) => {
                fi();
                var vt = Fn();
                Ge( () => fe(vt, ye())),
                H(Qe, vt)
            }
            ,
            $$slots: {
                default: !0
            }
        })
    }
    ;
    let L = Et(l, "id", 19, () => Ua(_))
      , O = Et(l, "ref", 15, null)
      , T = Et(l, "value", 15, "")
      , o = Et(l, "onValueChange", 3, Mu)
      , $ = Et(l, "onStateChange", 3, Mu)
      , W = Et(l, "loop", 3, !1)
      , ie = Et(l, "shouldFilter", 3, !0)
      , pe = Et(l, "filter", 3, Cv)
      , ye = Et(l, "label", 3, "")
      , X = Et(l, "vimBindings", 3, !0)
      , Se = Et(l, "disablePointerSelection", 3, !1)
      , we = Et(l, "disableInitialScroll", 3, !1)
      , Re = Et(l, "columns", 3, null)
      , ke = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
    const Oe = Pf.create({
        id: cr.with( () => L()),
        ref: cr.with( () => O(), it => O(it)),
        filter: cr.with( () => pe()),
        shouldFilter: cr.with( () => ie()),
        loop: cr.with( () => W()),
        value: cr.with( () => T(), it => {
            T() !== it && (T(it),
            o()(it))
        }
        ),
        vimBindings: cr.with( () => X()),
        disablePointerSelection: cr.with( () => Se()),
        disableInitialScroll: cr.with( () => we()),
        onStateChange: cr.with( () => $()),
        columns: cr.with( () => Re())
    })
      , Ee = it => Oe.updateSelectedToIndex(it)
      , Ne = it => Oe.updateSelectedByGroup(it)
      , ft = it => Oe.updateSelectedByItem(it)
      , ht = () => Oe.getValidItems()
      , Xe = lt( () => Da(ke, Oe.props));
    var ct = Jt()
      , Je = zt(ct);
    {
        var Be = it => {
            var Qe = h6()
              , Ae = zt(Qe);
            C(Ae);
            var vt = V(Ae, 2);
            Ji(vt, () => l.child, () => ({
                props: x(Xe)
            })),
            H(it, Qe)
        }
          , st = it => {
            var Qe = d6();
            er(Qe, () => ({
                ...x(Xe)
            }));
            var Ae = k(Qe);
            C(Ae);
            var vt = V(Ae, 2);
            Ji(vt, () => l.children ?? fa),
            A(Qe),
            H(it, Qe)
        }
        ;
        Ue(Je, it => {
            l.child ? it(Be) : it(st, !1)
        }
        )
    }
    return H(b, ct),
    Pr({
        updateSelectedToIndex: Ee,
        updateSelectedByGroup: Ne,
        updateSelectedByItem: ft,
        getValidItems: ht
    })
}
var f6 = Ie("<div><!></div>");
function m6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "id", 19, () => Ua(_))
      , L = Et(l, "ref", 15, null)
      , O = Et(l, "forceMount", 3, !1)
      , T = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
    const o = Lf.create({
        id: cr.with( () => C()),
        ref: cr.with( () => L(), ye => L(ye)),
        forceMount: cr.with( () => O())
    })
      , $ = lt( () => Da(o.props, T));
    var W = Jt()
      , ie = zt(W);
    {
        var pe = ye => {
            var X = Jt()
              , Se = zt(X);
            {
                var we = ke => {
                    var Oe = Jt()
                      , Ee = zt(Oe);
                    Ji(Ee, () => l.child, () => ({
                        props: x($)
                    })),
                    H(ke, Oe)
                }
                  , Re = ke => {
                    var Oe = f6();
                    er(Oe, () => ({
                        ...x($)
                    }));
                    var Ee = k(Oe);
                    Ji(Ee, () => l.children ?? fa),
                    A(Oe),
                    H(ke, Oe)
                }
                ;
                Ue(Se, ke => {
                    l.child ? ke(we) : ke(Re, !1)
                }
                )
            }
            H(ye, X)
        }
        ;
        Ue(ie, ye => {
            o.shouldRender && ye(pe)
        }
        )
    }
    H(b, W),
    Pr()
}
var _6 = Ie("<div><!></div>");
function g6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "id", 19, () => Ua(_))
      , L = Et(l, "ref", 15, null)
      , O = Et(l, "value", 3, "")
      , T = Et(l, "forceMount", 3, !1)
      , o = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
    const $ = Df.create({
        id: cr.with( () => C()),
        ref: cr.with( () => L(), Se => L(Se)),
        forceMount: cr.with( () => T()),
        value: cr.with( () => O())
    })
      , W = lt( () => Da(o, $.props));
    var ie = Jt()
      , pe = zt(ie);
    {
        var ye = Se => {
            var we = Jt()
              , Re = zt(we);
            Ji(Re, () => l.child, () => ({
                props: x(W)
            })),
            H(Se, we)
        }
          , X = Se => {
            var we = _6();
            er(we, () => ({
                ...x(W)
            }));
            var Re = k(we);
            Ji(Re, () => l.children ?? fa),
            A(we),
            H(Se, we)
        }
        ;
        Ue(pe, Se => {
            l.child ? Se(ye) : Se(X, !1)
        }
        )
    }
    H(b, ie),
    Pr()
}
var v6 = Ie("<div><!></div>");
function y6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "id", 19, () => Ua(_))
      , L = Et(l, "ref", 15, null)
      , O = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
    const T = Rf.create({
        id: cr.with( () => C()),
        ref: cr.with( () => L(), ye => L(ye))
    })
      , o = lt( () => Da(O, T.props));
    var $ = Jt()
      , W = zt($);
    {
        var ie = ye => {
            var X = Jt()
              , Se = zt(X);
            Ji(Se, () => l.child, () => ({
                props: x(o)
            })),
            H(ye, X)
        }
          , pe = ye => {
            var X = v6();
            er(X, () => ({
                ...x(o)
            }));
            var Se = k(X);
            Ji(Se, () => l.children ?? fa),
            A(X),
            H(ye, X)
        }
        ;
        Ue(W, ye => {
            l.child ? ye(ie) : ye(pe, !1)
        }
        )
    }
    H(b, $),
    Pr()
}
var x6 = Ie("<div><!></div>")
  , b6 = Ie('<div style="display: contents;"><!></div>');
function w6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "id", 19, () => Ua(_))
      , L = Et(l, "ref", 15, null)
      , O = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
    const T = Bf.create({
        id: cr.with( () => C()),
        ref: cr.with( () => L(), ye => L(ye))
    })
      , o = lt( () => Da(O, T.props));
    var $ = b6()
      , W = k($);
    {
        var ie = ye => {
            var X = Jt()
              , Se = zt(X);
            Ji(Se, () => l.child, () => ({
                props: x(o)
            })),
            H(ye, X)
        }
          , pe = ye => {
            var X = x6();
            er(X, () => ({
                ...x(o)
            }));
            var Se = k(X);
            Ji(Se, () => l.children ?? fa),
            A(X),
            H(ye, X)
        }
        ;
        Ue(W, ye => {
            l.child ? ye(ie) : ye(pe, !1)
        }
        )
    }
    A($),
    H(b, $),
    Pr()
}
var T6 = Ie("<input/>");
function C6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "value", 15, "")
      , L = Et(l, "autofocus", 3, !1)
      , O = Et(l, "id", 19, () => Ua(_))
      , T = Et(l, "ref", 15, null)
      , o = Qt(l, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
    const $ = Ff.create({
        id: cr.with( () => O()),
        ref: cr.with( () => T(), Se => T(Se)),
        value: cr.with( () => C(), Se => {
            C(Se)
        }
        ),
        autofocus: cr.with( () => L() ?? !1)
    })
      , W = lt( () => Da(o, $.props));
    var ie = Jt()
      , pe = zt(ie);
    {
        var ye = Se => {
            var we = Jt()
              , Re = zt(we);
            Ji(Re, () => l.child, () => ({
                props: x(W)
            })),
            H(Se, we)
        }
          , X = Se => {
            var we = T6();
            ea(we),
            er(we, () => ({
                ...x(W)
            })),
            jd(we, C),
            H(Se, we)
        }
        ;
        Ue(pe, Se => {
            l.child ? Se(ye) : Se(X, !1)
        }
        )
    }
    H(b, ie),
    Pr()
}
var S6 = Ie("<div><!></div>")
  , P6 = Ie('<div style="display: contents;" data-item-wrapper=""><!></div>');
function I6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "id", 19, () => Ua(_))
      , L = Et(l, "ref", 15, null)
      , O = Et(l, "value", 3, "")
      , T = Et(l, "disabled", 3, !1)
      , o = Et(l, "onSelect", 3, Mu)
      , $ = Et(l, "forceMount", 3, !1)
      , W = Et(l, "keywords", 19, () => [])
      , ie = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
    const pe = Of.create({
        id: cr.with( () => C()),
        ref: cr.with( () => L(), we => L(we)),
        value: cr.with( () => O()),
        disabled: cr.with( () => T()),
        onSelect: cr.with( () => o()),
        forceMount: cr.with( () => $()),
        keywords: cr.with( () => W())
    })
      , ye = lt( () => Da(ie, pe.props));
    var X = Jt()
      , Se = zt(X);
    Pu(Se, () => pe.root.key, we => {
        var Re = P6()
          , ke = k(Re);
        {
            var Oe = Ee => {
                var Ne = Jt()
                  , ft = zt(Ne);
                {
                    var ht = ct => {
                        var Je = Jt()
                          , Be = zt(Je);
                        Ji(Be, () => l.child, () => ({
                            props: x(ye)
                        })),
                        H(ct, Je)
                    }
                      , Xe = ct => {
                        var Je = S6();
                        er(Je, () => ({
                            ...x(ye)
                        }));
                        var Be = k(Je);
                        Ji(Be, () => l.children ?? fa),
                        A(Je),
                        H(ct, Je)
                    }
                    ;
                    Ue(ft, ct => {
                        l.child ? ct(ht) : ct(Xe, !1)
                    }
                    )
                }
                H(Ee, Ne)
            }
            ;
            Ue(ke, Ee => {
                pe.shouldRender && Ee(Oe)
            }
            )
        }
        A(Re),
        Ge( () => zr(Re, "data-value", pe.trueValue)),
        H(we, Re)
    }
    ),
    H(b, X),
    Pr()
}
var M6 = Ie("<div><!></div>");
function A6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "id", 19, () => Ua(_))
      , L = Et(l, "ref", 15, null)
      , O = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
    const T = jf.create({
        id: cr.with( () => C()),
        ref: cr.with( () => L(), ie => L(ie)),
        ariaLabel: cr.with( () => l["aria-label"] ?? "Suggestions...")
    })
      , o = lt( () => Da(O, T.props));
    var $ = Jt()
      , W = zt($);
    Pu(W, () => T.root._commandState.search === "", ie => {
        var pe = Jt()
          , ye = zt(pe);
        {
            var X = we => {
                var Re = Jt()
                  , ke = zt(Re);
                Ji(ke, () => l.child, () => ({
                    props: x(o)
                })),
                H(we, Re)
            }
              , Se = we => {
                var Re = M6();
                er(Re, () => ({
                    ...x(o)
                }));
                var ke = k(Re);
                Ji(ke, () => l.children ?? fa),
                A(Re),
                H(we, Re)
            }
            ;
            Ue(ye, we => {
                l.child ? we(X) : we(Se, !1)
            }
            )
        }
        H(ie, pe)
    }
    ),
    H(b, $),
    Pr()
}
const xg = 1
  , k6 = .9
  , E6 = .8
  , z6 = .17
  , ff = .1
  , mf = .999
  , L6 = .9999
  , D6 = .99
  , R6 = /[\\/_+.#"@[({&]/
  , B6 = /[\\/_+.#"@[({&]/g
  , F6 = /[\s-]/
  , Tv = /[\s-]/g;
function Vf(b, l, _, C, L, O, T) {
    if (O === l.length)
        return L === b.length ? xg : D6;
    const o = `${L},${O}`;
    if (T[o] !== void 0)
        return T[o];
    const $ = C.charAt(O);
    let W = _.indexOf($, L), ie = 0, pe, ye, X, Se;
    for (; W >= 0; )
        pe = Vf(b, l, _, C, W + 1, O + 1, T),
        pe > ie && (W === L ? pe *= xg : R6.test(b.charAt(W - 1)) ? (pe *= E6,
        X = b.slice(L, W - 1).match(B6),
        X && L > 0 && (pe *= mf ** X.length)) : F6.test(b.charAt(W - 1)) ? (pe *= k6,
        Se = b.slice(L, W - 1).match(Tv),
        Se && L > 0 && (pe *= mf ** Se.length)) : (pe *= z6,
        L > 0 && (pe *= mf ** (W - L))),
        b.charAt(W) !== l.charAt(O) && (pe *= L6)),
        (pe < ff && _.charAt(W - 1) === C.charAt(O + 1) || C.charAt(O + 1) === C.charAt(O) && _.charAt(W - 1) !== C.charAt(O)) && (ye = Vf(b, l, _, C, W + 1, O + 2, T),
        ye * ff > pe && (pe = ye * ff)),
        pe > ie && (ie = pe),
        W = _.indexOf($, W + 1);
    return T[o] = ie,
    ie
}
function bg(b) {
    return b.toLowerCase().replace(Tv, " ")
}
function Cv(b, l, _) {
    return b = _ && _.length > 0 ? `${`${b} ${_ == null ? void 0 : _.join(" ")}`}` : b,
    Vf(b, l, bg(b), bg(l), 0, 0, {})
}
const O6 = 18
  , Sv = 40
  , N6 = `${Sv}px`
  , j6 = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");
function q6({containerRef: b, inputRef: l, pushPasswordManagerStrategy: _, isFocused: C, domContext: L}) {
    let O = nt(!1)
      , T = nt(!1)
      , o = nt(!1);
    function $() {
        const ie = _.current;
        return ie === "none" ? !1 : ie === "increase-width" && x(O) && x(T)
    }
    function W() {
        const ie = b.current
          , pe = l.current;
        if (!ie || !pe || x(o) || _.current === "none")
            return;
        const ye = ie
          , X = ye.getBoundingClientRect().left + ye.offsetWidth
          , Se = ye.getBoundingClientRect().top + ye.offsetHeight / 2
          , we = X - O6
          , Re = Se;
        L.querySelectorAll(j6).length === 0 && L.getDocument().elementFromPoint(we, Re) === ie || (oe(O, !0),
        oe(o, !0))
    }
    return Zr( () => {
        const ie = b.current;
        if (!ie || _.current === "none")
            return;
        function pe() {
            const Se = pv(ie).innerWidth - ie.getBoundingClientRect().right;
            oe(T, Se >= Sv)
        }
        pe();
        const ye = setInterval(pe, 1e3);
        return () => {
            clearInterval(ye)
        }
    }
    ),
    Zr( () => {
        const ie = C.current || L.getActiveElement() === l.current;
        if (_.current === "none" || !ie)
            return;
        const pe = setTimeout(W, 0)
          , ye = setTimeout(W, 2e3)
          , X = setTimeout(W, 5e3)
          , Se = setTimeout( () => {
            oe(o, !0)
        }
        , 6e3);
        return () => {
            clearTimeout(pe),
            clearTimeout(ye),
            clearTimeout(X),
            clearTimeout(Se)
        }
    }
    ),
    {
        get hasPwmBadge() {
            return x(O)
        },
        get willPushPwmBadge() {
            return $()
        },
        PWM_BADGE_SPACE_WIDTH: N6
    }
}
const Pv = fv({
    component: "pin-input",
    parts: ["root", "cell"]
})
  , V6 = ["Backspace", "Delete", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Escape", "Enter", "Tab", "Shift", "Control", "Meta"];
var ja, oc, Ls, za, qa, lc, hs, Ds, so, cc, Bd, oh, lh, Fd, Od, Iv, ch, uh, Nd, hh;
const wm = class wm {
    constructor(l) {
        br(this, Od);
        lr(this, "opts");
        lr(this, "attachment");
        br(this, ja, cr(null));
        br(this, oc, nt(!1));
        lr(this, "inputAttachment", Va(et(this, ja)));
        br(this, Ls, cr(!1));
        br(this, za, nt(null));
        br(this, qa, nt(null));
        br(this, lc, new P4( () => this.opts.value.current ?? ""));
        br(this, hs, lt( () => typeof this.opts.pattern.current == "string" ? new RegExp(this.opts.pattern.current) : this.opts.pattern.current));
        br(this, Ds, nt(zn({
            prev: [null, null, "none"],
            willSyntheticBlur: !1
        })));
        br(this, so);
        br(this, cc);
        lr(this, "domContext");
        lr(this, "onkeydown", l => {
            const _ = l.key;
            V6.includes(_) || l.ctrlKey || l.metaKey || _ && x(et(this, hs)) && !x(et(this, hs)).test(_) && l.preventDefault()
        }
        );
        br(this, Bd, lt( () => ({
            position: "relative",
            cursor: this.opts.disabled.current ? "default" : "text",
            userSelect: "none",
            WebkitUserSelect: "none",
            pointerEvents: "none"
        })));
        br(this, oh, lt( () => ({
            id: this.opts.id.current,
            [Pv.root]: "",
            style: x(et(this, Bd)),
            ...this.attachment
        })));
        br(this, lh, lt( () => ({
            style: {
                position: "absolute",
                inset: 0,
                pointerEvents: "none"
            }
        })));
        br(this, Fd, lt( () => ({
            position: "absolute",
            inset: 0,
            width: et(this, so).willPushPwmBadge ? `calc(100% + ${et(this, so).PWM_BADGE_SPACE_WIDTH})` : "100%",
            clipPath: et(this, so).willPushPwmBadge ? `inset(0 ${et(this, so).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
            height: "100%",
            display: "flex",
            textAlign: this.opts.textAlign.current,
            opacity: "1",
            color: "transparent",
            pointerEvents: "all",
            background: "transparent",
            caretColor: "transparent",
            border: "0 solid transparent",
            outline: "0 solid transparent",
            boxShadow: "none",
            lineHeight: "1",
            letterSpacing: "-.5em",
            fontSize: "var(--bits-pin-input-root-height)",
            fontFamily: "monospace",
            fontVariantNumeric: "tabular-nums"
        })));
        br(this, ch, () => {
            var we;
            const l = et(this, ja).current
              , _ = this.opts.ref.current;
            if (!l || !_)
                return;
            if (this.domContext.getActiveElement() !== l) {
                oe(et(this, za), null),
                oe(et(this, qa), null);
                return
            }
            const C = l.selectionStart
              , L = l.selectionEnd
              , O = l.selectionDirection ?? "none"
              , T = l.maxLength
              , o = l.value
              , $ = x(et(this, Ds)).prev;
            let W = -1, ie = -1, pe;
            if (o.length !== 0 && C !== null && L !== null) {
                const Re = C === L
                  , ke = C === o.length && o.length < T;
                if (Re && !ke) {
                    const Oe = C;
                    if (Oe === 0)
                        W = 0,
                        ie = 1,
                        pe = "forward";
                    else if (Oe === T)
                        W = Oe - 1,
                        ie = Oe,
                        pe = "backward";
                    else if (T > 1 && o.length > 1) {
                        let Ee = 0;
                        if ($[0] !== null && $[1] !== null) {
                            pe = Oe < $[0] ? "backward" : "forward";
                            const Ne = $[0] === $[1] && $[0] < T;
                            pe === "backward" && !Ne && (Ee = -1)
                        }
                        W = Ee - Oe,
                        ie = Ee + Oe + 1
                    }
                }
                W !== -1 && ie !== -1 && W !== ie && ((we = et(this, ja).current) == null || we.setSelectionRange(W, ie, pe))
            }
            const ye = W !== -1 ? W : C
              , X = ie !== -1 ? ie : L
              , Se = pe ?? O;
            oe(et(this, za), ye, !0),
            oe(et(this, qa), X, !0),
            x(et(this, Ds)).prev = [ye, X, Se]
        }
        );
        lr(this, "oninput", l => {
            const _ = l.currentTarget.value.slice(0, this.opts.maxLength.current);
            if (_.length > 0 && x(et(this, hs)) && !x(et(this, hs)).test(_)) {
                l.preventDefault();
                return
            }
            typeof et(this, lc).current == "string" && _.length < et(this, lc).current.length && this.domContext.getDocument().dispatchEvent(new Event("selectionchange")),
            this.opts.value.current = _
        }
        );
        lr(this, "onfocus", l => {
            const _ = et(this, ja).current;
            if (_) {
                const C = Math.min(_.value.length, this.opts.maxLength.current - 1)
                  , L = _.value.length;
                _.setSelectionRange(C, L),
                oe(et(this, za), C, !0),
                oe(et(this, qa), L, !0)
            }
            et(this, Ls).current = !0
        }
        );
        lr(this, "onpaste", l => {
            var ie, pe, ye, X;
            const _ = et(this, ja).current;
            if (!_)
                return;
            const C = Se => {
                const we = _.selectionStart === null ? void 0 : _.selectionStart
                  , Re = _.selectionEnd === null ? void 0 : _.selectionEnd
                  , ke = we !== Re
                  , Oe = this.opts.value.current;
                return (ke ? Oe.slice(0, we) + Se + Oe.slice(Re) : Oe.slice(0, we) + Se + Oe.slice(we)).slice(0, this.opts.maxLength.current)
            }
              , L = Se => Se.length > 0 && x(et(this, hs)) && !x(et(this, hs)).test(Se);
            if (!((ie = this.opts.pasteTransformer) != null && ie.current) && (!et(this, cc).isIOS || !l.clipboardData || !_)) {
                const Se = C((pe = l.clipboardData) == null ? void 0 : pe.getData("text/plain"));
                L(Se) && l.preventDefault();
                return
            }
            const O = ((ye = l.clipboardData) == null ? void 0 : ye.getData("text/plain")) ?? ""
              , T = (X = this.opts.pasteTransformer) != null && X.current ? this.opts.pasteTransformer.current(O) : O;
            l.preventDefault();
            const o = C(T);
            if (L(o))
                return;
            _.value = o,
            this.opts.value.current = o;
            const $ = Math.min(o.length, this.opts.maxLength.current - 1)
              , W = o.length;
            _.setSelectionRange($, W),
            oe(et(this, za), $, !0),
            oe(et(this, qa), W, !0)
        }
        );
        lr(this, "onmouseover", l => {
            oe(et(this, oc), !0)
        }
        );
        lr(this, "onmouseleave", l => {
            oe(et(this, oc), !1)
        }
        );
        lr(this, "onblur", l => {
            if (x(et(this, Ds)).willSyntheticBlur) {
                x(et(this, Ds)).willSyntheticBlur = !1;
                return
            }
            et(this, Ls).current = !1
        }
        );
        br(this, uh, lt( () => {
            var l;
            return {
                id: this.opts.inputId.current,
                style: x(et(this, Fd)),
                autocomplete: this.opts.autocomplete.current || "one-time-code",
                "data-pin-input-input": "",
                "data-pin-input-input-mss": x(et(this, za)),
                "data-pin-input-input-mse": x(et(this, qa)),
                inputmode: this.opts.inputmode.current,
                pattern: (l = x(et(this, hs))) == null ? void 0 : l.source,
                maxlength: this.opts.maxLength.current,
                value: this.opts.value.current,
                disabled: U4(this.opts.disabled.current),
                onpaste: this.onpaste,
                oninput: this.oninput,
                onkeydown: this.onkeydown,
                onmouseover: this.onmouseover,
                onmouseleave: this.onmouseleave,
                onfocus: this.onfocus,
                onblur: this.onblur,
                ...this.inputAttachment
            }
        }
        ));
        br(this, Nd, lt( () => Array.from({
            length: this.opts.maxLength.current
        }).map( (l, _) => {
            const C = et(this, Ls).current && x(et(this, za)) !== null && x(et(this, qa)) !== null && (x(et(this, za)) === x(et(this, qa)) && _ === x(et(this, za)) || _ >= x(et(this, za)) && _ < x(et(this, qa)))
              , L = this.opts.value.current[_] !== void 0 ? this.opts.value.current[_] : null;
            return {
                char: L,
                isActive: C,
                hasFakeCaret: C && L === null
            }
        }
        )));
        br(this, hh, lt( () => ({
            cells: x(et(this, Nd)),
            isFocused: et(this, Ls).current,
            isHovering: x(et(this, oc))
        })));
        var _;
        this.opts = l,
        this.attachment = Va(this.opts.ref),
        this.domContext = new F4(l.ref),
        Jn(this, cc, {
            value: this.opts.value,
            isIOS: typeof window < "u" && ((_ = window == null ? void 0 : window.CSS) == null ? void 0 : _.supports("-webkit-touch-callout", "none"))
        }),
        Jn(this, so, q6({
            containerRef: this.opts.ref,
            inputRef: et(this, ja),
            isFocused: et(this, Ls),
            pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
            domContext: this.domContext
        })),
        Ii( () => {
            const C = et(this, ja).current
              , L = this.opts.ref.current;
            if (!C || !L)
                return;
            et(this, cc).value.current !== C.value && (this.opts.value.current = C.value),
            x(et(this, Ds)).prev = [C.selectionStart, C.selectionEnd, C.selectionDirection ?? "none"];
            const O = Su(this.domContext.getDocument(), "selectionchange", et(this, ch), {
                capture: !0
            });
            et(this, ch).call(this),
            this.domContext.getActiveElement() === C && (et(this, Ls).current = !0),
            this.domContext.getElementById("pin-input-style") || Fr(this, Od, Iv).call(this);
            const T = () => {
                L && L.style.setProperty("--bits-pin-input-root-height", `${C.clientHeight}px`)
            }
            ;
            T();
            const o = new ResizeObserver(T);
            return o.observe(C),
            () => {
                O(),
                o.disconnect()
            }
        }
        ),
        oo([ () => this.opts.value.current, () => et(this, ja).current], () => {
            U6( () => {
                const C = et(this, ja).current;
                if (!C)
                    return;
                C.dispatchEvent(new Event("input"));
                const L = C.selectionStart
                  , O = C.selectionEnd
                  , T = C.selectionDirection ?? "none";
                L !== null && O !== null && (oe(et(this, za), L, !0),
                oe(et(this, qa), O, !0),
                x(et(this, Ds)).prev = [L, O, T])
            }
            , this.domContext)
        }
        ),
        Zr( () => {
            const C = this.opts.value.current
              , L = et(this, lc).current
              , O = this.opts.maxLength.current
              , T = this.opts.onComplete.current;
            L !== void 0 && C !== L && L.length < O && C.length === O && T(C)
        }
        )
    }
    static create(l) {
        return new wm(l)
    }
    get rootProps() {
        return x(et(this, oh))
    }
    set rootProps(l) {
        oe(et(this, oh), l)
    }
    get inputWrapperProps() {
        return x(et(this, lh))
    }
    set inputWrapperProps(l) {
        oe(et(this, lh), l)
    }
    get inputProps() {
        return x(et(this, uh))
    }
    set inputProps(l) {
        oe(et(this, uh), l)
    }
    get snippetProps() {
        return x(et(this, hh))
    }
    set snippetProps(l) {
        oe(et(this, hh), l)
    }
}
;
ja = new WeakMap,
oc = new WeakMap,
Ls = new WeakMap,
za = new WeakMap,
qa = new WeakMap,
lc = new WeakMap,
hs = new WeakMap,
Ds = new WeakMap,
so = new WeakMap,
cc = new WeakMap,
Bd = new WeakMap,
oh = new WeakMap,
lh = new WeakMap,
Fd = new WeakMap,
Od = new WeakSet,
Iv = function() {
    const l = this.domContext.getDocument()
      , _ = l.createElement("style");
    if (_.id = "pin-input-style",
    l.head.appendChild(_),
    _.sheet) {
        const C = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
        vu(_.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"),
        vu(_.sheet, `[data-pin-input-input]:autofill { ${C} }`),
        vu(_.sheet, `[data-pin-input-input]:-webkit-autofill { ${C} }`),
        vu(_.sheet, "@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"),
        vu(_.sheet, "[data-pin-input-input] + * { pointer-events: all !important; }")
    }
}
,
ch = new WeakMap,
uh = new WeakMap,
Nd = new WeakMap,
hh = new WeakMap;
let Uf = wm;
var dh;
const Tm = class Tm {
    constructor(l) {
        lr(this, "opts");
        lr(this, "attachment");
        br(this, dh, lt( () => ({
            id: this.opts.id.current,
            [Pv.cell]: "",
            "data-active": this.opts.cell.current.isActive ? "" : void 0,
            "data-inactive": this.opts.cell.current.isActive ? void 0 : "",
            ...this.attachment
        })));
        this.opts = l,
        this.attachment = Va(this.opts.ref)
    }
    static create(l) {
        return new Tm(l)
    }
    get props() {
        return x(et(this, dh))
    }
    set props(l) {
        oe(et(this, dh), l)
    }
}
;
dh = new WeakMap;
let Zf = Tm;
function U6(b, l) {
    const _ = l.setTimeout(b, 0)
      , C = l.setTimeout(b, 10)
      , L = l.setTimeout(b, 50);
    return [_, C, L]
}
function vu(b, l) {
    try {
        b.insertRule(l)
    } catch {
        console.error("pin input could not insert CSS rule:", l)
    }
}
var Z6 = Ie("<div><!> <div><input/></div></div>");
function $6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "id", 19, () => Ua(_))
      , L = Et(l, "inputId", 19, () => `${Ua(_)}-input`)
      , O = Et(l, "ref", 15, null)
      , T = Et(l, "maxlength", 3, 6)
      , o = Et(l, "textalign", 3, "left")
      , $ = Et(l, "inputmode", 3, "numeric")
      , W = Et(l, "onComplete", 3, Mu)
      , ie = Et(l, "pushPasswordManagerStrategy", 3, "increase-width")
      , pe = Et(l, "class", 3, "")
      , ye = Et(l, "autocomplete", 3, "one-time-code")
      , X = Et(l, "disabled", 3, !1)
      , Se = Et(l, "value", 15, "")
      , we = Et(l, "onValueChange", 3, Mu)
      , Re = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "inputId", "ref", "maxlength", "textalign", "pattern", "inputmode", "onComplete", "pushPasswordManagerStrategy", "class", "children", "autocomplete", "disabled", "value", "onValueChange", "pasteTransformer"]);
    const ke = Uf.create({
        id: cr.with( () => C()),
        ref: cr.with( () => O(), Je => O(Je)),
        inputId: cr.with( () => L()),
        autocomplete: cr.with( () => ye()),
        maxLength: cr.with( () => T()),
        textAlign: cr.with( () => o()),
        disabled: cr.with( () => X()),
        inputmode: cr.with( () => $()),
        pattern: cr.with( () => l.pattern),
        onComplete: cr.with( () => W()),
        value: cr.with( () => Se(), Je => {
            Se(Je),
            we()(Je)
        }
        ),
        pushPasswordManagerStrategy: cr.with( () => ie()),
        pasteTransformer: cr.with( () => l.pasteTransformer)
    })
      , Oe = lt( () => Da(Re, ke.inputProps))
      , Ee = lt( () => Da(ke.rootProps, {
        class: pe()
    }))
      , Ne = lt( () => Da(ke.inputWrapperProps, {}));
    var ft = Z6();
    er(ft, () => ({
        ...x(Ee)
    }));
    var ht = k(ft);
    Ji(ht, () => l.children ?? fa, () => ke.snippetProps);
    var Xe = V(ht, 2);
    er(Xe, () => ({
        ...x(Ne)
    }));
    var ct = k(Xe);
    ea(ct),
    er(ct, () => ({
        ...x(Oe)
    })),
    A(Xe),
    A(ft),
    H(b, ft),
    Pr()
}
var G6 = Ie("<div><!></div>");
function H6(b, l) {
    const _ = ts();
    Sr(l, !0);
    let C = Et(l, "id", 19, () => Ua(_))
      , L = Et(l, "ref", 15, null)
      , O = Qt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "cell", "child", "children"]);
    const T = Zf.create({
        id: cr.with( () => C()),
        ref: cr.with( () => L(), ye => L(ye)),
        cell: cr.with( () => l.cell)
    })
      , o = lt( () => Da(O, T.props));
    var $ = Jt()
      , W = zt($);
    {
        var ie = ye => {
            var X = Jt()
              , Se = zt(X);
            Ji(Se, () => l.child, () => ({
                props: x(o)
            })),
            H(ye, X)
        }
          , pe = ye => {
            var X = G6();
            er(X, () => ({
                ...x(o)
            }));
            var Se = k(X);
            Ji(Se, () => l.children ?? fa),
            A(X),
            H(ye, X)
        }
        ;
        Ue(W, ye => {
            l.child ? ye(ie) : ye(pe, !1)
        }
        )
    }
    H(b, $),
    Pr()
}
function pc(...b) {
    return Fg(Tu(b))
}
function W6(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15, null)
      , C = Et(l, "value", 15, "")
      , L = Qt(l, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
    var O = Jt()
      , T = zt(O);
    {
        let o = lt( () => pc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", l.class));
        _n(T, () => p6, ($, W) => {
            W($, lo({
                "data-slot": "command",
                get class() {
                    return x(o)
                }
            }, () => L, {
                get value() {
                    return C()
                },
                set value(ie) {
                    C(ie)
                },
                get ref() {
                    return _()
                },
                set ref(ie) {
                    _(ie)
                }
            }))
        }
        )
    }
    H(b, O),
    Pr()
}
var X6 = Tr('<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>');
function fc(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = X6();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
function K6(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15, null)
      , C = Qt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
    var L = Jt()
      , O = zt(L);
    {
        let T = lt( () => pc("py-6 text-center text-sm", l.class));
        _n(O, () => m6, (o, $) => {
            $(o, lo({
                "data-slot": "command-empty",
                get class() {
                    return x(T)
                }
            }, () => C, {
                get ref() {
                    return _()
                },
                set ref(W) {
                    _(W)
                }
            }))
        }
        )
    }
    H(b, L),
    Pr()
}
var Y6 = Ie("<!> <!>", 1);
function J6(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15, null)
      , C = Qt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
    var L = Jt()
      , O = zt(L);
    {
        let T = lt( () => pc("text-foreground overflow-hidden p-1", l.class))
          , o = lt( () => l.value ?? l.heading ?? `----${a6()}`);
        _n(O, () => g6, ($, W) => {
            W($, lo({
                "data-slot": "command-group",
                get class() {
                    return x(T)
                },
                get value() {
                    return x(o)
                }
            }, () => C, {
                get ref() {
                    return _()
                },
                set ref(ie) {
                    _(ie)
                },
                children: (ie, pe) => {
                    var ye = Y6()
                      , X = zt(ye);
                    {
                        var Se = Re => {
                            var ke = Jt()
                              , Oe = zt(ke);
                            _n(Oe, () => y6, (Ee, Ne) => {
                                Ne(Ee, {
                                    class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                                    children: (ft, ht) => {
                                        fi();
                                        var Xe = Fn();
                                        Ge( () => fe(Xe, l.heading)),
                                        H(ft, Xe)
                                    }
                                    ,
                                    $$slots: {
                                        default: !0
                                    }
                                })
                            }
                            ),
                            H(Re, ke)
                        }
                        ;
                        Ue(X, Re => {
                            l.heading && Re(Se)
                        }
                        )
                    }
                    var we = V(X, 2);
                    _n(we, () => w6, (Re, ke) => {
                        ke(Re, {
                            get children() {
                                return l.children
                            }
                        })
                    }
                    ),
                    H(ie, ye)
                }
                ,
                $$slots: {
                    default: !0
                }
            }))
        }
        )
    }
    H(b, L),
    Pr()
}
function Q6(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15, null)
      , C = Qt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
    var L = Jt()
      , O = zt(L);
    {
        let T = lt( () => pc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", l.class));
        _n(O, () => I6, (o, $) => {
            $(o, lo({
                "data-slot": "command-item",
                get class() {
                    return x(T)
                }
            }, () => C, {
                get ref() {
                    return _()
                },
                set ref(W) {
                    _(W)
                }
            }))
        }
        )
    }
    H(b, L),
    Pr()
}
var eA = Tr('<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>');
function tA(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = eA();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var rA = Ie('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');
function iA(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15, null)
      , C = Et(l, "value", 15, "")
      , L = Qt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
    var O = rA()
      , T = k(O);
    tA(T, {
        class: "size-5 opacity-50"
    });
    var o = V(T, 2);
    {
        let $ = lt( () => pc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", l.class));
        _n(o, () => C6, (W, ie) => {
            ie(W, lo({
                "data-slot": "command-input",
                get class() {
                    return x($)
                }
            }, () => L, {
                get ref() {
                    return _()
                },
                set ref(pe) {
                    _(pe)
                },
                get value() {
                    return C()
                },
                set value(pe) {
                    C(pe)
                }
            }))
        }
        )
    }
    A(O),
    H(b, O),
    Pr()
}
function nA(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15, null)
      , C = Qt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
    var L = Jt()
      , O = zt(L);
    {
        let T = lt( () => pc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", l.class));
        _n(O, () => A6, (o, $) => {
            $(o, lo({
                "data-slot": "command-list",
                get class() {
                    return x(T)
                }
            }, () => C, {
                get ref() {
                    return _()
                },
                set ref(W) {
                    _(W)
                }
            }))
        }
        )
    }
    H(b, L),
    Pr()
}
var aA = Tr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');
function sA(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = aA();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var oA = Ie("<span> </span> <!>", 1)
  , lA = Ie('<span class="font-flag ml-0.5"> </span> ', 1)
  , cA = Ie('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>')
  , uA = Ie("<!> <!>", 1)
  , hA = Ie("<!> <!>", 1)
  , dA = (b, l) => {
    l(0)
}
  , pA = Ie('<button class="btn btn-xs btn-circle btn-ghost"><!></button>')
  , fA = Ie('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');
function wg(b, l) {
    Sr(l, !0);
    let _ = Et(l, "countryId", 15, 0)
      , C = Et(l, "dropdownDirection", 3, "right")
      , L = nt(null)
      , O = nt(null)
      , T = nt("");
    function o() {
        Mg().then( () => {
            var Ee;
            (Ee = document.activeElement) == null || Ee.blur(),
            oe(T, "")
        }
        )
    }
    var $ = fA()
      , W = k($)
      , ie = k(W)
      , pe = k(ie);
    {
        var ye = Ee => {
            var Ne = oA()
              , ft = zt(Ne)
              , ht = k(ft, !0);
            A(ft);
            var Xe = V(ft, 2);
            sA(Xe, {
                class: "size-3.5"
            }),
            Ge(ct => fe(ht, ct), [ () => Vg()]),
            H(Ee, Ne)
        }
          , X = Ee => {
            const Ne = lt( () => ds(_()));
            var ft = lA()
              , ht = zt(ft)
              , Xe = k(ht, !0);
            A(ht);
            var ct = V(ht);
            Ge( () => {
                fe(Xe, x(Ne).flag),
                fe(ct, ` ${x(Ne).name ?? ""}`)
            }
            ),
            H(Ee, ft)
        }
        ;
        Ue(pe, Ee => {
            _() === 0 ? Ee(ye) : Ee(X, !1)
        }
        )
    }
    A(ie);
    var Se = V(ie, 2);
    let we;
    var Re = k(Se);
    _n(Re, () => W6, (Ee, Ne) => {
        Ne(Ee, {
            children: (ft, ht) => {
                var Xe = hA()
                  , ct = zt(Xe);
                _n(ct, () => iA, (Be, st) => {
                    st(Be, {
                        placeholder: "Country",
                        get ref() {
                            return x(L)
                        },
                        set ref(it) {
                            oe(L, it)
                        },
                        get value() {
                            return x(T)
                        },
                        set value(it) {
                            oe(T, it, !0)
                        }
                    })
                }
                );
                var Je = V(ct, 2);
                _n(Je, () => nA, (Be, st) => {
                    st(Be, {
                        children: (it, Qe) => {
                            var Ae = uA()
                              , vt = zt(Ae);
                            _n(vt, () => K6, (te, _e) => {
                                _e(te, {
                                    children: (ne, Pe) => {
                                        fi();
                                        var Me = Fn();
                                        Ge(at => fe(Me, at), [ () => x2()]),
                                        H(ne, Me)
                                    }
                                    ,
                                    $$slots: {
                                        default: !0
                                    }
                                })
                            }
                            );
                            var Q = V(vt, 2);
                            _n(Q, () => J6, (te, _e) => {
                                _e(te, {
                                    children: (ne, Pe) => {
                                        var Me = Jt()
                                          , at = zt(Me);
                                        nn(at, 17, () => $n.countries, We => We.id, (We, Ct) => {
                                            var _t = Jt()
                                              , xt = zt(_t);
                                            _n(xt, () => Q6, (tt, pt) => {
                                                pt(tt, {
                                                    get value() {
                                                        return x(Ct).name
                                                    },
                                                    onSelect: () => {
                                                        _(x(Ct).id),
                                                        o()
                                                    }
                                                    ,
                                                    children: (It, ut) => {
                                                        var bt = cA()
                                                          , wt = k(bt)
                                                          , dt = k(wt, !0);
                                                        A(wt);
                                                        var Lt = V(wt);
                                                        A(bt),
                                                        Ge( () => {
                                                            fe(dt, x(Ct).flag),
                                                            fe(Lt, ` ${x(Ct).name ?? ""}`)
                                                        }
                                                        ),
                                                        H(It, bt)
                                                    }
                                                    ,
                                                    $$slots: {
                                                        default: !0
                                                    }
                                                })
                                            }
                                            ),
                                            H(We, _t)
                                        }
                                        ),
                                        H(ne, Me)
                                    }
                                    ,
                                    $$slots: {
                                        default: !0
                                    }
                                })
                            }
                            ),
                            H(it, Ae)
                        }
                        ,
                        $$slots: {
                            default: !0
                        }
                    })
                }
                ),
                H(ft, Xe)
            }
            ,
            $$slots: {
                default: !0
            }
        })
    }
    ),
    A(Se),
    A(W);
    var ke = V(W, 2);
    {
        var Oe = Ee => {
            var Ne = pA();
            Ne.__click = [dA, _];
            var ft = k(Ne);
            fc(ft, {
                class: "size-3.5"
            }),
            A(Ne),
            H(Ee, Ne)
        }
        ;
        Ue(ke, Ee => {
            _() != 0 && Ee(Oe)
        }
        )
    }
    A($),
    ps($, Ee => oe(O, Ee), () => x(O)),
    Ge(Ee => we = Or(Se, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, we, Ee), [ () => ({
        "right-1": C() === "left"
    })]),
    an("focus", ie, () => {
        x(L).focus()
    }
    ),
    H(b, $),
    Pr()
}
Wi(["click"]);
var mA = Tr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');
function _A(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = mA();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var gA = Tr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>')
  , vA = Tr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');
function $f(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var C = Jt()
      , L = zt(C);
    {
        var O = o => {
            var $ = gA();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
          , T = o => {
            var $ = vA();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
        ;
        Ue(L, o => {
            l.filled ? o(O) : o(T, !1)
        }
        )
    }
    H(b, C)
}
var yA = Ie('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>')
  , xA = Ie('<div class="mb-2"><!></div>')
  , bA = Ie('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>')
  , wA = (b, l, _) => {
    l.onvisitclick({
        lat: x(_).lastLatitude,
        lng: x(_).lastLongitude
    })
}
  , TA = Ie('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>')
  , CA = Ie('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>')
  , SA = Ie('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , PA = Ie('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>')
  , IA = Ie('<span class="font-flag tooltip ml-0.5"> </span>')
  , MA = Ie("<span> </span>")
  , AA = Ie('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , kA = Ie('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>')
  , EA = Ie('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , zA = Ie('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>')
  , LA = Ie('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>')
  , DA = Ie('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);
function RA(b, l) {
    Sr(l, !0);
    const _ = [];
    let C = nt(1e3);
    const L = lt( () => x(C) <= 640);
    let O = nt("today")
      , T = {
        regions: {
            label: VT(),
            icon: Wf
        },
        countries: {
            label: $T(),
            icon: _A
        },
        players: {
            label: Xg(),
            icon: Xd
        },
        alliances: {
            label: Kg(),
            icon: Kd
        }
    }
      , o = nt("regions")
      , $ = nt(0)
      , W = zn({
        players: {},
        alliances: {},
        regions: {},
        countries: {}
    })
      , ie = lt( () => {
        var Xe, ct, Je;
        return x(o) === "regions" ? (ct = (Xe = W[x(o)][x($)]) == null ? void 0 : Xe[x(O)]) == null ? void 0 : ct.entries : (Je = W[x(o)][x(O)]) == null ? void 0 : Je.entries
    }
    );
    const pe = 5 * 1e3;
    Zr( () => {
        var Be;
        if (!l.open)
            return;
        const Xe = x(O)
          , ct = x(o)
          , Je = x($);
        ct === "players" && (!W[ct][Xe] || Date.now() - W[ct][Xe].time > pe) ? ni.leaderboardPlayers(Xe).then(st => {
            W[ct][Xe] = {
                time: Date.now(),
                entries: st
            }
        }
        ).catch(st => qr.error(st.message)) : ct === "alliances" && (!W[ct][Xe] || Date.now() - W[ct][Xe].time > pe) ? ni.leaderboardAlliances(Xe).then(st => {
            W[ct][Xe] = {
                time: Date.now(),
                entries: st
            }
        }
        ).catch(st => qr.error(st.message)) : ct === "countries" && (!W[ct][Xe] || Date.now() - W[ct][Xe].time > pe) ? ni.leaderboardCountries(Xe).then(st => {
            W[ct][Xe] = {
                time: Date.now(),
                entries: st
            }
        }
        ).catch(st => qr.error(st.message)) : ct === "regions" && (!((Be = W[ct][Je]) != null && Be[Xe]) || Date.now() - W[ct][Je][Xe].time > pe) && ni.leaderboardRegions(Xe, Je).then(st => {
            W[ct][Je] || (W[ct][Je] = {}),
            W[ct][Je][Xe] = {
                time: Date.now(),
                entries: st
            }
        }
        ).catch(st => qr.error(st.message))
    }
    );
    var ye = DA()
      , X = zt(ye);
    nn(X, 21, () => Object.entries(T), ([Xe,{label: ct, icon: Je}]) => Xe, (Xe, ct) => {
        var Je = lt( () => Ag(x(ct), 2));
        let Be = () => x(Je)[0]
          , st = () => x(Je)[1].label
          , it = () => x(Je)[1].icon;
        const Qe = lt(it);
        var Ae = yA()
          , vt = k(Ae);
        ea(vt);
        var Q, te = V(vt, 2);
        _n(te, () => x(Qe), (ne, Pe) => {
            Pe(ne, {
                get this() {
                    return it()
                },
                class: "mr-1 size-5 max-sm:hidden"
            })
        }
        );
        var _e = V(te);
        A(Ae),
        Ge( () => {
            zr(vt, "aria-label", st()),
            Q !== (Q = Be()) && (vt.value = (vt.__value = Be()) ?? ""),
            fe(_e, ` ${st() ?? ""}`)
        }
        ),
        Vd(_, [], vt, () => (Be(),
        x(o)), ne => oe(o, ne)),
        H(Xe, Ae)
    }
    ),
    A(X);
    var Se = V(X, 2)
      , we = k(Se);
    sm(we, {
        get value() {
            return x(O)
        },
        set value(Xe) {
            oe(O, Xe, !0)
        }
    });
    var Re = V(we, 2);
    {
        var ke = Xe => {
            wg(Xe, {
                dropdownDirection: "left",
                get countryId() {
                    return x($)
                },
                set countryId(ct) {
                    oe($, ct, !0)
                }
            })
        }
        ;
        Ue(Re, Xe => {
            x(o) === "regions" && !x(L) && Xe(ke)
        }
        )
    }
    A(Se);
    var Oe = V(Se, 2);
    {
        var Ee = Xe => {
            var ct = xA()
              , Je = k(ct);
            wg(Je, {
                get countryId() {
                    return x($)
                },
                set countryId(Be) {
                    oe($, Be, !0)
                }
            }),
            A(ct),
            H(Xe, ct)
        }
        ;
        Ue(Oe, Xe => {
            x(o) === "regions" && x(L) && Xe(Ee)
        }
        )
    }
    var Ne = V(Oe, 2);
    {
        var ft = Xe => {
            var ct = bA()
              , Je = k(ct)
              , Be = V(Je);
            {
                var st = Qe => {
                    var Ae = Fn();
                    Ge(vt => fe(Ae, vt), [ () => Wd().toLowerCase()]),
                    H(Qe, Ae)
                }
                  , it = Qe => {
                    var Ae = Jt()
                      , vt = zt(Ae);
                    {
                        var Q = _e => {
                            var ne = Fn();
                            Ge(Pe => fe(ne, Pe), [ () => Qf()]),
                            H(_e, ne)
                        }
                          , te = _e => {
                            var ne = Jt()
                              , Pe = zt(ne);
                            {
                                var Me = at => {
                                    var We = Fn();
                                    Ge(Ct => fe(We, Ct), [ () => em()]),
                                    H(at, We)
                                }
                                ;
                                Ue(Pe, at => {
                                    x(O) === "month" && at(Me)
                                }
                                , !0)
                            }
                            H(_e, ne)
                        }
                        ;
                        Ue(vt, _e => {
                            x(O) === "week" ? _e(Q) : _e(te, !1)
                        }
                        , !0)
                    }
                    H(Qe, Ae)
                }
                ;
                Ue(Be, Qe => {
                    x(O) === "today" ? Qe(st) : Qe(it, !1)
                }
                )
            }
            A(ct),
            Ge(Qe => fe(Je, `${Qe ?? ""} `), [ () => Jf()]),
            H(Xe, ct)
        }
          , ht = Xe => {
            var ct = Jt()
              , Je = zt(ct);
            {
                var Be = it => {
                    var Qe = Jt()
                      , Ae = zt(Qe);
                    {
                        var vt = te => {
                            const _e = lt( () => x(ie));
                            var ne = CA()
                              , Pe = k(ne)
                              , Me = k(Pe)
                              , at = V(k(Me))
                              , We = k(at, !0);
                            A(at);
                            var Ct = V(at)
                              , _t = k(Ct)
                              , xt = V(_t, 2)
                              , tt = V(xt)
                              , pt = k(tt);
                            $f(pt, {
                                class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                            }),
                            A(tt),
                            A(Ct),
                            fi(),
                            A(Me),
                            A(Pe);
                            var It = V(Pe);
                            nn(It, 31, () => x(_e), ut => ut.id, (ut, bt, wt) => {
                                const dt = lt( () => ds(x(bt).countryId));
                                var Lt = TA()
                                  , Xt = k(Lt)
                                  , Yt = k(Xt, !0);
                                A(Xt);
                                var nr = V(Xt)
                                  , ar = k(nr)
                                  , Ft = k(ar, !0);
                                A(ar);
                                var dr = V(ar, 2)
                                  , _r = k(dr)
                                  , Ir = V(_r)
                                  , jr = k(Ir);
                                A(Ir),
                                A(dr),
                                A(nr);
                                var ur = V(nr)
                                  , Mr = k(ur, !0);
                                A(ur);
                                var Ar = V(ur)
                                  , kr = k(Ar);
                                kr.__click = [wA, l, bt];
                                var Nr = k(kr, !0);
                                A(kr),
                                A(Ar),
                                A(Lt),
                                Ge( (ce, F, q) => {
                                    fe(Yt, x(wt) + 1),
                                    zr(ar, "data-tip", x(dt).name),
                                    fe(Ft, x(dt).flag),
                                    Or(dr, 1, `font-semibold ${ce ?? ""}`),
                                    fe(_r, `${x(bt).name ?? ""} `),
                                    fe(jr, `#${x(bt).number ?? ""}`),
                                    fe(Mr, F),
                                    fe(Nr, q)
                                }
                                , [ () => Zn(x(bt).cityId), () => x(bt).pixelsPainted.toLocaleString("en-US"), () => l3()]),
                                Zo(Lt, () => $o, () => ({
                                    duration: 200
                                })),
                                H(ut, Lt)
                            }
                            ),
                            A(It),
                            A(ne),
                            Ge( (ut, bt, wt, dt) => {
                                fe(We, ut),
                                fe(_t, `${bt ?? ""} `),
                                fe(xt, `${wt ?? ""} `),
                                zr(tt, "data-tip", dt)
                            }
                            , [ () => JT(), () => Ql(), () => ec().toLowerCase(), () => a3()]),
                            H(te, ne)
                        }
                          , Q = te => {
                            var _e = Jt()
                              , ne = zt(_e);
                            {
                                var Pe = at => {
                                    var We = PA()
                                      , Ct = k(We)
                                      , _t = k(Ct)
                                      , xt = V(k(_t))
                                      , tt = k(xt, !0);
                                    A(xt);
                                    var pt = V(xt)
                                      , It = k(pt)
                                      , ut = V(It, 2)
                                      , bt = V(ut)
                                      , wt = k(bt);
                                    $f(wt, {
                                        class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                                    }),
                                    A(bt),
                                    A(pt),
                                    A(_t),
                                    A(Ct);
                                    var dt = V(Ct);
                                    nn(dt, 31, () => x(ie), Lt => Lt.id, (Lt, Xt, Yt) => {
                                        const nr = lt( () => ds(x(Xt).id));
                                        var ar = SA()
                                          , Ft = k(ar)
                                          , dr = k(Ft, !0);
                                        A(Ft);
                                        var _r = V(Ft)
                                          , Ir = k(_r)
                                          , jr = k(Ir, !0);
                                        A(Ir);
                                        var ur = V(Ir, 2)
                                          , Mr = k(ur, !0);
                                        A(ur),
                                        A(_r);
                                        var Ar = V(_r)
                                          , kr = k(Ar, !0);
                                        A(Ar),
                                        A(ar),
                                        Ge( (Nr, ce) => {
                                            fe(dr, x(Yt) + 1),
                                            zr(Ir, "data-tip", x(nr).name),
                                            fe(jr, x(nr).flag),
                                            Or(ur, 1, `font-semibold ${Nr ?? ""}`),
                                            fe(Mr, x(nr).name),
                                            fe(kr, ce)
                                        }
                                        , [ () => Zn(x(Xt).id), () => x(Xt).pixelsPainted.toLocaleString("en-US")]),
                                        Zo(ar, () => $o, () => ({
                                            duration: 200
                                        })),
                                        H(Lt, ar)
                                    }
                                    ),
                                    A(dt),
                                    A(We),
                                    Ge( (Lt, Xt, Yt, nr) => {
                                        fe(tt, Lt),
                                        fe(It, `${Xt ?? ""} `),
                                        fe(ut, `${Yt ?? ""} `),
                                        zr(bt, "data-tip", nr)
                                    }
                                    , [ () => Vg(), () => Ql(), () => ec().toLowerCase(), () => O3()]),
                                    H(at, We)
                                }
                                  , Me = at => {
                                    var We = Jt()
                                      , Ct = zt(We);
                                    {
                                        var _t = tt => {
                                            const pt = lt( () => x(ie));
                                            var It = kA()
                                              , ut = k(It)
                                              , bt = k(ut)
                                              , wt = V(k(bt))
                                              , dt = k(wt, !0);
                                            A(wt);
                                            var Lt = V(wt)
                                              , Xt = k(Lt)
                                              , Yt = V(Xt, 2, !0);
                                            A(Lt),
                                            A(bt),
                                            A(ut);
                                            var nr = V(ut);
                                            nn(nr, 31, () => x(pt), ar => ar.id, (ar, Ft, dr) => {
                                                const _r = lt( () => {
                                                    var xe;
                                                    return ((xe = Dt.data) == null ? void 0 : xe.id) === x(Ft).id
                                                }
                                                );
                                                var Ir = AA();
                                                let jr;
                                                var ur = k(Ir)
                                                  , Mr = k(ur, !0);
                                                A(ur);
                                                var Ar = V(ur)
                                                  , kr = k(Ar)
                                                  , Nr = k(kr);
                                                es(Nr, {
                                                    class: "size-8 border sm:size-10",
                                                    get userId() {
                                                        return x(Ft).id
                                                    },
                                                    get pictureUrl() {
                                                        return x(Ft).picture
                                                    }
                                                });
                                                var ce = V(Nr, 2)
                                                  , F = k(ce)
                                                  , q = k(F)
                                                  , G = V(q)
                                                  , K = k(G);
                                                A(G),
                                                A(F);
                                                var le = V(F, 2);
                                                {
                                                    var ve = xe => {
                                                        const At = lt( () => ds(x(Ft).equippedFlag));
                                                        var Pt = IA()
                                                          , kt = k(Pt, !0);
                                                        A(Pt),
                                                        Ge( () => {
                                                            zr(Pt, "data-tip", x(At).name),
                                                            fe(kt, x(At).flag)
                                                        }
                                                        ),
                                                        H(xe, Pt)
                                                    }
                                                    ;
                                                    Ue(le, xe => {
                                                        x(Ft).equippedFlag && xe(ve)
                                                    }
                                                    )
                                                }
                                                var Le = V(le, 2);
                                                {
                                                    var Ce = xe => {
                                                        ph(xe, {
                                                            get username() {
                                                                return x(Ft).discord
                                                            }
                                                        })
                                                    }
                                                    ;
                                                    Ue(Le, xe => {
                                                        x(Ft).discord && xe(Ce)
                                                    }
                                                    )
                                                }
                                                var Ze = V(Le, 2);
                                                {
                                                    var ot = xe => {
                                                        var At = MA()
                                                          , Pt = k(At, !0);
                                                        A(At),
                                                        Ge( (kt, Wt) => {
                                                            Or(At, 1, `badge badge-sm ml-0.5 border-0 ${kt ?? ""} ${Wt ?? ""}`),
                                                            fe(Pt, x(Ft).allianceName)
                                                        }
                                                        , [ () => Kf(x(Ft).allianceId), () => Zn(x(Ft).allianceId)]),
                                                        H(xe, At)
                                                    }
                                                    ;
                                                    Ue(Ze, xe => {
                                                        "allianceName"in x(Ft) && x(Ft).allianceName && xe(ot)
                                                    }
                                                    )
                                                }
                                                A(ce),
                                                A(kr),
                                                A(Ar);
                                                var Ye = V(Ar)
                                                  , Ot = k(Ye, !0);
                                                A(Ye),
                                                A(Ir),
                                                Ge( (xe, At, Pt) => {
                                                    jr = Or(Ir, 1, "", null, jr, xe),
                                                    fe(Mr, x(dr) + 1),
                                                    Or(F, 1, `font-semibold max-sm:ml-2 ${At ?? ""} flex gap-1`),
                                                    fe(q, `${x(Ft).name ?? ""} `),
                                                    fe(K, `#${x(Ft).id ?? ""}`),
                                                    fe(Ot, Pt)
                                                }
                                                , [ () => ({
                                                    "bg-base-200": x(_r)
                                                }), () => Zn(x(Ft).id), () => x(Ft).pixelsPainted.toLocaleString("en-US")]),
                                                Zo(Ir, () => $o, () => ({
                                                    duration: 200
                                                })),
                                                H(ar, Ir)
                                            }
                                            ),
                                            A(nr),
                                            A(It),
                                            Ge( (ar, Ft, dr) => {
                                                fe(dt, ar),
                                                fe(Xt, `${Ft ?? ""} `),
                                                fe(Yt, dr)
                                            }
                                            , [ () => tm(), () => Ql(), () => ec().toLowerCase()]),
                                            H(tt, It)
                                        }
                                          , xt = tt => {
                                            var pt = Jt()
                                              , It = zt(pt);
                                            {
                                                var ut = bt => {
                                                    var wt = zA()
                                                      , dt = k(wt)
                                                      , Lt = k(dt)
                                                      , Xt = V(k(Lt))
                                                      , Yt = k(Xt, !0);
                                                    A(Xt);
                                                    var nr = V(Xt)
                                                      , ar = k(nr)
                                                      , Ft = V(ar, 2, !0);
                                                    A(nr),
                                                    A(Lt),
                                                    A(dt);
                                                    var dr = V(dt);
                                                    nn(dr, 31, () => x(ie), _r => _r.id, (_r, Ir, jr) => {
                                                        const ur = lt( () => {
                                                            var le;
                                                            return ((le = Dt.data) == null ? void 0 : le.allianceId) === x(Ir).id
                                                        }
                                                        );
                                                        var Mr = EA();
                                                        let Ar;
                                                        var kr = k(Mr)
                                                          , Nr = k(kr, !0);
                                                        A(kr);
                                                        var ce = V(kr)
                                                          , F = k(ce)
                                                          , q = k(F, !0);
                                                        A(F),
                                                        A(ce);
                                                        var G = V(ce)
                                                          , K = k(G, !0);
                                                        A(G),
                                                        A(Mr),
                                                        Ge( (le, ve, Le) => {
                                                            Ar = Or(Mr, 1, "", null, Ar, le),
                                                            fe(Nr, x(jr) + 1),
                                                            Or(F, 1, `font-semibold ${ve ?? ""}`),
                                                            fe(q, x(Ir).name),
                                                            fe(K, Le)
                                                        }
                                                        , [ () => ({
                                                            "bg-base-200": x(ur)
                                                        }), () => Zn(x(Ir).id), () => x(Ir).pixelsPainted.toLocaleString("en-US")]),
                                                        Zo(Mr, () => $o, () => ({
                                                            duration: 200
                                                        })),
                                                        H(_r, Mr)
                                                    }
                                                    ),
                                                    A(dr),
                                                    A(wt),
                                                    Ge( (_r, Ir, jr) => {
                                                        fe(Yt, _r),
                                                        fe(ar, `${Ir ?? ""} `),
                                                        fe(Ft, jr)
                                                    }
                                                    , [ () => Gd(), () => Ql(), () => ec().toLowerCase()]),
                                                    H(bt, wt)
                                                }
                                                ;
                                                Ue(It, bt => {
                                                    x(o) === "alliances" && bt(ut)
                                                }
                                                , !0)
                                            }
                                            H(tt, pt)
                                        }
                                        ;
                                        Ue(Ct, tt => {
                                            x(o) === "players" ? tt(_t) : tt(xt, !1)
                                        }
                                        , !0)
                                    }
                                    H(at, We)
                                }
                                ;
                                Ue(ne, at => {
                                    x(o) === "countries" ? at(Pe) : at(Me, !1)
                                }
                                , !0)
                            }
                            H(te, _e)
                        }
                        ;
                        Ue(Ae, te => {
                            x(o) === "regions" ? te(vt) : te(Q, !1)
                        }
                        )
                    }
                    H(it, Qe)
                }
                  , st = it => {
                    var Qe = LA();
                    H(it, Qe)
                }
                ;
                Ue(Je, it => {
                    x(ie) ? it(Be) : it(st, !1)
                }
                , !0)
            }
            H(Xe, ct)
        }
        ;
        Ue(Ne, Xe => {
            x(ie) && x(ie).length === 0 ? Xe(ft) : Xe(ht, !1)
        }
        )
    }
    $d("innerWidth", Xe => oe(C, Xe, !0)),
    H(b, ye),
    Pr()
}
Wi(["click"]);
var BA = Tr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');
function Mv(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = BA();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var FA = Ie('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function OA(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15);
    Ii( () => {
        const pe = ye => {
            ye.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", pe),
        () => document.removeEventListener("keydown", pe)
    }
    );
    var C = FA()
      , L = k(C)
      , O = V(k(L), 2)
      , T = k(O);
    Mv(T, {
        class: "size-6"
    });
    var o = V(T, 2)
      , $ = k(o, !0);
    A(o),
    A(O);
    var W = V(O, 2)
      , ie = k(W);
    RA(ie, {
        get onvisitclick() {
            return l.onvisitclick
        },
        get open() {
            return _()
        }
    }),
    A(W),
    A(L),
    fi(2),
    A(C),
    On(C, () => pe => {
        Zr( () => {
            _() ? pe.show() : pe.close()
        }
        )
    }
    ),
    Ge(pe => fe($, pe), [ () => Yf()]),
    an("close", C, () => _(!1)),
    H(b, C),
    Pr()
}
var NA = Ie("<div><!></div>")
  , jA = Ie('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function qA(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15);
    Ii( () => {
        const o = $ => {
            $.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", o),
        () => document.removeEventListener("keydown", o)
    }
    );
    var C = jA()
      , L = k(C)
      , O = V(k(L), 2);
    {
        var T = o => {
            var $ = NA()
              , W = k($);
            yx(W, {}),
            A($),
            En(2, $, () => Qn, () => ({
                duration: 300
            })),
            H(o, $)
        }
        ;
        Ue(O, o => {
            _() && o(T)
        }
        )
    }
    A(L),
    fi(2),
    A(C),
    On(C, () => o => {
        Zr( () => {
            _() ? o.show() : o.close()
        }
        )
    }
    ),
    an("close", C, () => _(!1)),
    H(b, C),
    Pr()
}
var VA = (b, l, _) => {
    localStorage.setItem(x(l), "true"),
    oe(_, !1)
}
  , UA = Ie('<span class="indicator-item indicator-bottom indicator-center badge badge-primary badge-xs">new</span>')
  , ZA = Ie("<div><!> <!></div>");
function _f(b, l) {
    Sr(l, !0);
    let _ = nt(!1);
    const C = lt( () => "showed:" + l.key);
    Ii( () => {
        oe(_, !localStorage.getItem(x(C)))
    }
    );
    var L = ZA();
    L.__click = [VA, C, _];
    var O = k(L);
    {
        var T = $ => {
            var W = UA();
            En(3, W, () => Qn, () => ({
                duration: 200
            })),
            H($, W)
        }
        ;
        Ue(O, $ => {
            x(_) && $(T)
        }
        )
    }
    var o = V(O, 2);
    Ji(o, () => l.children),
    A(L),
    Ge( () => Or(L, 1, `indicator ${l.class ?? ""}`)),
    H(b, L),
    Pr()
}
Wi(["click"]);
var $A = Ie("<p>You don't have charges to paint. <br/> </p>");
function GA(b, l) {
    Sr(l, !1),
    Og();
    var _ = $A()
      , C = V(k(_), 2);
    A(_),
    Ge(L => fe(C, ` Next charge in ${L ?? ""}`), [ () => zd(Dt.cooldown ?? 0)]),
    H(b, _),
    Pr()
}
var HA = Ie("<canvas></canvas>");
function Av(b, l) {
    Sr(l, !0);
    let _ = Et(l, "width", 15, 0)
      , C = Qt(l, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"])
      , L = lt( () => Math.ceil(l.fontSize))
      , O = nt(null);
    const T = window.devicePixelRatio ?? 1
      , o = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"'
      , $ = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    Zr( () => {
        const ie = x(O).getContext("2d");
        ie.textBaseline = "top",
        ie.font = `${l.weight ?? "normal"} ${l.fontSize}px ${l.mono ? $ : o}`,
        ie.fillStyle = l.color ?? "#394e6a",
        ie.setTransform(T, 0, 0, T, 0, 0),
        ie.clearRect(0, 0, _(), x(L)),
        ie.fillText(l.value, 0, 0);
        const pe = ie.measureText(l.value);
        _(Math.ceil(pe.actualBoundingBoxRight)),
        oe(L, pe.actualBoundingBoxDescent)
    }
    );
    var W = HA();
    er(W, () => ({
        width: _() * T,
        height: x(L) * T,
        style: `width: ${_() ?? ""}px; height: ${x(L) ?? ""}px`,
        ...C
    })),
    ps(W, ie => oe(O, ie), () => x(O)),
    H(b, W),
    Pr()
}
var WA = Ie('<span class="w-7 text-xs"> </span>')
  , XA = Ie('<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>')
  , KA = Ie('<span class="loading loading-spinner center-absolute absolute"></span>')
  , YA = Ie('<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>');
function kv(b, l) {
    Sr(l, !0);
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy", "loading", "charges"])
      , C = nt(0);
    var L = YA();
    er(L, () => ({
        ..._,
        class: `btn btn-primary btn-lg sm:btn-xl relative ${l.class ?? ""}`
    }));
    var O = k(L);
    fh(O, {
        class: "size-6"
    });
    var T = V(O, 2)
      , o = k(T)
      , $ = V(o);
    {
        var W = ye => {
            const X = lt( () => `${Math.floor(l.charges)}/${Dt.data.charges.max}`);
            var Se = XA()
              , we = k(Se)
              , Re = k(we);
            {
                let Ee = lt( () => l.disabled ? "#394e6a33" : "#ffffff");
                Av(Re, {
                    weight: 600,
                    fontSize: 16,
                    get value() {
                        return x(X)
                    },
                    get color() {
                        return x(Ee)
                    },
                    get width() {
                        return x(C)
                    },
                    set width(Ne) {
                        oe(C, Ne, !0)
                    }
                })
            }
            A(we);
            var ke = V(we, 2);
            {
                var Oe = Ee => {
                    var Ne = WA()
                      , ft = k(Ne);
                    A(Ne),
                    Ge(ht => fe(ft, `(${ht ?? ""})`), [ () => zd(Dt.cooldown)]),
                    H(Ee, Ne)
                }
                ;
                Ue(ke, Ee => {
                    l.charges < Dt.data.charges.max && Dt.cooldown !== void 0 && Ee(Oe)
                }
                )
            }
            A(Se),
            Ge(Ee => uc(we, `width: ${Ee ?? ""}px`), [ () => (Math.floor(x(C) / 5) + 1) * 5]),
            H(ye, Se)
        }
        ;
        Ue($, ye => {
            l.charges !== void 0 && Dt.data && ye(W)
        }
        )
    }
    A(T);
    var ie = V(T, 2);
    {
        var pe = ye => {
            var X = KA();
            H(ye, X)
        }
        ;
        Ue(ie, ye => {
            l.loading && ye(pe)
        }
        )
    }
    A(L),
    Ge(ye => fe(o, `${ye ?? ""} `), [ () => Zg()]),
    H(b, L),
    Pr()
}
const JA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII="
  , QA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC"
  , ek = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC"
  , tk = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class rk {
    constructor(l) {
        lr(this, "gm");
        lr(this, "opacity", 1);
        lr(this, "id", `paint-preview-${Math.random()}`);
        lr(this, "tiles", new Map);
        this.input = l,
        this.gm = new hc(this.input.tileSize)
    }
    place([l,_], C) {
        const {tile: L, pixel: O} = this.gm.latLonToTileAndPixel(l, _, this.input.tileZoom)
          , T = this.getTileKey(L[0], L[1]);
        let o = this.tiles.get(T);
        if (!o) {
            const $ = this.gm.tileBoundsLatLon(L[0], L[1], this.input.tileZoom)
              , W = rm($, !0)
              , ie = new ik({
                coordinates: W,
                id: `${this.id}-${T}`,
                layerPaint: {
                    "raster-opacity": this.opacity,
                    "raster-resampling": "nearest"
                },
                tileSize: this.input.tileSize,
                beforeLayerId: this.input.beforeLayerId
            });
            ie.addTo(this.input.map),
            this.tiles.set(T, ie),
            o = ie
        }
        o.place(O[0], this.input.tileSize - O[1] - 1, C)
    }
    clear() {
        const l = this.input.map;
        for (const _ of this.tiles.values())
            _.removeFrom(l),
            _.removeDOM();
        this.tiles.clear()
    }
    clearAndPlace(l, _) {
        this.clear(),
        this.place(l, _)
    }
    remove([l,_]) {
        const {tile: C, pixel: L} = this.gm.latLonToTileAndPixel(l, _, this.input.tileZoom)
          , O = this.getTileKey(C[0], C[1])
          , T = this.tiles.get(O);
        T && T.remove(L[0], this.input.tileSize - L[1] - 1)
    }
    setCanvasOpacity(l) {
        this.opacity = l;
        for (const _ of this.tiles.values())
            _.setOpacity(l)
    }
    getTileKey(l, _) {
        return `${l},${_}`
    }
}
class ik {
    constructor(l) {
        lr(this, "canvas");
        lr(this, "maps", new Set);
        this.input = l;
        const _ = this.input.tileSize;
        this.canvas = document.createElement("canvas"),
        this.canvas.width = _,
        this.canvas.height = _
    }
    place(l, _, C) {
        var T;
        const L = ((T = $n.colors) == null ? void 0 : T[C]) ?? $n.colors[0]
          , O = this.canvas.getContext("2d");
        if (O) {
            const o = O.createImageData(1, 1)
              , [$,W,ie] = L.rgb
              , pe = C === 0 ? 0 : 255;
            o.data[0] = $,
            o.data[1] = W,
            o.data[2] = ie,
            o.data[3] = pe,
            O.putImageData(o, l, _)
        }
    }
    remove(l, _) {
        const C = this.canvas.getContext("2d");
        C && C.clearRect(l, _, 1, 1)
    }
    addTo(l) {
        const _ = this.input.id;
        l.getSource(_) || l.addSource(_, {
            type: "canvas",
            canvas: this.canvas,
            coordinates: this.input.coordinates
        }),
        l.getLayer(_) || (l.addLayer({
            id: _,
            type: "raster",
            source: _,
            paint: this.input.layerPaint
        }),
        this.input.beforeLayerId && l.moveLayer(_, this.input.beforeLayerId)),
        this.maps.add(l)
    }
    removeFrom(l) {
        const {id: _} = this.input;
        l.getLayer(_) && l.removeLayer(_),
        l.getSource(_) && l.removeSource(_),
        this.maps.delete(l)
    }
    removeDOM() {
        this.canvas.remove()
    }
    setOpacity(l) {
        for (const _ of this.maps.values())
            _.setPaintProperty(this.input.id, "raster-opacity", l)
    }
}
var nk = Tr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');
function ak(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = nk();
    er(C, () => ({
        viewBox: "0 0 24 24",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg",
        ..._
    })),
    H(b, C)
}
var sk = Tr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');
function ok(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = sk();
    er(C, () => ({
        viewBox: "0 0 24 24",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg",
        ..._
    })),
    H(b, C)
}
var lk = Ie("<div><!></div>");
function Kl(b, l) {
    Sr(l, !0);
    var _ = lk()
      , C = k(_);
    Ji(C, () => l.children ?? fa),
    A(_),
    Ge( () => Or(_, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${l.class ?? ""}`)),
    H(b, _),
    Pr()
}
var ck = Ie('<div class="confetti svelte-15ksp55"></div>')
  , uk = Ie("<div></div>");
function hm(b, l) {
    Sr(l, !0);
    const _ = Et(l, "size", 3, 10)
      , C = Et(l, "x", 19, () => [-.5, .5])
      , L = Et(l, "y", 19, () => [.25, 1])
      , O = Et(l, "duration", 3, 2e3)
      , T = Et(l, "infinite", 3, !1)
      , o = Et(l, "delay", 19, () => [0, 50])
      , $ = Et(l, "colorRange", 19, () => [0, 360])
      , W = Et(l, "colorArray", 19, () => [])
      , ie = Et(l, "amount", 3, 50)
      , pe = Et(l, "iterationCount", 3, 1)
      , ye = Et(l, "fallDistance", 3, "100px")
      , X = Et(l, "rounded", 3, !1)
      , Se = Et(l, "cone", 3, !1)
      , we = Et(l, "noGravity", 3, !1)
      , Re = Et(l, "xSpread", 3, .15)
      , ke = Et(l, "destroyOnComplete", 3, !0)
      , Oe = Et(l, "disableForReducedMotion", 3, !1);
    let Ee = nt(!1);
    Ii( () => {
        !ke() || T() || typeof pe() == "string" || setTimeout( () => oe(Ee, !0), (O() + o()[1]) * pe())
    }
    );
    function Ne(Je, Be) {
        return Math.random() * (Be - Je) + Je
    }
    function ft() {
        return W().length ? W()[Math.round(Math.random() * (W().length - 1))] : `hsl(${Math.round(Ne($()[0], $()[1]))}, 75%, 50%)`
    }
    var ht = Jt()
      , Xe = zt(ht);
    {
        var ct = Je => {
            var Be = uk();
            let st;
            nn(Be, 21, () => ({
                length: ie()
            }), Zd, (it, Qe) => {
                var Ae = ck();
                Ge( (vt, Q, te, _e, ne, Pe, Me, at, We, Ct, _t) => uc(Ae, `
        --color: ${vt ?? ""};
        --skew: ${Q ?? ""}deg,${te ?? ""}deg;
        --rotation-xyz: ${_e ?? ""}, ${ne ?? ""}, ${Pe ?? ""};
        --rotation-deg: ${Me ?? ""}deg;
        --translate-y-multiplier: ${at ?? ""};
        --translate-x-multiplier: ${We ?? ""};
        --scale: ${Ct ?? ""};
        --transition-delay: ${_t ?? ""}ms;
        --transition-duration: ${T() ? `calc(${O()}ms * var(--scale))` : `${O()}ms`};`), [ft, () => Ne(-45, 45), () => Ne(-45, 45), () => Ne(-10, 10), () => Ne(-10, 10), () => Ne(-10, 10), () => Ne(0, 360), () => Ne(L()[0], L()[1]), () => Ne(C()[0], C()[1]), () => .1 * Ne(2, 10), () => Ne(o()[0], o()[1])]),
                H(it, Ae)
            }
            ),
            A(Be),
            Ge(it => {
                st = Or(Be, 1, "confetti-holder svelte-15ksp55", null, st, it),
                uc(Be, `
    --fall-distance: ${ye() ?? ""};
    --size: ${_() ?? ""}px;
    --x-spread: ${1 - Re()};
    --transition-iteration-count: ${(T() ? "infinite" : pe()) ?? ""};`)
            }
            , [ () => ({
                rounded: X(),
                cone: Se(),
                "no-gravity": we(),
                "reduced-motion": Oe()
            })]),
            H(Je, Be)
        }
        ;
        Ue(Xe, Je => {
            x(Ee) || Je(ct)
        }
        )
    }
    H(b, ht),
    Pr()
}
var hk = async (b, l, _, C) => {
    try {
        oe(l, !0),
        await ni.purchase({
            id: _,
            amount: 1,
            variant: C.colorIdx
        }),
        await Dt.refresh(),
        pa.notification1.play()
    } catch (L) {
        qr.error(L.message)
    } finally {
        oe(l, !1)
    }
}
  , dk = Ie('<span class="loading loading-spinner center-absolute absolute"></span>')
  , pk = Ie('<!> <span class="text-sm">Droplets</span>', 1)
  , fk = Ie('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1)
  , mk = (b, l) => l(!1)
  , _k = Ie('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>')
  , gk = Ie('<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function vk(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15);
    const C = lt( () => $n.colors[l.colorIdx])
      , L = lt( () => {
        var X;
        return ((X = Dt.data) == null ? void 0 : X.droplets) ?? 0
    }
    );
    let O = nt(!1);
    const T = lt( () => (x(O),
    Dt.hasColor(l.colorIdx)));
    Ii( () => {
        const X = Se => {
            Se.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", X),
        () => document.removeEventListener("keydown", X)
    }
    );
    const o = 100
      , $ = $n.products[o];
    var W = gk()
      , ie = k(W)
      , pe = V(k(ie), 2);
    {
        var ye = X => {
            var Se = _k()
              , we = k(Se)
              , Re = k(we)
              , ke = k(Re);
            Ld(ke, {
                class: "size-6"
            });
            var Oe = V(ke, 4)
              , Ee = k(Oe);
            Rg(Ee, {
                get value() {
                    return x(L)
                }
            }),
            A(Oe),
            A(Re),
            fi(2),
            A(we);
            var Ne = V(we, 2)
              , ft = k(Ne)
              , ht = k(ft);
            A(ft);
            var Xe = V(ft, 2)
              , ct = k(Xe, !0);
            A(Xe);
            var Je = V(Xe, 2)
              , Be = k(Je);
            let st;
            var it = k(Be);
            it.__click = [hk, O, o, l];
            var Qe = k(it);
            {
                var Ae = ne => {
                    var Pe = dk();
                    H(ne, Pe)
                }
                ;
                Ue(Qe, ne => {
                    x(O) && ne(Ae)
                }
                )
            }
            var vt = V(Qe, 2);
            {
                var Q = ne => {
                    var Pe = pk()
                      , Me = zt(Pe);
                    Ud(Me, {
                        class: "size-5"
                    });
                    var at = V(Me);
                    fi(),
                    Ge(We => fe(at, ` ${We ?? ""} `), [ () => $.price.toLocaleString("en-US")]),
                    H(ne, Pe)
                }
                  , te = ne => {
                    var Pe = fk()
                      , Me = zt(Pe);
                    Ld(Me, {
                        class: "size-5"
                    });
                    var at = V(Me, 2)
                      , We = k(at);
                    hm(We, {}),
                    A(at),
                    H(ne, Pe)
                }
                ;
                Ue(vt, ne => {
                    x(T) ? ne(te, !1) : ne(Q)
                }
                )
            }
            A(it),
            A(Be);
            var _e = V(Be, 2);
            _e.__click = [mk, _],
            A(Je),
            A(Ne),
            A(Se),
            Ge( (ne, Pe) => {
                uc(ht, `background: rgb(${x(C).rgb[0]} ${x(C).rgb[1]} ${x(C).rgb[2]})`),
                zr(ht, "aria-label", x(C).name),
                fe(ct, x(C).name),
                zr(Be, "data-tip", ne),
                st = Or(Be, 1, "", null, st, Pe),
                it.disabled = x(L) < $.price || x(O) || x(T)
            }
            , [ () => Hd(), () => ({
                tooltip: !x(T) && x(L) < $.price
            })]),
            H(X, Se)
        }
        ;
        Ue(pe, X => {
            Dt.data && X(ye)
        }
        )
    }
    A(ie),
    fi(2),
    A(W),
    On(W, () => X => {
        Zr( () => {
            _() ? X.show() : X.close()
        }
        )
    }
    ),
    an("close", W, () => _(!1)),
    H(b, W),
    Pr()
}
Wi(["click"]);
var yk = Tr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');
function Tg(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = yk();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var xk = Tr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');
function Cg(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = xk();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var bk = Tr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');
function Ev(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = bk();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var wk = Tr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>')
  , Tk = Tr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');
function zv(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var C = Jt()
      , L = zt(C);
    {
        var O = o => {
            var $ = wk();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
          , T = o => {
            var $ = Tk();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
        ;
        Ue(L, o => {
            l.filled ? o(O) : o(T, !1)
        }
        )
    }
    H(b, C)
}
var Ck = Tr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');
function Gf(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Ck();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Sk = Tr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');
function Lv(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Sk();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Pk = Tr('<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>');
function Ik(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Pk();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Mk = Tr('<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>');
function Ak(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Mk();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var kk = Ie("<!> ", 1)
  , Ek = Ie("<!> ", 1)
  , zk = Ie("<!> ", 1)
  , Lk = Ie('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1)
  , Dk = Ie("<!> ", 1)
  , Rk = Ie("<!> <!>", 1)
  , Bk = (b, l) => oe(l, !x(l))
  , Fk = (b, l) => {
    oe(l, "colorpicker")
}
  , Ok = (b, l) => {
    l(!l())
}
  , Nk = (b, l) => {
    oe(l, "cleararea")
}
  , jk = Ie('<div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button><!></button></div>')
  , qk = (b, l) => {
    pa.smallPlop.play(),
    l()
}
  , Vk = (b, l, _) => {
    l(x(_).idx)
}
  , Uk = Ie('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1)
  , Zk = Ie("<div><button><!></button></div>")
  , $k = (b, l) => {
    oe(l, !x(l))
}
  , Gk = (b, l) => {
    oe(l, x(l) === "eraser" ? "pencil" : "eraser", !0)
}
  , Hk = Ie('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1"><h2 class="select-none text-xl"> <!></h2> <div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip"><button title="Toggle art opacity"><!></button></div> <!></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);
function Wk(b, l) {
    Sr(l, !0);
    let _ = Et(l, "screenLocked", 15)
      , C = Et(l, "opaquePixelArt", 15);
    const L = lt( () => new hc(l.tileSize));
    let O = nt(1)
      , T = nt("pencil");
    const o = new Map
      , $ = new Map;
    let W = nt(0)
      , ie = nt(!1)
      , pe = nt(!0)
      , ye = lt( () => Dt.charges ?? 0)
      , X = lt( () => x(ye) - x(W))
      , Se = nt(!1)
      , we = !1
      , Re = nt(!1)
      , ke = nt(zn([]));
    const Oe = lt( () => x(T) === "pencil")
      , Ee = lt( () => x(T) === "eraser")
      , Ne = lt( () => x(T) === "colorpicker")
      , ft = lt( () => x(T) === "cleararea")
      , ht = lt( () => {
        var Mt, Ke;
        return Cu((Ke = (Mt = Dt) == null ? void 0 : Mt.data) == null ? void 0 : Ke.role, ["admin", "global_moderator"])
    }
    );
    let Xe = nt(!1)
      , ct = nt(0)
      , Je = nt(void 0)
      , Be = nt(void 0);
    const st = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(Mt => ({
        ...$n.colors[Mt],
        idx: Mt
    }))
      , it = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(Mt => ({
        ...$n.colors[Mt],
        idx: Mt
    }));
    let Qe = nt(!1);
    const Ae = lt( () => x(Qe) ? st : it)
      , vt = "show-all-colors";
    Ii( () => {
        oe(Qe, localStorage.getItem(vt) === "true")
    }
    ),
    Zr( () => {
        localStorage.setItem(vt, x(Qe) ? "true" : "false")
    }
    );
    const Q = "selected-color";
    Ii( () => {
        const Mt = Number(localStorage.getItem(Q));
        !isNaN(Mt) && Mt < $n.colors.length && Mt > 0 && oe(O, Mt, !0)
    }
    ),
    Zr( () => {
        localStorage.setItem(Q, x(O).toString())
    }
    );
    const te = new rk({
        map: l.map,
        tileSize: l.tileSize,
        tileZoom: l.tileZoom,
        beforeLayerId: l.hoverLayerId
    });
    Zr( () => {
        const Mt = C() ? 1 : 0;
        te.setCanvasOpacity(Mt)
    }
    ),
    Zr( () => {
        C() ? yf() : Ct([...o.values()])
    }
    );
    let _e = !1;
    Ii( () => {
        Qa(l.map.getCenter(), l.map.getZoom());
        const Mt = l.map.on("click", rr => {
            var Qr;
            l.zoom < l.tileZoom + 2 && ((Qr = Dt.data) == null ? void 0 : Qr.role) === "user" && l.map.easeTo({
                center: rr.lngLat,
                zoom: 17
            });
            const yi = [rr.lngLat.lat, rr.lngLat.lng];
            if (x(Oe))
                Pe([yi], x(O));
            else if (x(Ee))
                Me([yi]);
            else if (x(Ne))
                at(yi, rr.point);
            else if (x(ft) && (x(ke).push(yi),
            Pe([yi], 0),
            x(ke).length >= 2)) {
                const [Yr,la] = x(ke)
                  , [sn,ta] = x(L).latLonToPixelsFloor(Yr[0], Yr[1], l.tileZoom)
                  , [Fi,Xi] = x(L).latLonToPixelsFloor(la[0], la[1], l.tileZoom)
                  , Gn = Math.min(sn, Fi)
                  , Hn = Math.max(sn, Fi)
                  , Ln = Math.min(ta, Xi)
                  , gt = Math.max(ta, Xi)
                  , qt = [];
                for (let vr = Ln; vr <= gt; vr++) {
                    const _i = x(L).pixelsToLatLon(Gn + .5, vr + .5, l.tileZoom)
                      , Di = x(L).pixelsToLatLon(Hn + .5, vr + .5, l.tileZoom)
                      , $i = Ke({
                        lat: _i[0],
                        lng: _i[1]
                    }, {
                        lat: Di[0],
                        lng: Di[1]
                    }).slice(0, x(X) - qt.length);
                    if (qt.push(...$i),
                    qt.length >= x(X))
                        break
                }
                Pe(qt, 0),
                oe(ke, [], !0),
                oe(T, "pencil")
            }
            oe(Se, !0)
        }
        );
        function Ke(rr, yi) {
            const Qr = x(L).latLonToPixels(rr.lat, rr.lng, l.tileZoom)
              , Yr = yi ? x(L).latLonToPixels(yi.lat, yi.lng, l.tileZoom) : Qr;
            return cx(Qr, Yr).map(sn => x(L).pixelsToLatLon(sn[0] + .5, sn[1] + .5, l.tileZoom))
        }
        function jt(rr, yi) {
            const Qr = Ke(rr, yi);
            x(Oe) ? Pe(Qr, x(O)) : x(Ee) && Me(Qr),
            oe(Se, !0)
        }
        let Gt;
        function Dr(rr) {
            const yi = l.map.unproject([rr.clientX, rr.clientY]);
            if (x(Re)) {
                const Qr = Ke(yi, Gt);
                Me(Qr)
            }
            (_e || we) && jt(yi, Gt),
            Gt = yi
        }
        window.addEventListener("mousemove", Dr);
        let Gr = !1;
        const li = l.map.on("touchstart", rr => {
            if (rr.points.length == 2) {
                _(!1),
                pt(),
                Gr = !0,
                setTimeout( () => Gr = !1, 150);
                return
            }
            _() && setTimeout( () => {
                !Gr && jt(rr.lngLat)
            }
            , 150),
            Gt = rr.lngLat
        }
        )
          , fr = l.map.on("touchmove", rr => {
            _() && jt(rr.lngLat, Gt),
            Gt = rr.lngLat
        }
        )
          , bi = rr => {
            rr.code === "Space" && (_e || Gt && jt(Gt),
            _e = !0,
            rr.preventDefault())
        }
        ;
        document.addEventListener("keydown", bi);
        const Si = rr => {
            rr.code === "Space" && (_e = !1,
            ne = !1,
            x(W) === 0 && x(Ee) && oe(T, "pencil"))
        }
        ;
        document.addEventListener("keyup", Si);
        function zi(rr) {
            if (rr.button === 2) {
                oe(Re, !0);
                const Qr = l.map.unproject([rr.clientX, rr.clientY]);
                Me([[Qr.lat, Qr.lng]])
            }
        }
        document.addEventListener("mousedown", zi);
        function mi(rr) {
            rr.button === 2 && oe(Re, !1)
        }
        document.addEventListener("mouseup", mi);
        const Li = rr => {
            switch (rr.code) {
            case "KeyE":
                x(W) > 0 && (x(Ee) ? oe(T, "pencil") : oe(T, "eraser"));
                return;
            case "KeyI":
                oe(T, "colorpicker");
                return;
            case "KeyC":
                x(ht) && oe(T, "cleararea");
                return
            }
        }
        ;
        return document.addEventListener("keypress", Li),
        () => {
            fr.unsubscribe(),
            li.unsubscribe(),
            Mt.unsubscribe(),
            document.removeEventListener("mousemove", Dr),
            document.removeEventListener("keydown", bi),
            document.removeEventListener("keyup", Si),
            document.removeEventListener("keypress", Li),
            document.removeEventListener("mousedown", zi),
            document.removeEventListener("mouseup", mi),
            _t()
        }
    }
    );
    let ne = !1;
    function Pe(Mt, Ke) {
        let jt = !1;
        const Gt = Ke === 0;
        for (let Dr of Mt) {
            const [Gr,li] = Dr
              , fr = gx(Ke)
              , {tile: bi, pixel: Si} = x(L).latLonToTileAndPixel(Gr, li, l.tileZoom)
              , zi = {
                color: fr,
                tile: bi,
                pixel: Si,
                season: l.season,
                colorIdx: Ke
            }
              , mi = cf(zi)
              , Li = o.get(mi)
              , rr = x(ye) - o.size;
            if (!Li && rr < 1) {
                if (ne && (_e || _()))
                    continue;
                ne = !0,
                qr.info(Z3());
                continue
            }
            Li && Li.colorIdx === Ke || (pa.plop.play(),
            jt || l.hidePixelHover(),
            o.set(mi, zi),
            te.place(Dr, Ke),
            l.crosshair.place(Dr),
            jt = !0,
            Gt && $.set(mi, zi))
        }
        oe(W, o.size, !0),
        jt && !C() ? Ct([...o.values()]) : jt && C() && Gt && Ct([...$.values()])
    }
    function Me(Mt) {
        let Ke = !1
          , jt = !1;
        for (let Gt of Mt) {
            const [Dr,Gr] = Gt
              , {tile: li, pixel: fr} = x(L).latLonToTileAndPixel(Dr, Gr, l.tileZoom)
              , bi = cf({
                tile: li,
                pixel: fr,
                season: l.season
            })
              , Si = o.get(bi);
            Si && (pa.plop.play(),
            l.hidePixelHover(),
            o.delete(bi),
            $.delete(bi),
            te.remove([Dr, Gr]),
            l.crosshair.remove(Gt),
            Ke = !0,
            Si.colorIdx === 0 && (jt = !0)),
            o.size === 0 && !(_e || we || _()) && oe(T, "pencil")
        }
        oe(W, o.size, !0),
        Ke && !C() ? Ct([...o.values()]) : Ke && C() && jt && Ct([...$.values()])
    }
    function at(Mt, Ke) {
        const {tile: jt, pixel: Gt} = x(L).latLonToTileAndPixel(Mt[0], Mt[1], l.tileZoom)
          , Dr = cf({
            tile: jt,
            pixel: Gt,
            season: l.season
        })
          , Gr = o.get(Dr);
        if (Gr) {
            It(Gr.colorIdx),
            requestAnimationFrame( () => {
                var Si;
                (Si = document.getElementById(`color-${Gr.colorIdx}`)) == null || Si.focus()
            }
            );
            return
        }
        const li = window.devicePixelRatio
          , fr = Math.floor(Ke.x * li)
          , bi = Math.floor(Ke.y * li);
        l.hidePixelHover(),
        dM(l.map, fr, bi).then( ([Si,zi,mi]) => {
            const Li = vx({
                r: Si,
                g: zi,
                b: mi
            });
            It(Li),
            requestAnimationFrame( () => {
                var rr;
                (rr = document.getElementById(`color-${Li}`)) == null || rr.focus()
            }
            )
        }
        )
    }
    dc( () => x(O), () => {
        l.clickedLatLon && !x(Se) && (x(O) === void 0 && oe(O, 1),
        Pe([l.clickedLatLon], x(O)))
    }
    ),
    Zr( () => {
        const Mt = x(pe) ? .8 : 0;
        l.crosshair.setCanvasOpacity(Mt)
    }
    );
    let We = nt(16.5);
    Zr( () => {
        if (x(Je) && x(Be) && l.clickedLatLon) {
            const Mt = l.map.getZoom();
            if (Mt < x(We)) {
                const [Ke,jt] = l.clickedLatLon
                  , Gt = x(L).latLonToPixelBoundsLatLon(Ke, jt, l.tileZoom)
                  , Dr = im(Gt)
                  , Gr = x(Je) - x(Be).clientHeight
                  , li = x(Je) / 2 - Gr / 2;
                l.map.flyTo({
                    center: {
                        lat: Dr[0],
                        lng: Dr[1]
                    },
                    zoom: 17.5,
                    offset: Mt > 11 ? [0, -li] : [0, 0]
                })
            }
            oe(We, l.tileZoom, !0)
        }
    }
    ),
    Ii( () => {
        const Mt = () => {
            !document.hidden && (console.log("Tab visible again"),
            C() ? Ct([...$.values()]) : Ct([...o.values()]))
        }
        ;
        return document.addEventListener("visibilitychange", Mt),
        () => document.removeEventListener("visibilitychange", Mt)
    }
    ),
    Zr( () => {
        switch (x(T)) {
        case "pencil":
            l.map.getCanvas().style.cursor = `url('${ek}') 8 8, default`,
            l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
            return;
        case "colorpicker":
            l.map.getCanvas().style.cursor = `url('${JA}') 0 16, default`,
            l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", 0);
            return;
        case "eraser":
            l.map.getCanvas().style.cursor = `url('${QA}') 2 14, default`,
            l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
            return
        }
    }
    ),
    Zr( () => {
        _() ? tt() : pt()
    }
    );
    async function Ct(Mt) {
        await ax(Mt),
        l.refreshPixelArt()
    }
    async function _t() {
        await yf(),
        te.clear(),
        l.refreshPixelArt(),
        l.crosshair.clear()
    }
    async function xt() {
        await _t(),
        pt(),
        l.map.getCanvas().style.cursor = "default",
        l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4),
        l.onclose()
    }
    function tt() {
        l.map.dragPan.disable(),
        l.map.touchZoomRotate.disable(),
        document.body.style.overscrollBehavior = "none"
    }
    function pt() {
        l.map.dragPan.enable(),
        l.map.touchZoomRotate.enable(),
        document.body.style.overscrollBehavior = ""
    }
    function It(Mt) {
        return Mt >= 32 && oe(Qe, !0),
        Dt.hasColor(Mt) ? (pa.smallDropplet.play(),
        oe(O, Mt, !0),
        oe(T, "pencil"),
        !0) : (pa.smallDropplet.play(),
        oe(Xe, !0),
        oe(ct, Mt, !0),
        !1)
    }
    ox(Mt => {
        Mt.type === "leave" && x(W) > 0 && Mt.cancel()
    }
    );
    const ut = "show-paint-more-than-one-pixel-msg";
    let bt = nt(!1);
    Ii( () => {
        var Mt;
        oe(bt, !localStorage.getItem(ut) && (((Mt = Dt.data) == null ? void 0 : Mt.pixelsPainted) ?? 0) < 100, !0)
    }
    ),
    Zr( () => {
        x(W) > 1 && (oe(bt, !1),
        localStorage.setItem(ut, "false"))
    }
    );
    const wt = "lp";
    Ii( () => {
        var Ke;
        const Mt = localStorage.getItem(wt);
        if (Mt)
            try {
                const jt = JSON.parse(atob(Mt))
                  , Gt = (jt == null ? void 0 : jt.time) ?? 0
                  , Dr = 60 * 1e3;
                (jt == null ? void 0 : jt.userId) !== ((Ke = Dt.data) == null ? void 0 : Ke.id) && Date.now() - Gt < 30 * Dr && !ux && (qr.error(H3()),
                xt())
            } catch (jt) {
                console.error(jt)
            }
    }
    );
    function dt() {
        var Ke;
        const Mt = btoa(JSON.stringify({
            userId: (Ke = Dt.data) == null ? void 0 : Ke.id,
            time: Date.now()
        }));
        localStorage.setItem(wt, Mt)
    }
    var Lt = Hk()
      , Xt = zt(Lt)
      , Yt = k(Xt);
    {
        var nr = Mt => {
            Kl(Mt, {
                children: (Ke, jt) => {
                    var Gt = kk()
                      , Dr = zt(Gt);
                    Ev(Dr, {
                        class: "inline size-5"
                    });
                    var Gr = V(Dr);
                    Ge(li => fe(Gr, ` ${li ?? ""}`), [ () => cw()]),
                    H(Ke, Gt)
                }
                ,
                $$slots: {
                    default: !0
                }
            })
        }
          , ar = Mt => {
            var Ke = Jt()
              , jt = zt(Ke);
            {
                var Gt = Gr => {
                    Kl(Gr, {
                        class: "not-touchscreen:hidden",
                        children: (li, fr) => {
                            var bi = Ek()
                              , Si = zt(bi);
                            lg(Si, {
                                class: "inline size-5"
                            });
                            var zi = V(Si);
                            Ge(mi => fe(zi, ` ${mi ?? ""}`), [ () => dw()]),
                            H(li, bi)
                        }
                        ,
                        $$slots: {
                            default: !0
                        }
                    })
                }
                  , Dr = Gr => {
                    var li = Jt()
                      , fr = zt(li);
                    {
                        var bi = zi => {
                            Kl(zi, {
                                class: "not-touchscreen:hidden",
                                children: (mi, Li) => {
                                    var rr = zk()
                                      , yi = zt(rr);
                                    Cg(yi, {
                                        class: "inline size-5"
                                    });
                                    var Qr = V(yi, 1, !0);
                                    Ge(Yr => fe(Qr, Yr), [ () => mw()]),
                                    H(mi, rr)
                                }
                                ,
                                $$slots: {
                                    default: !0
                                }
                            })
                        }
                          , Si = zi => {
                            var mi = Jt()
                              , Li = zt(mi);
                            {
                                var rr = Qr => {
                                    Kl(Qr, {
                                        class: "touchscreen:hidden",
                                        children: (Yr, la) => {
                                            var sn = Lk()
                                              , ta = zt(sn);
                                            Lv(ta, {
                                                class: "inline size-5"
                                            });
                                            var Fi = V(ta)
                                              , Xi = k(Fi, !0);
                                            A(Fi);
                                            var Gn = V(Fi, 2)
                                              , Hn = k(Gn)
                                              , Ln = V(Hn)
                                              , gt = k(Ln, !0);
                                            A(Ln),
                                            A(Gn);
                                            var qt = V(Gn);
                                            Ge( (vr, _i, Di, $i) => {
                                                fe(Xi, vr),
                                                fe(Hn, `${_i ?? ""} `),
                                                fe(gt, Di),
                                                fe(qt, ` ${$i ?? ""}`)
                                            }
                                            , [ () => vw(), () => Cw(), () => bw(), () => Iw()]),
                                            H(Yr, sn)
                                        }
                                        ,
                                        $$slots: {
                                            default: !0
                                        }
                                    })
                                }
                                  , yi = Qr => {
                                    var Yr = Jt()
                                      , la = zt(Yr);
                                    {
                                        var sn = Fi => {
                                            Kl(Fi, {
                                                class: "bg-warning text-warning-content animate-bounce",
                                                children: (Xi, Gn) => {
                                                    var Hn = Dk()
                                                      , Ln = zt(Hn);
                                                    fh(Ln, {
                                                        class: "inline size-5"
                                                    });
                                                    var gt = V(Ln);
                                                    Ge(qt => fe(gt, ` ${qt ?? ""}`), [ () => kw()]),
                                                    H(Xi, Hn)
                                                }
                                                ,
                                                $$slots: {
                                                    default: !0
                                                }
                                            })
                                        }
                                          , ta = Fi => {
                                            var Xi = Jt()
                                              , Gn = zt(Xi);
                                            {
                                                var Hn = Ln => {
                                                    Kl(Ln, {
                                                        class: "bg-warning text-warning-content animate-bounce",
                                                        children: (gt, qt) => {
                                                            var vr = Rk()
                                                              , _i = zt(vr);
                                                            Tg(_i, {
                                                                class: "inline size-5"
                                                            });
                                                            var Di = V(_i, 2);
                                                            {
                                                                var $i = Cr => {
                                                                    var gn = Fn();
                                                                    Ge(tr => fe(gn, tr), [ () => cP()]),
                                                                    H(Cr, gn)
                                                                }
                                                                  , Mi = Cr => {
                                                                    var gn = Jt()
                                                                      , tr = zt(gn);
                                                                    {
                                                                        var Ht = ei => {
                                                                            var ri = Fn();
                                                                            Ge(gi => fe(ri, gi), [ () => dP()]),
                                                                            H(ei, ri)
                                                                        }
                                                                        ;
                                                                        Ue(tr, ei => {
                                                                            x(ke).length === 1 && ei(Ht)
                                                                        }
                                                                        , !0)
                                                                    }
                                                                    H(Cr, gn)
                                                                }
                                                                ;
                                                                Ue(Di, Cr => {
                                                                    x(ke).length === 0 ? Cr($i) : Cr(Mi, !1)
                                                                }
                                                                )
                                                            }
                                                            H(gt, vr)
                                                        }
                                                        ,
                                                        $$slots: {
                                                            default: !0
                                                        }
                                                    })
                                                }
                                                ;
                                                Ue(Gn, Ln => {
                                                    x(ft) && Ln(Hn)
                                                }
                                                , !0)
                                            }
                                            H(Fi, Xi)
                                        }
                                        ;
                                        Ue(la, Fi => {
                                            x(bt) ? Fi(sn) : Fi(ta, !1)
                                        }
                                        , !0)
                                    }
                                    H(Qr, Yr)
                                }
                                ;
                                Ue(Li, Qr => {
                                    x(Oe) && x(W) === 0 ? Qr(rr) : Qr(yi, !1)
                                }
                                , !0)
                            }
                            H(zi, mi)
                        }
                        ;
                        Ue(fr, zi => {
                            x(Ne) ? zi(bi) : zi(Si, !1)
                        }
                        , !0)
                    }
                    H(Gr, li)
                }
                ;
                Ue(jt, Gr => {
                    x(Ee) ? Gr(Gt) : Gr(Dr, !1)
                }
                , !0)
            }
            H(Mt, Ke)
        }
        ;
        Ue(Yt, Mt => {
            x(Ee) && x(W) === 0 ? Mt(nr) : Mt(ar, !1)
        }
        )
    }
    var Ft = V(Yt, 2)
      , dr = k(Ft);
    dr.__click = [Bk, pe];
    var _r = k(dr);
    {
        var Ir = Mt => {
            ak(Mt, {
                class: "size-4"
            })
        }
          , jr = Mt => {
            ok(Mt, {
                class: "size-4"
            })
        }
        ;
        Ue(_r, Mt => {
            x(pe) ? Mt(Ir) : Mt(jr, !1)
        }
        )
    }
    A(dr);
    var ur = V(dr, 2)
      , Mr = k(ur)
      , Ar = k(Mr)
      , kr = V(Ar);
    Av(kr, {
        class: "inline",
        fontSize: 14,
        get value() {
            return `(${x(W) ?? ""})`
        },
        mono: !0
    }),
    A(Mr);
    var Nr = V(Mr, 2)
      , ce = k(Nr)
      , F = k(ce);
    fi(),
    A(ce);
    var q = V(ce, 2);
    q.__click = [Fk, T];
    var G = k(q);
    Cg(G, {
        class: "size-4.5"
    }),
    A(q),
    A(Nr);
    var K = V(Nr, 2)
      , le = k(K);
    let ve;
    le.__click = [Ok, C];
    var Le = k(le);
    {
        let Mt = lt( () => !C());
        zv(Le, {
            class: "size-4.5",
            get filled() {
                return x(Mt)
            }
        })
    }
    A(le),
    A(K);
    var Ce = V(K, 2);
    {
        var Ze = Mt => {
            var Ke = jk()
              , jt = k(Ke)
              , Gt = k(jt);
            fi(),
            A(jt);
            var Dr = V(jt, 2);
            Dr.__click = [Nk, T];
            var Gr = k(Dr);
            Tg(Gr, {
                class: "size-4.5"
            }),
            A(Dr),
            A(Ke),
            Ge(li => {
                fe(Gt, `${li ?? ""} `),
                Or(Dr, 1, Vo({
                    "btn btn-circle btn-sm": !0,
                    "btn-ghost": !x(ft),
                    "btn-primary": x(ft)
                }))
            }
            , [ () => sP()]),
            H(Mt, Ke)
        }
        ;
        Ue(Ce, Mt => {
            x(ht) && Mt(Ze)
        }
        )
    }
    A(ur);
    var ot = V(ur, 2);
    ot.__click = [qk, xt];
    var Ye = k(ot);
    fc(Ye, {
        class: "size-4"
    }),
    A(ot),
    A(Ft);
    var Ot = V(Ft, 2)
      , xe = k(Ot);
    nn(xe, 23, () => x(Ae), Mt => Mt.idx, (Mt, Ke, jt) => {
        const Gt = lt( () => {
            const [mi,Li,rr] = x(Ke).rgb;
            return {
                r: mi,
                g: Li,
                b: rr
            }
        }
        )
          , Dr = lt( () => x(O) === x(Ke).idx && x(Oe))
          , Gr = lt( () => x(Ke).idx === 0)
          , li = lt( () => Dt.hasColor(x(Ke).idx));
        var fr = Zk()
          , bi = k(fr);
        bi.__click = [Vk, It, Ke];
        var Si = k(bi);
        {
            var zi = mi => {
                var Li = Uk()
                  , rr = zt(Li);
                Gf(rr, {
                    class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
                });
                var yi = V(rr, 2)
                  , Qr = k(yi);
                Gf(Qr, {
                    class: "text-base-content/80 size-4"
                }),
                A(yi),
                H(mi, Li)
            }
            ;
            Ue(Si, mi => {
                x(li) || mi(zi)
            }
            )
        }
        A(bi),
        A(fr),
        Ge( () => {
            Or(fr, 1, Vo({
                tooltip: !0,
                "max-sm:h-6": x(Qe),
                "max-sm:before:translate-x-1/4": x(jt) % 8 === 0 && x(Ke).name.length > 7,
                "max-sm:before:-translate-x-1/4": (x(jt) - 7) % 8 === 0 && x(Ke).name.length > 7,
                "max-xl:before:translate-x-1/4": x(jt) % 16 === 0 && x(Ke).name.length > 7,
                "max-xl:before:-translate-x-1/4": (x(jt) - 15) % 16 === 0 && x(Ke).name.length > 7,
                "xl:before:translate-x-1/4": x(Qe) && x(jt) % 32 === 0 && x(Ke).name.length > 7,
                "xl:before:-translate-x-1/4": x(Qe) && (x(jt) - 31) % 32 === 0 && x(Ke).name.length > 7
            })),
            zr(fr, "data-tip", x(Ke).name),
            Or(bi, 1, Vo({
                "btn relative aspect-square w-full rounded-xl": !0,
                "border-primary ring-primary ring-2": x(Dr),
                "border-base-300": !x(Dr) && x(Gr),
                "border-base-content/20": !x(Dr) && !x(Gr),
                "max-sm:h-6 max-sm:rounded-md": x(Qe)
            })),
            uc(bi, x(Gr) ? `background-image: url(${tk}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${x(Gt).r} ${x(Gt).g} ${x(Gt).b})`),
            zr(bi, "aria-label", x(Ke).name),
            zr(bi, "id", `color-${x(Ke).idx ?? ""}`)
        }
        ),
        an("focus", bi, () => {
            x(li) && (oe(O, x(Ke).idx, !0),
            oe(T, "pencil"))
        }
        ),
        H(Mt, fr)
    }
    ),
    A(xe),
    A(Ot);
    var At = V(Ot, 2)
      , Pt = k(At);
    Pt.__click = [$k, Qe];
    var kt = k(Pt);
    {
        var Wt = Mt => {
            Ik(Mt, {
                class: "size-5"
            })
        }
          , Lr = Mt => {
            Ak(Mt, {
                class: "size-5"
            })
        }
        ;
        Ue(kt, Mt => {
            x(Qe) ? Mt(Wt) : Mt(Lr, !1)
        }
        )
    }
    A(Pt);
    var Kr = V(Pt, 2)
      , Hr = k(Kr);
    {
        let Mt = lt( () => x(W) > 100 ? "animate-pulse" : "")
          , Ke = lt( () => x(W) === 0 || x(ie) || x(X) < 0 || !oa.captcha)
          , jt = lt( () => x(ie) || !oa.captcha);
        kv(Hr, {
            get class() {
                return x(Mt)
            },
            get charges() {
                return x(X)
            },
            get disabled() {
                return x(Ke)
            },
            get loading() {
                return x(jt)
            },
            onclick: async () => {
                var Gr;
                const Gt = (Gr = oa.captcha) == null ? void 0 : Gr.token;
                if (!Gt)
                    return;
                pa.droppletAndPlop.play();
                const Dr = [...o.values()];
                oe(ie, !0);
                try {
                    await ni.paint(Dr, Gt),
                    await sx(Dr),
                    dt(),
                    Dt.refresh(),
                    Id.shouldReload = !0,
                    await xt()
                } catch (li) {
                    qr.error(`${li.message}`, {
                        duration: 7e3
                    })
                } finally {
                    oe(ie, !1),
                    oa.captcha = void 0
                }
            }
        })
    }
    A(Kr);
    var $r = V(Kr, 2)
      , mr = k($r)
      , gr = k(mr)
      , ai = k(gr);
    fi(),
    A(gr);
    var Tt = V(gr, 2);
    let Ci;
    Tt.__click = [Gk, T];
    var di = k(Tt);
    lg(di, {
        class: "size-5",
        get filled() {
            return x(Ee)
        }
    }),
    A(Tt),
    A(mr),
    A($r),
    A(At),
    A(Xt),
    ps(Xt, Mt => oe(Be, Mt), () => x(Be));
    var Pn = V(Xt, 2);
    vk(Pn, {
        get colorIdx() {
            return x(ct)
        },
        get open() {
            return x(Xe)
        },
        set open(Mt) {
            oe(Xe, Mt, !0)
        }
    }),
    Ge( (Mt, Ke, jt, Gt, Dr, Gr) => {
        fe(Ar, `${Mt ?? ""} `),
        fe(F, `${Ke ?? ""} `),
        Or(q, 1, Vo({
            "btn btn-circle btn-sm": !0,
            "btn-ghost": !x(Ne),
            "btn-primary": x(Ne)
        })),
        zr(K, "data-tip", jt),
        ve = Or(le, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, ve, Gt),
        Or(xe, 1, Vo({
            "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
            "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": x(Qe),
            "gap-1": !x(Qe)
        })),
        fe(ai, `${Dr ?? ""} `),
        Ci = Or(Tt, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, Ci, Gr),
        Tt.disabled = x(W) === 0
    }
    , [ () => Lw(), () => Bw(), () => Ug(), () => ({
        "text-primary": !C()
    }), () => hx(), () => ({
        "btn-primary": x(Ee)
    })]),
    $d("innerHeight", Mt => oe(Je, Mt, !0)),
    H(b, Lt),
    Pr()
}
Wi(["click"]);
function dm(...b) {
    return Fg(Tu(b))
}
var Xk = Ie("<div><!></div>");
function Kk(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15, null)
      , C = Qt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
    var L = Xk();
    er(L, T => ({
        class: T,
        ...C
    }), [ () => dm("flex items-center", l.class)]);
    var O = k(L);
    Ji(O, () => l.children ?? fa),
    A(L),
    ps(L, T => _(T), () => _()),
    H(b, L),
    Pr()
}
var Yk = Ie('<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>')
  , Jk = Ie(" <!>", 1);
function Qk(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15, null)
      , C = Qt(l, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
    var L = Jt()
      , O = zt(L);
    {
        let T = lt( () => dm("border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md", l.cell.isActive && "ring-base-content/40 z-10 ring-2", l.class));
        _n(O, () => H6, (o, $) => {
            $(o, lo({
                get cell() {
                    return l.cell
                },
                get class() {
                    return x(T)
                }
            }, () => C, {
                get ref() {
                    return _()
                },
                set ref(W) {
                    _(W)
                },
                children: (W, ie) => {
                    fi();
                    var pe = Jk()
                      , ye = zt(pe)
                      , X = V(ye);
                    {
                        var Se = we => {
                            var Re = Yk();
                            H(we, Re)
                        }
                        ;
                        Ue(X, we => {
                            l.cell.hasFakeCaret && we(Se)
                        }
                        )
                    }
                    Ge( () => fe(ye, `${l.cell.char ?? ""} `)),
                    H(W, pe)
                }
                ,
                $$slots: {
                    default: !0
                }
            }))
        }
        )
    }
    H(b, L),
    Pr()
}
function eE(b, l) {
    Sr(l, !0);
    let _ = Et(l, "ref", 15, null)
      , C = Et(l, "value", 15, "")
      , L = Qt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
    var O = Jt()
      , T = zt(O);
    {
        let o = lt( () => dm("flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed", l.class));
        _n(T, () => $6, ($, W) => {
            W($, lo({
                get class() {
                    return x(o)
                }
            }, () => L, {
                get ref() {
                    return _()
                },
                set ref(ie) {
                    _(ie)
                },
                get value() {
                    return C()
                },
                set value(ie) {
                    C(ie)
                }
            }))
        }
        )
    }
    H(b, O),
    Pr()
}
var gf = {
    exports: {}
}, Sg;
function tE() {
    return Sg || (Sg = 1,
    (function(b) {
        (function(l) {
            b.exports ? b.exports = l() : window.intlTelInput = l()
        }
        )( () => {
            var l = ( () => {
                var _ = Object.defineProperty
                  , C = Object.getOwnPropertyDescriptor
                  , L = Object.getOwnPropertyNames
                  , O = Object.prototype.hasOwnProperty
                  , T = (Q, te) => {
                    for (var _e in te)
                        _(Q, _e, {
                            get: te[_e],
                            enumerable: !0
                        })
                }
                  , o = (Q, te, _e, ne) => {
                    if (te && typeof te == "object" || typeof te == "function")
                        for (let Pe of L(te))
                            !O.call(Q, Pe) && Pe !== _e && _(Q, Pe, {
                                get: () => te[Pe],
                                enumerable: !(ne = C(te, Pe)) || ne.enumerable
                            });
                    return Q
                }
                  , $ = Q => o(_({}, "__esModule", {
                    value: !0
                }), Q)
                  , W = {};
                T(W, {
                    Iti: () => it,
                    default: () => vt
                });
                var ie = [["af", "93"], ["ax", "358", 1], ["al", "355"], ["dz", "213"], ["as", "1", 5, ["684"]], ["ad", "376"], ["ao", "244"], ["ai", "1", 6, ["264"]], ["ag", "1", 7, ["268"]], ["ar", "54"], ["am", "374"], ["aw", "297"], ["ac", "247"], ["au", "61", 0, null, "0"], ["at", "43"], ["az", "994"], ["bs", "1", 8, ["242"]], ["bh", "973"], ["bd", "880"], ["bb", "1", 9, ["246"]], ["by", "375"], ["be", "32"], ["bz", "501"], ["bj", "229"], ["bm", "1", 10, ["441"]], ["bt", "975"], ["bo", "591"], ["ba", "387"], ["bw", "267"], ["br", "55"], ["io", "246"], ["vg", "1", 11, ["284"]], ["bn", "673"], ["bg", "359"], ["bf", "226"], ["bi", "257"], ["kh", "855"], ["cm", "237"], ["ca", "1", 1, ["204", "226", "236", "249", "250", "263", "289", "306", "343", "354", "365", "367", "368", "382", "387", "403", "416", "418", "428", "431", "437", "438", "450", "584", "468", "474", "506", "514", "519", "548", "579", "581", "584", "587", "604", "613", "639", "647", "672", "683", "705", "709", "742", "753", "778", "780", "782", "807", "819", "825", "867", "873", "879", "902", "905"]], ["cv", "238"], ["bq", "599", 1, ["3", "4", "7"]], ["ky", "1", 12, ["345"]], ["cf", "236"], ["td", "235"], ["cl", "56"], ["cn", "86"], ["cx", "61", 2, ["89164"], "0"], ["cc", "61", 1, ["89162"], "0"], ["co", "57"], ["km", "269"], ["cg", "242"], ["cd", "243"], ["ck", "682"], ["cr", "506"], ["ci", "225"], ["hr", "385"], ["cu", "53"], ["cw", "599", 0], ["cy", "357"], ["cz", "420"], ["dk", "45"], ["dj", "253"], ["dm", "1", 13, ["767"]], ["do", "1", 2, ["809", "829", "849"]], ["ec", "593"], ["eg", "20"], ["sv", "503"], ["gq", "240"], ["er", "291"], ["ee", "372"], ["sz", "268"], ["et", "251"], ["fk", "500"], ["fo", "298"], ["fj", "679"], ["fi", "358", 0], ["fr", "33"], ["gf", "594"], ["pf", "689"], ["ga", "241"], ["gm", "220"], ["ge", "995"], ["de", "49"], ["gh", "233"], ["gi", "350"], ["gr", "30"], ["gl", "299"], ["gd", "1", 14, ["473"]], ["gp", "590", 0], ["gu", "1", 15, ["671"]], ["gt", "502"], ["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"], ["gn", "224"], ["gw", "245"], ["gy", "592"], ["ht", "509"], ["hn", "504"], ["hk", "852"], ["hu", "36"], ["is", "354"], ["in", "91"], ["id", "62"], ["ir", "98"], ["iq", "964"], ["ie", "353"], ["im", "44", 2, ["1624", "74576", "7524", "7924", "7624"], "0"], ["il", "972"], ["it", "39", 0], ["jm", "1", 4, ["876", "658"]], ["jp", "81"], ["je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"], "0"], ["jo", "962"], ["kz", "7", 1, ["33", "7"], "8"], ["ke", "254"], ["ki", "686"], ["xk", "383"], ["kw", "965"], ["kg", "996"], ["la", "856"], ["lv", "371"], ["lb", "961"], ["ls", "266"], ["lr", "231"], ["ly", "218"], ["li", "423"], ["lt", "370"], ["lu", "352"], ["mo", "853"], ["mg", "261"], ["mw", "265"], ["my", "60"], ["mv", "960"], ["ml", "223"], ["mt", "356"], ["mh", "692"], ["mq", "596"], ["mr", "222"], ["mu", "230"], ["yt", "262", 1, ["269", "639"], "0"], ["mx", "52"], ["fm", "691"], ["md", "373"], ["mc", "377"], ["mn", "976"], ["me", "382"], ["ms", "1", 16, ["664"]], ["ma", "212", 0, null, "0"], ["mz", "258"], ["mm", "95"], ["na", "264"], ["nr", "674"], ["np", "977"], ["nl", "31"], ["nc", "687"], ["nz", "64"], ["ni", "505"], ["ne", "227"], ["ng", "234"], ["nu", "683"], ["nf", "672"], ["kp", "850"], ["mk", "389"], ["mp", "1", 17, ["670"]], ["no", "47", 0], ["om", "968"], ["pk", "92"], ["pw", "680"], ["ps", "970"], ["pa", "507"], ["pg", "675"], ["py", "595"], ["pe", "51"], ["ph", "63"], ["pl", "48"], ["pt", "351"], ["pr", "1", 3, ["787", "939"]], ["qa", "974"], ["re", "262", 0, null, "0"], ["ro", "40"], ["ru", "7", 0, null, "8"], ["rw", "250"], ["ws", "685"], ["sm", "378"], ["st", "239"], ["sa", "966"], ["sn", "221"], ["rs", "381"], ["sc", "248"], ["sl", "232"], ["sg", "65"], ["sx", "1", 21, ["721"]], ["sk", "421"], ["si", "386"], ["sb", "677"], ["so", "252"], ["za", "27"], ["kr", "82"], ["ss", "211"], ["es", "34"], ["lk", "94"], ["bl", "590", 1], ["sh", "290"], ["kn", "1", 18, ["869"]], ["lc", "1", 19, ["758"]], ["mf", "590", 2], ["pm", "508"], ["vc", "1", 20, ["784"]], ["sd", "249"], ["sr", "597"], ["sj", "47", 1, ["79"]], ["se", "46"], ["ch", "41"], ["sy", "963"], ["tw", "886"], ["tj", "992"], ["tz", "255"], ["th", "66"], ["tl", "670"], ["tg", "228"], ["tk", "690"], ["to", "676"], ["tt", "1", 22, ["868"]], ["tn", "216"], ["tr", "90"], ["tm", "993"], ["tc", "1", 23, ["649"]], ["tv", "688"], ["ug", "256"], ["ua", "380"], ["ae", "971"], ["gb", "44", 0, null, "0"], ["us", "1", 0], ["uy", "598"], ["vi", "1", 24, ["340"]], ["uz", "998"], ["vu", "678"], ["va", "39", 1, ["06698"]], ["ve", "58"], ["vn", "84"], ["wf", "681"], ["eh", "212", 1, ["5288", "5289"], "0"], ["ye", "967"], ["zm", "260"], ["zw", "263"]]
                  , pe = [];
                for (let Q = 0; Q < ie.length; Q++) {
                    const te = ie[Q];
                    pe[Q] = {
                        name: "",
                        iso2: te[0],
                        dialCode: te[1],
                        priority: te[2] || 0,
                        areaCodes: te[3] || null,
                        nodeById: {},
                        nationalPrefix: te[4] || null
                    }
                }
                var ye = pe
                  , X = {
                    ad: "Andorra",
                    ae: "United Arab Emirates",
                    af: "Afghanistan",
                    ag: "Antigua & Barbuda",
                    ai: "Anguilla",
                    al: "Albania",
                    am: "Armenia",
                    ao: "Angola",
                    ar: "Argentina",
                    as: "American Samoa",
                    at: "Austria",
                    au: "Australia",
                    aw: "Aruba",
                    ax: "Åland Islands",
                    az: "Azerbaijan",
                    ba: "Bosnia & Herzegovina",
                    bb: "Barbados",
                    bd: "Bangladesh",
                    be: "Belgium",
                    bf: "Burkina Faso",
                    bg: "Bulgaria",
                    bh: "Bahrain",
                    bi: "Burundi",
                    bj: "Benin",
                    bl: "St. Barthélemy",
                    bm: "Bermuda",
                    bn: "Brunei",
                    bo: "Bolivia",
                    bq: "Caribbean Netherlands",
                    br: "Brazil",
                    bs: "Bahamas",
                    bt: "Bhutan",
                    bw: "Botswana",
                    by: "Belarus",
                    bz: "Belize",
                    ca: "Canada",
                    cc: "Cocos (Keeling) Islands",
                    cd: "Congo - Kinshasa",
                    cf: "Central African Republic",
                    cg: "Congo - Brazzaville",
                    ch: "Switzerland",
                    ci: "Côte d’Ivoire",
                    ck: "Cook Islands",
                    cl: "Chile",
                    cm: "Cameroon",
                    cn: "China",
                    co: "Colombia",
                    cr: "Costa Rica",
                    cu: "Cuba",
                    cv: "Cape Verde",
                    cw: "Curaçao",
                    cx: "Christmas Island",
                    cy: "Cyprus",
                    cz: "Czechia",
                    de: "Germany",
                    dj: "Djibouti",
                    dk: "Denmark",
                    dm: "Dominica",
                    do: "Dominican Republic",
                    dz: "Algeria",
                    ec: "Ecuador",
                    ee: "Estonia",
                    eg: "Egypt",
                    eh: "Western Sahara",
                    er: "Eritrea",
                    es: "Spain",
                    et: "Ethiopia",
                    fi: "Finland",
                    fj: "Fiji",
                    fk: "Falkland Islands",
                    fm: "Micronesia",
                    fo: "Faroe Islands",
                    fr: "France",
                    ga: "Gabon",
                    gb: "United Kingdom",
                    gd: "Grenada",
                    ge: "Georgia",
                    gf: "French Guiana",
                    gg: "Guernsey",
                    gh: "Ghana",
                    gi: "Gibraltar",
                    gl: "Greenland",
                    gm: "Gambia",
                    gn: "Guinea",
                    gp: "Guadeloupe",
                    gq: "Equatorial Guinea",
                    gr: "Greece",
                    gt: "Guatemala",
                    gu: "Guam",
                    gw: "Guinea-Bissau",
                    gy: "Guyana",
                    hk: "Hong Kong SAR China",
                    hn: "Honduras",
                    hr: "Croatia",
                    ht: "Haiti",
                    hu: "Hungary",
                    id: "Indonesia",
                    ie: "Ireland",
                    il: "Israel",
                    im: "Isle of Man",
                    in: "India",
                    io: "British Indian Ocean Territory",
                    iq: "Iraq",
                    ir: "Iran",
                    is: "Iceland",
                    it: "Italy",
                    je: "Jersey",
                    jm: "Jamaica",
                    jo: "Jordan",
                    jp: "Japan",
                    ke: "Kenya",
                    kg: "Kyrgyzstan",
                    kh: "Cambodia",
                    ki: "Kiribati",
                    km: "Comoros",
                    kn: "St. Kitts & Nevis",
                    kp: "North Korea",
                    kr: "South Korea",
                    kw: "Kuwait",
                    ky: "Cayman Islands",
                    kz: "Kazakhstan",
                    la: "Laos",
                    lb: "Lebanon",
                    lc: "St. Lucia",
                    li: "Liechtenstein",
                    lk: "Sri Lanka",
                    lr: "Liberia",
                    ls: "Lesotho",
                    lt: "Lithuania",
                    lu: "Luxembourg",
                    lv: "Latvia",
                    ly: "Libya",
                    ma: "Morocco",
                    mc: "Monaco",
                    md: "Moldova",
                    me: "Montenegro",
                    mf: "St. Martin",
                    mg: "Madagascar",
                    mh: "Marshall Islands",
                    mk: "North Macedonia",
                    ml: "Mali",
                    mm: "Myanmar (Burma)",
                    mn: "Mongolia",
                    mo: "Macao SAR China",
                    mp: "Northern Mariana Islands",
                    mq: "Martinique",
                    mr: "Mauritania",
                    ms: "Montserrat",
                    mt: "Malta",
                    mu: "Mauritius",
                    mv: "Maldives",
                    mw: "Malawi",
                    mx: "Mexico",
                    my: "Malaysia",
                    mz: "Mozambique",
                    na: "Namibia",
                    nc: "New Caledonia",
                    ne: "Niger",
                    nf: "Norfolk Island",
                    ng: "Nigeria",
                    ni: "Nicaragua",
                    nl: "Netherlands",
                    no: "Norway",
                    np: "Nepal",
                    nr: "Nauru",
                    nu: "Niue",
                    nz: "New Zealand",
                    om: "Oman",
                    pa: "Panama",
                    pe: "Peru",
                    pf: "French Polynesia",
                    pg: "Papua New Guinea",
                    ph: "Philippines",
                    pk: "Pakistan",
                    pl: "Poland",
                    pm: "St. Pierre & Miquelon",
                    pr: "Puerto Rico",
                    ps: "Palestinian Territories",
                    pt: "Portugal",
                    pw: "Palau",
                    py: "Paraguay",
                    qa: "Qatar",
                    re: "Réunion",
                    ro: "Romania",
                    rs: "Serbia",
                    ru: "Russia",
                    rw: "Rwanda",
                    sa: "Saudi Arabia",
                    sb: "Solomon Islands",
                    sc: "Seychelles",
                    sd: "Sudan",
                    se: "Sweden",
                    sg: "Singapore",
                    sh: "St. Helena",
                    si: "Slovenia",
                    sj: "Svalbard & Jan Mayen",
                    sk: "Slovakia",
                    sl: "Sierra Leone",
                    sm: "San Marino",
                    sn: "Senegal",
                    so: "Somalia",
                    sr: "Suriname",
                    ss: "South Sudan",
                    st: "São Tomé & Príncipe",
                    sv: "El Salvador",
                    sx: "Sint Maarten",
                    sy: "Syria",
                    sz: "Eswatini",
                    tc: "Turks & Caicos Islands",
                    td: "Chad",
                    tg: "Togo",
                    th: "Thailand",
                    tj: "Tajikistan",
                    tk: "Tokelau",
                    tl: "Timor-Leste",
                    tm: "Turkmenistan",
                    tn: "Tunisia",
                    to: "Tonga",
                    tr: "Turkey",
                    tt: "Trinidad & Tobago",
                    tv: "Tuvalu",
                    tw: "Taiwan",
                    tz: "Tanzania",
                    ua: "Ukraine",
                    ug: "Uganda",
                    us: "United States",
                    uy: "Uruguay",
                    uz: "Uzbekistan",
                    va: "Vatican City",
                    vc: "St. Vincent & Grenadines",
                    ve: "Venezuela",
                    vg: "British Virgin Islands",
                    vi: "U.S. Virgin Islands",
                    vn: "Vietnam",
                    vu: "Vanuatu",
                    wf: "Wallis & Futuna",
                    ws: "Samoa",
                    ye: "Yemen",
                    yt: "Mayotte",
                    za: "South Africa",
                    zm: "Zambia",
                    zw: "Zimbabwe"
                }
                  , Se = X
                  , we = {
                    selectedCountryAriaLabel: "Selected country",
                    noCountrySelected: "No country selected",
                    countryListAriaLabel: "List of countries",
                    searchPlaceholder: "Search",
                    zeroSearchResults: "No results found",
                    oneSearchResult: "1 result found",
                    multipleSearchResults: "${count} results found",
                    ac: "Ascension Island",
                    xk: "Kosovo"
                }
                  , Re = we
                  , ke = {
                    ...Se,
                    ...Re
                }
                  , Oe = ke;
                for (let Q = 0; Q < ye.length; Q++)
                    ye[Q].name = Oe[ye[Q].iso2];
                var Ee = 0
                  , Ne = {
                    allowDropdown: !0,
                    autoPlaceholder: "polite",
                    containerClass: "",
                    countryOrder: null,
                    countrySearch: !0,
                    customPlaceholder: null,
                    dropdownContainer: null,
                    excludeCountries: [],
                    fixDropdownWidth: !0,
                    formatAsYouType: !0,
                    formatOnDisplay: !0,
                    geoIpLookup: null,
                    hiddenInput: null,
                    i18n: {},
                    initialCountry: "",
                    loadUtils: null,
                    nationalMode: !0,
                    onlyCountries: [],
                    placeholderNumberType: "MOBILE",
                    showFlags: !0,
                    separateDialCode: !1,
                    strictMode: !1,
                    useFullscreenPopup: typeof navigator < "u" && typeof window < "u" ? /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 500 : !1,
                    validationNumberTypes: ["MOBILE"]
                }
                  , ft = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"]
                  , ht = Q => Q.replace(/\D/g, "")
                  , Xe = (Q="") => Q.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase()
                  , ct = Q => {
                    const te = ht(Q);
                    if (te.charAt(0) === "1") {
                        const _e = te.substr(1, 3);
                        return ft.includes(_e)
                    }
                    return !1
                }
                  , Je = (Q, te, _e, ne) => {
                    if (_e === 0 && !ne)
                        return 0;
                    let Pe = 0;
                    for (let Me = 0; Me < te.length; Me++) {
                        if (/[+0-9]/.test(te[Me]) && Pe++,
                        Pe === Q && !ne)
                            return Me + 1;
                        if (ne && Pe === Q + 1)
                            return Me
                    }
                    return te.length
                }
                  , Be = (Q, te, _e) => {
                    const ne = document.createElement(Q);
                    return te && Object.entries(te).forEach( ([Pe,Me]) => ne.setAttribute(Pe, Me)),
                    _e && _e.appendChild(ne),
                    ne
                }
                  , st = (Q, ...te) => {
                    const {instances: _e} = Ae;
                    Object.values(_e).forEach(ne => ne[Q](...te))
                }
                  , it = class {
                    constructor(Q, te={}) {
                        this.id = Ee++,
                        this.telInput = Q,
                        this.highlightedItem = null,
                        this.options = Object.assign({}, Ne, te),
                        this.hadInitialPlaceholder = !!Q.getAttribute("placeholder")
                    }
                    _init() {
                        this.options.useFullscreenPopup && (this.options.fixDropdownWidth = !1),
                        this.options.onlyCountries.length === 1 && (this.options.initialCountry = this.options.onlyCountries[0]),
                        this.options.separateDialCode && (this.options.nationalMode = !1),
                        this.options.allowDropdown && !this.options.showFlags && !this.options.separateDialCode && (this.options.nationalMode = !1),
                        this.options.useFullscreenPopup && !this.options.dropdownContainer && (this.options.dropdownContainer = document.body),
                        this.isAndroid = typeof navigator < "u" ? /Android/i.test(navigator.userAgent) : !1,
                        this.isRTL = !!this.telInput.closest("[dir=rtl]");
                        const Q = this.options.allowDropdown || this.options.separateDialCode;
                        this.showSelectedCountryOnLeft = this.isRTL ? !Q : Q,
                        this.options.separateDialCode && (this.isRTL ? this.originalPaddingRight = this.telInput.style.paddingRight : this.originalPaddingLeft = this.telInput.style.paddingLeft),
                        this.options.i18n = {
                            ...Oe,
                            ...this.options.i18n
                        };
                        const te = new Promise( (ne, Pe) => {
                            this.resolveAutoCountryPromise = ne,
                            this.rejectAutoCountryPromise = Pe
                        }
                        )
                          , _e = new Promise( (ne, Pe) => {
                            this.resolveUtilsScriptPromise = ne,
                            this.rejectUtilsScriptPromise = Pe
                        }
                        );
                        this.promise = Promise.all([te, _e]),
                        this.selectedCountryData = {},
                        this._processCountryData(),
                        this._generateMarkup(),
                        this._setInitialState(),
                        this._initListeners(),
                        this._initRequests()
                    }
                    _processCountryData() {
                        this._processAllCountries(),
                        this._processDialCodes(),
                        this._translateCountryNames(),
                        this._sortCountries()
                    }
                    _sortCountries() {
                        this.options.countryOrder && (this.options.countryOrder = this.options.countryOrder.map(Q => Q.toLowerCase())),
                        this.countries.sort( (Q, te) => {
                            const {countryOrder: _e} = this.options;
                            if (_e) {
                                const ne = _e.indexOf(Q.iso2)
                                  , Pe = _e.indexOf(te.iso2)
                                  , Me = ne > -1
                                  , at = Pe > -1;
                                if (Me || at)
                                    return Me && at ? ne - Pe : Me ? -1 : 1
                            }
                            return Q.name.localeCompare(te.name)
                        }
                        )
                    }
                    _addToDialCodeMap(Q, te, _e) {
                        te.length > this.dialCodeMaxLen && (this.dialCodeMaxLen = te.length),
                        this.dialCodeToIso2Map.hasOwnProperty(te) || (this.dialCodeToIso2Map[te] = []);
                        for (let Pe = 0; Pe < this.dialCodeToIso2Map[te].length; Pe++)
                            if (this.dialCodeToIso2Map[te][Pe] === Q)
                                return;
                        const ne = _e !== void 0 ? _e : this.dialCodeToIso2Map[te].length;
                        this.dialCodeToIso2Map[te][ne] = Q
                    }
                    _processAllCountries() {
                        const {onlyCountries: Q, excludeCountries: te} = this.options;
                        if (Q.length) {
                            const _e = Q.map(ne => ne.toLowerCase());
                            this.countries = ye.filter(ne => _e.includes(ne.iso2))
                        } else if (te.length) {
                            const _e = te.map(ne => ne.toLowerCase());
                            this.countries = ye.filter(ne => !_e.includes(ne.iso2))
                        } else
                            this.countries = ye
                    }
                    _translateCountryNames() {
                        for (let Q = 0; Q < this.countries.length; Q++) {
                            const te = this.countries[Q].iso2.toLowerCase();
                            this.options.i18n.hasOwnProperty(te) && (this.countries[Q].name = this.options.i18n[te])
                        }
                    }
                    _processDialCodes() {
                        this.dialCodes = {},
                        this.dialCodeMaxLen = 0,
                        this.dialCodeToIso2Map = {};
                        for (let Q = 0; Q < this.countries.length; Q++) {
                            const te = this.countries[Q];
                            this.dialCodes[te.dialCode] || (this.dialCodes[te.dialCode] = !0),
                            this._addToDialCodeMap(te.iso2, te.dialCode, te.priority)
                        }
                        for (let Q = 0; Q < this.countries.length; Q++) {
                            const te = this.countries[Q];
                            if (te.areaCodes) {
                                const _e = this.dialCodeToIso2Map[te.dialCode][0];
                                for (let ne = 0; ne < te.areaCodes.length; ne++) {
                                    const Pe = te.areaCodes[ne];
                                    for (let Me = 1; Me < Pe.length; Me++) {
                                        const at = Pe.substr(0, Me)
                                          , We = te.dialCode + at;
                                        this._addToDialCodeMap(_e, We),
                                        this._addToDialCodeMap(te.iso2, We)
                                    }
                                    this._addToDialCodeMap(te.iso2, te.dialCode + Pe)
                                }
                            }
                        }
                    }
                    _generateMarkup() {
                        var pt, It, ut;
                        this.telInput.classList.add("iti__tel-input"),
                        !this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete")) && this.telInput.setAttribute("autocomplete", "off");
                        const {allowDropdown: Q, separateDialCode: te, showFlags: _e, containerClass: ne, hiddenInput: Pe, dropdownContainer: Me, fixDropdownWidth: at, useFullscreenPopup: We, countrySearch: Ct, i18n: _t} = this.options;
                        let xt = "iti";
                        Q && (xt += " iti--allow-dropdown"),
                        _e && (xt += " iti--show-flags"),
                        ne && (xt += ` ${ne}`),
                        We || (xt += " iti--inline-dropdown");
                        const tt = Be("div", {
                            class: xt
                        });
                        if ((pt = this.telInput.parentNode) == null || pt.insertBefore(tt, this.telInput),
                        Q || _e || te) {
                            this.countryContainer = Be("div", {
                                class: "iti__country-container"
                            }, tt),
                            this.showSelectedCountryOnLeft ? this.countryContainer.style.left = "0px" : this.countryContainer.style.right = "0px",
                            Q ? (this.selectedCountry = Be("button", {
                                type: "button",
                                class: "iti__selected-country",
                                "aria-expanded": "false",
                                "aria-label": this.options.i18n.selectedCountryAriaLabel,
                                "aria-haspopup": "true",
                                "aria-controls": `iti-${this.id}__dropdown-content`,
                                role: "combobox"
                            }, this.countryContainer),
                            this.telInput.disabled && this.selectedCountry.setAttribute("disabled", "true")) : this.selectedCountry = Be("div", {
                                class: "iti__selected-country"
                            }, this.countryContainer);
                            const bt = Be("div", {
                                class: "iti__selected-country-primary"
                            }, this.selectedCountry);
                            if (this.selectedCountryInner = Be("div", {
                                class: "iti__flag"
                            }, bt),
                            this.selectedCountryA11yText = Be("span", {
                                class: "iti__a11y-text"
                            }, this.selectedCountryInner),
                            Q && (this.dropdownArrow = Be("div", {
                                class: "iti__arrow",
                                "aria-hidden": "true"
                            }, bt)),
                            te && (this.selectedDialCode = Be("div", {
                                class: "iti__selected-dial-code"
                            }, this.selectedCountry)),
                            Q) {
                                const wt = at ? "" : "iti--flexible-dropdown-width";
                                if (this.dropdownContent = Be("div", {
                                    id: `iti-${this.id}__dropdown-content`,
                                    class: `iti__dropdown-content iti__hide ${wt}`
                                }),
                                Ct && (this.searchInput = Be("input", {
                                    type: "text",
                                    class: "iti__search-input",
                                    placeholder: _t.searchPlaceholder,
                                    role: "combobox",
                                    "aria-expanded": "true",
                                    "aria-label": _t.searchPlaceholder,
                                    "aria-controls": `iti-${this.id}__country-listbox`,
                                    "aria-autocomplete": "list",
                                    autocomplete: "off"
                                }, this.dropdownContent),
                                this.searchResultsA11yText = Be("span", {
                                    class: "iti__a11y-text"
                                }, this.dropdownContent)),
                                this.countryList = Be("ul", {
                                    class: "iti__country-list",
                                    id: `iti-${this.id}__country-listbox`,
                                    role: "listbox",
                                    "aria-label": _t.countryListAriaLabel
                                }, this.dropdownContent),
                                this._appendListItems(),
                                Ct && this._updateSearchResultsText(),
                                Me) {
                                    let dt = "iti iti--container";
                                    We ? dt += " iti--fullscreen-popup" : dt += " iti--inline-dropdown",
                                    this.dropdown = Be("div", {
                                        class: dt
                                    }),
                                    this.dropdown.appendChild(this.dropdownContent)
                                } else
                                    this.countryContainer.appendChild(this.dropdownContent)
                            }
                        }
                        if (tt.appendChild(this.telInput),
                        this._updateInputPadding(),
                        Pe) {
                            const bt = this.telInput.getAttribute("name") || ""
                              , wt = Pe(bt);
                            if (wt.phone) {
                                const dt = (It = this.telInput.form) == null ? void 0 : It.querySelector(`input[name="${wt.phone}"]`);
                                dt ? this.hiddenInput = dt : (this.hiddenInput = Be("input", {
                                    type: "hidden",
                                    name: wt.phone
                                }),
                                tt.appendChild(this.hiddenInput))
                            }
                            if (wt.country) {
                                const dt = (ut = this.telInput.form) == null ? void 0 : ut.querySelector(`input[name="${wt.country}"]`);
                                dt ? this.hiddenInputCountry = dt : (this.hiddenInputCountry = Be("input", {
                                    type: "hidden",
                                    name: wt.country
                                }),
                                tt.appendChild(this.hiddenInputCountry))
                            }
                        }
                    }
                    _appendListItems() {
                        for (let Q = 0; Q < this.countries.length; Q++) {
                            const te = this.countries[Q]
                              , _e = Q === 0 ? "iti__highlight" : ""
                              , ne = Be("li", {
                                id: `iti-${this.id}__item-${te.iso2}`,
                                class: `iti__country ${_e}`,
                                tabindex: "-1",
                                role: "option",
                                "data-dial-code": te.dialCode,
                                "data-country-code": te.iso2,
                                "aria-selected": "false"
                            }, this.countryList);
                            te.nodeById[this.id] = ne;
                            let Pe = "";
                            this.options.showFlags && (Pe += `<div class='iti__flag iti__${te.iso2}'></div>`),
                            Pe += `<span class='iti__country-name'>${te.name}</span>`,
                            Pe += `<span class='iti__dial-code'>+${te.dialCode}</span>`,
                            ne.insertAdjacentHTML("beforeend", Pe)
                        }
                    }
                    _setInitialState(Q=!1) {
                        const te = this.telInput.getAttribute("value")
                          , _e = this.telInput.value
                          , Pe = te && te.charAt(0) === "+" && (!_e || _e.charAt(0) !== "+") ? te : _e
                          , Me = this._getDialCode(Pe)
                          , at = ct(Pe)
                          , {initialCountry: We, geoIpLookup: Ct} = this.options
                          , _t = We === "auto" && Ct;
                        if (Me && !at)
                            this._updateCountryFromNumber(Pe);
                        else if (!_t || Q) {
                            const xt = We ? We.toLowerCase() : "";
                            xt && this._getCountryData(xt, !0) ? this._setCountry(xt) : Me && at ? this._setCountry("us") : this._setCountry()
                        }
                        Pe && this._updateValFromNumber(Pe)
                    }
                    _initListeners() {
                        this._initTelInputListeners(),
                        this.options.allowDropdown && this._initDropdownListeners(),
                        (this.hiddenInput || this.hiddenInputCountry) && this.telInput.form && this._initHiddenInputListener()
                    }
                    _initHiddenInputListener() {
                        var Q;
                        this._handleHiddenInputSubmit = () => {
                            this.hiddenInput && (this.hiddenInput.value = this.getNumber()),
                            this.hiddenInputCountry && (this.hiddenInputCountry.value = this.getSelectedCountryData().iso2 || "")
                        }
                        ,
                        (Q = this.telInput.form) == null || Q.addEventListener("submit", this._handleHiddenInputSubmit)
                    }
                    _initDropdownListeners() {
                        this._handleLabelClick = te => {
                            this.dropdownContent.classList.contains("iti__hide") ? this.telInput.focus() : te.preventDefault()
                        }
                        ;
                        const Q = this.telInput.closest("label");
                        Q && Q.addEventListener("click", this._handleLabelClick),
                        this._handleClickSelectedCountry = () => {
                            this.dropdownContent.classList.contains("iti__hide") && !this.telInput.disabled && !this.telInput.readOnly && this._openDropdown()
                        }
                        ,
                        this.selectedCountry.addEventListener("click", this._handleClickSelectedCountry),
                        this._handleCountryContainerKeydown = te => {
                            this.dropdownContent.classList.contains("iti__hide") && ["ArrowUp", "ArrowDown", " ", "Enter"].includes(te.key) && (te.preventDefault(),
                            te.stopPropagation(),
                            this._openDropdown()),
                            te.key === "Tab" && this._closeDropdown()
                        }
                        ,
                        this.countryContainer.addEventListener("keydown", this._handleCountryContainerKeydown)
                    }
                    _initRequests() {
                        let {loadUtils: Q, initialCountry: te, geoIpLookup: _e} = this.options;
                        Q && !Ae.utils ? (this._handlePageLoad = () => {
                            var Pe;
                            window.removeEventListener("load", this._handlePageLoad),
                            (Pe = Ae.attachUtils(Q)) == null || Pe.catch( () => {}
                            )
                        }
                        ,
                        Ae.documentReady() ? this._handlePageLoad() : window.addEventListener("load", this._handlePageLoad)) : this.resolveUtilsScriptPromise(),
                        te === "auto" && _e && !this.selectedCountryData.iso2 ? this._loadAutoCountry() : this.resolveAutoCountryPromise()
                    }
                    _loadAutoCountry() {
                        Ae.autoCountry ? this.handleAutoCountry() : Ae.startedLoadingAutoCountry || (Ae.startedLoadingAutoCountry = !0,
                        typeof this.options.geoIpLookup == "function" && this.options.geoIpLookup( (Q="") => {
                            const te = Q.toLowerCase();
                            te && this._getCountryData(te, !0) ? (Ae.autoCountry = te,
                            setTimeout( () => st("handleAutoCountry"))) : (this._setInitialState(!0),
                            st("rejectAutoCountryPromise"))
                        }
                        , () => {
                            this._setInitialState(!0),
                            st("rejectAutoCountryPromise")
                        }
                        ))
                    }
                    _openDropdownWithPlus() {
                        this._openDropdown(),
                        this.searchInput.value = "+",
                        this._filterCountries("", !0)
                    }
                    _initTelInputListeners() {
                        const {strictMode: Q, formatAsYouType: te, separateDialCode: _e, formatOnDisplay: ne, allowDropdown: Pe, countrySearch: Me} = this.options;
                        let at = !1;
                        new RegExp("\\p{L}","u").test(this.telInput.value) && (at = !0),
                        this._handleInputEvent = We => {
                            if (this.isAndroid && (We == null ? void 0 : We.data) === "+" && _e && Pe && Me) {
                                const tt = this.telInput.selectionStart || 0
                                  , pt = this.telInput.value.substring(0, tt - 1)
                                  , It = this.telInput.value.substring(tt);
                                this.telInput.value = pt + It,
                                this._openDropdownWithPlus();
                                return
                            }
                            this._updateCountryFromNumber(this.telInput.value) && this._triggerCountryChange();
                            const Ct = (We == null ? void 0 : We.data) && /[^+0-9]/.test(We.data)
                              , _t = (We == null ? void 0 : We.inputType) === "insertFromPaste" && this.telInput.value;
                            Ct || _t && !Q ? at = !0 : /[^+0-9]/.test(this.telInput.value) || (at = !1);
                            const xt = (We == null ? void 0 : We.detail) && We.detail.isSetNumber && !ne;
                            if (te && !at && !xt) {
                                const tt = this.telInput.selectionStart || 0
                                  , It = this.telInput.value.substring(0, tt).replace(/[^+0-9]/g, "").length
                                  , ut = (We == null ? void 0 : We.inputType) === "deleteContentForward"
                                  , bt = this._formatNumberAsYouType()
                                  , wt = Je(It, bt, tt, ut);
                                this.telInput.value = bt,
                                this.telInput.setSelectionRange(wt, wt)
                            }
                        }
                        ,
                        this.telInput.addEventListener("input", this._handleInputEvent),
                        (Q || _e) && (this._handleKeydownEvent = We => {
                            if (We.key && We.key.length === 1 && !We.altKey && !We.ctrlKey && !We.metaKey) {
                                if (_e && Pe && Me && We.key === "+") {
                                    We.preventDefault(),
                                    this._openDropdownWithPlus();
                                    return
                                }
                                if (Q) {
                                    const Ct = this.telInput.value
                                      , _t = Ct.charAt(0) === "+"
                                      , xt = !_t && this.telInput.selectionStart === 0 && We.key === "+"
                                      , tt = /^[0-9]$/.test(We.key)
                                      , pt = _e ? tt : xt || tt
                                      , It = Ct.slice(0, this.telInput.selectionStart) + We.key + Ct.slice(this.telInput.selectionEnd)
                                      , ut = this._getFullNumber(It)
                                      , bt = Ae.utils.getCoreNumber(ut, this.selectedCountryData.iso2)
                                      , wt = this.maxCoreNumberLength && bt.length > this.maxCoreNumberLength;
                                    let dt = !1;
                                    if (_t) {
                                        const Lt = this.selectedCountryData.iso2;
                                        dt = this._getCountryFromNumber(ut) !== Lt
                                    }
                                    (!pt || wt && !dt && !xt) && We.preventDefault()
                                }
                            }
                        }
                        ,
                        this.telInput.addEventListener("keydown", this._handleKeydownEvent))
                    }
                    _cap(Q) {
                        const te = parseInt(this.telInput.getAttribute("maxlength") || "", 10);
                        return te && Q.length > te ? Q.substr(0, te) : Q
                    }
                    _trigger(Q, te={}) {
                        const _e = new CustomEvent(Q,{
                            bubbles: !0,
                            cancelable: !0,
                            detail: te
                        });
                        this.telInput.dispatchEvent(_e)
                    }
                    _openDropdown() {
                        const {fixDropdownWidth: Q, countrySearch: te} = this.options;
                        if (Q && (this.dropdownContent.style.width = `${this.telInput.offsetWidth}px`),
                        this.dropdownContent.classList.remove("iti__hide"),
                        this.selectedCountry.setAttribute("aria-expanded", "true"),
                        this._setDropdownPosition(),
                        te) {
                            const _e = this.countryList.firstElementChild;
                            _e && (this._highlightListItem(_e, !1),
                            this.countryList.scrollTop = 0),
                            this.searchInput.focus()
                        }
                        this._bindDropdownListeners(),
                        this.dropdownArrow.classList.add("iti__arrow--up"),
                        this._trigger("open:countrydropdown")
                    }
                    _setDropdownPosition() {
                        if (this.options.dropdownContainer && this.options.dropdownContainer.appendChild(this.dropdown),
                        !this.options.useFullscreenPopup) {
                            const Q = this.telInput.getBoundingClientRect()
                              , te = this.telInput.offsetHeight;
                            this.options.dropdownContainer && (this.dropdown.style.top = `${Q.top + te}px`,
                            this.dropdown.style.left = `${Q.left}px`,
                            this._handleWindowScroll = () => this._closeDropdown(),
                            window.addEventListener("scroll", this._handleWindowScroll))
                        }
                    }
                    _bindDropdownListeners() {
                        this._handleMouseoverCountryList = ne => {
                            var Me;
                            const Pe = (Me = ne.target) == null ? void 0 : Me.closest(".iti__country");
                            Pe && this._highlightListItem(Pe, !1)
                        }
                        ,
                        this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList),
                        this._handleClickCountryList = ne => {
                            var Me;
                            const Pe = (Me = ne.target) == null ? void 0 : Me.closest(".iti__country");
                            Pe && this._selectListItem(Pe)
                        }
                        ,
                        this.countryList.addEventListener("click", this._handleClickCountryList);
                        let Q = !0;
                        this._handleClickOffToClose = () => {
                            Q || this._closeDropdown(),
                            Q = !1
                        }
                        ,
                        document.documentElement.addEventListener("click", this._handleClickOffToClose);
                        let te = ""
                          , _e = null;
                        if (this._handleKeydownOnDropdown = ne => {
                            ["ArrowUp", "ArrowDown", "Enter", "Escape"].includes(ne.key) && (ne.preventDefault(),
                            ne.stopPropagation(),
                            ne.key === "ArrowUp" || ne.key === "ArrowDown" ? this._handleUpDownKey(ne.key) : ne.key === "Enter" ? this._handleEnterKey() : ne.key === "Escape" && this._closeDropdown()),
                            !this.options.countrySearch && /^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(ne.key) && (ne.stopPropagation(),
                            _e && clearTimeout(_e),
                            te += ne.key.toLowerCase(),
                            this._searchForCountry(te),
                            _e = setTimeout( () => {
                                te = ""
                            }
                            , 1e3))
                        }
                        ,
                        document.addEventListener("keydown", this._handleKeydownOnDropdown),
                        this.options.countrySearch) {
                            const ne = () => {
                                const Me = this.searchInput.value.trim();
                                Me ? this._filterCountries(Me) : this._filterCountries("", !0)
                            }
                            ;
                            let Pe = null;
                            this._handleSearchChange = () => {
                                Pe && clearTimeout(Pe),
                                Pe = setTimeout( () => {
                                    ne(),
                                    Pe = null
                                }
                                , 100)
                            }
                            ,
                            this.searchInput.addEventListener("input", this._handleSearchChange),
                            this.searchInput.addEventListener("click", Me => Me.stopPropagation())
                        }
                    }
                    _searchForCountry(Q) {
                        for (let te = 0; te < this.countries.length; te++) {
                            const _e = this.countries[te];
                            if (_e.name.substr(0, Q.length).toLowerCase() === Q) {
                                const Pe = _e.nodeById[this.id];
                                this._highlightListItem(Pe, !1),
                                this._scrollTo(Pe);
                                break
                            }
                        }
                    }
                    _filterCountries(Q, te=!1) {
                        let _e = !0;
                        this.countryList.innerHTML = "";
                        const ne = Xe(Q);
                        for (let Pe = 0; Pe < this.countries.length; Pe++) {
                            const Me = this.countries[Pe]
                              , at = Xe(Me.name)
                              , We = Me.name.split(/[^a-zA-ZÀ-ÿа-яА-Я]/).map(_t => _t[0]).join("").toLowerCase()
                              , Ct = `+${Me.dialCode}`;
                            if (te || at.includes(ne) || Ct.includes(ne) || Me.iso2.includes(ne) || We.includes(ne)) {
                                const _t = Me.nodeById[this.id];
                                _t && this.countryList.appendChild(_t),
                                _e && (this._highlightListItem(_t, !1),
                                _e = !1)
                            }
                        }
                        _e && this._highlightListItem(null, !1),
                        this.countryList.scrollTop = 0,
                        this._updateSearchResultsText()
                    }
                    _updateSearchResultsText() {
                        const {i18n: Q} = this.options
                          , te = this.countryList.childElementCount;
                        let _e;
                        te === 0 ? _e = Q.zeroSearchResults : te === 1 ? _e = Q.oneSearchResult : _e = Q.multipleSearchResults.replace("${count}", te.toString()),
                        this.searchResultsA11yText.textContent = _e
                    }
                    _handleUpDownKey(Q) {
                        var _e, ne;
                        let te = Q === "ArrowUp" ? (_e = this.highlightedItem) == null ? void 0 : _e.previousElementSibling : (ne = this.highlightedItem) == null ? void 0 : ne.nextElementSibling;
                        !te && this.countryList.childElementCount > 1 && (te = Q === "ArrowUp" ? this.countryList.lastElementChild : this.countryList.firstElementChild),
                        te && (this._scrollTo(te),
                        this._highlightListItem(te, !1))
                    }
                    _handleEnterKey() {
                        this.highlightedItem && this._selectListItem(this.highlightedItem)
                    }
                    _updateValFromNumber(Q) {
                        let te = Q;
                        if (this.options.formatOnDisplay && Ae.utils && this.selectedCountryData) {
                            const _e = this.options.nationalMode || te.charAt(0) !== "+" && !this.options.separateDialCode
                              , {NATIONAL: ne, INTERNATIONAL: Pe} = Ae.utils.numberFormat
                              , Me = _e ? ne : Pe;
                            te = Ae.utils.formatNumber(te, this.selectedCountryData.iso2, Me)
                        }
                        te = this._beforeSetNumber(te),
                        this.telInput.value = te
                    }
                    _updateCountryFromNumber(Q) {
                        const te = this._getCountryFromNumber(Q);
                        return te !== null ? this._setCountry(te) : !1
                    }
                    _ensureHasDialCode(Q) {
                        const {dialCode: te, nationalPrefix: _e} = this.selectedCountryData;
                        if (Q.charAt(0) === "+" || !te)
                            return Q;
                        const Me = _e && Q.charAt(0) === _e && !this.options.separateDialCode ? Q.substring(1) : Q;
                        return `+${te}${Me}`
                    }
                    _getCountryFromNumber(Q) {
                        const te = Q.indexOf("+");
                        let _e = te ? Q.substring(te) : Q;
                        const ne = this.selectedCountryData.iso2
                          , Pe = this.selectedCountryData.dialCode;
                        _e = this._ensureHasDialCode(_e);
                        const Me = this._getDialCode(_e, !0)
                          , at = ht(_e);
                        if (Me) {
                            const We = ht(Me)
                              , Ct = this.dialCodeToIso2Map[We];
                            if (!ne && this.defaultCountry && Ct.includes(this.defaultCountry))
                                return this.defaultCountry;
                            const _t = ne && Ct.includes(ne) && (at.length === We.length || !this.selectedCountryData.areaCodes);
                            if (!(Pe === "1" && ct(at)) && !_t) {
                                for (let tt = 0; tt < Ct.length; tt++)
                                    if (Ct[tt])
                                        return Ct[tt]
                            }
                        } else {
                            if (_e.charAt(0) === "+" && at.length)
                                return "";
                            if ((!_e || _e === "+") && !this.selectedCountryData.iso2)
                                return this.defaultCountry
                        }
                        return null
                    }
                    _highlightListItem(Q, te) {
                        const _e = this.highlightedItem;
                        if (_e && (_e.classList.remove("iti__highlight"),
                        _e.setAttribute("aria-selected", "false")),
                        this.highlightedItem = Q,
                        this.highlightedItem) {
                            this.highlightedItem.classList.add("iti__highlight"),
                            this.highlightedItem.setAttribute("aria-selected", "true");
                            const ne = this.highlightedItem.getAttribute("id") || "";
                            this.selectedCountry.setAttribute("aria-activedescendant", ne),
                            this.options.countrySearch && this.searchInput.setAttribute("aria-activedescendant", ne)
                        }
                        te && this.highlightedItem.focus()
                    }
                    _getCountryData(Q, te) {
                        for (let _e = 0; _e < this.countries.length; _e++)
                            if (this.countries[_e].iso2 === Q)
                                return this.countries[_e];
                        if (te)
                            return null;
                        throw new Error(`No country data for '${Q}'`)
                    }
                    _setCountry(Q) {
                        const {separateDialCode: te, showFlags: _e, i18n: ne} = this.options
                          , Pe = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
                        if (this.selectedCountryData = Q ? this._getCountryData(Q, !1) || {} : {},
                        this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2),
                        this.selectedCountryInner) {
                            let Me = ""
                              , at = "";
                            Q && _e ? (Me = `iti__flag iti__${Q}`,
                            at = `${this.selectedCountryData.name} +${this.selectedCountryData.dialCode}`) : (Me = "iti__flag iti__globe",
                            at = ne.noCountrySelected),
                            this.selectedCountryInner.className = Me,
                            this.selectedCountryA11yText.textContent = at
                        }
                        if (this._setSelectedCountryTitleAttribute(Q, te),
                        te) {
                            const Me = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : "";
                            this.selectedDialCode.innerHTML = Me,
                            this._updateInputPadding()
                        }
                        return this._updatePlaceholder(),
                        this._updateMaxLength(),
                        Pe.iso2 !== Q
                    }
                    _updateInputPadding() {
                        if (this.selectedCountry) {
                            const te = (this.selectedCountry.offsetWidth || this._getHiddenSelectedCountryWidth()) + 6;
                            this.showSelectedCountryOnLeft ? this.telInput.style.paddingLeft = `${te}px` : this.telInput.style.paddingRight = `${te}px`
                        }
                    }
                    _updateMaxLength() {
                        const {strictMode: Q, placeholderNumberType: te, validationNumberTypes: _e} = this.options
                          , {iso2: ne} = this.selectedCountryData;
                        if (Q && Ae.utils)
                            if (ne) {
                                const Pe = Ae.utils.numberType[te];
                                let Me = Ae.utils.getExampleNumber(ne, !1, Pe, !0)
                                  , at = Me;
                                for (; Ae.utils.isPossibleNumber(Me, ne, _e); )
                                    at = Me,
                                    Me += "0";
                                const We = Ae.utils.getCoreNumber(at, ne);
                                this.maxCoreNumberLength = We.length,
                                ne === "by" && (this.maxCoreNumberLength = We.length + 1)
                            } else
                                this.maxCoreNumberLength = null
                    }
                    _setSelectedCountryTitleAttribute(Q=null, te) {
                        if (!this.selectedCountry)
                            return;
                        let _e;
                        Q && !te ? _e = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}` : Q ? _e = this.selectedCountryData.name : _e = "Unknown",
                        this.selectedCountry.setAttribute("title", _e)
                    }
                    _getHiddenSelectedCountryWidth() {
                        if (this.telInput.parentNode) {
                            const Q = this.telInput.parentNode.cloneNode(!1);
                            Q.style.visibility = "hidden",
                            document.body.appendChild(Q);
                            const te = this.countryContainer.cloneNode();
                            Q.appendChild(te);
                            const _e = this.selectedCountry.cloneNode(!0);
                            te.appendChild(_e);
                            const ne = _e.offsetWidth;
                            return document.body.removeChild(Q),
                            ne
                        }
                        return 0
                    }
                    _updatePlaceholder() {
                        const {autoPlaceholder: Q, placeholderNumberType: te, nationalMode: _e, customPlaceholder: ne} = this.options
                          , Pe = Q === "aggressive" || !this.hadInitialPlaceholder && Q === "polite";
                        if (Ae.utils && Pe) {
                            const Me = Ae.utils.numberType[te];
                            let at = this.selectedCountryData.iso2 ? Ae.utils.getExampleNumber(this.selectedCountryData.iso2, _e, Me) : "";
                            at = this._beforeSetNumber(at),
                            typeof ne == "function" && (at = ne(at, this.selectedCountryData)),
                            this.telInput.setAttribute("placeholder", at)
                        }
                    }
                    _selectListItem(Q) {
                        const te = this._setCountry(Q.getAttribute("data-country-code"));
                        this._closeDropdown(),
                        this._updateDialCode(Q.getAttribute("data-dial-code")),
                        this.telInput.focus(),
                        te && this._triggerCountryChange()
                    }
                    _closeDropdown() {
                        this.dropdownContent.classList.add("iti__hide"),
                        this.selectedCountry.setAttribute("aria-expanded", "false"),
                        this.selectedCountry.removeAttribute("aria-activedescendant"),
                        this.highlightedItem && this.highlightedItem.setAttribute("aria-selected", "false"),
                        this.options.countrySearch && this.searchInput.removeAttribute("aria-activedescendant"),
                        this.dropdownArrow.classList.remove("iti__arrow--up"),
                        document.removeEventListener("keydown", this._handleKeydownOnDropdown),
                        this.options.countrySearch && this.searchInput.removeEventListener("input", this._handleSearchChange),
                        document.documentElement.removeEventListener("click", this._handleClickOffToClose),
                        this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList),
                        this.countryList.removeEventListener("click", this._handleClickCountryList),
                        this.options.dropdownContainer && (this.options.useFullscreenPopup || window.removeEventListener("scroll", this._handleWindowScroll),
                        this.dropdown.parentNode && this.dropdown.parentNode.removeChild(this.dropdown)),
                        this._handlePageLoad && window.removeEventListener("load", this._handlePageLoad),
                        this._trigger("close:countrydropdown")
                    }
                    _scrollTo(Q) {
                        const te = this.countryList
                          , _e = document.documentElement.scrollTop
                          , ne = te.offsetHeight
                          , Pe = te.getBoundingClientRect().top + _e
                          , Me = Pe + ne
                          , at = Q.offsetHeight
                          , We = Q.getBoundingClientRect().top + _e
                          , Ct = We + at
                          , _t = We - Pe + te.scrollTop;
                        if (We < Pe)
                            te.scrollTop = _t;
                        else if (Ct > Me) {
                            const xt = ne - at;
                            te.scrollTop = _t - xt
                        }
                    }
                    _updateDialCode(Q) {
                        const te = this.telInput.value
                          , _e = `+${Q}`;
                        let ne;
                        if (te.charAt(0) === "+") {
                            const Pe = this._getDialCode(te);
                            Pe ? ne = te.replace(Pe, _e) : ne = _e,
                            this.telInput.value = ne
                        }
                    }
                    _getDialCode(Q, te) {
                        let _e = "";
                        if (Q.charAt(0) === "+") {
                            let ne = "";
                            for (let Pe = 0; Pe < Q.length; Pe++) {
                                const Me = Q.charAt(Pe);
                                if (!isNaN(parseInt(Me, 10))) {
                                    if (ne += Me,
                                    te)
                                        this.dialCodeToIso2Map[ne] && (_e = Q.substr(0, Pe + 1));
                                    else if (this.dialCodes[ne]) {
                                        _e = Q.substr(0, Pe + 1);
                                        break
                                    }
                                    if (ne.length === this.dialCodeMaxLen)
                                        break
                                }
                            }
                        }
                        return _e
                    }
                    _getFullNumber(Q) {
                        const te = Q || this.telInput.value.trim()
                          , {dialCode: _e} = this.selectedCountryData;
                        let ne;
                        const Pe = ht(te);
                        return this.options.separateDialCode && te.charAt(0) !== "+" && _e && Pe ? ne = `+${_e}` : ne = "",
                        ne + te
                    }
                    _beforeSetNumber(Q) {
                        let te = Q;
                        if (this.options.separateDialCode) {
                            let _e = this._getDialCode(te);
                            if (_e) {
                                _e = `+${this.selectedCountryData.dialCode}`;
                                const ne = te[_e.length] === " " || te[_e.length] === "-" ? _e.length + 1 : _e.length;
                                te = te.substr(ne)
                            }
                        }
                        return this._cap(te)
                    }
                    _triggerCountryChange() {
                        this._trigger("countrychange")
                    }
                    _formatNumberAsYouType() {
                        const Q = this._getFullNumber()
                          , te = Ae.utils ? Ae.utils.formatNumberAsYouType(Q, this.selectedCountryData.iso2) : Q
                          , {dialCode: _e} = this.selectedCountryData;
                        return this.options.separateDialCode && this.telInput.value.charAt(0) !== "+" && te.includes(`+${_e}`) ? (te.split(`+${_e}`)[1] || "").trim() : te
                    }
                    handleAutoCountry() {
                        this.options.initialCountry === "auto" && Ae.autoCountry && (this.defaultCountry = Ae.autoCountry,
                        this.selectedCountryData.iso2 || this.selectedCountryInner.classList.contains("iti__globe") || this.setCountry(this.defaultCountry),
                        this.resolveAutoCountryPromise())
                    }
                    handleUtils() {
                        Ae.utils && (this.telInput.value && this._updateValFromNumber(this.telInput.value),
                        this.selectedCountryData.iso2 && (this._updatePlaceholder(),
                        this._updateMaxLength())),
                        this.resolveUtilsScriptPromise()
                    }
                    destroy() {
                        var Pe, Me;
                        const {allowDropdown: Q, separateDialCode: te} = this.options;
                        if (Q) {
                            this._closeDropdown(),
                            this.selectedCountry.removeEventListener("click", this._handleClickSelectedCountry),
                            this.countryContainer.removeEventListener("keydown", this._handleCountryContainerKeydown);
                            const at = this.telInput.closest("label");
                            at && at.removeEventListener("click", this._handleLabelClick)
                        }
                        const {form: _e} = this.telInput;
                        this._handleHiddenInputSubmit && _e && _e.removeEventListener("submit", this._handleHiddenInputSubmit),
                        this.telInput.removeEventListener("input", this._handleInputEvent),
                        this._handleKeydownEvent && this.telInput.removeEventListener("keydown", this._handleKeydownEvent),
                        this.telInput.removeAttribute("data-intl-tel-input-id"),
                        te && (this.isRTL ? this.telInput.style.paddingRight = this.originalPaddingRight : this.telInput.style.paddingLeft = this.originalPaddingLeft);
                        const ne = this.telInput.parentNode;
                        (Pe = ne == null ? void 0 : ne.parentNode) == null || Pe.insertBefore(this.telInput, ne),
                        (Me = ne == null ? void 0 : ne.parentNode) == null || Me.removeChild(ne),
                        delete Ae.instances[this.id]
                    }
                    getExtension() {
                        return Ae.utils ? Ae.utils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2) : ""
                    }
                    getNumber(Q) {
                        if (Ae.utils) {
                            const {iso2: te} = this.selectedCountryData;
                            return Ae.utils.formatNumber(this._getFullNumber(), te, Q)
                        }
                        return ""
                    }
                    getNumberType() {
                        return Ae.utils ? Ae.utils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2) : -99
                    }
                    getSelectedCountryData() {
                        return this.selectedCountryData
                    }
                    getValidationError() {
                        if (Ae.utils) {
                            const {iso2: Q} = this.selectedCountryData;
                            return Ae.utils.getValidationError(this._getFullNumber(), Q)
                        }
                        return -99
                    }
                    isValidNumber() {
                        if (!this.selectedCountryData.iso2)
                            return !1;
                        const Q = this._getFullNumber()
                          , te = Q.search(new RegExp("\\p{L}","u"));
                        if (te > -1) {
                            const _e = Q.substring(0, te)
                              , ne = this._utilsIsPossibleNumber(_e)
                              , Pe = this._utilsIsPossibleNumber(Q);
                            return ne && Pe
                        }
                        return this._utilsIsPossibleNumber(Q)
                    }
                    _utilsIsPossibleNumber(Q) {
                        return Ae.utils ? Ae.utils.isPossibleNumber(Q, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
                    }
                    isValidNumberPrecise() {
                        if (!this.selectedCountryData.iso2)
                            return !1;
                        const Q = this._getFullNumber()
                          , te = Q.search(new RegExp("\\p{L}","u"));
                        if (te > -1) {
                            const _e = Q.substring(0, te)
                              , ne = this._utilsIsValidNumber(_e)
                              , Pe = this._utilsIsValidNumber(Q);
                            return ne && Pe
                        }
                        return this._utilsIsValidNumber(Q)
                    }
                    _utilsIsValidNumber(Q) {
                        return Ae.utils ? Ae.utils.isValidNumber(Q, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
                    }
                    setCountry(Q) {
                        const te = Q == null ? void 0 : Q.toLowerCase()
                          , _e = this.selectedCountryData.iso2;
                        (Q && te !== _e || !Q && _e) && (this._setCountry(te),
                        this._updateDialCode(this.selectedCountryData.dialCode),
                        this._triggerCountryChange())
                    }
                    setNumber(Q) {
                        const te = this._updateCountryFromNumber(Q);
                        this._updateValFromNumber(Q),
                        te && this._triggerCountryChange(),
                        this._trigger("input", {
                            isSetNumber: !0
                        })
                    }
                    setPlaceholderNumberType(Q) {
                        this.options.placeholderNumberType = Q,
                        this._updatePlaceholder()
                    }
                    setDisabled(Q) {
                        this.telInput.disabled = Q,
                        Q ? this.selectedCountry.setAttribute("disabled", "true") : this.selectedCountry.removeAttribute("disabled")
                    }
                }
                  , Qe = Q => {
                    if (!Ae.utils && !Ae.startedLoadingUtilsScript) {
                        let te;
                        if (typeof Q == "function")
                            try {
                                te = Promise.resolve(Q())
                            } catch (_e) {
                                return Promise.reject(_e)
                            }
                        else
                            return Promise.reject(new TypeError(`The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof Q}`));
                        return Ae.startedLoadingUtilsScript = !0,
                        te.then(_e => {
                            const ne = _e == null ? void 0 : _e.default;
                            if (!ne || typeof ne != "object")
                                throw new TypeError("The loader function passed to attachUtils did not resolve to a module object with utils as its default export.");
                            return Ae.utils = ne,
                            st("handleUtils"),
                            !0
                        }
                        ).catch(_e => {
                            throw st("rejectUtilsScriptPromise", _e),
                            _e
                        }
                        )
                    }
                    return null
                }
                  , Ae = Object.assign( (Q, te) => {
                    const _e = new it(Q,te);
                    return _e._init(),
                    Q.setAttribute("data-intl-tel-input-id", _e.id.toString()),
                    Ae.instances[_e.id] = _e,
                    _e
                }
                , {
                    defaults: Ne,
                    documentReady: () => document.readyState === "complete",
                    getCountryData: () => ye,
                    getInstance: Q => {
                        const te = Q.getAttribute("data-intl-tel-input-id");
                        return te ? Ae.instances[te] : null
                    }
                    ,
                    instances: {},
                    attachUtils: Qe,
                    startedLoadingUtilsScript: !1,
                    startedLoadingAutoCountry: !1,
                    version: "25.3.2"
                })
                  , vt = Ae;
                return $(W)
            }
            )();
            return l.default
        }
        )
    }
    )(gf)),
    gf.exports
}
var rE = tE();
const iE = nm(rE);
var nE = Ie('<div><span class="loading loading-spinner loading-xl"></span></div>')
  , aE = Ie('<span class="w-8"> </span>')
  , sE = Ie('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>', 1)
  , oE = async (b, l, _) => {
    await l(x(_))
}
  , lE = Ie('<span class="w-8"> </span>')
  , cE = (b, l) => {
    oe(l, "")
}
  , uE = Ie('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>', 1)
  , hE = Ie('<div class="flex h-full w-full flex-col items-center justify-center"><!></div>');
function dE(b, l) {
    Sr(l, !0);
    let _ = nt(!0)
      , C = nt("")
      , L = nt(0)
      , O = nt(!1);
    const T = lt( () => x(L) > 0 || x(O));
    let o = nt(!1)
      , $ = nt("")
      , W = nt(void 0);
    const ie = lt( () => {
        var Re;
        return `phone:${(Re = Dt.data) == null ? void 0 : Re.id}`
    }
    );
    Zr( () => {
        const Re = localStorage.getItem(x(ie));
        Re && oe(C, Re, !0)
    }
    ),
    Ii( () => {
        ni.getOtpCooldown().then(Oe => {
            oe(L, Oe.cooldownMs, !0)
        }
        ).catch(Oe => {
            qr.error(Oe.message)
        }
        ).finally( () => {
            oe(_, !1)
        }
        );
        const Re = 1e3
          , ke = setInterval( () => {
            oe(L, Math.max(0, x(L) - Re), !0)
        }
        , Re);
        return () => {
            clearInterval(ke)
        }
    }
    );
    async function pe(Re) {
        try {
            oe(O, !0);
            const ke = await ni.sendOtp(Re);
            qr.info(`${K3()} ${ke.phone}`),
            oe(C, ke.phone, !0),
            oe(L, ke.cooldownMs, !0),
            localStorage.setItem(x(ie), x(C))
        } catch (ke) {
            qr.error(ke.message)
        } finally {
            oe(O, !1)
        }
    }
    Zr( () => {
        x($).length === 6 && (oe(o, !0),
        (async () => {
            try {
                await ni.verifyOtp(x($)),
                await Dt.refresh(),
                qr.success(Q3()),
                localStorage.removeItem(x(ie)),
                l.onsuccess(x(C))
            } catch (Re) {
                qr.error(Re.message)
            } finally {
                oe($, ""),
                oe(o, !1)
            }
        }
        )())
    }
    );
    var ye = hE()
      , X = k(ye);
    {
        var Se = Re => {
            var ke = nE();
            H(Re, ke)
        }
          , we = Re => {
            var ke = Jt()
              , Oe = zt(ke);
            {
                var Ee = ft => {
                    var ht = sE()
                      , Xe = zt(ht)
                      , ct = k(Xe)
                      , Je = k(ct, !0);
                    A(ct);
                    var Be = V(ct, 2)
                      , st = k(Be, !0);
                    A(Be),
                    A(Xe);
                    var it = V(Xe, 2)
                      , Qe = k(it);
                    On(Qe, () => _e => (oe(W, iE(_e, {
                        strictMode: !0,
                        initialCountry: "br",
                        loadUtils: () => bx( () => import("../chunks/1FgtjJRR.js"), [], import.meta.url),
                        containerClass: "w-full",
                        dropdownContainer: document.body
                    })),
                    () => {
                        var ne;
                        (ne = x(W)) == null || ne.destroy()
                    }
                    ));
                    var Ae = V(Qe, 2)
                      , vt = k(Ae)
                      , Q = V(vt);
                    {
                        var te = _e => {
                            var ne = aE()
                              , Pe = k(ne);
                            A(ne),
                            Ge(Me => fe(Pe, `(${Me ?? ""})`), [ () => zd(x(L))]),
                            H(_e, ne)
                        }
                        ;
                        Ue(Q, _e => {
                            x(L) > 0 && _e(te)
                        }
                        )
                    }
                    A(Ae),
                    A(it),
                    Ge( (_e, ne, Pe) => {
                        fe(Je, _e),
                        fe(st, ne),
                        Ae.disabled = x(T),
                        fe(vt, `${Pe ?? ""} `)
                    }
                    , [ () => AC(), () => zC(), () => RC()]),
                    an("submit", it, async () => {
                        var ne;
                        if (x(T))
                            return;
                        if (!((ne = x(W)) != null && ne.isValidNumber())) {
                            qr.error(rC());
                            return
                        }
                        const _e = x(W).getNumber();
                        await pe(_e)
                    }
                    ),
                    H(ft, ht)
                }
                  , Ne = ft => {
                    var ht = uE()
                      , Xe = zt(ht)
                      , ct = k(Xe)
                      , Je = k(ct, !0);
                    A(ct);
                    var Be = V(ct, 2)
                      , st = k(Be);
                    A(Be),
                    A(Xe);
                    var it = V(Xe, 2)
                      , Qe = k(it);
                    {
                        const Me = (at, We) => {
                            let Ct = () => We == null ? void 0 : We().cells;
                            var _t = Jt()
                              , xt = zt(_t);
                            _n(xt, () => Kk, (tt, pt) => {
                                pt(tt, {
                                    class: "border-primary",
                                    children: (It, ut) => {
                                        var bt = Jt()
                                          , wt = zt(bt);
                                        nn(wt, 16, Ct, dt => dt, (dt, Lt) => {
                                            var Xt = Jt()
                                              , Yt = zt(Xt);
                                            _n(Yt, () => Qk, (nr, ar) => {
                                                ar(nr, {
                                                    get cell() {
                                                        return Lt
                                                    },
                                                    class: "border-base-content/20 size-11 sm:size-12"
                                                })
                                            }
                                            ),
                                            H(dt, Xt)
                                        }
                                        ),
                                        H(It, bt)
                                    }
                                    ,
                                    $$slots: {
                                        default: !0
                                    }
                                })
                            }
                            ),
                            H(at, _t)
                        }
                        ;
                        _n(Qe, () => eE, (at, We) => {
                            We(at, {
                                maxlength: 6,
                                class: "mx-auto w-max",
                                get disabled() {
                                    return x(o)
                                },
                                get value() {
                                    return x($)
                                },
                                set value(Ct) {
                                    oe($, Ct, !0)
                                },
                                children: Me,
                                $$slots: {
                                    default: !0
                                }
                            })
                        }
                        )
                    }
                    A(it);
                    var Ae = V(it, 2)
                      , vt = k(Ae);
                    vt.__click = [oE, pe, C];
                    var Q = k(vt)
                      , te = V(Q);
                    {
                        var _e = Me => {
                            var at = lE()
                              , We = k(at);
                            A(at),
                            Ge(Ct => fe(We, `(${Ct ?? ""})`), [ () => zd(x(L))]),
                            H(Me, at)
                        }
                        ;
                        Ue(te, Me => {
                            x(L) > 0 && Me(_e)
                        }
                        )
                    }
                    A(vt);
                    var ne = V(vt, 2);
                    ne.__click = [cE, C];
                    var Pe = k(ne, !0);
                    A(ne),
                    A(Ae),
                    Ge( (Me, at, We, Ct) => {
                        fe(Je, Me),
                        fe(st, `${at ?? ""} ${x(C) ?? ""}`),
                        vt.disabled = x(T),
                        fe(Q, `${We ?? ""} `),
                        fe(Pe, Ct)
                    }
                    , [ () => OC(), () => qC(), () => ZC(), () => HC()]),
                    H(ft, ht)
                }
                ;
                Ue(Oe, ft => {
                    x(C) ? ft(Ne, !1) : ft(Ee)
                }
                , !0)
            }
            H(Re, ke)
        }
        ;
        Ue(X, Re => {
            x(_) ? Re(Se) : Re(we, !1)
        }
        )
    }
    A(ye),
    H(b, ye),
    Pr()
}
Wi(["click"]);
var pE = Ie('<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div></dialog>');
function fE(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15);
    var C = pE()
      , L = k(C)
      , O = V(k(L), 2);
    {
        var T = o => {
            dE(o, {
                onsuccess: () => _(!1)
            })
        }
        ;
        Ue(O, o => {
            _() && o(T)
        }
        )
    }
    A(L),
    A(C),
    On(C, () => o => {
        Zr( () => {
            _() ? o.show() : o.close()
        }
        )
    }
    ),
    an("close", C, () => _(!1)),
    H(b, C),
    Pr()
}
var mE = (b, l) => {
    l()
}
  , _E = Ie('<span class="center-absolute loading loading-spinner absolute"></span>')
  , gE = Ie('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>')
  , vE = (b, l, _) => {
    l(x(_).id)
}
  , yE = Ie('<span class="center-absolute loading loading-spinner absolute"></span>')
  , xE = Ie('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>')
  , bE = Ie('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>')
  , wE = (b, l) => {
    var _;
    (_ = x(l)) == null || _.show()
}
  , TE = (b, l) => {
    l(!1)
}
  , CE = (b, l) => {
    var _;
    (_ = x(l)) == null || _.close()
}
  , SE = async (b, l) => {
    try {
        oe(l, !0),
        await ni.deleteMe(),
        qr.warning(gC()),
        await Dt.logout()
    } catch (_) {
        qr.error(_.message)
    } finally {
        oe(l, !1)
    }
}
  , PE = Ie('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="flex w-full flex-col gap-3"><!> <!> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="mt-4 flex w-full items-center justify-between"><button type="button" class="btn btn-error btn-soft btn-sm w-max"> </button> <div class="flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <div class="mt-4 flex justify-end gap-2"><button class="btn btn-soft"> </button> <button class="btn btn-error"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);
function IE(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15)
      , C = nt(zn(l.userData.name))
      , L = nt(zn(l.userData.discord))
      , O = nt(zn(l.userData.showLastPixel))
      , T = nt(!1)
      , o = nt(void 0)
      , $ = nt(void 0);
    Ii( () => {
        const Ft = dr => {
            dr.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", Ft),
        () => document.removeEventListener("keydown", Ft)
    }
    );
    let W = nt(void 0)
      , ie = nt(void 0);
    Zr( () => {
        oe(C, l.userData.name, !0),
        oe(O, l.userData.showLastPixel, !0)
    }
    ),
    Zr( () => {
        _() && !x($) && ni.getMyProfilePictures().then(Ft => {
            oe($, Ft, !0)
        }
        ).catch(Ft => {
            qr.error(Ft.message)
        }
        )
    }
    );
    let pe = nt(!1);
    async function ye(Ft) {
        try {
            oe(pe, !0),
            await ni.changeProfilePicture(Ft),
            await Dt.refresh()
        } finally {
            oe(pe, !1)
        }
    }
    var X = PE()
      , Se = zt(X)
      , we = k(Se)
      , Re = V(k(we), 2)
      , ke = k(Re, !0);
    A(Re);
    var Oe = V(Re, 2)
      , Ee = k(Oe)
      , Ne = k(Ee)
      , ft = k(Ne)
      , ht = k(ft);
    es(ht, {
        class: "size-30",
        get userId() {
            return l.userData.id
        },
        get pictureUrl() {
            return l.userData.picture
        }
    });
    var Xe = V(ht, 2)
      , ct = k(Xe);
    Dg(ct, {
        class: "size-5"
    }),
    A(Xe),
    A(ft);
    var Je = V(ft, 2);
    {
        var Be = Ft => {
            var dr = bE()
              , _r = k(dr)
              , Ir = k(_r, !0);
            A(_r);
            var jr = V(_r, 2)
              , ur = k(jr);
            {
                var Mr = kr => {
                    var Nr = gE();
                    Nr.__click = [mE, ye];
                    var ce = k(Nr);
                    es(ce, {
                        class: "size-10 border",
                        get userId() {
                            return l.userData.id
                        }
                    });
                    var F = V(ce, 2);
                    {
                        var q = G => {
                            var K = _E();
                            H(G, K)
                        }
                        ;
                        Ue(F, G => {
                            x(pe) && G(q)
                        }
                        )
                    }
                    A(Nr),
                    Ge( () => Nr.disabled = x(pe)),
                    H(kr, Nr)
                }
                ;
                Ue(ur, kr => {
                    l.userData.picture && kr(Mr)
                }
                )
            }
            var Ar = V(ur, 2);
            nn(Ar, 17, () => x($), kr => kr.id, (kr, Nr) => {
                var ce = Jt()
                  , F = zt(ce);
                {
                    var q = G => {
                        var K = xE();
                        K.__click = [vE, ye, Nr];
                        var le = k(K);
                        es(le, {
                            class: "size-10 border",
                            get userId() {
                                return l.userData.id
                            },
                            get pictureUrl() {
                                return x(Nr).url
                            }
                        });
                        var ve = V(le, 2);
                        {
                            var Le = Ce => {
                                var Ze = yE();
                                H(Ce, Ze)
                            }
                            ;
                            Ue(ve, Ce => {
                                x(pe) && Ce(Le)
                            }
                            )
                        }
                        A(K),
                        Ge( () => K.disabled = x(pe)),
                        H(G, K)
                    }
                    ;
                    Ue(F, G => {
                        l.userData.picture !== x(Nr).url && G(q)
                    }
                    )
                }
                H(kr, ce)
            }
            ),
            A(jr),
            A(dr),
            Ge(kr => fe(Ir, kr), [ () => jb()]),
            H(Ft, dr)
        }
        ;
        Ue(Je, Ft => {
            var dr;
            (dr = x($)) != null && dr.length && Ft(Be)
        }
        )
    }
    A(Ne);
    var st = V(Ne, 2)
      , it = k(st);
    {
        let Ft = lt( () => xf())
          , dr = lt( () => xf());
        Tf(it, {
            get label() {
                return x(Ft)
            },
            get placeholder() {
                return x(dr)
            },
            min: 1,
            max: 16,
            get value() {
                return x(C)
            },
            set value(_r) {
                oe(C, _r, !0)
            },
            get validate() {
                return x(W)
            },
            set validate(_r) {
                oe(W, _r, !0)
            }
        })
    }
    var Qe = V(it, 2);
    {
        let Ft = lt( () => Zw());
        Tf(Qe, {
            label: "Discord",
            get placeholder() {
                return x(Ft)
            },
            max: 32,
            get value() {
                return x(L)
            },
            set value(dr) {
                oe(L, dr, !0)
            },
            get validate() {
                return x(ie)
            },
            set validate(dr) {
                oe(ie, dr, !0)
            }
        })
    }
    var Ae = V(Qe, 2)
      , vt = k(Ae);
    ea(vt);
    var Q = V(vt);
    A(Ae),
    A(st),
    A(Ee);
    var te = V(Ee, 2)
      , _e = k(te);
    _e.__click = [wE, o];
    var ne = k(_e, !0);
    A(_e);
    var Pe = V(_e, 2)
      , Me = k(Pe);
    Me.__click = [TE, _];
    var at = k(Me, !0);
    A(Me);
    var We = V(Me, 2)
      , Ct = k(We, !0);
    A(We),
    A(Pe),
    A(te),
    A(Oe),
    A(we),
    A(Se),
    On(Se, () => Ft => {
        Zr( () => {
            _() ? Ft.show() : Ft.close()
        }
        )
    }
    );
    var _t = V(Se, 2)
      , xt = k(_t)
      , tt = V(k(xt), 2)
      , pt = k(tt, !0);
    A(tt);
    var It = V(tt, 2)
      , ut = k(It, !0);
    A(It);
    var bt = V(It, 2)
      , wt = k(bt);
    wt.__click = [CE, o];
    var dt = k(wt, !0);
    A(wt);
    var Lt = V(wt, 2);
    Lt.__click = [SE, T];
    var Xt = k(Lt, !0);
    A(Lt),
    A(bt),
    A(xt);
    var Yt = V(xt, 2)
      , nr = k(Yt)
      , ar = k(nr, !0);
    A(nr),
    A(Yt),
    A(_t),
    ps(_t, Ft => oe(o, Ft), () => x(o)),
    Ge( (Ft, dr, _r, Ir, jr, ur, Mr, Ar, kr, Nr, ce) => {
        fe(ke, Ft),
        zr(Xe, "data-tip", dr),
        fe(Q, ` ${_r ?? ""}`),
        fe(ne, Ir),
        Me.disabled = x(T),
        fe(at, jr),
        We.disabled = x(T),
        fe(Ct, ur),
        fe(pt, Mr),
        fe(ut, Ar),
        fe(dt, kr),
        Lt.disabled = x(T),
        fe(Xt, Nr),
        fe(ar, ce)
    }
    , [ () => KC(), () => dx(), () => Ub(), () => ug(), () => tc(), () => Wb(), () => Yb(), () => e2(), () => qd(), () => ug(), () => tc()]),
    an("close", Se, () => _(!1)),
    an("submit", Oe, async () => {
        var Ft, dr;
        try {
            if (!((Ft = x(W)) != null && Ft()) || !((dr = x(ie)) != null && dr()))
                return;
            oe(T, !0),
            await ni.updateMe({
                name: x(C),
                showLastPixel: x(O),
                discord: x(L)
            }),
            Dt.refresh(),
            qr.success(fC()),
            _(!1)
        } catch (_r) {
            qr.error(_r.message)
        } finally {
            oe(T, !1)
        }
    }
    ),
    px(vt, () => x(O), Ft => oe(O, Ft)),
    H(b, X),
    Pr()
}
Wi(["click"]);
var ME = Tr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');
function AE(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = ME();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var kE = Tr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');
function Dv(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = kE();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var EE = Tr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');
function zE(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = EE();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var LE = Tr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');
function DE(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = LE();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        viewBox: "0 0 216 216",
        ..._
    }), void 0, void 0, "svelte-1977t4s"),
    H(b, C)
}
var RE = Tr('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');
function BE(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = RE();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var FE = Tr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');
function OE(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = FE();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var NE = Tr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');
function jE(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = NE();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var qE = Tr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');
function VE(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = qE();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var UE = (b, l) => {
    oe(l, !0)
}
  , ZE = Ie('<span class="tooltip font-flag ml-0.5"> </span>')
  , $E = Ie('<div class="mt-1"><!></div>')
  , GE = (b, l, _) => {
    localStorage.setItem(mx, x(l).key),
    oe(_, x(l).key, !0),
    location.reload()
}
  , HE = Ie('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>')
  , WE = Ie("<li><button><!> </button></li>")
  , XE = async (b, l) => {
    var _;
    try {
        const C = await ((_ = x(l)) == null ? void 0 : _.prompt());
        (C == null ? void 0 : C.outcome) === "accepted" && oe(l, void 0)
    } catch (C) {
        qr.error(Sb({
            error: C.message
        }))
    }
}
  , KE = Ie('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>')
  , YE = Ie('<a class="btn w-full"><!> </a>')
  , JE = Ie('<form class="w-full" method="POST"><button class="btn w-full"><!> Purchases</button></form>')
  , QE = async (b, l, _, C) => {
    var L;
    try {
        oe(l, !0),
        await _.user.logout(),
        C(),
        qr.warning(xC(), {
            icon: Dv
        }),
        (L = _.onlogout) == null || L.call(_)
    } catch {
        qr.error(TC())
    } finally {
        oe(l, !1)
    }
}
  , e8 = Ie('<div class="dropdown"><div tabindex="0" role="button" class="btn size-12 p-0 shadow-md"><!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 relative right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="0"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div></div></div>  <!> <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);
function t8(b, l) {
    Sr(l, !0);
    let _ = nt(!1)
      , C = nt(!1);
    function L() {
        var pe;
        (pe = document.activeElement) == null || pe.blur()
    }
    const O = [{
        label: "🇺🇸 English",
        key: "en"
    }, {
        label: "🇧🇷 Português",
        key: "pt"
    }];
    let T = nt("")
      , o = nt(void 0);
    var $ = Jt()
      , W = zt($);
    {
        var ie = pe => {
            var ye = e8()
              , X = zt(ye)
              , Se = k(X)
              , we = k(Se);
            Bg(we, {
                get userId() {
                    return l.user.data.id
                },
                get level() {
                    return l.user.data.level
                },
                get pictureUrl() {
                    return l.user.data.picture
                }
            }),
            A(Se);
            var Re = V(Se, 2)
              , ke = k(Re);
            ke.__click = L;
            var Oe = k(ke);
            fc(Oe, {
                class: "size-5"
            }),
            A(ke);
            var Ee = V(ke, 2)
              , Ne = k(Ee)
              , ft = k(Ne);
            es(ft, {
                get userId() {
                    return l.user.data.id
                },
                get pictureUrl() {
                    return l.user.data.picture
                }
            });
            var ht = V(ft, 2);
            ht.__click = [UE, _];
            var Xe = k(ht);
            Cf(Xe, {
                class: "size-4"
            }),
            A(ht),
            A(Ne);
            var ct = V(Ne, 2)
              , Je = k(ct)
              , Be = k(Je)
              , st = k(Be, !0);
            A(Be);
            var it = V(Be, 2)
              , Qe = k(it);
            A(it);
            var Ae = V(it, 2);
            {
                var vt = At => {
                    const Pt = lt( () => ds(l.user.data.equippedFlag));
                    var kt = ZE()
                      , Wt = k(kt, !0);
                    A(kt),
                    Ge( () => {
                        zr(kt, "data-tip", x(Pt).name),
                        fe(Wt, x(Pt).flag)
                    }
                    ),
                    H(At, kt)
                }
                ;
                Ue(Ae, At => {
                    l.user.data.equippedFlag && At(vt)
                }
                )
            }
            var Q = V(Ae, 2);
            {
                var te = At => {
                    var Pt = $E()
                      , kt = k(Pt);
                    ph(kt, {
                        get username() {
                            return l.user.data.discord
                        }
                    }),
                    A(Pt),
                    H(At, Pt)
                }
                ;
                Ue(Q, At => {
                    l.user.data.discord && At(te)
                }
                )
            }
            A(Je);
            var _e = V(Je, 2)
              , ne = k(_e);
            fh(ne, {
                class: "inline size-4"
            });
            var Pe = V(ne, 2)
              , Me = k(Pe)
              , at = V(Me)
              , We = k(at, !0);
            A(at),
            A(Pe),
            A(_e);
            var Ct = V(_e, 2)
              , _t = k(Ct);
            AE(_t, {
                class: "inline size-4"
            });
            var xt = V(_t, 2)
              , tt = k(xt)
              , pt = k(tt);
            A(tt);
            var It = V(tt)
              , ut = V(It)
              , bt = k(ut);
            $f(bt, {
                class: "mb-0.5 inline size-4 opacity-50"
            }),
            A(ut),
            A(xt),
            A(Ct),
            A(ct),
            A(Ee);
            var wt = V(Ee, 2)
              , dt = k(wt)
              , Lt = k(dt)
              , Xt = k(Lt, !0);
            A(Lt);
            var Yt = V(Lt, 2)
              , nr = k(Yt)
              , ar = k(nr)
              , Ft = k(ar);
            OE(Ft, {
                class: "size-4"
            }),
            A(ar);
            var dr = V(ar, 2);
            nn(dr, 21, () => O, Zd, (At, Pt) => {
                const kt = lt( () => x(T) === x(Pt).key);
                var Wt = WE()
                  , Lr = k(Wt);
                let Kr;
                Lr.__click = [GE, Pt, T];
                var Hr = k(Lr);
                {
                    var $r = gr => {
                        var ai = HE();
                        H(gr, ai)
                    }
                    ;
                    Ue(Hr, gr => {
                        x(kt) && gr($r)
                    }
                    )
                }
                var mr = V(Hr);
                A(Lr),
                A(Wt),
                Ge(gr => {
                    Kr = Or(Lr, 1, "font-flag relative font-medium", null, Kr, gr),
                    fe(mr, ` ${x(Pt).label ?? ""}`)
                }
                , [ () => ({
                    "bg-base-200": x(kt)
                })]),
                H(At, Wt)
            }
            ),
            A(dr),
            A(nr);
            var _r = V(nr, 2)
              , Ir = k(_r);
            Ir.__click = () => {
                oa.muted = !oa.muted
            }
            ;
            var jr = k(Ir);
            {
                var ur = At => {
                    jE(At, {
                        class: "size-4"
                    })
                }
                  , Mr = At => {
                    VE(At, {
                        class: "size-4"
                    })
                }
                ;
                Ue(jr, At => {
                    oa.muted ? At(ur) : At(Mr, !1)
                }
                )
            }
            A(Ir),
            A(_r),
            A(Yt),
            A(dt);
            var Ar = V(dt, 2);
            {
                var kr = At => {
                    var Pt = KE();
                    Pt.__click = [XE, o];
                    var kt = k(Pt);
                    sv(kt, {
                        class: "size-5"
                    });
                    var Wt = V(kt);
                    A(Pt),
                    Ge(Lr => fe(Wt, ` ${Lr ?? ""}`), [ () => Mb()]),
                    H(At, Pt)
                }
                ;
                Ue(Ar, At => {
                    x(o) && At(kr)
                }
                )
            }
            var Nr = V(Ar, 2);
            {
                var ce = At => {
                    var Pt = YE()
                      , kt = k(Pt);
                    BE(kt, {
                        class: "size-5"
                    });
                    var Wt = V(kt);
                    A(Pt),
                    Ge(Lr => {
                        zr(Pt, "href", `${La.url.origin ?? ""}/moderation`),
                        fe(Wt, ` ${Lr ?? ""}`)
                    }
                    , [ () => YS()]),
                    H(At, Pt)
                }
                ;
                Ue(Nr, At => {
                    var Pt;
                    (Pt = l.user.data) != null && Pt.role && l.user.data.role !== "user" && At(ce)
                }
                )
            }
            var F = V(Nr, 2)
              , q = k(F);
            jg(q, {
                class: "size-5"
            });
            var G = V(q);
            A(F);
            var K = V(F, 2)
              , le = k(K);
            am(le, {
                class: "size-5"
            }),
            fi(),
            A(K);
            var ve = V(K, 2)
              , Le = k(ve);
            DE(Le, {
                class: "size-5"
            }),
            fi(),
            A(ve);
            var Ce = V(ve, 2);
            {
                var Ze = At => {
                    var Pt = JE()
                      , kt = k(Pt)
                      , Wt = k(kt);
                    zE(Wt, {
                        class: "size-5"
                    }),
                    fi(),
                    A(kt),
                    A(Pt),
                    Ge( () => zr(Pt, "action", `${Cd}/payment/create-portal-session`)),
                    H(At, Pt)
                }
                ;
                Ue(Ce, At => {
                    var Pt;
                    (Pt = l.user.data) != null && Pt.isCustomer && At(Ze)
                }
                )
            }
            var ot = V(Ce, 2);
            ot.__click = [QE, C, l, L];
            var Ye = k(ot);
            Dv(Ye, {
                class: "size-5"
            });
            var Ot = V(Ye);
            A(ot),
            A(wt),
            A(Re),
            A(X);
            var xe = V(X, 2);
            IE(xe, {
                get userData() {
                    return l.user.data
                },
                get open() {
                    return x(_)
                },
                set open(At) {
                    oe(_, At, !0)
                }
            }),
            Ge( (At, Pt, kt, Wt, Lr, Kr, Hr, $r, mr, gr, ai) => {
                zr(Se, "title", At),
                zr(Be, "title", l.user.data.name),
                fe(st, l.user.data.name),
                Or(it, 1, Pt),
                fe(Qe, `#${l.user.data.id ?? ""}`),
                fe(Me, `${kt ?? ""}: `),
                fe(We, Wt),
                fe(pt, `Level ${Lr ?? ""}`),
                fe(It, ` (${Kr ?? ""}%) `),
                zr(ut, "data-tip", Hr),
                fe(Xt, $r),
                zr(_r, "data-tip", mr),
                fe(G, ` ${gr ?? ""}`),
                ot.disabled = x(C),
                fe(Ot, ` ${ai ?? ""}`)
            }
            , [ () => yb(), () => Vo(Zn(l.user.data.id)), () => Xf(), () => l.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(l.user.data.level), () => Math.floor(l.user.data.level % 1 * 100), () => Nw(), () => wb(), () => oa.muted ? z3() : A3(), () => Eb(), () => Db()]),
            an("focus", Se, () => {
                oe(o, window.pwaInstallPrompt, !0)
            }
            ),
            H(pe, ye)
        }
        ;
        Ue(W, pe => {
            l.user.data && l.user.charges !== void 0 && pe(ie)
        }
        )
    }
    H(b, $),
    Pr()
}
Wi(["click"]);
var r8 = Tr('<svg><path d="M100-240v-480l360 240-360 240Zm400 0v-480l360 240-360 240ZM180-480Zm400 0Zm-400 90 136-90-136-90v180Zm400 0 136-90-136-90v180Z"></path></svg>');
function i8(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = r8();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var n8 = Tr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');
function a8(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = n8();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var s8 = async (b, l, _, C, L, O) => {
    if (x(l)) {
        _.map.easeTo(x(l)),
        oe(l, void 0);
        return
    }
    oe(C, !0);
    try {
        Qa(_.map.getCenter(), _.map.getZoom());
        const T = new hc(x(L))
          , {tile: o, pixel: $} = await ni.getRandomTile(_.season)
          , W = o.x * x(L) + $.x
          , ie = o.y * x(L) + $.y
          , [pe,ye] = T.pixelsToLatLon(W, ie, x(O))
          , X = {
            lat: pe,
            lng: ye
        }
          , Se = x(O) + 2;
        oe(l, {
            zoom: Se,
            center: X
        }, !0),
        _.map.flyTo(x(l)),
        Ho.isEmpty() && Ho.push({
            pos: _.map.getCenter(),
            zoom: _.map.getZoom()
        }),
        setTimeout( () => {
            oe(l, void 0)
        }
        , 2500),
        Ho.push({
            pos: X,
            zoom: Se
        })
    } catch (T) {
        qr.error(T.message)
    } finally {
        oe(C, !1)
    }
}
  , o8 = Ie('<button class="btn btn-square shadow-md"><!></button>');
function l8(b, l) {
    Sr(l, !0);
    const _ = lt( () => $n.seasons[l.season].tileSize)
      , C = lt( () => $n.seasons[l.season].zoom);
    let L = nt(!1)
      , O = nt(void 0);
    var T = o8();
    T.__click = [s8, O, l, L, _, C];
    var o = k(T);
    {
        var $ = ie => {
            a8(ie, {
                class: "size-5"
            })
        }
          , W = ie => {
            i8(ie, {
                class: "size-5"
            })
        }
        ;
        Ue(o, ie => {
            x(O) ? ie(W, !1) : ie($)
        }
        )
    }
    A(T),
    Ge(ie => {
        zr(T, "title", ie),
        T.disabled = x(L)
    }
    , [ () => H1()]),
    H(b, T),
    Pr()
}
Wi(["click"]);
var c8 = Ie('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>')
  , u8 = Ie('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>')
  , h8 = Ie('<span class="font-flag tooltip ml-0.5"> </span>')
  , d8 = Ie("<span> </span>")
  , p8 = Ie('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , f8 = Ie('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>')
  , m8 = Ie('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , _8 = Ie('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>')
  , g8 = Ie('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>')
  , v8 = Ie('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);
function y8(b, l) {
    Sr(l, !0);
    const _ = [];
    let C = nt("today")
      , L = {
        players: {
            label: Xg(),
            icon: Xd
        },
        alliances: {
            label: Kg(),
            icon: Kd
        }
    }
      , O = nt("players")
      , T = zn({
        players: {},
        alliances: {}
    });
    const o = lt( () => T[x(O)][x(C)]);
    Zr( () => {
        if (x(o))
            return;
        const we = x(C)
          , Re = x(O);
        Re === "players" ? ni.leaderboardRegionPlayers(l.regionId, we).then(ke => {
            T[Re][we] = ke
        }
        ).catch(ke => {
            qr.error(ke.message)
        }
        ) : Re === "alliances" && ni.leaderboardRegionAlliances(l.regionId, we).then(ke => {
            T[Re][we] = ke
        }
        ).catch(ke => {
            qr.error(ke.message)
        }
        )
    }
    );
    var $ = v8()
      , W = zt($);
    nn(W, 21, () => Object.entries(L), ([we,{label: Re, icon: ke}]) => we, (we, Re) => {
        var ke = lt( () => Ag(x(Re), 2));
        let Oe = () => x(ke)[0]
          , Ee = () => x(ke)[1].label
          , Ne = () => x(ke)[1].icon;
        const ft = lt(Ne);
        var ht = c8()
          , Xe = k(ht);
        ea(Xe);
        var ct, Je = V(Xe, 2);
        _n(Je, () => x(ft), (st, it) => {
            it(st, {
                get this() {
                    return Ne()
                },
                class: "mr-1 size-5 max-sm:hidden"
            })
        }
        );
        var Be = V(Je);
        A(ht),
        Ge( () => {
            zr(Xe, "aria-label", Ee()),
            ct !== (ct = Oe()) && (Xe.value = (Xe.__value = Oe()) ?? ""),
            fe(Be, ` ${Ee() ?? ""}`)
        }
        ),
        Vd(_, [], Xe, () => (Oe(),
        x(O)), st => oe(O, st)),
        H(we, ht)
    }
    ),
    A(W);
    var ie = V(W, 2)
      , pe = k(ie);
    sm(pe, {
        get value() {
            return x(C)
        },
        set value(we) {
            oe(C, we, !0)
        }
    }),
    A(ie);
    var ye = V(ie, 2);
    {
        var X = we => {
            var Re = u8()
              , ke = k(Re)
              , Oe = V(ke);
            {
                var Ee = ft => {
                    var ht = Fn();
                    Ge(Xe => fe(ht, Xe), [ () => Wd().toLowerCase()]),
                    H(ft, ht)
                }
                  , Ne = ft => {
                    var ht = Jt()
                      , Xe = zt(ht);
                    {
                        var ct = Be => {
                            var st = Fn();
                            Ge(it => fe(st, it), [ () => Qf()]),
                            H(Be, st)
                        }
                          , Je = Be => {
                            var st = Jt()
                              , it = zt(st);
                            {
                                var Qe = Ae => {
                                    var vt = Fn();
                                    Ge(Q => fe(vt, Q), [ () => em()]),
                                    H(Ae, vt)
                                }
                                ;
                                Ue(it, Ae => {
                                    x(C) === "month" && Ae(Qe)
                                }
                                , !0)
                            }
                            H(Be, st)
                        }
                        ;
                        Ue(Xe, Be => {
                            x(C) === "week" ? Be(ct) : Be(Je, !1)
                        }
                        , !0)
                    }
                    H(ft, ht)
                }
                ;
                Ue(Oe, ft => {
                    x(C) === "today" ? ft(Ee) : ft(Ne, !1)
                }
                )
            }
            A(Re),
            Ge(ft => fe(ke, `${ft ?? ""} `), [ () => Jf()]),
            H(we, Re)
        }
          , Se = we => {
            var Re = Jt()
              , ke = zt(Re);
            {
                var Oe = Ne => {
                    var ft = Jt()
                      , ht = zt(ft);
                    {
                        var Xe = Je => {
                            const Be = lt( () => x(o));
                            var st = f8()
                              , it = k(st)
                              , Qe = k(it)
                              , Ae = V(k(Qe))
                              , vt = k(Ae, !0);
                            A(Ae);
                            var Q = V(Ae)
                              , te = k(Q)
                              , _e = V(te, 2, !0);
                            A(Q),
                            A(Qe),
                            A(it);
                            var ne = V(it);
                            nn(ne, 31, () => x(Be), Pe => Pe.id, (Pe, Me, at) => {
                                const We = lt( () => {
                                    var ur;
                                    return ((ur = Dt.data) == null ? void 0 : ur.id) === x(Me).id
                                }
                                );
                                var Ct = p8();
                                let _t;
                                var xt = k(Ct)
                                  , tt = k(xt, !0);
                                A(xt);
                                var pt = V(xt)
                                  , It = k(pt)
                                  , ut = k(It);
                                es(ut, {
                                    class: "size-10 border",
                                    get userId() {
                                        return x(Me).id
                                    },
                                    get pictureUrl() {
                                        return x(Me).picture
                                    }
                                });
                                var bt = V(ut, 2)
                                  , wt = k(bt)
                                  , dt = k(wt)
                                  , Lt = V(dt)
                                  , Xt = k(Lt);
                                A(Lt),
                                A(wt);
                                var Yt = V(wt, 2);
                                {
                                    var nr = ur => {
                                        const Mr = lt( () => ds(x(Me).equippedFlag));
                                        var Ar = h8()
                                          , kr = k(Ar, !0);
                                        A(Ar),
                                        Ge( () => {
                                            zr(Ar, "data-tip", x(Mr).name),
                                            fe(kr, x(Mr).flag)
                                        }
                                        ),
                                        H(ur, Ar)
                                    }
                                    ;
                                    Ue(Yt, ur => {
                                        "equippedFlag"in x(Me) && x(Me).equippedFlag && ur(nr)
                                    }
                                    )
                                }
                                var ar = V(Yt, 2);
                                {
                                    var Ft = ur => {
                                        ph(ur, {
                                            get username() {
                                                return x(Me).discord
                                            }
                                        })
                                    }
                                    ;
                                    Ue(ar, ur => {
                                        x(Me).discord && ur(Ft)
                                    }
                                    )
                                }
                                var dr = V(ar, 2);
                                {
                                    var _r = ur => {
                                        var Mr = d8()
                                          , Ar = k(Mr, !0);
                                        A(Mr),
                                        Ge( (kr, Nr) => {
                                            Or(Mr, 1, `badge badge-sm ml-0.5 border-0 ${kr ?? ""} ${Nr ?? ""}`),
                                            fe(Ar, x(Me).allianceName)
                                        }
                                        , [ () => Kf(x(Me).allianceId), () => Zn(x(Me).allianceId)]),
                                        H(ur, Mr)
                                    }
                                    ;
                                    Ue(dr, ur => {
                                        "allianceName"in x(Me) && x(Me).allianceName && ur(_r)
                                    }
                                    )
                                }
                                A(bt),
                                A(It),
                                A(pt);
                                var Ir = V(pt)
                                  , jr = k(Ir, !0);
                                A(Ir),
                                A(Ct),
                                Ge( (ur, Mr, Ar) => {
                                    _t = Or(Ct, 1, "", null, _t, ur),
                                    fe(tt, x(at) + 1),
                                    Or(wt, 1, `font-semibold max-sm:ml-2 ${Mr ?? ""} flex gap-1`),
                                    fe(dt, `${x(Me).name ?? ""} `),
                                    fe(Xt, `#${x(Me).id ?? ""}`),
                                    fe(jr, Ar)
                                }
                                , [ () => ({
                                    "bg-base-200": x(We)
                                }), () => Zn(x(Me).id), () => x(Me).pixelsPainted.toLocaleString("en-US")]),
                                Zo(Ct, () => $o, () => ({
                                    duration: 200
                                })),
                                H(Pe, Ct)
                            }
                            ),
                            A(ne),
                            A(st),
                            Ge( (Pe, Me, at) => {
                                fe(vt, Pe),
                                fe(te, `${Me ?? ""} `),
                                fe(_e, at)
                            }
                            , [ () => tm(), () => Ql(), () => ec().toLowerCase()]),
                            H(Je, st)
                        }
                          , ct = Je => {
                            var Be = Jt()
                              , st = zt(Be);
                            {
                                var it = Qe => {
                                    var Ae = _8()
                                      , vt = k(Ae)
                                      , Q = k(vt)
                                      , te = V(k(Q))
                                      , _e = k(te, !0);
                                    A(te);
                                    var ne = V(te)
                                      , Pe = k(ne)
                                      , Me = V(Pe, 2, !0);
                                    A(ne),
                                    A(Q),
                                    A(vt);
                                    var at = V(vt);
                                    nn(at, 31, () => x(o), We => We.id, (We, Ct, _t) => {
                                        const xt = lt( () => {
                                            var Yt;
                                            return ((Yt = Dt.data) == null ? void 0 : Yt.allianceId) === x(Ct).id
                                        }
                                        );
                                        var tt = m8();
                                        let pt;
                                        var It = k(tt)
                                          , ut = k(It, !0);
                                        A(It);
                                        var bt = V(It)
                                          , wt = k(bt)
                                          , dt = k(wt, !0);
                                        A(wt),
                                        A(bt);
                                        var Lt = V(bt)
                                          , Xt = k(Lt, !0);
                                        A(Lt),
                                        A(tt),
                                        Ge( (Yt, nr, ar) => {
                                            pt = Or(tt, 1, "", null, pt, Yt),
                                            fe(ut, x(_t) + 1),
                                            Or(wt, 1, `font-semibold ${nr ?? ""}`),
                                            fe(dt, x(Ct).name),
                                            fe(Xt, ar)
                                        }
                                        , [ () => ({
                                            "bg-base-200": x(xt)
                                        }), () => Zn(x(Ct).id), () => x(Ct).pixelsPainted.toLocaleString("en-US")]),
                                        Zo(tt, () => $o, () => ({
                                            duration: 200
                                        })),
                                        H(We, tt)
                                    }
                                    ),
                                    A(at),
                                    A(Ae),
                                    Ge( (We, Ct, _t) => {
                                        fe(_e, We),
                                        fe(Pe, `${Ct ?? ""} `),
                                        fe(Me, _t)
                                    }
                                    , [ () => Gd(), () => Ql(), () => ec().toLowerCase()]),
                                    H(Qe, Ae)
                                }
                                ;
                                Ue(st, Qe => {
                                    x(O) === "alliances" && Qe(it)
                                }
                                , !0)
                            }
                            H(Je, Be)
                        }
                        ;
                        Ue(ht, Je => {
                            x(O) === "players" ? Je(Xe) : Je(ct, !1)
                        }
                        )
                    }
                    H(Ne, ft)
                }
                  , Ee = Ne => {
                    var ft = g8();
                    H(Ne, ft)
                }
                ;
                Ue(ke, Ne => {
                    x(o) ? Ne(Oe) : Ne(Ee, !1)
                }
                , !0)
            }
            H(we, Re)
        }
        ;
        Ue(ye, we => {
            x(o) && x(o).length === 0 ? we(X) : we(Se, !1)
        }
        )
    }
    H(b, $),
    Pr()
}
var x8 = Ie('<div class="mt-5"><!></div>')
  , b8 = Ie('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function w8(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15);
    const C = lt( () => ds(l.region.countryId));
    Ii( () => {
        const we = Re => {
            Re.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", we),
        () => document.removeEventListener("keydown", we)
    }
    );
    var L = b8()
      , O = k(L)
      , T = V(k(O), 2)
      , o = k(T)
      , $ = k(o, !0);
    A(o);
    var W = V(o, 2)
      , ie = k(W, !0);
    A(W);
    var pe = V(W, 2)
      , ye = k(pe);
    A(pe),
    A(T);
    var X = V(T, 2);
    {
        var Se = we => {
            var Re = x8()
              , ke = k(Re);
            y8(ke, {
                get regionId() {
                    return l.region.id
                }
            }),
            A(Re),
            En(2, Re, () => Qn, () => ({
                duration: 300
            })),
            H(we, Re)
        }
        ;
        Ue(X, we => {
            _() && we(Se)
        }
        )
    }
    A(O),
    fi(2),
    A(L),
    On(L, () => we => {
        Zr( () => {
            _() ? we.show() : we.close()
        }
        )
    }
    ),
    Ge(we => {
        Or(T, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${we ?? ""}`),
        zr(o, "data-tip", x(C).name),
        fe($, x(C).flag),
        fe(ie, l.region.name),
        fe(ye, `#${l.region.number ?? ""}`)
    }
    , [ () => Zn(l.region.cityId)]),
    an("close", L, () => _(!1)),
    H(b, L),
    Pr()
}
var T8 = Tr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');
function C8(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = T8();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var S8 = Tr('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');
function P8(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = S8();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var I8 = Tr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>')
  , M8 = Tr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');
function A8(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var C = Jt()
      , L = zt(C);
    {
        var O = o => {
            var $ = I8();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
          , T = o => {
            var $ = M8();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
        ;
        Ue(L, o => {
            l.filled ? o(O) : o(T, !1)
        }
        )
    }
    H(b, C)
}
var k8 = (b, l, _, C, L) => {
    if (x(l) && x(_)) {
        const O = x(l) - x(_).clientHeight
          , T = x(l) / 2 - O / 2;
        C.map.flyTo({
            center: {
                lat: x(L).center[0],
                lng: x(L).center[1]
            },
            zoom: 17.5,
            offset: [0, -T]
        })
    }
}
  , E8 = (b, l, _) => l.onclickregion(x(_))
  , z8 = Ie('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>')
  , L8 = Ie('<div class="skeleton h-5 w-16"></div>')
  , D8 = Ie('<div class="skeleton mt-1 h-5 w-32"></div>')
  , R8 = Ie('<span class="font-flag tooltip ml-0.5"> </span>')
  , B8 = Ie("<span> </span>")
  , F8 = (b, l) => {
    l("report-user")
}
  , O8 = Ie("<li><button><!> </button></li>")
  , N8 = (b, l) => {
    l("timeout")
}
  , j8 = Ie("<li><button><!> </button></li>")
  , q8 = (b, l) => {
    l("ban")
}
  , V8 = Ie("<li><button><!> </button></li>")
  , U8 = async (b, l, _, C, L, O) => {
    oe(l, !0);
    try {
        await ni.banAllianceUser(x(_).id),
        await C({
            ...x(L),
            season: O.season
        })
    } catch (T) {
        qr.error(T.message)
    } finally {
        oe(l, !1)
    }
}
  , Z8 = Ie('<li><button class="text-error font-medium"><!> </button></li>')
  , $8 = Ie('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>')
  , G8 = Ie('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!></div> <!></div>')
  , H8 = (b, l) => l.onclickpaint(l.latLon)
  , W8 = async (b, l, _, C) => {
    try {
        oe(l, !0),
        x(_) ? (await ni.deleteFavoriteLocation(x(_).id),
        qr.warning(aC())) : (await ni.favoriteLocation(x(C).center),
        qr.success(lC())),
        pa.smallPlop.play(),
        Dt.refresh()
    } catch (L) {
        qr.error(L.message)
    } finally {
        oe(l, !1)
    }
}
  , X8 = Ie("<button><!> </button>")
  , K8 = (b, l, _) => l.onclickshare(MP(La.url, {
    pos: {
        lat: x(_).center[0],
        lng: x(_).center[1]
    },
    zoom: l.zoom
}))
  , Y8 = Ie('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><button class="btn btn-primary"><!> </button> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');
function J8(b, l) {
    Sr(l, !0);
    let _ = nt(void 0);
    const C = lt( () => new hc(l.tileSize));
    let L = nt(void 0)
      , O = nt(void 0)
      , T = nt(!1)
      , o = nt(!1);
    const $ = lt( () => {
        var tt, pt, It;
        return !!((pt = (tt = x(_)) == null ? void 0 : tt.paintedBy) != null && pt.id) && ((It = Dt.data) == null ? void 0 : It.id) === x(_).paintedBy.id
    }
    )
      , W = lt( () => {
        const [tt,pt] = l.latLon ?? [0, 0]
          , It = x(C).latLonToPixelBoundsLatLon(tt, pt, l.pixelArtZoom)
          , ut = im(It)
          , {tile: bt, pixel: wt} = x(C).latLonToTileAndPixel(tt, pt, l.pixelArtZoom)
          , dt = x(C).latLonToRegionAndPixel(tt, pt, l.pixelArtZoom);
        return {
            bounds: It,
            center: ut,
            tile: bt,
            pixel: wt,
            regionPixel: dt.pixel
        }
    }
    );
    Zr( () => {
        pa.plop.play(),
        l.crosshair.clearAndPlace(l.latLon)
    }
    );
    let ie = 0;
    const pe = ({pixel: tt, tile: pt, season: It}) => `s${It}:p(${tt[0]},${tt[1]}):t(${pt[0]},${pt[1]})`;
    let ye;
    dc( () => [x(W), l.season], () => {
        const tt = {
            ...x(W),
            season: l.season
        }
          , pt = pe(tt);
        if (oe(_, l.pixelInfoCache.get(pt), !0),
        x(_) !== void 0)
            return;
        l.pixelInfoCache.size === 0 && (ie = 0),
        ie++,
        ie > 6 ? (clearTimeout(ye),
        ye = setTimeout(async () => X(tt), 500)) : X(tt)
    }
    );
    async function X(tt) {
        const pt = await ni.getPixelInfo(tt);
        if (pt.paintedBy !== void 0) {
            const ut = pe(tt);
            l.pixelInfoCache.set(ut, pt)
        }
        const It = pe({
            ...x(W),
            season: l.season
        });
        return oe(_, l.pixelInfoCache.get(It), !0),
        pt
    }
    function Se() {
        l.crosshair.clear(),
        pa.smallPlop.play(),
        l.onclose()
    }
    Ii( () => {
        const tt = pt => {
            pt.key === "Escape" && Se()
        }
        ;
        return document.addEventListener("keydown", tt),
        () => document.removeEventListener("keydown", tt)
    }
    );
    const we = lt( () => {
        var bt, wt, dt, Lt, Xt, Yt, nr;
        const tt = []
          , pt = (wt = (bt = Dt) == null ? void 0 : bt.data) == null ? void 0 : wt.role;
        Cu(pt, ["admin"]) && !x($) && tt.push("ban-user"),
        Cu(pt, ["admin", "global_moderator", "moderator"]) && !x($) && tt.push("timeout-user"),
        ((((Lt = (dt = Dt) == null ? void 0 : dt.data) == null ? void 0 : Lt.id) ?? Number.MAX_SAFE_INTEGER) <= 2e6 || Cu(pt, ["admin", "moderator", "global_moderator"])) && !x($) && tt.push("report-user");
        const ut = (Xt = x(_)) == null ? void 0 : Xt.paintedBy;
        return (ut == null ? void 0 : ut.allianceId) === ((Yt = Dt.data) == null ? void 0 : Yt.allianceId) && ((nr = Dt.data) == null ? void 0 : nr.allianceRole) === "admin" && Dt.data.id !== (ut == null ? void 0 : ut.id) && !x($) && tt.push("ban-alliance"),
        tt
    }
    );
    function Re(tt) {
        const pt = (async () => await av(l.map, {
            maxHeight: 1080,
            maxWidth: 1080,
            quality: .8,
            type: "image/jpeg"
        }))();
        l.onclickmodaction(x(_), pt, l.latLon, tt)
    }
    var ke = Y8()
      , Oe = k(ke)
      , Ee = k(Oe)
      , Ne = k(Ee);
    Ne.__click = [k8, L, O, l, W];
    var ft = k(Ne);
    Wf(ft, {
        class: "fill-primary size-5"
    }),
    A(Ne);
    var ht = V(Ne, 2)
      , Xe = k(ht)
      , ct = k(Xe);
    A(Xe);
    var Je = V(Xe, 2);
    {
        var Be = tt => {
            const pt = lt( () => x(_).region)
              , It = lt( () => ds(x(pt).countryId));
            var ut = z8();
            ut.__click = [E8, l, pt];
            var bt = k(ut)
              , wt = k(bt, !0);
            A(bt);
            var dt = V(bt, 2)
              , Lt = k(dt, !0);
            A(dt);
            var Xt = V(dt, 2)
              , Yt = k(Xt);
            A(Xt),
            A(ut),
            Ge(nr => {
                Or(ut, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${nr ?? ""}`),
                zr(bt, "data-tip", x(It).name),
                fe(wt, x(It).flag),
                fe(Lt, x(pt).name),
                fe(Yt, `#${x(pt).number ?? ""}`)
            }
            , [ () => Zn(x(pt).cityId)]),
            H(tt, ut)
        }
          , st = tt => {
            var pt = L8();
            H(tt, pt)
        }
        ;
        Ue(Je, tt => {
            var pt;
            (pt = x(_)) != null && pt.region ? tt(Be) : tt(st, !1)
        }
        )
    }
    A(ht),
    A(Ee);
    var it = V(Ee, 2);
    it.__click = Se;
    var Qe = k(it);
    fc(Qe, {
        class: "size-4"
    }),
    A(it),
    A(Oe);
    var Ae = V(Oe, 2)
      , vt = k(Ae);
    {
        var Q = tt => {
            var pt = D8();
            H(tt, pt)
        }
          , te = tt => {
            var pt = Jt()
              , It = zt(pt);
            {
                var ut = wt => {
                    var dt = Fn();
                    Ge(Lt => fe(dt, Lt), [ () => h3()]),
                    H(wt, dt)
                }
                  , bt = wt => {
                    const dt = lt( () => x(_).paintedBy);
                    var Lt = G8()
                      , Xt = k(Lt)
                      , Yt = k(Xt);
                    A(Xt);
                    var nr = V(Xt, 2)
                      , ar = k(nr);
                    es(ar, {
                        class: "size-5 border-0",
                        get userId() {
                            return x(dt).id
                        },
                        get pictureUrl() {
                            return x(dt).picture
                        }
                    }),
                    A(nr);
                    var Ft = V(nr, 2)
                      , dr = k(Ft)
                      , _r = k(dr)
                      , Ir = k(_r, !0);
                    A(_r);
                    var jr = V(_r, 2)
                      , ur = k(jr);
                    A(jr),
                    A(dr);
                    var Mr = V(dr, 2);
                    {
                        var Ar = K => {
                            const le = lt( () => ds(x(dt).equippedFlag));
                            var ve = R8()
                              , Le = k(ve, !0);
                            A(ve),
                            Ge( () => {
                                zr(ve, "data-tip", x(le).name),
                                fe(Le, x(le).flag)
                            }
                            ),
                            H(K, ve)
                        }
                        ;
                        Ue(Mr, K => {
                            x(dt).equippedFlag && K(Ar)
                        }
                        )
                    }
                    var kr = V(Mr, 2);
                    {
                        var Nr = K => {
                            ph(K, {
                                get username() {
                                    return x(dt).discord
                                }
                            })
                        }
                        ;
                        Ue(kr, K => {
                            x(dt).discord && K(Nr)
                        }
                        )
                    }
                    var ce = V(kr, 2);
                    {
                        var F = K => {
                            var le = B8()
                              , ve = k(le, !0);
                            A(le),
                            Ge( (Le, Ce) => {
                                Or(le, 1, `badge badge-sm ml-0.5 border-0 ${Le ?? ""} ${Ce ?? ""}`),
                                fe(ve, x(dt).allianceName)
                            }
                            , [ () => Kf(x(dt).allianceId), () => Zn(x(dt).allianceId)]),
                            H(K, le)
                        }
                        ;
                        Ue(ce, K => {
                            x(dt).allianceId && K(F)
                        }
                        )
                    }
                    A(Ft);
                    var q = V(Ft, 2);
                    {
                        var G = K => {
                            var le = $8()
                              , ve = k(le)
                              , Le = k(ve);
                            om(Le, {
                                class: "size-4"
                            }),
                            A(ve);
                            var Ce = V(ve, 2);
                            nn(Ce, 21, () => x(we), Zd, (Ze, ot) => {
                                var Ye = Jt()
                                  , Ot = zt(Ye);
                                {
                                    var xe = Pt => {
                                        var kt = O8()
                                          , Wt = k(kt);
                                        let Lr;
                                        Wt.__click = [F8, Re];
                                        var Kr = k(Wt);
                                        P8(Kr, {
                                            class: "size-5"
                                        });
                                        var Hr = V(Kr);
                                        A(Wt),
                                        A(kt),
                                        Ge( ($r, mr) => {
                                            Lr = Or(Wt, 1, "text-error py-2 font-medium", null, Lr, $r),
                                            fe(Hr, ` ${mr ?? ""}`)
                                        }
                                        , [ () => ({
                                            "cursor-not-allowed": x($)
                                        }), () => Yg()]),
                                        H(Pt, kt)
                                    }
                                      , At = Pt => {
                                        var kt = Jt()
                                          , Wt = zt(kt);
                                        {
                                            var Lr = Hr => {
                                                var $r = j8()
                                                  , mr = k($r);
                                                let gr;
                                                mr.__click = [N8, Re];
                                                var ai = k(mr);
                                                Eg(ai, {
                                                    class: "size-5"
                                                });
                                                var Tt = V(ai);
                                                A(mr),
                                                A($r),
                                                Ge( (Ci, di) => {
                                                    gr = Or(mr, 1, "text-error font-medium", null, gr, Ci),
                                                    fe(Tt, ` ${di ?? ""}`)
                                                }
                                                , [ () => ({
                                                    "cursor-not-allowed": x($)
                                                }), () => Qg()]),
                                                H(Hr, $r)
                                            }
                                              , Kr = Hr => {
                                                var $r = Jt()
                                                  , mr = zt($r);
                                                {
                                                    var gr = Tt => {
                                                        var Ci = V8()
                                                          , di = k(Ci);
                                                        let Pn;
                                                        di.__click = [q8, Re];
                                                        var Mt = k(di);
                                                        $y(Mt, {
                                                            class: "size-5"
                                                        });
                                                        var Ke = V(Mt);
                                                        A(di),
                                                        A(Ci),
                                                        Ge( (jt, Gt) => {
                                                            Pn = Or(di, 1, "text-error font-medium", null, Pn, jt),
                                                            fe(Ke, ` ${Gt ?? ""}`)
                                                        }
                                                        , [ () => ({
                                                            "cursor-not-allowed": x($)
                                                        }), () => Jg()]),
                                                        H(Tt, Ci)
                                                    }
                                                      , ai = Tt => {
                                                        var Ci = Jt()
                                                          , di = zt(Ci);
                                                        {
                                                            var Pn = Mt => {
                                                                var Ke = Z8()
                                                                  , jt = k(Ke);
                                                                jt.__click = [U8, o, dt, X, W, l];
                                                                var Gt = k(jt);
                                                                C8(Gt, {
                                                                    class: "size-5"
                                                                });
                                                                var Dr = V(Gt);
                                                                A(jt),
                                                                A(Ke),
                                                                Ge(Gr => fe(Dr, ` ${Gr ?? ""}`), [ () => Wg()]),
                                                                H(Mt, Ke)
                                                            }
                                                            ;
                                                            Ue(di, Mt => {
                                                                x(ot) === "ban-alliance" && Mt(Pn)
                                                            }
                                                            , !0)
                                                        }
                                                        H(Tt, Ci)
                                                    }
                                                    ;
                                                    Ue(mr, Tt => {
                                                        x(ot) === "ban-user" ? Tt(gr) : Tt(ai, !1)
                                                    }
                                                    , !0)
                                                }
                                                H(Hr, $r)
                                            }
                                            ;
                                            Ue(Wt, Hr => {
                                                x(ot) === "timeout-user" ? Hr(Lr) : Hr(Kr, !1)
                                            }
                                            , !0)
                                        }
                                        H(Pt, kt)
                                    }
                                    ;
                                    Ue(Ot, Pt => {
                                        x(ot) === "report-user" ? Pt(xe) : Pt(At, !1)
                                    }
                                    )
                                }
                                H(Ze, Ye)
                            }
                            ),
                            A(Ce),
                            A(le),
                            H(K, le)
                        }
                        ;
                        Ue(q, K => {
                            x(we).length > 0 && K(G)
                        }
                        )
                    }
                    A(Lt),
                    Ge( (K, le) => {
                        var ve;
                        fe(Yt, `${K ?? ""}:`),
                        Or(dr, 1, `font-medium ${le ?? ""} flex gap-1.5`),
                        fe(Ir, ((ve = Dt.data) == null ? void 0 : ve.id) === x(dt).id ? Dt.data.name : x(dt).name),
                        fe(ur, `#${x(dt).id ?? ""}`)
                    }
                    , [ () => f3(), () => Zn(x(dt).id)]),
                    H(wt, Lt)
                }
                ;
                Ue(It, wt => {
                    x(_).paintedBy.id === 0 ? wt(ut) : wt(bt, !1)
                }
                , !0)
            }
            H(tt, pt)
        }
        ;
        Ue(vt, tt => {
            x(_) === void 0 ? tt(Q) : tt(te, !1)
        }
        )
    }
    A(Ae);
    var _e = V(Ae, 2)
      , ne = k(_e);
    ne.__click = [H8, l];
    var Pe = k(ne);
    fh(Pe, {
        class: "size-4.5"
    });
    var Me = V(Pe);
    A(ne);
    var at = V(ne, 2);
    {
        var We = tt => {
            const pt = lt( () => Dt.data.favoriteLocations.find(Lt => Math.abs(Lt.latitude - x(W).center[0]) < 5e-5 && Math.abs(Lt.longitude - x(W).center[1]) < 5e-5))
              , It = lt( () => !x(pt) && Dt.data.favoriteLocations.length >= Dt.data.maxFavoriteLocations);
            var ut = X8();
            let bt;
            ut.__click = [W8, T, pt, W];
            var wt = k(ut);
            {
                let Lt = lt( () => !!x(pt));
                A8(wt, {
                    class: "size-4.5",
                    get filled() {
                        return x(Lt)
                    }
                })
            }
            var dt = V(wt);
            A(ut),
            Ge( (Lt, Xt) => {
                bt = Or(ut, 1, "btn btn-primary btn-soft", null, bt, Lt),
                ut.disabled = x(T) || x(It),
                fe(dt, ` ${Xt ?? ""}`)
            }
            , [ () => ({
                "text-yellow-400": !!x(pt)
            }), () => x(It) ? g3() : x3()]),
            H(tt, ut)
        }
        ;
        Ue(at, tt => {
            Dt.data && tt(We)
        }
        )
    }
    var Ct = V(at, 2);
    Ct.__click = [K8, l, W];
    var _t = k(Ct);
    ov(_t, {
        class: "size-4.5"
    });
    var xt = V(_t);
    A(Ct),
    A(_e),
    A(ke),
    ps(ke, tt => oe(O, tt), () => x(O)),
    Ge( (tt, pt) => {
        fe(ct, `Pixel: ${x(W).regionPixel[0] ?? ""}, ${x(W).regionPixel[1] ?? ""}`),
        ne.disabled = Dt.loading,
        fe(Me, ` ${tt ?? ""}`),
        fe(xt, ` ${pt ?? ""}`)
    }
    , [ () => Zg(), () => T3()]),
    $d("innerHeight", tt => oe(L, tt, !0)),
    H(b, ke),
    Pr()
}
Wi(["click"]);
function Q8(b) {
    var C;
    const l = document.createElement("div");
    (C = b.parentElement) == null || C.insertBefore(l, b.nextSibling);
    const _ = new IntersectionObserver(L => {
        L[0].isIntersecting ? b.classList.remove("stuck") : b.classList.add("stuck")
    }
    ,{
        threshold: 0,
        rootMargin: "0px"
    });
    return _.observe(l),
    () => {
        l.remove(),
        _.disconnect()
    }
}
var ez = Tr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>')
  , tz = Tr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');
function rz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var C = Jt()
      , L = zt(C);
    {
        var O = o => {
            var $ = ez();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
          , T = o => {
            var $ = tz();
            er($, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, $)
        }
        ;
        Ue(L, o => {
            l.filled ? o(O) : o(T, !1)
        }
        )
    }
    H(b, C)
}
var iz = Ie('<span class="loading loading-spinner center-absolute absolute"></span>')
  , nz = Ie('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>')
  , az = Ie('<span class="loading loading-spinner center-absolute absolute"></span>')
  , sz = Ie('<!> <span class="text-sm"> </span>', 1)
  , oz = Ie('<span class="text-sm"> </span>')
  , lz = Ie('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>')
  , cz = Ie('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <p class="mt-2 text-center text-xl font-bold"> </p> <!> <div><!></div></div>')
  , uz = (b, l) => {
    oe(l, !x(l))
}
  , hz = Ie('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');
function dz(b, l) {
    Sr(l, !0);
    const _ = (Ee, Ne=fa) => {
        const ft = lt( () => {
            var ne;
            return (((ne = Dt.data) == null ? void 0 : ne.droplets) ?? 0) >= T.price
        }
        )
          , ht = lt( () => x($) === Ne().id);
        var Xe = cz()
          , ct = k(Xe)
          , Je = k(ct, !0);
        A(ct);
        var Be = V(ct, 2)
          , st = k(Be, !0);
        A(Be);
        var it = V(Be, 2);
        {
            var Qe = ne => {
                hm(ne, {})
            }
            ;
            Ue(it, ne => {
                Ne().id === x(W) && ne(Qe)
            }
            )
        }
        var Ae = V(it, 2);
        let vt;
        var Q = k(Ae);
        {
            var te = ne => {
                var Pe = nz();
                Pe.__click = async () => {
                    try {
                        const _t = Ne().id;
                        oe($, _t, !0),
                        await ni.purchase({
                            id: O,
                            amount: 1,
                            variant: _t
                        }),
                        Dt.refresh(),
                        pa.notification1.play();
                        const xt = L.find(tt => tt.id === _t);
                        xt && (xt.owned = !0),
                        oe(W, _t, !0)
                    } catch (_t) {
                        qr.error(_t.message)
                    } finally {
                        oe($, void 0)
                    }
                }
                ;
                var Me = k(Pe);
                {
                    var at = _t => {
                        var xt = iz();
                        H(_t, xt)
                    }
                    ;
                    Ue(Me, _t => {
                        x(ht) && _t(at)
                    }
                    )
                }
                var We = V(Me, 2);
                Ud(We, {
                    class: "size-4"
                });
                var Ct = V(We);
                fi(),
                A(Pe),
                Ge(_t => {
                    Pe.disabled = !x(ft) || x(ht),
                    fe(Ct, ` ${_t ?? ""} `)
                }
                , [ () => T.price.toLocaleString("en-US")]),
                H(ne, Pe)
            }
              , _e = ne => {
                const Pe = lt( () => {
                    var ut;
                    return ((ut = Dt.data) == null ? void 0 : ut.equippedFlag) === Ne().id
                }
                );
                var Me = lz();
                let at;
                Me.__click = async () => {
                    try {
                        oe($, Ne().id, !0);
                        const ut = x(Pe) ? 0 : Ne().id;
                        await ni.equipFlag(ut),
                        Dt.data && (Dt.data.equippedFlag = ut),
                        Dt.refresh()
                    } catch (ut) {
                        qr.error(ut.message)
                    } finally {
                        oe($, void 0)
                    }
                }
                ;
                var We = k(Me)
                  , Ct = k(We, !0);
                A(We);
                var _t = V(We, 2);
                {
                    var xt = ut => {
                        var bt = az();
                        H(ut, bt)
                    }
                    ;
                    Ue(_t, ut => {
                        x(ht) && ut(xt)
                    }
                    )
                }
                var tt = V(_t, 2);
                {
                    var pt = ut => {
                        var bt = sz()
                          , wt = zt(bt);
                        fc(wt, {
                            class: "size-4"
                        });
                        var dt = V(wt, 2)
                          , Lt = k(dt, !0);
                        A(dt),
                        Ge(Xt => fe(Lt, Xt), [ () => d2()]),
                        H(ut, bt)
                    }
                      , It = ut => {
                        var bt = oz()
                          , wt = k(bt, !0);
                        A(bt),
                        Ge(dt => fe(wt, dt), [ () => m2()]),
                        H(ut, bt)
                    }
                    ;
                    Ue(tt, ut => {
                        x(Pe) ? ut(pt) : ut(It, !1)
                    }
                    )
                }
                A(Me),
                Ge( (ut, bt) => {
                    at = Or(Me, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, at, ut),
                    Me.disabled = x(ht),
                    fe(Ct, bt)
                }
                , [ () => ({
                    "btn-warning": x(Pe)
                }), () => c2()]),
                H(ne, Me)
            }
            ;
            Ue(Q, ne => {
                Ne().owned ? ne(_e, !1) : ne(te)
            }
            )
        }
        A(Ae),
        A(Xe),
        Ge( (ne, Pe) => {
            fe(Je, Ne().flag),
            fe(st, Ne().name),
            vt = Or(Ae, 1, "mt-3", null, vt, ne),
            zr(Ae, "data-tip", Pe)
        }
        , [ () => ({
            tooltip: !x(ft)
        }), () => Hd()]),
        H(Ee, Xe)
    }
      , C = $n.countries.map(Ee => ({
        ...Ee,
        owned: Dt.flagsBitmap.get(Ee.id)
    }));
    C.sort( (Ee, Ne) => Number(Ne.owned) - Number(Ee.owned));
    const L = zn(C)
      , O = 110
      , T = $n.products[O];
    let o = nt(!1)
      , $ = nt(void 0)
      , W = nt(void 0);
    var ie = hz()
      , pe = k(ie)
      , ye = k(pe);
    rz(ye, {
        class: "size-5.5",
        filled: !0
    }),
    fi(2),
    A(pe);
    var X = V(pe, 2)
      , Se = k(X, !0);
    A(X);
    var we = V(X, 2);
    nn(we, 23, () => L, Ee => Ee.id, (Ee, Ne, ft) => {
        var ht = Jt()
          , Xe = zt(ht);
        {
            var ct = Je => {
                _(Je, () => x(Ne))
            }
            ;
            Ue(Xe, Je => {
                (x(ft) < 8 || x(o)) && Je(ct)
            }
            )
        }
        H(Ee, ht)
    }
    ),
    A(we);
    var Re = V(we, 2)
      , ke = k(Re);
    ke.__click = [uz, o];
    var Oe = k(ke, !0);
    A(ke),
    A(Re),
    A(ie),
    Ge(Ee => {
        fe(Se, Ee),
        fe(Oe, x(o) ? "Show less" : "Show more")
    }
    , [ () => s2()]),
    H(b, ie),
    Pr()
}
Wi(["click"]);
var pz = Ie('<p class="mt-1 text-center text-sm"> </p>')
  , fz = (b, l) => {
    kg(l, -1)
}
  , mz = (b, l) => {
    kg(l)
}
  , _z = (b, l, _) => {
    l(x(_))
}
  , gz = Ie('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>')
  , vz = async (b, l, _, C) => {
    try {
        oe(l, !0),
        await ni.purchase({
            id: _.productId,
            amount: C()
        }),
        pa.notification1.play(),
        _.onpurchasecompleted(C())
    } catch (L) {
        qr.error(L.message)
    } finally {
        oe(l, !1)
    }
}
  , yz = Ie('<span class="loading loading-spinner center-absolute absolute"></span>')
  , xz = Ie('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');
function Pg(b, l) {
    Sr(l, !0);
    let _ = Et(l, "amount", 15, 1);
    const C = lt( () => _() * l.unitPrice)
      , L = lt( () => Math.floor(l.userDroplets / l.unitPrice));
    let O = nt(!1);
    Zr( () => {
        _() < 0 && _(0)
    }
    );
    var T = xz()
      , o = k(T)
      , $ = k(o);
    Ji($, () => l.icon ?? fa),
    A(o);
    var W = V(o, 2)
      , ie = k(W, !0);
    A(W);
    var pe = V(W, 2);
    {
        var ye = Be => {
            var st = pz()
              , it = k(st, !0);
            A(st),
            Ge( () => fe(it, l.subtitle)),
            H(Be, st)
        }
        ;
        Ue(pe, Be => {
            l.subtitle && Be(ye)
        }
        )
    }
    var X = V(pe, 2)
      , Se = k(X);
    Se.__click = [fz, _];
    var we = V(Se, 2);
    ea(we);
    var Re = V(we, 2);
    Re.__click = [mz, _];
    var ke = V(Re, 2);
    {
        var Oe = Be => {
            var st = gz();
            st.__click = [_z, _, L],
            H(Be, st)
        }
        ;
        Ue(ke, Be => {
            _() < x(L) && Be(Oe)
        }
        )
    }
    A(X);
    var Ee = V(X, 2);
    let Ne;
    var ft = k(Ee);
    ft.__click = [vz, O, l, _];
    var ht = k(ft);
    {
        var Xe = Be => {
            var st = yz();
            H(Be, st)
        }
        ;
        Ue(ht, Be => {
            x(O) && Be(Xe)
        }
        )
    }
    var ct = V(ht, 2);
    Ud(ct, {
        class: "size-4"
    });
    var Je = V(ct);
    fi(),
    A(ft),
    A(Ee),
    A(T),
    Ge( (Be, st, it, Qe) => {
        fe(ie, Be),
        Re.disabled = _() >= x(L),
        zr(Ee, "data-tip", st),
        Ne = Or(Ee, 1, "", null, Ne, it),
        ft.disabled = l.userDroplets < x(C) || x(O) || !_(),
        fe(Je, ` ${Qe ?? ""} `)
    }
    , [ () => l.title(_()), () => Hd(), () => ({
        tooltip: l.userDroplets < x(C)
    }), () => x(C).toLocaleString("en-US")]),
    jd(we, _),
    H(b, T),
    Pr()
}
Wi(["click"]);
var bz = Tr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');
function wz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = bz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Tz = Tr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');
function Rv(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Tz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Cz = Tr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');
function Sz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Cz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Pz = Tr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');
function Iz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Pz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Mz = Ie('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">✕</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>')
  , Az = Ie('<span class="center-absolute absolute"><!></span>')
  , kz = Ie('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);
function Ez(b, l) {
    Sr(l, !0);
    let _ = Et(l, "open", 15)
      , C = nt(void 0)
      , L = nt(zn({
        name: hg(),
        prev: 1e3,
        new: 1e5
    }));
    Ii( () => {
        const Me = at => {
            at.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", Me),
        () => document.removeEventListener("keydown", Me)
    }
    );
    const O = {
        id: 70,
        product: $n.products[70]
    }
      , T = {
        id: 80,
        product: $n.products[80]
    }
      , o = {
        product: $n.products[120]
    };
    var $ = kz()
      , W = zt($)
      , ie = k(W)
      , pe = k(ie);
    {
        var ye = Me => {
            var at = Mz()
              , We = k(at)
              , Ct = k(We)
              , _t = k(Ct);
            Rv(_t, {
                class: "size-8"
            });
            var xt = V(_t, 2)
              , tt = k(xt, !0);
            A(xt);
            var pt = V(xt, 2)
              , It = k(pt);
            {
                let Pt = lt( () => {
                    var kt;
                    return ((kt = Dt.data) == null ? void 0 : kt.droplets) ?? 0
                }
                );
                Rg(It, {
                    get value() {
                        return x(Pt)
                    }
                })
            }
            A(pt),
            fi(2),
            A(Ct),
            A(We),
            On(We, () => Q8);
            var ut = V(We, 2)
              , bt = k(ut)
              , wt = k(bt)
              , dt = k(wt);
            wz(dt, {
                class: "size-5.5",
                filled: !0
            });
            var Lt = V(dt, 2)
              , Xt = k(Lt, !0);
            A(Lt),
            A(wt);
            var Yt = V(wt, 2)
              , nr = k(Yt, !0);
            A(Yt);
            var ar = V(Yt, 2)
              , Ft = k(ar);
            {
                const Pt = Wt => {
                    Iz(Wt, {
                        class: "text-primary size-26"
                    })
                }
                ;
                let kt = lt( () => lb());
                Pg(Ft, {
                    get productId() {
                        return O.id
                    },
                    title: Wt => ab({
                        amount: O.product.items[0].amount * Wt
                    }),
                    get subtitle() {
                        return x(kt)
                    },
                    get unitPrice() {
                        return O.product.price
                    },
                    get userDroplets() {
                        return Dt.data.droplets
                    },
                    onpurchasecompleted: async Wt => {
                        var Hr, $r, mr, gr, ai;
                        const Lr = ($r = (Hr = Dt.data) == null ? void 0 : Hr.charges) == null ? void 0 : $r.max;
                        await Dt.refresh();
                        const Kr = (gr = (mr = Dt.data) == null ? void 0 : mr.charges) == null ? void 0 : gr.max;
                        Lr !== void 0 && Kr !== void 0 && (oe(L, {
                            name: hg(),
                            prev: Lr,
                            new: Kr
                        }, !0),
                        (ai = x(C)) == null || ai.show())
                    }
                    ,
                    icon: Pt,
                    $$slots: {
                        icon: !0
                    }
                })
            }
            var dr = V(Ft, 2);
            {
                const Pt = Wt => {
                    Ev(Wt, {
                        class: "text-primary my-3 size-20"
                    })
                }
                ;
                let kt = lt( () => K1());
                Pg(dr, {
                    get productId() {
                        return T.id
                    },
                    title: Wt => Jw({
                        amount: T.product.items[0].amount * Wt
                    }),
                    get subtitle() {
                        return x(kt)
                    },
                    get unitPrice() {
                        return T.product.price
                    },
                    get userDroplets() {
                        return Dt.data.droplets
                    },
                    onpurchasecompleted: async Wt => {
                        var Kr, Hr, $r;
                        const Lr = (Hr = (Kr = Dt.data) == null ? void 0 : Kr.charges) == null ? void 0 : Hr.count;
                        await Dt.refresh(),
                        Lr !== void 0 && (oe(L, {
                            name: Xw(),
                            prev: Math.floor(Lr),
                            new: Math.floor(Lr + T.product.items[0].amount * Wt)
                        }, !0),
                        ($r = x(C)) == null || $r.show())
                    }
                    ,
                    icon: Pt,
                    $$slots: {
                        icon: !0
                    }
                })
            }
            A(ar),
            A(bt);
            var _r = V(bt, 2)
              , Ir = k(_r)
              , jr = k(Ir);
            Xd(jr, {
                class: "size-5.5",
                filled: !0
            });
            var ur = V(jr, 2)
              , Mr = k(ur, !0);
            A(ur),
            A(Ir);
            var Ar = V(Ir, 2)
              , kr = k(Ar)
              , Nr = k(kr)
              , ce = k(Nr)
              , F = k(ce)
              , q = k(F);
            Bg(q, {
                get userId() {
                    return Dt.data.id
                },
                get level() {
                    return Dt.data.level
                },
                get pictureUrl() {
                    return Dt.data.picture
                }
            }),
            A(F),
            A(ce),
            A(Nr);
            var G = V(Nr, 2)
              , K = k(G, !0);
            A(G);
            var le = V(G, 2)
              , ve = k(le, !0);
            A(le);
            var Le = V(le, 2);
            let Ce;
            var Ze = k(Le)
              , ot = k(Ze)
              , Ye = k(ot);
            Ud(Ye, {
                class: "size-4"
            });
            var Ot = V(Ye);
            fi(),
            A(ot),
            A(Ze),
            A(Le),
            A(kr),
            A(Ar),
            A(_r);
            var xe = V(_r, 2)
              , At = k(xe);
            dz(At, {}),
            A(xe),
            A(ut),
            A(at),
            Ge( (Pt, kt, Wt, Lr, Kr, Hr, $r, mr, gr) => {
                fe(tt, Pt),
                fe(Xt, kt),
                fe(nr, Wt),
                fe(Mr, Lr),
                fe(K, Kr),
                fe(ve, Hr),
                zr(Le, "data-tip", $r),
                Ce = Or(Le, 1, "", null, Ce, mr),
                ot.disabled = Dt.data.droplets < o.product.price,
                fe(Ot, ` ${gr ?? ""} `)
            }
            , [ () => qg(), () => Q1(), () => rb(), () => i2(), () => hb(), () => fb(), () => Hd(), () => ({
                tooltip: Dt.data.droplets < o.product.price
            }), () => o.product.price.toLocaleString("en-US")]),
            En(2, at, () => Qn),
            H(Me, at)
        }
        ;
        Ue(pe, Me => {
            Dt.data && _() && Me(ye)
        }
        )
    }
    A(ie);
    var X = V(ie, 2)
      , Se = k(X)
      , we = k(Se, !0);
    A(Se),
    A(X),
    A(W),
    On(W, () => Me => {
        Zr( () => {
            _() ? Me.show() : Me.close()
        }
        )
    }
    );
    var Re = V(W, 2)
      , ke = k(Re)
      , Oe = k(ke)
      , Ee = k(Oe)
      , Ne = k(Ee, !0);
    A(Ee);
    var ft = V(Ee, 2)
      , ht = k(ft)
      , Xe = k(ht)
      , ct = V(Xe)
      , Je = k(ct);
    A(ct),
    A(ht);
    var Be = V(ht, 2)
      , st = k(Be);
    Sz(st, {
        class: "size-5"
    }),
    A(Be);
    var it = V(Be, 2)
      , Qe = k(it, !0);
    A(it),
    A(ft);
    var Ae = V(ft, 2)
      , vt = k(Ae)
      , Q = k(vt)
      , te = V(Q);
    Pu(te, () => x(L).new, Me => {
        var at = Az()
          , We = k(at);
        hm(We, {}),
        A(at),
        H(Me, at)
    }
    ),
    A(vt),
    A(Ae),
    A(Oe),
    A(ke);
    var _e = V(ke, 2)
      , ne = k(_e)
      , Pe = k(ne, !0);
    A(ne),
    A(_e),
    A(Re),
    ps(Re, Me => oe(C, Me), () => x(C)),
    Ge( (Me, at, We) => {
        fe(we, Me),
        fe(Ne, x(L).name),
        fe(Xe, `${x(L).prev ?? ""} `),
        fe(Je, `(+${x(L).new - x(L).prev})`),
        fe(Qe, x(L).new),
        fe(Q, `${at ?? ""} `),
        fe(Pe, We)
    }
    , [ () => tc(), () => tc(), () => tc()]),
    an("close", W, () => _(!1)),
    H(b, $),
    Pr()
}
var zz = Tr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');
function Lz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = zz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Dz = Tr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');
function Rz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Dz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Bz = Tr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');
function Fz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Bz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Oz = Tr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');
function Nz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Oz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var jz = Tr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');
function qz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = jz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Vz = Tr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');
function Uz(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Vz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
var Zz = Tr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');
function $z(b, l) {
    let _ = Qt(l, ["$$slots", "$$events", "$$legacy"]);
    var C = Zz();
    er(C, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(b, C)
}
function vf(b) {
    const l = document.createElement("img");
    return l.src = b,
    new Promise( (_, C) => {
        l.addEventListener("load", () => {
            _(l)
        }
        ),
        l.addEventListener("error", L => {
            C(L)
        }
        )
    }
    )
}
function Gz(b) {
    const l = document.createElement("canvas");
    l.width = b.naturalWidth,
    l.height = b.naturalHeight;
    const _ = l.getContext("2d");
    return _ == null || _.drawImage(b, 0, 0),
    l
}
function Hz(b, l, _) {
    return b < l ? l : b > _ ? _ : b
}
function Wz(b, l) {
    const _ = 10 ** l;
    return Math.round(b * _) / _
}
var Xz = Ie('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1)
  , Kz = (b, l) => {
    oe(l, !x(l))
}
  , Yz = Ie("<button><!></button>")
  , Jz = async (b, l, _, C) => {
    var L;
    x(l) || oe(l, await new Promise( (O, T) => {
        navigator.geolocation.getCurrentPosition(o => {
            O(o)
        }
        , o => {
            T(o)
        }
        )
    }
    )),
    x(l) && (Qa({
        lat: x(l).coords.latitude,
        lng: x(l).coords.longitude
    }, x(_)),
    (L = x(C)) == null || L.flyTo({
        center: {
            lat: x(l).coords.latitude,
            lng: x(l).coords.longitude
        },
        zoom: 16.5
    }))
}
  , Qz = Ie('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>')
  , eL = Ie('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>')
  , tL = (b, l, _, C) => {
    var L;
    oe(l, !0),
    x(_) && Qa((L = x(_)) == null ? void 0 : L.getCenter(), x(C))
}
  , rL = Ie('<button class="btn btn-primary shadow-xl"> </button>')
  , iL = Ie('<a class="badge badge-secondary absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold" target="_blank"> </a>')
  , nL = Ie('<div class="relative"><!> <!></div>')
  , aL = (b, l, _, C) => {
    var O;
    oe(l, !0);
    const L = (O = x(_)) == null ? void 0 : O.getCenter();
    L && Qa(L, x(C))
}
  , sL = Ie('<button class="btn btn-square shadow-md"><!></button>')
  , oL = (b, l) => {
    oe(l, !0)
}
  , lL = Ie('<button class="btn btn-square relative shadow-md"><!></button>')
  , cL = (b, l) => {
    oe(l, !0)
}
  , uL = Ie('<button class="btn btn-square relative shadow-md"><!></button>')
  , hL = Ie('<div class="flex flex-col items-center gap-3"><!> <!> <!> <!></div>')
  , dL = (b, l) => {
    oe(l, !x(l))
}
  , pL = Ie('<div class="flex flex-col gap-3"><button><!></button></div>')
  , fL = Ie('<div class="z-100 absolute bottom-1 left-1/2 -translate-x-1/2"><!></div>')
  , mL = (b, l) => {
    oe(l, !0)
}
  , _L = Ie('<button class="btn btn-sm btn-circle"><!></button>')
  , gL = (b, l) => {
    var _;
    (_ = x(l)) == null || _.zoomIn()
}
  , vL = (b, l) => {
    var _;
    (_ = x(l)) == null || _.zoomOut()
}
  , yL = Ie('<button class="btn btn-sm btn-circle"><!></button>')
  , xL = () => {
    window.location.replace(La.url.origin)
}
  , bL = Ie('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>')
  , wL = (b, l) => {
    x(l) && Ho.goToPrev(x(l))
}
  , TL = Ie('<button class="btn btn-sm btn-circle"><!></button>')
  , CL = Ie('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>')
  , SL = (b, l, _) => {
    var C;
    (C = x(l)) == null || C.flyTo({
        center: x(l).getCenter(),
        zoom: _
    })
}
  , PL = Ie('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>')
  , IL = Ie("<span></span>")
  , ML = Ie('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>')
  , AL = Ie('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>')
  , kL = (b, l) => {
    oe(l, {
        name: "mainMenu"
    }, !0)
}
  , EL = Ie('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>')
  , zL = Ie('<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-6wmtgk"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <!> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <div class="max-sm:hidden"><a href="https://www.twitch.tv/directory/category/wplace" class="btn btn-sm btn-circle" target="_blank" title="Livestreams"><!></a></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);
function oD(b, l) {
    Sr(l, !0);
    const _ = og
      , C = rx
      , L = new hc(C)
      , O = _ - .4
      , T = IP(La.url)
      , o = T.season ?? sg
      , $ = new Map;
    let W = nt(void 0)
      , ie = nt(14.5)
      , pe = nt(!1);
    const ye = lt( () => {
        var gt;
        return ((gt = Dt.data) == null ? void 0 : gt.id) === 401
    }
    );
    let X = nt(!1)
      , Se = nt(zn(T.select && T.pos ? {
        name: "pixelSelected",
        latLon: [T.pos.lat, T.pos.lng]
    } : {
        name: "mainMenu"
    }));
    Ii( () => {
        Re().then(vr => oe(W, vr));
        let gt = [0, 0];
        function qt(vr) {
            var _i;
            if (x(W) && x(ie) > _ + 1) {
                const {lat: Di, lng: $i} = x(W).unproject([vr.clientX, vr.clientY])
                  , Mi = L.latLonToPixels(Di, $i, _)
                  , Cr = Math.floor(Mi[0])
                  , gn = Math.floor(Mi[1]);
                if (gt[0] !== Cr || gt[1] !== gn) {
                    const tr = L.latLonToPixelBoundsLatLon(Di, $i, _)
                      , Ht = rm(tr, !0);
                    (_i = x(W).getSource(Ee)) == null || _i.setCoordinates(Ht),
                    gt = [Cr, gn]
                }
            }
        }
        return window.addEventListener("mousemove", qt),
        () => {
            var vr;
            (vr = x(W)) == null || vr.remove(),
            window.removeEventListener("mousemove", qt),
            we && clearInterval(we),
            yf()
        }
    }
    );
    let we;
    async function Re() {
        const gt = T.pos ? {
            ...T.pos,
            zoom: x(ie)
        } : await gP();
        T.zoom !== void 0 && (gt.zoom = T.zoom);
        const qt = await new Promise(Mi => {
            const Cr = new bd.Map({
                style: "https://maps.wplace.live/styles/liberty",
                center: gt,
                zoom: gt.zoom,
                container: "map",
                dragRotate: !1,
                doubleClickZoom: !1,
                pitch: 0,
                maxPitch: 0,
                attributionControl: !1
            });
            Cr.touchZoomRotate.disableRotation(),
            Cr.on("style.load", () => {
                Cr == null || Cr.setLayoutProperty("poi_transit", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("poi_r20", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("poi_r7", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("poi_r1", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("building", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("building-3d", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("landuse_pitch", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("landuse_hospital", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("landuse_school", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("landuse_residential", "visibility", "none"),
                Cr == null || Cr.setLayoutProperty("waterway_tunnel", "visibility", "none"),
                Cr == null || Cr.setFilter("water", ["all", ["!=", "brunnel", "tunnel"], ["!=", "class", "swimming_pool"]]),
                Mi(Cr)
            }
            )
        }
        );
        Oe(qt),
        Xe();
        const vr = $n.refreshIntervalMs;
        function _i() {
            let Mi = x(ie) > _ + 1.5 ? vr : 2.5 * vr;
            try {
                document.visibilityState === "visible" && Oe(qt)
            } finally {
                setTimeout(_i, Mi)
            }
        }
        we = setTimeout(_i, vr);
        let Di = x(ie);
        qt.on("zoom", () => {
            oe(ie, qt.getZoom(), !0);
            const Mi = Wz(x(ie), 1);
            Mi != Di && (x(Ae) && x(Ae).setOpacity(vt(Di)),
            Di = Mi)
        }
        );
        let $i = "default";
        return qt.on("dragstart", () => {
            const Mi = qt.getCanvas();
            $i = Mi.style.cursor,
            Mi.style.cursor = "move"
        }
        ),
        qt.on("dragend", () => {
            qt.getCanvas().style.cursor = $i
        }
        ),
        qt.on("mouseout", () => {
            ct()
        }
        ),
        qt.on("click", async Mi => {
            var ei;
            const Cr = Mi.lngLat.lat
              , gn = Mi.lngLat.lng
              , tr = [Cr, gn];
            if (x(Se).name === "paintingPixel")
                return;
            if (x(Se).name === "selectHq") {
                x(Se).hq = tr,
                (ei = x(Q)) == null || ei.clearAndPlace(tr);
                return
            }
            const Ht = qt.getZoom();
            if (Ht < O) {
                qr.info(PC());
                return
            }
            Qa({
                lat: Cr,
                lng: gn
            }, Ht),
            oe(Se, {
                name: "pixelSelected",
                latLon: tr
            }, !0)
        }
        ),
        qt
    }
    const ke = "pixel-art-layer";
    function Oe(gt) {
        const qt = window.innerWidth
          , vr = `${ix}/s${sg}/tiles/{x}/{y}.png`;
        if ($.clear(),
        !gt.style)
            return;
        gt.getSource(ke) ? gt.refreshTiles(ke) : gt.addSource(ke, {
            type: "raster",
            tiles: [vr],
            minzoom: _,
            maxzoom: _,
            tileSize: qt > 640 ? 550 : 400
        }),
        gt.getLayer(ke) || gt.addLayer({
            id: ke,
            type: "raster",
            source: ke,
            paint: {
                "raster-resampling": "nearest",
                "raster-opacity": x(Be)
            }
        })
    }
    const Ee = "pixel-hover"
      , Ne = 1e-5
      , ft = [[0, 0], [Ne, 0], [Ne, -Ne], [0, -Ne]]
      , ht = .4;
    async function Xe() {
        var gt, qt, vr, _i;
        if (!((gt = x(W)) != null && gt.getSource(Ee))) {
            const Di = Gz(await vf(mP));
            (qt = x(W)) == null || qt.addSource(Ee, {
                type: "canvas",
                canvas: Di,
                coordinates: ft
            })
        }
        (vr = x(W)) != null && vr.getLayer(Ee) || (_i = x(W)) == null || _i.addLayer({
            id: Ee,
            type: "raster",
            source: Ee,
            paint: {
                "raster-resampling": "nearest",
                "raster-opacity": ht
            }
        })
    }
    function ct() {
        var gt, qt;
        (qt = (gt = x(W)) == null ? void 0 : gt.getSource(Ee)) == null || qt.setCoordinates(ft)
    }
    let Je = nt(zn(T.opaque ?? !0))
      , Be = lt( () => x(Je) ? 1 : .1);
    Zr( () => {
        var gt;
        (gt = x(W)) != null && gt.getLayer(ke) && x(W).setPaintProperty(ke, "raster-opacity", x(Be))
    }
    );
    let st = nt(void 0)
      , it = nt(void 0)
      , Qe = nt(void 0);
    Ii( () => (navigator.permissions.query({
        name: "geolocation"
    }).then(gt => {
        gt.state === "granted" && oe(Qe, navigator.geolocation.watchPosition(qt => {
            oe(st, qt)
        }
        , qt => {
            oe(it, qt)
        }
        , {
            enableHighAccuracy: !1,
            maximumAge: 1e3,
            timeout: 6e3
        }), !0)
    }
    ),
    () => {
        x(Qe) && navigator.geolocation.clearWatch(x(Qe))
    }
    ));
    let Ae = nt(void 0);
    dc( () => [x(st), x(W)], () => {
        var gt, qt;
        if (x(st) && x(W)) {
            const vr = {
                lat: x(st).coords.latitude,
                lng: x(st).coords.longitude
            }
              , _i = vt(x(ie));
            if (!x(Ae)) {
                const Di = document.createElement("div");
                Di.classList.add("maplibregl-user-location-dot"),
                Di.classList.add("cursor-auto"),
                oe(Ae, new bd.Marker({
                    element: Di,
                    opacity: _i
                }).setLngLat(vr).addTo(x(W)))
            }
            (qt = (gt = x(Ae)) == null ? void 0 : gt.setLngLat(vr)) == null || qt.setOpacity(_i)
        }
    }
    );
    function vt(gt) {
        return gt < _ ? "1.0" : Hz((gt - _) * .2, .5, 1).toFixed(2)
    }
    let Q = nt(void 0);
    Zr( () => {
        var gt;
        x(W) && ((gt = Go( () => x(Q))) == null || gt.clear(),
        vf(dg).then(qt => {
            oe(Q, new fg({
                id: "select-crosshair",
                map: x(W),
                tileSize: C,
                zoom: _,
                img: qt,
                markerFn: () => {
                    const vr = new bd.Marker({
                        color: "#0069ff"
                    });
                    return vr.addClassName("z-20"),
                    vr
                }
            }))
        }
        ))
    }
    );
    let te = nt(void 0);
    Zr( () => {
        var gt;
        x(W) && ((gt = Go( () => x(Q))) == null || gt.clear(),
        vf(dg).then(qt => {
            oe(te, new fg({
                id: "paint-crosshair",
                map: x(W),
                tileSize: C,
                zoom: _,
                img: qt
            }))
        }
        ))
    }
    );
    let _e = nt(!1)
      , ne = nt(!1)
      , Pe = nt(!1)
      , Me = nt(!!T.newUser)
      , at = nt(!1)
      , We = nt(!!T.alliance)
      , Ct = nt(!1);
    const _t = "void-message-2";
    let xt = nt(!1);
    Zr( () => {
        const gt = localStorage.getItem(_t);
        Dt.data && !gt && (oe(xt, !0),
        localStorage.setItem(_t, "true"))
    }
    );
    let tt = nt(!1)
      , pt = nt(zn(La.url))
      , It = nt(zn({
        cityId: 0,
        countryId: 1,
        id: 0,
        name: "None",
        number: 1
    }))
      , ut = nt(!1);
    const bt = "view-rules";
    let wt = !1;
    Zr( () => {
        Dt.data && (!wt && Dt.data.pixelsPainted > 1 && (localStorage.getItem(bt) || (oe(ut, !0),
        localStorage.setItem(bt, "true"))),
        wt = !0)
    }
    );
    let dt = nt(!1);
    Zr( () => {
        var gt;
        oe(dt, !!((gt = Dt.data) != null && gt.needsPhoneVerification))
    }
    );
    let Lt = nt([])
      , Xt = lt( () => x(ie) < O ? "1.0" : x(ie) < O + 2 ? "0.5" : "0.3");
    Zr( () => {
        var qt;
        const gt = (qt = Dt.data) == null ? void 0 : qt.favoriteLocations;
        if (gt && x(W)) {
            for (const vr of Go( () => x(Lt)))
                vr.remove();
            oe(Lt, gt.map(vr => {
                const _i = document.createElement("div");
                _i.classList.add("text-yellow-400"),
                _i.classList.add("cursor-pointer"),
                _i.classList.add("z-10"),
                _i.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
                const Di = {
                    lat: vr.latitude,
                    lng: vr.longitude
                };
                return _i.addEventListener("click", Mi => {
                    Mi.stopPropagation(),
                    Yt([vr.latitude, vr.longitude])
                }
                ),
                new bd.Marker({
                    element: _i,
                    opacity: x(Xt)
                }).setLngLat(Di).addTo(x(W))
            }
            ))
        }
    }
    );
    function Yt(gt) {
        var vr;
        const qt = {
            lat: gt[0],
            lng: gt[1]
        };
        (vr = x(W)) == null || vr.flyTo({
            center: qt,
            zoom: Math.max(x(ie), 15)
        }),
        Qa(qt, x(ie)),
        oe(Se, {
            name: "pixelSelected",
            latLon: [qt.lat, qt.lng]
        }, !0)
    }
    Zr( () => {
        if (x(Se).name === "paintingPixel")
            for (const gt of x(Lt))
                gt.addClassName("hidden");
        else
            for (const gt of x(Lt))
                gt.removeClassName("hidden"),
                gt.setOpacity(x(Xt))
    }
    );
    let nr = Number.MAX_VALUE;
    Zr( () => {
        if (Dt.charges !== void 0 && Dt.data) {
            const gt = Dt.data.charges.max
              , qt = Dt.charges;
            nr < gt && qt >= gt && pa.notification1.play(),
            nr = Dt.charges
        }
    }
    );
    let ar = nt(!1)
      , Ft = Date.now();
    Ii( () => {
        const gt = PP()
          , qt = () => {
            var _i;
            if (!document.hidden && Date.now() - Ft > 30 * Yl.min) {
                if (gt) {
                    const $i = (_i = x(W)) == null ? void 0 : _i.getCenter();
                    $i && Qa($i, x(ie)),
                    window.location.replace(La.url.origin)
                } else
                    Dt.refresh();
                Ft = Date.now()
            }
        }
        ;
        return document.addEventListener("visibilitychange", qt),
        () => document.removeEventListener("visibilitychange", qt)
    }
    ),
    Ii( () => {
        function gt() {
            ni.online = !0
        }
        window.addEventListener("online", gt);
        function qt() {
            ni.online = !1
        }
        return window.addEventListener("offline", qt),
        () => {
            window.removeEventListener("online", gt),
            window.removeEventListener("offline", qt)
        }
    }
    ),
    Zr( () => {
        if (!ni.online) {
            const gt = setInterval( () => {
                ni.health().then( () => {
                    ni.online = !0,
                    !Dt.data && !Dt.loading && Dt.refresh()
                }
                )
            }
            , 5e3);
            return () => {
                clearInterval(gt)
            }
        }
    }
    ),
    Ii( () => {
        function gt(qt) {
            qt.data.type && x(W) && Oe(x(W))
        }
        return navigator.serviceWorker.addEventListener("message", gt),
        () => {
            navigator.serviceWorker.removeEventListener("message", gt)
        }
    }
    );
    let dr = nt(!1)
      , _r = nt("report-user")
      , Ir = nt(void 0)
      , jr = nt(void 0)
      , ur = nt(void 0)
      , Mr = nt(0);
    var Ar = zL();
    Vy(gt => {
        var qt = Xz();
        qy.title = "Wplace - Paint the world",
        fi(6),
        H(gt, qt)
    }
    );
    var kr = zt(Ar);
    {
        const gt = tr => {
            var Ht = Yz();
            Ht.__click = [Kz, Je];
            var ei = k(Ht);
            {
                let ri = lt( () => !x(Je));
                zv(ei, {
                    class: "size-5",
                    get filled() {
                        return x(ri)
                    }
                })
            }
            A(Ht),
            Ge(ri => {
                zr(Ht, "title", ri),
                Or(Ht, 1, Vo({
                    "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
                    "text-base-content/80": x(Je),
                    "btn-primary btn-soft": !x(Je)
                }))
            }
            , [ () => Ug()]),
            H(tr, Ht)
        }
          , qt = tr => {
            var Ht = eL();
            Ht.__click = [Jz, st, ie, W];
            var ei = k(Ht);
            {
                var ri = ci => {
                    Nz(ci, {
                        class: "size-5.5 fill-blue-800"
                    })
                }
                  , gi = ci => {
                    var pi = Qz()
                      , Er = k(pi);
                    Fz(Er, {
                        class: "size-5.5 fill-red-400"
                    }),
                    fi(2),
                    A(pi),
                    H(ci, pi)
                }
                ;
                Ue(ei, ci => {
                    x(st) ? ci(ri) : ci(gi, !1)
                }
                )
            }
            A(Ht),
            Ge(ci => zr(Ht, "title", ci), [ () => h1()]),
            H(tr, Ht)
        }
        ;
        var Nr = V(k(kr), 2);
        let vr;
        var ce = k(Nr);
        let _i;
        var F = k(ce);
        {
            var q = tr => {
                var Ht = rL();
                Ht.__click = [tL, _e, W, ie];
                var ei = k(Ht, !0);
                A(Ht),
                Ge(ri => fe(ei, ri), [ () => kx()]),
                H(tr, Ht)
            }
              , G = tr => {
                var Ht = Jt()
                  , ei = zt(Ht);
                {
                    var ri = gi => {
                        var ci = nL()
                          , pi = k(ci);
                        {
                            var Er = ui => {
                                var Jr = iL()
                                  , ti = k(Jr, !0);
                                A(Jr),
                                Ge( () => {
                                    var yr;
                                    zr(Jr, "href", `${La.url.origin ?? ""}/moderation`),
                                    fe(ti, ((yr = Dt.data) == null ? void 0 : yr.role) === "admin" ? "ADMIN" : "MOD")
                                }
                                ),
                                H(ui, Jr)
                            }
                            ;
                            Ue(pi, ui => {
                                var Jr;
                                Cu((Jr = Dt.data) == null ? void 0 : Jr.role, ["admin", "moderator", "global_moderator"]) && ui(Er)
                            }
                            )
                        }
                        var Ri = V(pi, 2);
                        t8(Ri, {
                            get user() {
                                return Dt
                            },
                            onlogout: () => {
                                oe(Se, {
                                    name: "mainMenu"
                                }, !0)
                            }
                            ,
                            onclickleaderboard: () => {
                                oe(Pe, !0)
                            }
                            ,
                            onclickshop: () => {
                                var Jr;
                                oe(ne, !0);
                                const ui = (Jr = x(W)) == null ? void 0 : Jr.getCenter();
                                ui && Qa(ui, x(ie))
                            }
                        }),
                        A(ci),
                        En(3, ci, () => Qn, () => ({
                            duration: 150
                        })),
                        H(gi, ci)
                    }
                    ;
                    Ue(ei, gi => {
                        Dt.data && x(W) && x(Se).name !== "paintingPixel" && gi(ri)
                    }
                    , !0)
                }
                H(tr, Ht)
            }
            ;
            Ue(F, tr => {
                !Dt.loading && !Dt.data ? tr(q) : tr(G, !1)
            }
            )
        }
        var K = V(F, 2);
        {
            var le = tr => {
                var Ht = hL()
                  , ei = k(Ht);
                {
                    var ri = Ri => {
                        _f(Ri, {
                            key: "shop-profile-picture",
                            children: (ui, Jr) => {
                                var ti = sL();
                                ti.__click = [aL, ne, W, ie];
                                var yr = k(ti);
                                Rv(yr, {
                                    class: "size-5"
                                }),
                                A(ti),
                                Ge(on => zr(ti, "title", on), [ () => qg()]),
                                H(ui, ti)
                            }
                            ,
                            $$slots: {
                                default: !0
                            }
                        })
                    }
                    ;
                    Ue(ei, Ri => {
                        Dt.data && Ri(ri)
                    }
                    )
                }
                var gi = V(ei, 2);
                {
                    var ci = Ri => {
                        var ui = lL();
                        ui.__click = [oL, We];
                        var Jr = k(ui);
                        Kd(Jr, {
                            class: "size-5"
                        }),
                        A(ui),
                        Ge(ti => zr(ui, "title", ti), [ () => Gd()]),
                        H(Ri, ui)
                    }
                    ;
                    Ue(gi, Ri => {
                        Dt.data && Ri(ci)
                    }
                    )
                }
                var pi = V(gi, 2);
                l8(pi, {
                    get map() {
                        return x(W)
                    },
                    get season() {
                        return o
                    }
                });
                var Er = V(pi, 2);
                _f(Er, {
                    key: "region-leaderboard",
                    children: (Ri, ui) => {
                        var Jr = uL();
                        Jr.__click = [cL, Pe];
                        var ti = k(Jr);
                        Mv(ti, {
                            class: "size-5"
                        }),
                        A(Jr),
                        Ge(yr => zr(Jr, "title", yr), [ () => Yf()]),
                        H(Ri, Jr)
                    }
                    ,
                    $$slots: {
                        default: !0
                    }
                }),
                A(Ht),
                En(3, Ht, () => Qn, () => ({
                    duration: 150
                })),
                H(tr, Ht)
            }
              , ve = tr => {
                var Ht = Jt()
                  , ei = zt(Ht);
                {
                    var ri = gi => {
                        var ci = pL()
                          , pi = k(ci);
                        let Er;
                        pi.__click = [dL, pe];
                        var Ri = k(pi);
                        {
                            var ui = ti => {
                                Gf(ti, {
                                    class: "size-5"
                                })
                            }
                              , Jr = ti => {
                                Ld(ti, {
                                    class: "size-5"
                                })
                            }
                            ;
                            Ue(Ri, ti => {
                                x(pe) ? ti(ui) : ti(Jr, !1)
                            }
                            )
                        }
                        A(pi),
                        A(ci),
                        Ge( (ti, yr) => {
                            zr(pi, "title", ti),
                            Er = Or(pi, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, Er, yr)
                        }
                        , [ () => x(pe) ? Nx() : Vx(), () => ({
                            "btn-primary": x(pe)
                        })]),
                        En(1, ci, () => Qn, () => ({
                            delay: 150,
                            duration: 150
                        })),
                        H(gi, ci)
                    }
                    ;
                    Ue(ei, gi => {
                        x(W) && x(Se).name === "paintingPixel" && gi(ri)
                    }
                    , !0)
                }
                H(tr, Ht)
            }
            ;
            Ue(K, tr => {
                x(W) && x(Se).name !== "paintingPixel" ? tr(le) : tr(ve, !1)
            }
            )
        }
        A(ce),
        A(Nr);
        var Le = V(Nr, 2);
        {
            var Ce = tr => {
                var Ht = fL()
                  , ei = k(Ht);
                {
                    let ri = lt( () => nx.trim());
                    console.log(x(ri));
                    xx(ei, {
                        get siteKey() {
                            return x(ri)
                        },
                        refreshExpired: "auto",
                        appearance: "interaction-only",
                        callback: gi => {
                            oa.captcha = {
                                token: gi,
                                time: Date.now()
                            }
                        }
                    })
                }
                A(Ht),
                En(2, Ht, () => Qn, () => ({
                    duration: 300
                })),
                H(tr, Ht)
            }
            ;
            Ue(Le, tr => {
                (!oa.captcha || oa.now - oa.captcha.time > 180 * 1e3) && tr(Ce)
            }
            )
        }
        var Ze = V(Le, 2);
        let Di;
        var ot = k(Ze);
        {
            var Ye = tr => {
                _f(tr, {
                    key: "info",
                    children: (Ht, ei) => {
                        var ri = _L();
                        ri.__click = [mL, at];
                        var gi = k(ri);
                        Rz(gi, {
                            class: "size-3.5"
                        }),
                        A(ri),
                        Ge(ci => zr(ri, "title", ci), [ () => $x()]),
                        H(Ht, ri)
                    }
                    ,
                    $$slots: {
                        default: !0
                    }
                })
            }
            ;
            Ue(ot, tr => {
                x(Se).name !== "paintingPixel" && tr(Ye)
            }
            )
        }
        var Ot = V(ot, 2)
          , xe = k(Ot);
        xe.__click = [gL, W];
        var At = V(xe, 2);
        At.__click = [vL, W],
        A(Ot);
        var Pt = V(Ot, 2)
          , kt = k(Pt)
          , Wt = k(kt);
        jg(Wt, {
            class: "size-4"
        }),
        A(kt),
        A(Pt);
        var Lr = V(Pt, 2);
        {
            var Kr = tr => {
                var Ht = yL()
                  , ei = k(Ht);
                $z(ei, {
                    class: "size-4",
                    onclick: () => {
                        oe(X, !x(X))
                    }
                }),
                A(Ht),
                Ge(ri => zr(Ht, "title", ri), [ () => Fb()]),
                H(tr, Ht)
            }
            ;
            Ue(Lr, tr => {
                x(ye) && tr(Kr)
            }
            )
        }
        var Hr = V(Lr, 2);
        {
            var $r = tr => {
                var Ht = bL();
                Ht.__click = [xL];
                var ei = k(Ht);
                wx(ei, {
                    class: "size-3"
                }),
                A(Ht),
                Ge(ri => zr(Ht, "title", ri), [ () => Tx()]),
                H(tr, Ht)
            }
            ;
            Ue(Hr, tr => {
                x(Se).name !== "paintingPixel" && tr($r)
            }
            )
        }
        var mr = V(Hr, 2);
        {
            var gr = tr => {
                var Ht = TL();
                Ht.__click = [wL, W];
                var ei = k(Ht);
                Uz(ei, {
                    class: "size-3"
                }),
                A(Ht),
                Ge( (ri, gi) => {
                    zr(Ht, "title", ri),
                    Ht.disabled = gi
                }
                , [ () => e1(), () => !Ho.hasPrev()]),
                En(1, Ht, () => Qn, () => ({
                    delay: 1e3,
                    duration: 300
                })),
                En(2, Ht, () => Qn, () => ({
                    duration: 300
                })),
                H(tr, Ht)
            }
            ;
            Ue(mr, tr => {
                Ho.hasPrev() && x(Se).name !== "paintingPixel" && tr(gr)
            }
            )
        }
        A(Ze);
        var ai = V(Ze, 2);
        let $i;
        var Tt = k(ai);
        {
            var Ci = tr => {
                var Ht = CL()
                  , ei = k(Ht);
                Cx(ei, {
                    class: "size-5"
                });
                var ri = V(ei);
                A(Ht),
                Ge(gi => fe(ri, ` ${gi ?? ""}`), [ () => i1()]),
                En(1, Ht, () => Qn, () => ({
                    duration: 1e3
                })),
                En(2, Ht, () => Qn),
                H(tr, Ht)
            }
            ;
            Ue(Tt, tr => {
                ni.online || tr(Ci)
            }
            )
        }
        var di = V(Tt, 2);
        {
            var Pn = tr => {
                var Ht = PL();
                Ht.__click = [SL, W, _];
                var ei = k(Ht);
                qz(ei, {
                    class: "size-5"
                });
                var ri = V(ei);
                A(Ht),
                Ge(gi => fe(ri, ` ${gi ?? ""}`), [ () => s1()]),
                En(3, Ht, () => Qn, () => ({
                    duration: 300
                })),
                H(tr, Ht)
            }
            ;
            Ue(di, tr => {
                x(ie) < O && tr(Pn)
            }
            )
        }
        A(ai);
        var Mt = V(ai, 2);
        let Mi;
        var Ke = k(Mt);
        gt(Ke),
        A(Mt);
        var jt = V(Mt, 2);
        let Cr;
        var Gt = k(jt);
        {
            var Dr = tr => {
                kv(tr, {
                    class: "z-30",
                    onclick: () => {
                        var Ht;
                        (Ht = Dt.data) != null && Ht.needsPhoneVerification ? (oe(dt, !0),
                        qr.warning(cg())) : Dt.charges !== void 0 && Dt.charges < 1 ? qr.warning(GA, {
                            icon: Eg
                        }) : x(W) && Dt.data ? (pa.smallDropplet.play(),
                        oe(Se, {
                            name: "paintingPixel"
                        }, !0)) : (oe(_e, !0),
                        x(W) && Qa(x(W).getCenter(), x(ie)))
                    }
                    ,
                    get disabled() {
                        return Dt.loading
                    },
                    get loading() {
                        return Dt.loading
                    },
                    get charges() {
                        return Dt.charges
                    }
                })
            }
              , Gr = tr => {
                var Ht = IL();
                H(tr, Ht)
            }
            ;
            Ue(Gt, tr => {
                x(Se).name === "mainMenu" ? tr(Dr) : tr(Gr, !1)
            }
            )
        }
        A(jt);
        var li = V(jt, 2);
        let gn;
        var fr = k(li);
        qt(fr),
        A(li);
        var bi = V(li, 2);
        {
            var Si = tr => {
                var Ht = Jt()
                  , ei = zt(Ht);
                {
                    var ri = ci => {
                        var pi = ML()
                          , Er = k(pi)
                          , Ri = k(Er);
                        J8(Ri, {
                            get latLon() {
                                return x(Se).latLon
                            },
                            get map() {
                                return x(W)
                            },
                            get crosshair() {
                                return x(Q)
                            },
                            get pixelInfoCache() {
                                return $
                            },
                            get season() {
                                return o
                            },
                            get tileSize() {
                                return C
                            },
                            get pixelArtZoom() {
                                return _
                            },
                            get zoom() {
                                return x(ie)
                            },
                            get opaquePixelArt() {
                                return x(Je)
                            },
                            onclose: () => oe(Se, {
                                name: "mainMenu"
                            }, !0),
                            onclickshare: ui => {
                                oe(pt, ui, !0),
                                oe(tt, !0)
                            }
                            ,
                            onclickpaint: ([ui,Jr]) => {
                                var yr, on, vn;
                                if (!Dt.data) {
                                    oe(_e, !0);
                                    return
                                }
                                if ((yr = Dt.data) != null && yr.needsPhoneVerification) {
                                    oe(dt, !0),
                                    qr.warning(cg());
                                    return
                                }
                                if (Dt.charges !== void 0 && Dt.charges < 1) {
                                    qr.warning(f1());
                                    return
                                }
                                const ti = im(L.latLonToPixelBoundsLatLon(ui, Jr, _));
                                (on = x(W)) == null || on.flyTo({
                                    center: {
                                        lat: ti[0],
                                        lon: ti[1]
                                    }
                                }),
                                oe(Se, {
                                    name: "paintingPixel",
                                    clickedLatLon: [ui, Jr]
                                }, !0),
                                (vn = x(Q)) == null || vn.clear()
                            }
                            ,
                            onclickregion: ui => {
                                oe(It, ui, !0),
                                oe(Ct, !0)
                            }
                            ,
                            onclickmodaction: (ui, Jr, ti, yr) => {
                                var on, vn, _a;
                                (on = x(W)) == null || on.setZoom(Math.max(x(ie), _ + 2)),
                                (vn = x(W)) == null || vn.setCenter({
                                    lat: ti[0],
                                    lng: ti[1]
                                }),
                                oe(Ir, Jr, !0),
                                oe(jr, ui, !0),
                                oe(ur, ti, !0),
                                oe(Mr, ((_a = x(W)) == null ? void 0 : _a.getZoom()) ?? 0, !0),
                                oe(_r, yr, !0),
                                oe(dr, !0)
                            }
                        }),
                        A(Er),
                        A(pi),
                        En(3, Er, () => uf, () => ({
                            duration: 100
                        })),
                        H(ci, pi)
                    }
                      , gi = ci => {
                        var pi = Jt()
                          , Er = zt(pi);
                        {
                            var Ri = Jr => {
                                var ti = AL()
                                  , yr = k(ti)
                                  , on = k(yr);
                                Wk(on, {
                                    get map() {
                                        return x(W)
                                    },
                                    get clickedLatLon() {
                                        return x(Se).clickedLatLon
                                    },
                                    get tileSize() {
                                        return C
                                    },
                                    get tileZoom() {
                                        return _
                                    },
                                    get season() {
                                        return o
                                    },
                                    get zoom() {
                                        return x(ie)
                                    },
                                    get crosshair() {
                                        return x(te)
                                    },
                                    refreshPixelArt: () => x(W) && Oe(x(W)),
                                    hidePixelHover: ct,
                                    hoverLayerId: Ee,
                                    onclose: () => {
                                        oe(Se, {
                                            name: "mainMenu"
                                        }, !0),
                                        ct()
                                    }
                                    ,
                                    get screenLocked() {
                                        return x(pe)
                                    },
                                    set screenLocked(vn) {
                                        oe(pe, vn, !0)
                                    },
                                    get opaquePixelArt() {
                                        return x(Je)
                                    },
                                    set opaquePixelArt(vn) {
                                        oe(Je, vn, !0)
                                    }
                                }),
                                A(yr),
                                A(ti),
                                En(3, yr, () => uf, () => ({
                                    duration: 100
                                })),
                                H(Jr, ti)
                            }
                              , ui = Jr => {
                                var ti = Jt()
                                  , yr = zt(ti);
                                {
                                    var on = vn => {
                                        var _a = EL()
                                          , ln = k(_a)
                                          , Ki = k(ln)
                                          , cn = k(Ki)
                                          , Ni = k(cn)
                                          , wi = k(Ni);
                                        Lv(wi, {
                                            class: "inline size-4"
                                        });
                                        var Ko = V(wi);
                                        A(Ni);
                                        var un = V(Ni, 2);
                                        un.__click = [kL, Se];
                                        var Nn = k(un);
                                        fc(Nn, {
                                            class: "size-4"
                                        }),
                                        A(un),
                                        A(cn);
                                        var hn = V(cn, 2)
                                          , Ti = k(hn);
                                        Ti.__click = async () => {
                                            var wr;
                                            if (x(Se).name === "selectHq") {
                                                const Vr = x(Se).hq;
                                                if (Vr)
                                                    try {
                                                        oe(ar, !0),
                                                        await ni.updateAllianceHeadquarters(Vr[0], Vr[1]),
                                                        (wr = x(Q)) == null || wr.clear(),
                                                        oe(We, !0),
                                                        oe(Se, {
                                                            name: "mainMenu"
                                                        }, !0)
                                                    } catch (ga) {
                                                        qr.error(ga.message)
                                                    } finally {
                                                        oe(ar, !1)
                                                    }
                                            }
                                        }
                                        ;
                                        var Za = k(Ti);
                                        Lz(Za, {
                                            class: "size-6"
                                        }),
                                        A(Ti),
                                        A(hn),
                                        A(Ki),
                                        A(ln),
                                        A(_a),
                                        Ge(wr => {
                                            fe(Ko, ` ${wr ?? ""}`),
                                            Ti.disabled = x(Se).hq === void 0 || x(ar)
                                        }
                                        , [ () => R3()]),
                                        En(3, ln, () => uf, () => ({
                                            duration: 100
                                        })),
                                        H(vn, _a)
                                    }
                                    ;
                                    Ue(yr, vn => {
                                        x(Se).name === "selectHq" && vn(on)
                                    }
                                    , !0)
                                }
                                H(Jr, ti)
                            }
                            ;
                            Ue(Er, Jr => {
                                x(Se).name === "paintingPixel" && x(te) ? Jr(Ri) : Jr(ui, !1)
                            }
                            , !0)
                        }
                        H(ci, pi)
                    }
                    ;
                    Ue(ei, ci => {
                        x(Se).name === "pixelSelected" && x(Q) ? ci(ri) : ci(gi, !1)
                    }
                    )
                }
                H(tr, Ht)
            }
            ;
            Ue(bi, tr => {
                x(W) && tr(Si)
            }
            )
        }
        A(kr),
        Ge( (tr, Ht, ei, ri, gi, ci, pi, Er, Ri) => {
            vr = Or(Nr, 1, "absolute right-2 top-2 z-30", null, vr, tr),
            _i = Or(ce, 1, "flex flex-col gap-4", null, _i, Ht),
            Di = Or(Ze, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3", null, Di, ei),
            zr(xe, "title", ri),
            zr(At, "title", gi),
            $i = Or(ai, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, $i, ci),
            Mi = Or(Mt, 1, "absolute bottom-3 left-3 z-30", null, Mi, pi),
            Cr = Or(jt, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, Cr, Er),
            gn = Or(li, 1, "absolute bottom-3 right-3 z-30", null, gn, Ri)
        }
        , [ () => ({
            hidden: x(X)
        }), () => ({
            "items-end": !Dt.data,
            "items-center": Dt.data
        }), () => ({
            hidden: x(X)
        }), () => Wx(), () => Yx(), () => ({
            hidden: x(X)
        }), () => ({
            hidden: x(X)
        }), () => ({
            hidden: x(X)
        }), () => ({
            hidden: x(X)
        })])
    }
    var zi = V(kr, 2);
    qA(zi, {
        get open() {
            return x(_e)
        },
        set open(gt) {
            oe(_e, gt, !0)
        }
    });
    var mi = V(zi, 2);
    Ez(mi, {
        get open() {
            return x(ne)
        },
        set open(gt) {
            oe(ne, gt, !0)
        }
    });
    var Li = V(mi, 2);
    DM(Li, {
        get open() {
            return x(Me)
        },
        set open(gt) {
            oe(Me, gt, !0)
        }
    });
    var rr = V(Li, 2);
    HM(rr, {
        get open() {
            return x(at)
        },
        set open(gt) {
            oe(at, gt, !0)
        }
    });
    var yi = V(rr, 2);
    EM(yi, {
        get open() {
            return x(ut)
        },
        set open(gt) {
            oe(ut, gt, !0)
        }
    });
    var Qr = V(yi, 2);
    OA(Qr, {
        onvisitclick: gt => {
            var qt;
            (qt = x(W)) == null || qt.flyTo({
                center: gt,
                zoom: og + 1
            }),
            Qa(gt, x(ie)),
            Ho.push({
                pos: gt,
                zoom: x(ie)
            }),
            oe(Pe, !1)
        }
        ,
        get open() {
            return x(Pe)
        },
        set open(gt) {
            oe(Pe, gt, !0)
        }
    });
    var Yr = V(Qr, 2);
    w8(Yr, {
        get region() {
            return x(It)
        },
        get open() {
            return x(Ct)
        },
        set open(gt) {
            oe(Ct, gt, !0)
        }
    });
    var la = V(Yr, 2);
    fx(la, {
        get open() {
            return oa.dropletsDialogOpen
        },
        set open(gt) {
            oa.dropletsDialogOpen = gt
        }
    });
    var sn = V(la, 2);
    {
        var ta = gt => {
            oM(gt, {
                onhqchange: () => {
                    oe(Se, {
                        name: "selectHq"
                    }, !0),
                    oe(We, !1)
                }
                ,
                onhqclick: qt => {
                    var vr;
                    (vr = x(W)) == null || vr.flyTo({
                        center: qt,
                        zoom: Math.max(x(ie), 15)
                    }),
                    oe(Se, {
                        name: "pixelSelected",
                        latLon: [qt.lat, qt.lng]
                    }, !0),
                    oe(We, !1)
                }
                ,
                onlastpixelclick: qt => {
                    var vr;
                    (vr = x(W)) == null || vr.flyTo({
                        center: qt,
                        zoom: Math.max(x(ie), 15)
                    }),
                    oe(Se, {
                        name: "pixelSelected",
                        latLon: [qt.lat, qt.lng]
                    }, !0),
                    oe(We, !1)
                }
                ,
                get open() {
                    return x(We)
                },
                set open(qt) {
                    oe(We, qt, !0)
                }
            })
        }
        ;
        Ue(sn, gt => {
            x(W) && gt(ta)
        }
        )
    }
    var Fi = V(sn, 2);
    fE(Fi, {
        get open() {
            return x(dt)
        },
        set open(gt) {
            oe(dt, gt, !0)
        }
    });
    var Xi = V(Fi, 2);
    {
        var Gn = gt => {
            CM(gt, {
                get url() {
                    return x(pt)
                },
                get map() {
                    return x(W)
                },
                hideHover: () => {
                    var qt, vr;
                    (qt = x(W)) == null || qt.setPaintProperty(Ee, "raster-opacity", 0),
                    (vr = x(Q)) == null || vr.setCanvasOpacity(0)
                }
                ,
                showHover: () => {
                    var qt, vr;
                    (qt = x(W)) == null || qt.setPaintProperty(Ee, "raster-opacity", ht),
                    (vr = x(Q)) == null || vr.setCanvasOpacity(1)
                }
                ,
                get open() {
                    return x(tt)
                },
                set open(qt) {
                    oe(tt, qt, !0)
                }
            })
        }
        ;
        Ue(Xi, gt => {
            x(W) && gt(Gn)
        }
        )
    }
    var Hn = V(Xi, 2);
    {
        var Ln = gt => {
            hM(gt, {
                get image() {
                    return x(Ir)
                },
                get paintedBy() {
                    return x(jr).paintedBy
                },
                get latLon() {
                    return x(ur)
                },
                get zoom() {
                    return x(Mr)
                },
                get action() {
                    return x(_r)
                },
                get open() {
                    return x(dr)
                },
                set open(qt) {
                    oe(dr, qt, !0)
                }
            })
        }
        ;
        Ue(Hn, gt => {
            x(jr) && x(Ir) && x(ur) && gt(Ln)
        }
        )
    }
    H(b, Ar),
    Pr()
}
Wi(["click"]);
export {oD as component};
